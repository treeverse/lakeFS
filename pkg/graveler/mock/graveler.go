// Code generated by MockGen. DO NOT EDIT.
// Source: graveler.go

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	reflect "reflect"
	time "time"

	gomock "github.com/golang/mock/gomock"
	graveler "github.com/treeverse/lakefs/pkg/graveler"
)

// MockKeyValueStore is a mock of KeyValueStore interface.
type MockKeyValueStore struct {
	ctrl     *gomock.Controller
	recorder *MockKeyValueStoreMockRecorder
}

// MockKeyValueStoreMockRecorder is the mock recorder for MockKeyValueStore.
type MockKeyValueStoreMockRecorder struct {
	mock *MockKeyValueStore
}

// NewMockKeyValueStore creates a new mock instance.
func NewMockKeyValueStore(ctrl *gomock.Controller) *MockKeyValueStore {
	mock := &MockKeyValueStore{ctrl: ctrl}
	mock.recorder = &MockKeyValueStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockKeyValueStore) EXPECT() *MockKeyValueStoreMockRecorder {
	return m.recorder
}

// Delete mocks base method.
func (m *MockKeyValueStore) Delete(ctx context.Context, repository *graveler.RepositoryRecord, branchID graveler.BranchID, key graveler.Key, opts ...graveler.SetOptionsFunc) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, repository, branchID, key}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Delete", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete.
func (mr *MockKeyValueStoreMockRecorder) Delete(ctx, repository, branchID, key interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, repository, branchID, key}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockKeyValueStore)(nil).Delete), varargs...)
}

// DeleteBatch mocks base method.
func (m *MockKeyValueStore) DeleteBatch(ctx context.Context, repository *graveler.RepositoryRecord, branchID graveler.BranchID, keys []graveler.Key, opts ...graveler.SetOptionsFunc) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, repository, branchID, keys}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteBatch", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteBatch indicates an expected call of DeleteBatch.
func (mr *MockKeyValueStoreMockRecorder) DeleteBatch(ctx, repository, branchID, keys interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, repository, branchID, keys}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteBatch", reflect.TypeOf((*MockKeyValueStore)(nil).DeleteBatch), varargs...)
}

// Get mocks base method.
func (m *MockKeyValueStore) Get(ctx context.Context, repository *graveler.RepositoryRecord, ref graveler.Ref, key graveler.Key, opts ...graveler.GetOptionsFunc) (*graveler.Value, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, repository, ref, key}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Get", varargs...)
	ret0, _ := ret[0].(*graveler.Value)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockKeyValueStoreMockRecorder) Get(ctx, repository, ref, key interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, repository, ref, key}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockKeyValueStore)(nil).Get), varargs...)
}

// GetByCommitID mocks base method.
func (m *MockKeyValueStore) GetByCommitID(ctx context.Context, repository *graveler.RepositoryRecord, commitID graveler.CommitID, key graveler.Key) (*graveler.Value, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetByCommitID", ctx, repository, commitID, key)
	ret0, _ := ret[0].(*graveler.Value)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByCommitID indicates an expected call of GetByCommitID.
func (mr *MockKeyValueStoreMockRecorder) GetByCommitID(ctx, repository, commitID, key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByCommitID", reflect.TypeOf((*MockKeyValueStore)(nil).GetByCommitID), ctx, repository, commitID, key)
}

// GetRangeIDByKey mocks base method.
func (m *MockKeyValueStore) GetRangeIDByKey(ctx context.Context, repository *graveler.RepositoryRecord, commitID graveler.CommitID, key graveler.Key) (graveler.RangeID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRangeIDByKey", ctx, repository, commitID, key)
	ret0, _ := ret[0].(graveler.RangeID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetRangeIDByKey indicates an expected call of GetRangeIDByKey.
func (mr *MockKeyValueStoreMockRecorder) GetRangeIDByKey(ctx, repository, commitID, key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRangeIDByKey", reflect.TypeOf((*MockKeyValueStore)(nil).GetRangeIDByKey), ctx, repository, commitID, key)
}

// List mocks base method.
func (m *MockKeyValueStore) List(ctx context.Context, repository *graveler.RepositoryRecord, ref graveler.Ref, batchSize int) (graveler.ValueIterator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "List", ctx, repository, ref, batchSize)
	ret0, _ := ret[0].(graveler.ValueIterator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// List indicates an expected call of List.
func (mr *MockKeyValueStoreMockRecorder) List(ctx, repository, ref, batchSize interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockKeyValueStore)(nil).List), ctx, repository, ref, batchSize)
}

// ListStaging mocks base method.
func (m *MockKeyValueStore) ListStaging(ctx context.Context, branch *graveler.Branch, batchSize int) (graveler.ValueIterator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListStaging", ctx, branch, batchSize)
	ret0, _ := ret[0].(graveler.ValueIterator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListStaging indicates an expected call of ListStaging.
func (mr *MockKeyValueStoreMockRecorder) ListStaging(ctx, branch, batchSize interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListStaging", reflect.TypeOf((*MockKeyValueStore)(nil).ListStaging), ctx, branch, batchSize)
}

// Set mocks base method.
func (m *MockKeyValueStore) Set(ctx context.Context, repository *graveler.RepositoryRecord, branchID graveler.BranchID, key graveler.Key, value graveler.Value, opts ...graveler.SetOptionsFunc) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, repository, branchID, key, value}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Set", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Set indicates an expected call of Set.
func (mr *MockKeyValueStoreMockRecorder) Set(ctx, repository, branchID, key, value interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, repository, branchID, key, value}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockKeyValueStore)(nil).Set), varargs...)
}

// MockVersionController is a mock of VersionController interface.
type MockVersionController struct {
	ctrl     *gomock.Controller
	recorder *MockVersionControllerMockRecorder
}

// MockVersionControllerMockRecorder is the mock recorder for MockVersionController.
type MockVersionControllerMockRecorder struct {
	mock *MockVersionController
}

// NewMockVersionController creates a new mock instance.
func NewMockVersionController(ctrl *gomock.Controller) *MockVersionController {
	mock := &MockVersionController{ctrl: ctrl}
	mock.recorder = &MockVersionControllerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockVersionController) EXPECT() *MockVersionControllerMockRecorder {
	return m.recorder
}

// AddCommit mocks base method.
func (m *MockVersionController) AddCommit(ctx context.Context, repository *graveler.RepositoryRecord, commit graveler.Commit, opts ...graveler.SetOptionsFunc) (graveler.CommitID, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, repository, commit}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AddCommit", varargs...)
	ret0, _ := ret[0].(graveler.CommitID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AddCommit indicates an expected call of AddCommit.
func (mr *MockVersionControllerMockRecorder) AddCommit(ctx, repository, commit interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, repository, commit}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddCommit", reflect.TypeOf((*MockVersionController)(nil).AddCommit), varargs...)
}

// CherryPick mocks base method.
func (m *MockVersionController) CherryPick(ctx context.Context, repository *graveler.RepositoryRecord, id graveler.BranchID, reference graveler.Ref, number *int, committer string, opts ...graveler.SetOptionsFunc) (graveler.CommitID, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, repository, id, reference, number, committer}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CherryPick", varargs...)
	ret0, _ := ret[0].(graveler.CommitID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CherryPick indicates an expected call of CherryPick.
func (mr *MockVersionControllerMockRecorder) CherryPick(ctx, repository, id, reference, number, committer interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, repository, id, reference, number, committer}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CherryPick", reflect.TypeOf((*MockVersionController)(nil).CherryPick), varargs...)
}

// Commit mocks base method.
func (m *MockVersionController) Commit(ctx context.Context, repository *graveler.RepositoryRecord, branchID graveler.BranchID, commitParams graveler.CommitParams, opts ...graveler.SetOptionsFunc) (graveler.CommitID, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, repository, branchID, commitParams}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Commit", varargs...)
	ret0, _ := ret[0].(graveler.CommitID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Commit indicates an expected call of Commit.
func (mr *MockVersionControllerMockRecorder) Commit(ctx, repository, branchID, commitParams interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, repository, branchID, commitParams}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockVersionController)(nil).Commit), varargs...)
}

// Compare mocks base method.
func (m *MockVersionController) Compare(ctx context.Context, repository *graveler.RepositoryRecord, left, right graveler.Ref) (graveler.DiffIterator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Compare", ctx, repository, left, right)
	ret0, _ := ret[0].(graveler.DiffIterator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Compare indicates an expected call of Compare.
func (mr *MockVersionControllerMockRecorder) Compare(ctx, repository, left, right interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Compare", reflect.TypeOf((*MockVersionController)(nil).Compare), ctx, repository, left, right)
}

// CreateBareRepository mocks base method.
func (m *MockVersionController) CreateBareRepository(ctx context.Context, repositoryID graveler.RepositoryID, storageNamespace graveler.StorageNamespace, defaultBranchID graveler.BranchID, readOnly bool) (*graveler.RepositoryRecord, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateBareRepository", ctx, repositoryID, storageNamespace, defaultBranchID, readOnly)
	ret0, _ := ret[0].(*graveler.RepositoryRecord)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateBareRepository indicates an expected call of CreateBareRepository.
func (mr *MockVersionControllerMockRecorder) CreateBareRepository(ctx, repositoryID, storageNamespace, defaultBranchID, readOnly interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateBareRepository", reflect.TypeOf((*MockVersionController)(nil).CreateBareRepository), ctx, repositoryID, storageNamespace, defaultBranchID, readOnly)
}

// CreateBranch mocks base method.
func (m *MockVersionController) CreateBranch(ctx context.Context, repository *graveler.RepositoryRecord, branchID graveler.BranchID, ref graveler.Ref, opts ...graveler.SetOptionsFunc) (*graveler.Branch, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, repository, branchID, ref}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateBranch", varargs...)
	ret0, _ := ret[0].(*graveler.Branch)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateBranch indicates an expected call of CreateBranch.
func (mr *MockVersionControllerMockRecorder) CreateBranch(ctx, repository, branchID, ref interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, repository, branchID, ref}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateBranch", reflect.TypeOf((*MockVersionController)(nil).CreateBranch), varargs...)
}

// CreateCommitRecord mocks base method.
func (m *MockVersionController) CreateCommitRecord(ctx context.Context, repository *graveler.RepositoryRecord, commitID graveler.CommitID, commit graveler.Commit, opts ...graveler.SetOptionsFunc) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, repository, commitID, commit}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateCommitRecord", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateCommitRecord indicates an expected call of CreateCommitRecord.
func (mr *MockVersionControllerMockRecorder) CreateCommitRecord(ctx, repository, commitID, commit interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, repository, commitID, commit}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateCommitRecord", reflect.TypeOf((*MockVersionController)(nil).CreateCommitRecord), varargs...)
}

// CreateRepository mocks base method.
func (m *MockVersionController) CreateRepository(ctx context.Context, repositoryID graveler.RepositoryID, storageNamespace graveler.StorageNamespace, branchID graveler.BranchID, readOnly bool) (*graveler.RepositoryRecord, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateRepository", ctx, repositoryID, storageNamespace, branchID, readOnly)
	ret0, _ := ret[0].(*graveler.RepositoryRecord)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateRepository indicates an expected call of CreateRepository.
func (mr *MockVersionControllerMockRecorder) CreateRepository(ctx, repositoryID, storageNamespace, branchID, readOnly interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateRepository", reflect.TypeOf((*MockVersionController)(nil).CreateRepository), ctx, repositoryID, storageNamespace, branchID, readOnly)
}

// CreateTag mocks base method.
func (m *MockVersionController) CreateTag(ctx context.Context, repository *graveler.RepositoryRecord, tagID graveler.TagID, commitID graveler.CommitID, opts ...graveler.SetOptionsFunc) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, repository, tagID, commitID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateTag", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateTag indicates an expected call of CreateTag.
func (mr *MockVersionControllerMockRecorder) CreateTag(ctx, repository, tagID, commitID interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, repository, tagID, commitID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTag", reflect.TypeOf((*MockVersionController)(nil).CreateTag), varargs...)
}

// DeleteBranch mocks base method.
func (m *MockVersionController) DeleteBranch(ctx context.Context, repository *graveler.RepositoryRecord, branchID graveler.BranchID, opts ...graveler.SetOptionsFunc) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, repository, branchID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteBranch", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteBranch indicates an expected call of DeleteBranch.
func (mr *MockVersionControllerMockRecorder) DeleteBranch(ctx, repository, branchID interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, repository, branchID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteBranch", reflect.TypeOf((*MockVersionController)(nil).DeleteBranch), varargs...)
}

// DeleteExpiredImports mocks base method.
func (m *MockVersionController) DeleteExpiredImports(ctx context.Context, repository *graveler.RepositoryRecord) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteExpiredImports", ctx, repository)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteExpiredImports indicates an expected call of DeleteExpiredImports.
func (mr *MockVersionControllerMockRecorder) DeleteExpiredImports(ctx, repository interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteExpiredImports", reflect.TypeOf((*MockVersionController)(nil).DeleteExpiredImports), ctx, repository)
}

// DeleteRepository mocks base method.
func (m *MockVersionController) DeleteRepository(ctx context.Context, repositoryID graveler.RepositoryID, opts ...graveler.SetOptionsFunc) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, repositoryID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteRepository", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteRepository indicates an expected call of DeleteRepository.
func (mr *MockVersionControllerMockRecorder) DeleteRepository(ctx, repositoryID interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, repositoryID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteRepository", reflect.TypeOf((*MockVersionController)(nil).DeleteRepository), varargs...)
}

// DeleteTag mocks base method.
func (m *MockVersionController) DeleteTag(ctx context.Context, repository *graveler.RepositoryRecord, tagID graveler.TagID, opts ...graveler.SetOptionsFunc) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, repository, tagID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteTag", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteTag indicates an expected call of DeleteTag.
func (mr *MockVersionControllerMockRecorder) DeleteTag(ctx, repository, tagID interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, repository, tagID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteTag", reflect.TypeOf((*MockVersionController)(nil).DeleteTag), varargs...)
}

// Dereference mocks base method.
func (m *MockVersionController) Dereference(ctx context.Context, repository *graveler.RepositoryRecord, ref graveler.Ref) (*graveler.ResolvedRef, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Dereference", ctx, repository, ref)
	ret0, _ := ret[0].(*graveler.ResolvedRef)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Dereference indicates an expected call of Dereference.
func (mr *MockVersionControllerMockRecorder) Dereference(ctx, repository, ref interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Dereference", reflect.TypeOf((*MockVersionController)(nil).Dereference), ctx, repository, ref)
}

// Diff mocks base method.
func (m *MockVersionController) Diff(ctx context.Context, repository *graveler.RepositoryRecord, left, right graveler.Ref) (graveler.DiffIterator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Diff", ctx, repository, left, right)
	ret0, _ := ret[0].(graveler.DiffIterator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Diff indicates an expected call of Diff.
func (mr *MockVersionControllerMockRecorder) Diff(ctx, repository, left, right interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Diff", reflect.TypeOf((*MockVersionController)(nil).Diff), ctx, repository, left, right)
}

// DiffUncommitted mocks base method.
func (m *MockVersionController) DiffUncommitted(ctx context.Context, repository *graveler.RepositoryRecord, branchID graveler.BranchID) (graveler.DiffIterator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DiffUncommitted", ctx, repository, branchID)
	ret0, _ := ret[0].(graveler.DiffIterator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DiffUncommitted indicates an expected call of DiffUncommitted.
func (mr *MockVersionControllerMockRecorder) DiffUncommitted(ctx, repository, branchID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DiffUncommitted", reflect.TypeOf((*MockVersionController)(nil).DiffUncommitted), ctx, repository, branchID)
}

// FindMergeBase mocks base method.
func (m *MockVersionController) FindMergeBase(ctx context.Context, repository *graveler.RepositoryRecord, from, to graveler.Ref) (*graveler.CommitRecord, *graveler.CommitRecord, *graveler.Commit, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindMergeBase", ctx, repository, from, to)
	ret0, _ := ret[0].(*graveler.CommitRecord)
	ret1, _ := ret[1].(*graveler.CommitRecord)
	ret2, _ := ret[2].(*graveler.Commit)
	ret3, _ := ret[3].(error)
	return ret0, ret1, ret2, ret3
}

// FindMergeBase indicates an expected call of FindMergeBase.
func (mr *MockVersionControllerMockRecorder) FindMergeBase(ctx, repository, from, to interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindMergeBase", reflect.TypeOf((*MockVersionController)(nil).FindMergeBase), ctx, repository, from, to)
}

// GCGetUncommittedLocation mocks base method.
func (m *MockVersionController) GCGetUncommittedLocation(repository *graveler.RepositoryRecord, runID string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GCGetUncommittedLocation", repository, runID)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GCGetUncommittedLocation indicates an expected call of GCGetUncommittedLocation.
func (mr *MockVersionControllerMockRecorder) GCGetUncommittedLocation(repository, runID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GCGetUncommittedLocation", reflect.TypeOf((*MockVersionController)(nil).GCGetUncommittedLocation), repository, runID)
}

// GCNewRunID mocks base method.
func (m *MockVersionController) GCNewRunID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GCNewRunID")
	ret0, _ := ret[0].(string)
	return ret0
}

// GCNewRunID indicates an expected call of GCNewRunID.
func (mr *MockVersionControllerMockRecorder) GCNewRunID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GCNewRunID", reflect.TypeOf((*MockVersionController)(nil).GCNewRunID))
}

// GetBranch mocks base method.
func (m *MockVersionController) GetBranch(ctx context.Context, repository *graveler.RepositoryRecord, branchID graveler.BranchID) (*graveler.Branch, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBranch", ctx, repository, branchID)
	ret0, _ := ret[0].(*graveler.Branch)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBranch indicates an expected call of GetBranch.
func (mr *MockVersionControllerMockRecorder) GetBranch(ctx, repository, branchID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBranch", reflect.TypeOf((*MockVersionController)(nil).GetBranch), ctx, repository, branchID)
}

// GetBranchProtectionRules mocks base method.
func (m *MockVersionController) GetBranchProtectionRules(ctx context.Context, repository *graveler.RepositoryRecord) (*graveler.BranchProtectionRules, *string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBranchProtectionRules", ctx, repository)
	ret0, _ := ret[0].(*graveler.BranchProtectionRules)
	ret1, _ := ret[1].(*string)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetBranchProtectionRules indicates an expected call of GetBranchProtectionRules.
func (mr *MockVersionControllerMockRecorder) GetBranchProtectionRules(ctx, repository interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBranchProtectionRules", reflect.TypeOf((*MockVersionController)(nil).GetBranchProtectionRules), ctx, repository)
}

// GetCommit mocks base method.
func (m *MockVersionController) GetCommit(ctx context.Context, repository *graveler.RepositoryRecord, commitID graveler.CommitID) (*graveler.Commit, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCommit", ctx, repository, commitID)
	ret0, _ := ret[0].(*graveler.Commit)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCommit indicates an expected call of GetCommit.
func (mr *MockVersionControllerMockRecorder) GetCommit(ctx, repository, commitID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCommit", reflect.TypeOf((*MockVersionController)(nil).GetCommit), ctx, repository, commitID)
}

// GetGarbageCollectionRules mocks base method.
func (m *MockVersionController) GetGarbageCollectionRules(ctx context.Context, repository *graveler.RepositoryRecord) (*graveler.GarbageCollectionRules, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetGarbageCollectionRules", ctx, repository)
	ret0, _ := ret[0].(*graveler.GarbageCollectionRules)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetGarbageCollectionRules indicates an expected call of GetGarbageCollectionRules.
func (mr *MockVersionControllerMockRecorder) GetGarbageCollectionRules(ctx, repository interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetGarbageCollectionRules", reflect.TypeOf((*MockVersionController)(nil).GetGarbageCollectionRules), ctx, repository)
}

// GetRepository mocks base method.
func (m *MockVersionController) GetRepository(ctx context.Context, repositoryID graveler.RepositoryID) (*graveler.RepositoryRecord, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRepository", ctx, repositoryID)
	ret0, _ := ret[0].(*graveler.RepositoryRecord)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetRepository indicates an expected call of GetRepository.
func (mr *MockVersionControllerMockRecorder) GetRepository(ctx, repositoryID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRepository", reflect.TypeOf((*MockVersionController)(nil).GetRepository), ctx, repositoryID)
}

// GetRepositoryMetadata mocks base method.
func (m *MockVersionController) GetRepositoryMetadata(ctx context.Context, repositoryID graveler.RepositoryID) (graveler.RepositoryMetadata, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRepositoryMetadata", ctx, repositoryID)
	ret0, _ := ret[0].(graveler.RepositoryMetadata)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetRepositoryMetadata indicates an expected call of GetRepositoryMetadata.
func (mr *MockVersionControllerMockRecorder) GetRepositoryMetadata(ctx, repositoryID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRepositoryMetadata", reflect.TypeOf((*MockVersionController)(nil).GetRepositoryMetadata), ctx, repositoryID)
}

// GetStagingToken mocks base method.
func (m *MockVersionController) GetStagingToken(ctx context.Context, repository *graveler.RepositoryRecord, branchID graveler.BranchID) (*graveler.StagingToken, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStagingToken", ctx, repository, branchID)
	ret0, _ := ret[0].(*graveler.StagingToken)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetStagingToken indicates an expected call of GetStagingToken.
func (mr *MockVersionControllerMockRecorder) GetStagingToken(ctx, repository, branchID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStagingToken", reflect.TypeOf((*MockVersionController)(nil).GetStagingToken), ctx, repository, branchID)
}

// GetTag mocks base method.
func (m *MockVersionController) GetTag(ctx context.Context, repository *graveler.RepositoryRecord, tagID graveler.TagID) (*graveler.CommitID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTag", ctx, repository, tagID)
	ret0, _ := ret[0].(*graveler.CommitID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTag indicates an expected call of GetTag.
func (mr *MockVersionControllerMockRecorder) GetTag(ctx, repository, tagID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTag", reflect.TypeOf((*MockVersionController)(nil).GetTag), ctx, repository, tagID)
}

// Import mocks base method.
func (m *MockVersionController) Import(ctx context.Context, repository *graveler.RepositoryRecord, destination graveler.BranchID, source graveler.MetaRangeID, commitParams graveler.CommitParams, prefixes []graveler.Prefix, opts ...graveler.SetOptionsFunc) (graveler.CommitID, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, repository, destination, source, commitParams, prefixes}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Import", varargs...)
	ret0, _ := ret[0].(graveler.CommitID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Import indicates an expected call of Import.
func (mr *MockVersionControllerMockRecorder) Import(ctx, repository, destination, source, commitParams, prefixes interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, repository, destination, source, commitParams, prefixes}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Import", reflect.TypeOf((*MockVersionController)(nil).Import), varargs...)
}

// ListBranches mocks base method.
func (m *MockVersionController) ListBranches(ctx context.Context, repository *graveler.RepositoryRecord) (graveler.BranchIterator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListBranches", ctx, repository)
	ret0, _ := ret[0].(graveler.BranchIterator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListBranches indicates an expected call of ListBranches.
func (mr *MockVersionControllerMockRecorder) ListBranches(ctx, repository interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListBranches", reflect.TypeOf((*MockVersionController)(nil).ListBranches), ctx, repository)
}

// ListRepositories mocks base method.
func (m *MockVersionController) ListRepositories(ctx context.Context) (graveler.RepositoryIterator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListRepositories", ctx)
	ret0, _ := ret[0].(graveler.RepositoryIterator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListRepositories indicates an expected call of ListRepositories.
func (mr *MockVersionControllerMockRecorder) ListRepositories(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListRepositories", reflect.TypeOf((*MockVersionController)(nil).ListRepositories), ctx)
}

// ListTags mocks base method.
func (m *MockVersionController) ListTags(ctx context.Context, repository *graveler.RepositoryRecord) (graveler.TagIterator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListTags", ctx, repository)
	ret0, _ := ret[0].(graveler.TagIterator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListTags indicates an expected call of ListTags.
func (mr *MockVersionControllerMockRecorder) ListTags(ctx, repository interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListTags", reflect.TypeOf((*MockVersionController)(nil).ListTags), ctx, repository)
}

// Log mocks base method.
func (m *MockVersionController) Log(ctx context.Context, repository *graveler.RepositoryRecord, commitID graveler.CommitID, firstParent bool, since *time.Time) (graveler.CommitIterator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Log", ctx, repository, commitID, firstParent, since)
	ret0, _ := ret[0].(graveler.CommitIterator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Log indicates an expected call of Log.
func (mr *MockVersionControllerMockRecorder) Log(ctx, repository, commitID, firstParent, since interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Log", reflect.TypeOf((*MockVersionController)(nil).Log), ctx, repository, commitID, firstParent, since)
}

// Merge mocks base method.
func (m *MockVersionController) Merge(ctx context.Context, repository *graveler.RepositoryRecord, destination graveler.BranchID, source graveler.Ref, commitParams graveler.CommitParams, strategy string, opts ...graveler.SetOptionsFunc) (graveler.CommitID, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, repository, destination, source, commitParams, strategy}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Merge", varargs...)
	ret0, _ := ret[0].(graveler.CommitID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Merge indicates an expected call of Merge.
func (mr *MockVersionControllerMockRecorder) Merge(ctx, repository, destination, source, commitParams, strategy interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, repository, destination, source, commitParams, strategy}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Merge", reflect.TypeOf((*MockVersionController)(nil).Merge), varargs...)
}

// ParseRef mocks base method.
func (m *MockVersionController) ParseRef(ref graveler.Ref) (graveler.RawRef, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ParseRef", ref)
	ret0, _ := ret[0].(graveler.RawRef)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ParseRef indicates an expected call of ParseRef.
func (mr *MockVersionControllerMockRecorder) ParseRef(ref interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ParseRef", reflect.TypeOf((*MockVersionController)(nil).ParseRef), ref)
}

// Reset mocks base method.
func (m *MockVersionController) Reset(ctx context.Context, repository *graveler.RepositoryRecord, branchID graveler.BranchID, opts ...graveler.SetOptionsFunc) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, repository, branchID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Reset", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Reset indicates an expected call of Reset.
func (mr *MockVersionControllerMockRecorder) Reset(ctx, repository, branchID interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, repository, branchID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Reset", reflect.TypeOf((*MockVersionController)(nil).Reset), varargs...)
}

// ResetHard mocks base method.
func (m *MockVersionController) ResetHard(ctx context.Context, repository *graveler.RepositoryRecord, branchID graveler.BranchID, ref graveler.Ref, opts ...graveler.SetOptionsFunc) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, repository, branchID, ref}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ResetHard", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ResetHard indicates an expected call of ResetHard.
func (mr *MockVersionControllerMockRecorder) ResetHard(ctx, repository, branchID, ref interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, repository, branchID, ref}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResetHard", reflect.TypeOf((*MockVersionController)(nil).ResetHard), varargs...)
}

// ResetKey mocks base method.
func (m *MockVersionController) ResetKey(ctx context.Context, repository *graveler.RepositoryRecord, branchID graveler.BranchID, key graveler.Key, opts ...graveler.SetOptionsFunc) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, repository, branchID, key}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ResetKey", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ResetKey indicates an expected call of ResetKey.
func (mr *MockVersionControllerMockRecorder) ResetKey(ctx, repository, branchID, key interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, repository, branchID, key}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResetKey", reflect.TypeOf((*MockVersionController)(nil).ResetKey), varargs...)
}

// ResetPrefix mocks base method.
func (m *MockVersionController) ResetPrefix(ctx context.Context, repository *graveler.RepositoryRecord, branchID graveler.BranchID, key graveler.Key, opts ...graveler.SetOptionsFunc) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, repository, branchID, key}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ResetPrefix", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ResetPrefix indicates an expected call of ResetPrefix.
func (mr *MockVersionControllerMockRecorder) ResetPrefix(ctx, repository, branchID, key interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, repository, branchID, key}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResetPrefix", reflect.TypeOf((*MockVersionController)(nil).ResetPrefix), varargs...)
}

// ResolveRawRef mocks base method.
func (m *MockVersionController) ResolveRawRef(ctx context.Context, repository *graveler.RepositoryRecord, rawRef graveler.RawRef) (*graveler.ResolvedRef, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ResolveRawRef", ctx, repository, rawRef)
	ret0, _ := ret[0].(*graveler.ResolvedRef)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ResolveRawRef indicates an expected call of ResolveRawRef.
func (mr *MockVersionControllerMockRecorder) ResolveRawRef(ctx, repository, rawRef interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResolveRawRef", reflect.TypeOf((*MockVersionController)(nil).ResolveRawRef), ctx, repository, rawRef)
}

// Revert mocks base method.
func (m *MockVersionController) Revert(ctx context.Context, repository *graveler.RepositoryRecord, branchID graveler.BranchID, ref graveler.Ref, parentNumber int, commitParams graveler.CommitParams, opts ...graveler.SetOptionsFunc) (graveler.CommitID, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, repository, branchID, ref, parentNumber, commitParams}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Revert", varargs...)
	ret0, _ := ret[0].(graveler.CommitID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Revert indicates an expected call of Revert.
func (mr *MockVersionControllerMockRecorder) Revert(ctx, repository, branchID, ref, parentNumber, commitParams interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, repository, branchID, ref, parentNumber, commitParams}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Revert", reflect.TypeOf((*MockVersionController)(nil).Revert), varargs...)
}

// SaveGarbageCollectionCommits mocks base method.
func (m *MockVersionController) SaveGarbageCollectionCommits(ctx context.Context, repository *graveler.RepositoryRecord) (*graveler.GarbageCollectionRunMetadata, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SaveGarbageCollectionCommits", ctx, repository)
	ret0, _ := ret[0].(*graveler.GarbageCollectionRunMetadata)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SaveGarbageCollectionCommits indicates an expected call of SaveGarbageCollectionCommits.
func (mr *MockVersionControllerMockRecorder) SaveGarbageCollectionCommits(ctx, repository interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveGarbageCollectionCommits", reflect.TypeOf((*MockVersionController)(nil).SaveGarbageCollectionCommits), ctx, repository)
}

// SetBranchProtectionRules mocks base method.
func (m *MockVersionController) SetBranchProtectionRules(ctx context.Context, repository *graveler.RepositoryRecord, rules *graveler.BranchProtectionRules, lastKnownChecksum *string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetBranchProtectionRules", ctx, repository, rules, lastKnownChecksum)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetBranchProtectionRules indicates an expected call of SetBranchProtectionRules.
func (mr *MockVersionControllerMockRecorder) SetBranchProtectionRules(ctx, repository, rules, lastKnownChecksum interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetBranchProtectionRules", reflect.TypeOf((*MockVersionController)(nil).SetBranchProtectionRules), ctx, repository, rules, lastKnownChecksum)
}

// SetGarbageCollectionRules mocks base method.
func (m *MockVersionController) SetGarbageCollectionRules(ctx context.Context, repository *graveler.RepositoryRecord, rules *graveler.GarbageCollectionRules) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetGarbageCollectionRules", ctx, repository, rules)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetGarbageCollectionRules indicates an expected call of SetGarbageCollectionRules.
func (mr *MockVersionControllerMockRecorder) SetGarbageCollectionRules(ctx, repository, rules interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetGarbageCollectionRules", reflect.TypeOf((*MockVersionController)(nil).SetGarbageCollectionRules), ctx, repository, rules)
}

// SetHooksHandler mocks base method.
func (m *MockVersionController) SetHooksHandler(handler graveler.HooksHandler) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetHooksHandler", handler)
}

// SetHooksHandler indicates an expected call of SetHooksHandler.
func (mr *MockVersionControllerMockRecorder) SetHooksHandler(handler interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetHooksHandler", reflect.TypeOf((*MockVersionController)(nil).SetHooksHandler), handler)
}

// SetRepositoryMetadata mocks base method.
func (m *MockVersionController) SetRepositoryMetadata(ctx context.Context, repository *graveler.RepositoryRecord, updateFunc graveler.RepoMetadataUpdateFunc) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetRepositoryMetadata", ctx, repository, updateFunc)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetRepositoryMetadata indicates an expected call of SetRepositoryMetadata.
func (mr *MockVersionControllerMockRecorder) SetRepositoryMetadata(ctx, repository, updateFunc interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetRepositoryMetadata", reflect.TypeOf((*MockVersionController)(nil).SetRepositoryMetadata), ctx, repository, updateFunc)
}

// UpdateBranch mocks base method.
func (m *MockVersionController) UpdateBranch(ctx context.Context, repository *graveler.RepositoryRecord, branchID graveler.BranchID, ref graveler.Ref, opts ...graveler.SetOptionsFunc) (*graveler.Branch, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, repository, branchID, ref}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateBranch", varargs...)
	ret0, _ := ret[0].(*graveler.Branch)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateBranch indicates an expected call of UpdateBranch.
func (mr *MockVersionControllerMockRecorder) UpdateBranch(ctx, repository, branchID, ref interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, repository, branchID, ref}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateBranch", reflect.TypeOf((*MockVersionController)(nil).UpdateBranch), varargs...)
}

// WriteMetaRangeByIterator mocks base method.
func (m *MockVersionController) WriteMetaRangeByIterator(ctx context.Context, repository *graveler.RepositoryRecord, it graveler.ValueIterator, opts ...graveler.SetOptionsFunc) (*graveler.MetaRangeID, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, repository, it}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WriteMetaRangeByIterator", varargs...)
	ret0, _ := ret[0].(*graveler.MetaRangeID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WriteMetaRangeByIterator indicates an expected call of WriteMetaRangeByIterator.
func (mr *MockVersionControllerMockRecorder) WriteMetaRangeByIterator(ctx, repository, it interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, repository, it}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteMetaRangeByIterator", reflect.TypeOf((*MockVersionController)(nil).WriteMetaRangeByIterator), varargs...)
}

// MockPlumbing is a mock of Plumbing interface.
type MockPlumbing struct {
	ctrl     *gomock.Controller
	recorder *MockPlumbingMockRecorder
}

// MockPlumbingMockRecorder is the mock recorder for MockPlumbing.
type MockPlumbingMockRecorder struct {
	mock *MockPlumbing
}

// NewMockPlumbing creates a new mock instance.
func NewMockPlumbing(ctrl *gomock.Controller) *MockPlumbing {
	mock := &MockPlumbing{ctrl: ctrl}
	mock.recorder = &MockPlumbingMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPlumbing) EXPECT() *MockPlumbingMockRecorder {
	return m.recorder
}

// GetMetaRange mocks base method.
func (m *MockPlumbing) GetMetaRange(ctx context.Context, repository *graveler.RepositoryRecord, metaRangeID graveler.MetaRangeID) (graveler.MetaRangeAddress, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMetaRange", ctx, repository, metaRangeID)
	ret0, _ := ret[0].(graveler.MetaRangeAddress)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetMetaRange indicates an expected call of GetMetaRange.
func (mr *MockPlumbingMockRecorder) GetMetaRange(ctx, repository, metaRangeID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMetaRange", reflect.TypeOf((*MockPlumbing)(nil).GetMetaRange), ctx, repository, metaRangeID)
}

// GetRange mocks base method.
func (m *MockPlumbing) GetRange(ctx context.Context, repository *graveler.RepositoryRecord, rangeID graveler.RangeID) (graveler.RangeAddress, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRange", ctx, repository, rangeID)
	ret0, _ := ret[0].(graveler.RangeAddress)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetRange indicates an expected call of GetRange.
func (mr *MockPlumbingMockRecorder) GetRange(ctx, repository, rangeID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRange", reflect.TypeOf((*MockPlumbing)(nil).GetRange), ctx, repository, rangeID)
}

// StageObject mocks base method.
func (m *MockPlumbing) StageObject(ctx context.Context, stagingToken string, object graveler.ValueRecord) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StageObject", ctx, stagingToken, object)
	ret0, _ := ret[0].(error)
	return ret0
}

// StageObject indicates an expected call of StageObject.
func (mr *MockPlumbingMockRecorder) StageObject(ctx, stagingToken, object interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StageObject", reflect.TypeOf((*MockPlumbing)(nil).StageObject), ctx, stagingToken, object)
}

// WriteMetaRange mocks base method.
func (m *MockPlumbing) WriteMetaRange(ctx context.Context, repository *graveler.RepositoryRecord, ranges []*graveler.RangeInfo, opts ...graveler.SetOptionsFunc) (*graveler.MetaRangeInfo, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, repository, ranges}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WriteMetaRange", varargs...)
	ret0, _ := ret[0].(*graveler.MetaRangeInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WriteMetaRange indicates an expected call of WriteMetaRange.
func (mr *MockPlumbingMockRecorder) WriteMetaRange(ctx, repository, ranges interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, repository, ranges}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteMetaRange", reflect.TypeOf((*MockPlumbing)(nil).WriteMetaRange), varargs...)
}

// WriteRange mocks base method.
func (m *MockPlumbing) WriteRange(ctx context.Context, repository *graveler.RepositoryRecord, it graveler.ValueIterator, opts ...graveler.SetOptionsFunc) (*graveler.RangeInfo, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, repository, it}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WriteRange", varargs...)
	ret0, _ := ret[0].(*graveler.RangeInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WriteRange indicates an expected call of WriteRange.
func (mr *MockPlumbingMockRecorder) WriteRange(ctx, repository, it interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, repository, it}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteRange", reflect.TypeOf((*MockPlumbing)(nil).WriteRange), varargs...)
}

// MockDumper is a mock of Dumper interface.
type MockDumper struct {
	ctrl     *gomock.Controller
	recorder *MockDumperMockRecorder
}

// MockDumperMockRecorder is the mock recorder for MockDumper.
type MockDumperMockRecorder struct {
	mock *MockDumper
}

// NewMockDumper creates a new mock instance.
func NewMockDumper(ctrl *gomock.Controller) *MockDumper {
	mock := &MockDumper{ctrl: ctrl}
	mock.recorder = &MockDumperMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDumper) EXPECT() *MockDumperMockRecorder {
	return m.recorder
}

// DumpBranches mocks base method.
func (m *MockDumper) DumpBranches(ctx context.Context, repository *graveler.RepositoryRecord) (*graveler.MetaRangeID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DumpBranches", ctx, repository)
	ret0, _ := ret[0].(*graveler.MetaRangeID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DumpBranches indicates an expected call of DumpBranches.
func (mr *MockDumperMockRecorder) DumpBranches(ctx, repository interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DumpBranches", reflect.TypeOf((*MockDumper)(nil).DumpBranches), ctx, repository)
}

// DumpCommits mocks base method.
func (m *MockDumper) DumpCommits(ctx context.Context, repository *graveler.RepositoryRecord) (*graveler.MetaRangeID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DumpCommits", ctx, repository)
	ret0, _ := ret[0].(*graveler.MetaRangeID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DumpCommits indicates an expected call of DumpCommits.
func (mr *MockDumperMockRecorder) DumpCommits(ctx, repository interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DumpCommits", reflect.TypeOf((*MockDumper)(nil).DumpCommits), ctx, repository)
}

// DumpTags mocks base method.
func (m *MockDumper) DumpTags(ctx context.Context, repository *graveler.RepositoryRecord) (*graveler.MetaRangeID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DumpTags", ctx, repository)
	ret0, _ := ret[0].(*graveler.MetaRangeID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DumpTags indicates an expected call of DumpTags.
func (mr *MockDumperMockRecorder) DumpTags(ctx, repository interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DumpTags", reflect.TypeOf((*MockDumper)(nil).DumpTags), ctx, repository)
}

// MockLoader is a mock of Loader interface.
type MockLoader struct {
	ctrl     *gomock.Controller
	recorder *MockLoaderMockRecorder
}

// MockLoaderMockRecorder is the mock recorder for MockLoader.
type MockLoaderMockRecorder struct {
	mock *MockLoader
}

// NewMockLoader creates a new mock instance.
func NewMockLoader(ctrl *gomock.Controller) *MockLoader {
	mock := &MockLoader{ctrl: ctrl}
	mock.recorder = &MockLoaderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLoader) EXPECT() *MockLoaderMockRecorder {
	return m.recorder
}

// LoadBranches mocks base method.
func (m *MockLoader) LoadBranches(ctx context.Context, repository *graveler.RepositoryRecord, metaRangeID graveler.MetaRangeID, opts ...graveler.SetOptionsFunc) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, repository, metaRangeID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LoadBranches", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// LoadBranches indicates an expected call of LoadBranches.
func (mr *MockLoaderMockRecorder) LoadBranches(ctx, repository, metaRangeID interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, repository, metaRangeID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadBranches", reflect.TypeOf((*MockLoader)(nil).LoadBranches), varargs...)
}

// LoadCommits mocks base method.
func (m *MockLoader) LoadCommits(ctx context.Context, repository *graveler.RepositoryRecord, metaRangeID graveler.MetaRangeID, opts ...graveler.SetOptionsFunc) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, repository, metaRangeID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LoadCommits", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// LoadCommits indicates an expected call of LoadCommits.
func (mr *MockLoaderMockRecorder) LoadCommits(ctx, repository, metaRangeID interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, repository, metaRangeID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadCommits", reflect.TypeOf((*MockLoader)(nil).LoadCommits), varargs...)
}

// LoadTags mocks base method.
func (m *MockLoader) LoadTags(ctx context.Context, repository *graveler.RepositoryRecord, metaRangeID graveler.MetaRangeID, opts ...graveler.SetOptionsFunc) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, repository, metaRangeID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LoadTags", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// LoadTags indicates an expected call of LoadTags.
func (mr *MockLoaderMockRecorder) LoadTags(ctx, repository, metaRangeID interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, repository, metaRangeID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadTags", reflect.TypeOf((*MockLoader)(nil).LoadTags), varargs...)
}

// MockRepositoryIterator is a mock of RepositoryIterator interface.
type MockRepositoryIterator struct {
	ctrl     *gomock.Controller
	recorder *MockRepositoryIteratorMockRecorder
}

// MockRepositoryIteratorMockRecorder is the mock recorder for MockRepositoryIterator.
type MockRepositoryIteratorMockRecorder struct {
	mock *MockRepositoryIterator
}

// NewMockRepositoryIterator creates a new mock instance.
func NewMockRepositoryIterator(ctrl *gomock.Controller) *MockRepositoryIterator {
	mock := &MockRepositoryIterator{ctrl: ctrl}
	mock.recorder = &MockRepositoryIteratorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepositoryIterator) EXPECT() *MockRepositoryIteratorMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockRepositoryIterator) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close.
func (mr *MockRepositoryIteratorMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockRepositoryIterator)(nil).Close))
}

// Err mocks base method.
func (m *MockRepositoryIterator) Err() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Err")
	ret0, _ := ret[0].(error)
	return ret0
}

// Err indicates an expected call of Err.
func (mr *MockRepositoryIteratorMockRecorder) Err() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Err", reflect.TypeOf((*MockRepositoryIterator)(nil).Err))
}

// Next mocks base method.
func (m *MockRepositoryIterator) Next() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Next")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Next indicates an expected call of Next.
func (mr *MockRepositoryIteratorMockRecorder) Next() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Next", reflect.TypeOf((*MockRepositoryIterator)(nil).Next))
}

// SeekGE mocks base method.
func (m *MockRepositoryIterator) SeekGE(id graveler.RepositoryID) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SeekGE", id)
}

// SeekGE indicates an expected call of SeekGE.
func (mr *MockRepositoryIteratorMockRecorder) SeekGE(id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SeekGE", reflect.TypeOf((*MockRepositoryIterator)(nil).SeekGE), id)
}

// Value mocks base method.
func (m *MockRepositoryIterator) Value() *graveler.RepositoryRecord {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Value")
	ret0, _ := ret[0].(*graveler.RepositoryRecord)
	return ret0
}

// Value indicates an expected call of Value.
func (mr *MockRepositoryIteratorMockRecorder) Value() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Value", reflect.TypeOf((*MockRepositoryIterator)(nil).Value))
}

// MockValueIterator is a mock of ValueIterator interface.
type MockValueIterator struct {
	ctrl     *gomock.Controller
	recorder *MockValueIteratorMockRecorder
}

// MockValueIteratorMockRecorder is the mock recorder for MockValueIterator.
type MockValueIteratorMockRecorder struct {
	mock *MockValueIterator
}

// NewMockValueIterator creates a new mock instance.
func NewMockValueIterator(ctrl *gomock.Controller) *MockValueIterator {
	mock := &MockValueIterator{ctrl: ctrl}
	mock.recorder = &MockValueIteratorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockValueIterator) EXPECT() *MockValueIteratorMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockValueIterator) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close.
func (mr *MockValueIteratorMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockValueIterator)(nil).Close))
}

// Err mocks base method.
func (m *MockValueIterator) Err() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Err")
	ret0, _ := ret[0].(error)
	return ret0
}

// Err indicates an expected call of Err.
func (mr *MockValueIteratorMockRecorder) Err() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Err", reflect.TypeOf((*MockValueIterator)(nil).Err))
}

// Next mocks base method.
func (m *MockValueIterator) Next() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Next")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Next indicates an expected call of Next.
func (mr *MockValueIteratorMockRecorder) Next() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Next", reflect.TypeOf((*MockValueIterator)(nil).Next))
}

// SeekGE mocks base method.
func (m *MockValueIterator) SeekGE(id graveler.Key) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SeekGE", id)
}

// SeekGE indicates an expected call of SeekGE.
func (mr *MockValueIteratorMockRecorder) SeekGE(id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SeekGE", reflect.TypeOf((*MockValueIterator)(nil).SeekGE), id)
}

// Value mocks base method.
func (m *MockValueIterator) Value() *graveler.ValueRecord {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Value")
	ret0, _ := ret[0].(*graveler.ValueRecord)
	return ret0
}

// Value indicates an expected call of Value.
func (mr *MockValueIteratorMockRecorder) Value() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Value", reflect.TypeOf((*MockValueIterator)(nil).Value))
}

// MockDiffIterator is a mock of DiffIterator interface.
type MockDiffIterator struct {
	ctrl     *gomock.Controller
	recorder *MockDiffIteratorMockRecorder
}

// MockDiffIteratorMockRecorder is the mock recorder for MockDiffIterator.
type MockDiffIteratorMockRecorder struct {
	mock *MockDiffIterator
}

// NewMockDiffIterator creates a new mock instance.
func NewMockDiffIterator(ctrl *gomock.Controller) *MockDiffIterator {
	mock := &MockDiffIterator{ctrl: ctrl}
	mock.recorder = &MockDiffIteratorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDiffIterator) EXPECT() *MockDiffIteratorMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockDiffIterator) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close.
func (mr *MockDiffIteratorMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockDiffIterator)(nil).Close))
}

// Err mocks base method.
func (m *MockDiffIterator) Err() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Err")
	ret0, _ := ret[0].(error)
	return ret0
}

// Err indicates an expected call of Err.
func (mr *MockDiffIteratorMockRecorder) Err() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Err", reflect.TypeOf((*MockDiffIterator)(nil).Err))
}

// Next mocks base method.
func (m *MockDiffIterator) Next() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Next")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Next indicates an expected call of Next.
func (mr *MockDiffIteratorMockRecorder) Next() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Next", reflect.TypeOf((*MockDiffIterator)(nil).Next))
}

// SeekGE mocks base method.
func (m *MockDiffIterator) SeekGE(id graveler.Key) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SeekGE", id)
}

// SeekGE indicates an expected call of SeekGE.
func (mr *MockDiffIteratorMockRecorder) SeekGE(id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SeekGE", reflect.TypeOf((*MockDiffIterator)(nil).SeekGE), id)
}

// Value mocks base method.
func (m *MockDiffIterator) Value() *graveler.Diff {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Value")
	ret0, _ := ret[0].(*graveler.Diff)
	return ret0
}

// Value indicates an expected call of Value.
func (mr *MockDiffIteratorMockRecorder) Value() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Value", reflect.TypeOf((*MockDiffIterator)(nil).Value))
}

// MockBranchIterator is a mock of BranchIterator interface.
type MockBranchIterator struct {
	ctrl     *gomock.Controller
	recorder *MockBranchIteratorMockRecorder
}

// MockBranchIteratorMockRecorder is the mock recorder for MockBranchIterator.
type MockBranchIteratorMockRecorder struct {
	mock *MockBranchIterator
}

// NewMockBranchIterator creates a new mock instance.
func NewMockBranchIterator(ctrl *gomock.Controller) *MockBranchIterator {
	mock := &MockBranchIterator{ctrl: ctrl}
	mock.recorder = &MockBranchIteratorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBranchIterator) EXPECT() *MockBranchIteratorMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockBranchIterator) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close.
func (mr *MockBranchIteratorMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockBranchIterator)(nil).Close))
}

// Err mocks base method.
func (m *MockBranchIterator) Err() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Err")
	ret0, _ := ret[0].(error)
	return ret0
}

// Err indicates an expected call of Err.
func (mr *MockBranchIteratorMockRecorder) Err() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Err", reflect.TypeOf((*MockBranchIterator)(nil).Err))
}

// Next mocks base method.
func (m *MockBranchIterator) Next() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Next")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Next indicates an expected call of Next.
func (mr *MockBranchIteratorMockRecorder) Next() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Next", reflect.TypeOf((*MockBranchIterator)(nil).Next))
}

// SeekGE mocks base method.
func (m *MockBranchIterator) SeekGE(id graveler.BranchID) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SeekGE", id)
}

// SeekGE indicates an expected call of SeekGE.
func (mr *MockBranchIteratorMockRecorder) SeekGE(id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SeekGE", reflect.TypeOf((*MockBranchIterator)(nil).SeekGE), id)
}

// Value mocks base method.
func (m *MockBranchIterator) Value() *graveler.BranchRecord {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Value")
	ret0, _ := ret[0].(*graveler.BranchRecord)
	return ret0
}

// Value indicates an expected call of Value.
func (mr *MockBranchIteratorMockRecorder) Value() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Value", reflect.TypeOf((*MockBranchIterator)(nil).Value))
}

// MockTagIterator is a mock of TagIterator interface.
type MockTagIterator struct {
	ctrl     *gomock.Controller
	recorder *MockTagIteratorMockRecorder
}

// MockTagIteratorMockRecorder is the mock recorder for MockTagIterator.
type MockTagIteratorMockRecorder struct {
	mock *MockTagIterator
}

// NewMockTagIterator creates a new mock instance.
func NewMockTagIterator(ctrl *gomock.Controller) *MockTagIterator {
	mock := &MockTagIterator{ctrl: ctrl}
	mock.recorder = &MockTagIteratorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTagIterator) EXPECT() *MockTagIteratorMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockTagIterator) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close.
func (mr *MockTagIteratorMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockTagIterator)(nil).Close))
}

// Err mocks base method.
func (m *MockTagIterator) Err() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Err")
	ret0, _ := ret[0].(error)
	return ret0
}

// Err indicates an expected call of Err.
func (mr *MockTagIteratorMockRecorder) Err() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Err", reflect.TypeOf((*MockTagIterator)(nil).Err))
}

// Next mocks base method.
func (m *MockTagIterator) Next() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Next")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Next indicates an expected call of Next.
func (mr *MockTagIteratorMockRecorder) Next() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Next", reflect.TypeOf((*MockTagIterator)(nil).Next))
}

// SeekGE mocks base method.
func (m *MockTagIterator) SeekGE(id graveler.TagID) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SeekGE", id)
}

// SeekGE indicates an expected call of SeekGE.
func (mr *MockTagIteratorMockRecorder) SeekGE(id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SeekGE", reflect.TypeOf((*MockTagIterator)(nil).SeekGE), id)
}

// Value mocks base method.
func (m *MockTagIterator) Value() *graveler.TagRecord {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Value")
	ret0, _ := ret[0].(*graveler.TagRecord)
	return ret0
}

// Value indicates an expected call of Value.
func (mr *MockTagIteratorMockRecorder) Value() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Value", reflect.TypeOf((*MockTagIterator)(nil).Value))
}

// MockCommitIterator is a mock of CommitIterator interface.
type MockCommitIterator struct {
	ctrl     *gomock.Controller
	recorder *MockCommitIteratorMockRecorder
}

// MockCommitIteratorMockRecorder is the mock recorder for MockCommitIterator.
type MockCommitIteratorMockRecorder struct {
	mock *MockCommitIterator
}

// NewMockCommitIterator creates a new mock instance.
func NewMockCommitIterator(ctrl *gomock.Controller) *MockCommitIterator {
	mock := &MockCommitIterator{ctrl: ctrl}
	mock.recorder = &MockCommitIteratorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCommitIterator) EXPECT() *MockCommitIteratorMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockCommitIterator) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close.
func (mr *MockCommitIteratorMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockCommitIterator)(nil).Close))
}

// Err mocks base method.
func (m *MockCommitIterator) Err() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Err")
	ret0, _ := ret[0].(error)
	return ret0
}

// Err indicates an expected call of Err.
func (mr *MockCommitIteratorMockRecorder) Err() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Err", reflect.TypeOf((*MockCommitIterator)(nil).Err))
}

// Next mocks base method.
func (m *MockCommitIterator) Next() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Next")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Next indicates an expected call of Next.
func (mr *MockCommitIteratorMockRecorder) Next() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Next", reflect.TypeOf((*MockCommitIterator)(nil).Next))
}

// SeekGE mocks base method.
func (m *MockCommitIterator) SeekGE(id graveler.CommitID) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SeekGE", id)
}

// SeekGE indicates an expected call of SeekGE.
func (mr *MockCommitIteratorMockRecorder) SeekGE(id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SeekGE", reflect.TypeOf((*MockCommitIterator)(nil).SeekGE), id)
}

// Value mocks base method.
func (m *MockCommitIterator) Value() *graveler.CommitRecord {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Value")
	ret0, _ := ret[0].(*graveler.CommitRecord)
	return ret0
}

// Value indicates an expected call of Value.
func (mr *MockCommitIteratorMockRecorder) Value() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Value", reflect.TypeOf((*MockCommitIterator)(nil).Value))
}

// MockLinkAddressIterator is a mock of LinkAddressIterator interface.
type MockLinkAddressIterator struct {
	ctrl     *gomock.Controller
	recorder *MockLinkAddressIteratorMockRecorder
}

// MockLinkAddressIteratorMockRecorder is the mock recorder for MockLinkAddressIterator.
type MockLinkAddressIteratorMockRecorder struct {
	mock *MockLinkAddressIterator
}

// NewMockLinkAddressIterator creates a new mock instance.
func NewMockLinkAddressIterator(ctrl *gomock.Controller) *MockLinkAddressIterator {
	mock := &MockLinkAddressIterator{ctrl: ctrl}
	mock.recorder = &MockLinkAddressIteratorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLinkAddressIterator) EXPECT() *MockLinkAddressIteratorMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockLinkAddressIterator) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close.
func (mr *MockLinkAddressIteratorMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockLinkAddressIterator)(nil).Close))
}

// Err mocks base method.
func (m *MockLinkAddressIterator) Err() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Err")
	ret0, _ := ret[0].(error)
	return ret0
}

// Err indicates an expected call of Err.
func (mr *MockLinkAddressIteratorMockRecorder) Err() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Err", reflect.TypeOf((*MockLinkAddressIterator)(nil).Err))
}

// Next mocks base method.
func (m *MockLinkAddressIterator) Next() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Next")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Next indicates an expected call of Next.
func (mr *MockLinkAddressIteratorMockRecorder) Next() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Next", reflect.TypeOf((*MockLinkAddressIterator)(nil).Next))
}

// SeekGE mocks base method.
func (m *MockLinkAddressIterator) SeekGE(address string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SeekGE", address)
}

// SeekGE indicates an expected call of SeekGE.
func (mr *MockLinkAddressIteratorMockRecorder) SeekGE(address interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SeekGE", reflect.TypeOf((*MockLinkAddressIterator)(nil).SeekGE), address)
}

// Value mocks base method.
func (m *MockLinkAddressIterator) Value() *graveler.LinkAddressData {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Value")
	ret0, _ := ret[0].(*graveler.LinkAddressData)
	return ret0
}

// Value indicates an expected call of Value.
func (mr *MockLinkAddressIteratorMockRecorder) Value() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Value", reflect.TypeOf((*MockLinkAddressIterator)(nil).Value))
}

// MockRefManager is a mock of RefManager interface.
type MockRefManager struct {
	ctrl     *gomock.Controller
	recorder *MockRefManagerMockRecorder
}

// MockRefManagerMockRecorder is the mock recorder for MockRefManager.
type MockRefManagerMockRecorder struct {
	mock *MockRefManager
}

// NewMockRefManager creates a new mock instance.
func NewMockRefManager(ctrl *gomock.Controller) *MockRefManager {
	mock := &MockRefManager{ctrl: ctrl}
	mock.recorder = &MockRefManagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRefManager) EXPECT() *MockRefManagerMockRecorder {
	return m.recorder
}

// AddCommit mocks base method.
func (m *MockRefManager) AddCommit(ctx context.Context, repository *graveler.RepositoryRecord, commit graveler.Commit) (graveler.CommitID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddCommit", ctx, repository, commit)
	ret0, _ := ret[0].(graveler.CommitID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AddCommit indicates an expected call of AddCommit.
func (mr *MockRefManagerMockRecorder) AddCommit(ctx, repository, commit interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddCommit", reflect.TypeOf((*MockRefManager)(nil).AddCommit), ctx, repository, commit)
}

// BranchUpdate mocks base method.
func (m *MockRefManager) BranchUpdate(ctx context.Context, repository *graveler.RepositoryRecord, branchID graveler.BranchID, f graveler.BranchUpdateFunc) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BranchUpdate", ctx, repository, branchID, f)
	ret0, _ := ret[0].(error)
	return ret0
}

// BranchUpdate indicates an expected call of BranchUpdate.
func (mr *MockRefManagerMockRecorder) BranchUpdate(ctx, repository, branchID, f interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BranchUpdate", reflect.TypeOf((*MockRefManager)(nil).BranchUpdate), ctx, repository, branchID, f)
}

// CreateBareRepository mocks base method.
func (m *MockRefManager) CreateBareRepository(ctx context.Context, repositoryID graveler.RepositoryID, repository graveler.Repository) (*graveler.RepositoryRecord, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateBareRepository", ctx, repositoryID, repository)
	ret0, _ := ret[0].(*graveler.RepositoryRecord)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateBareRepository indicates an expected call of CreateBareRepository.
func (mr *MockRefManagerMockRecorder) CreateBareRepository(ctx, repositoryID, repository interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateBareRepository", reflect.TypeOf((*MockRefManager)(nil).CreateBareRepository), ctx, repositoryID, repository)
}

// CreateBranch mocks base method.
func (m *MockRefManager) CreateBranch(ctx context.Context, repository *graveler.RepositoryRecord, branchID graveler.BranchID, branch graveler.Branch) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateBranch", ctx, repository, branchID, branch)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateBranch indicates an expected call of CreateBranch.
func (mr *MockRefManagerMockRecorder) CreateBranch(ctx, repository, branchID, branch interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateBranch", reflect.TypeOf((*MockRefManager)(nil).CreateBranch), ctx, repository, branchID, branch)
}

// CreateCommitRecord mocks base method.
func (m *MockRefManager) CreateCommitRecord(ctx context.Context, repository *graveler.RepositoryRecord, commitID graveler.CommitID, commit graveler.Commit) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateCommitRecord", ctx, repository, commitID, commit)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateCommitRecord indicates an expected call of CreateCommitRecord.
func (mr *MockRefManagerMockRecorder) CreateCommitRecord(ctx, repository, commitID, commit interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateCommitRecord", reflect.TypeOf((*MockRefManager)(nil).CreateCommitRecord), ctx, repository, commitID, commit)
}

// CreateRepository mocks base method.
func (m *MockRefManager) CreateRepository(ctx context.Context, repositoryID graveler.RepositoryID, repository graveler.Repository) (*graveler.RepositoryRecord, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateRepository", ctx, repositoryID, repository)
	ret0, _ := ret[0].(*graveler.RepositoryRecord)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateRepository indicates an expected call of CreateRepository.
func (mr *MockRefManagerMockRecorder) CreateRepository(ctx, repositoryID, repository interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateRepository", reflect.TypeOf((*MockRefManager)(nil).CreateRepository), ctx, repositoryID, repository)
}

// CreateTag mocks base method.
func (m *MockRefManager) CreateTag(ctx context.Context, repository *graveler.RepositoryRecord, tagID graveler.TagID, commitID graveler.CommitID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateTag", ctx, repository, tagID, commitID)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateTag indicates an expected call of CreateTag.
func (mr *MockRefManagerMockRecorder) CreateTag(ctx, repository, tagID, commitID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTag", reflect.TypeOf((*MockRefManager)(nil).CreateTag), ctx, repository, tagID, commitID)
}

// DeleteBranch mocks base method.
func (m *MockRefManager) DeleteBranch(ctx context.Context, repository *graveler.RepositoryRecord, branchID graveler.BranchID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteBranch", ctx, repository, branchID)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteBranch indicates an expected call of DeleteBranch.
func (mr *MockRefManagerMockRecorder) DeleteBranch(ctx, repository, branchID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteBranch", reflect.TypeOf((*MockRefManager)(nil).DeleteBranch), ctx, repository, branchID)
}

// DeleteExpiredImports mocks base method.
func (m *MockRefManager) DeleteExpiredImports(ctx context.Context, repository *graveler.RepositoryRecord) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteExpiredImports", ctx, repository)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteExpiredImports indicates an expected call of DeleteExpiredImports.
func (mr *MockRefManagerMockRecorder) DeleteExpiredImports(ctx, repository interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteExpiredImports", reflect.TypeOf((*MockRefManager)(nil).DeleteExpiredImports), ctx, repository)
}

// DeleteRepository mocks base method.
func (m *MockRefManager) DeleteRepository(ctx context.Context, repositoryID graveler.RepositoryID, opts ...graveler.SetOptionsFunc) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, repositoryID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteRepository", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteRepository indicates an expected call of DeleteRepository.
func (mr *MockRefManagerMockRecorder) DeleteRepository(ctx, repositoryID interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, repositoryID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteRepository", reflect.TypeOf((*MockRefManager)(nil).DeleteRepository), varargs...)
}

// DeleteTag mocks base method.
func (m *MockRefManager) DeleteTag(ctx context.Context, repository *graveler.RepositoryRecord, tagID graveler.TagID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteTag", ctx, repository, tagID)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteTag indicates an expected call of DeleteTag.
func (mr *MockRefManagerMockRecorder) DeleteTag(ctx, repository, tagID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteTag", reflect.TypeOf((*MockRefManager)(nil).DeleteTag), ctx, repository, tagID)
}

// FindMergeBase mocks base method.
func (m *MockRefManager) FindMergeBase(ctx context.Context, repository *graveler.RepositoryRecord, commitIDs ...graveler.CommitID) (*graveler.Commit, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, repository}
	for _, a := range commitIDs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FindMergeBase", varargs...)
	ret0, _ := ret[0].(*graveler.Commit)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindMergeBase indicates an expected call of FindMergeBase.
func (mr *MockRefManagerMockRecorder) FindMergeBase(ctx, repository interface{}, commitIDs ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, repository}, commitIDs...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindMergeBase", reflect.TypeOf((*MockRefManager)(nil).FindMergeBase), varargs...)
}

// GCBranchIterator mocks base method.
func (m *MockRefManager) GCBranchIterator(ctx context.Context, repository *graveler.RepositoryRecord) (graveler.BranchIterator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GCBranchIterator", ctx, repository)
	ret0, _ := ret[0].(graveler.BranchIterator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GCBranchIterator indicates an expected call of GCBranchIterator.
func (mr *MockRefManagerMockRecorder) GCBranchIterator(ctx, repository interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GCBranchIterator", reflect.TypeOf((*MockRefManager)(nil).GCBranchIterator), ctx, repository)
}

// GCCommitIterator mocks base method.
func (m *MockRefManager) GCCommitIterator(ctx context.Context, repository *graveler.RepositoryRecord) (graveler.CommitIterator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GCCommitIterator", ctx, repository)
	ret0, _ := ret[0].(graveler.CommitIterator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GCCommitIterator indicates an expected call of GCCommitIterator.
func (mr *MockRefManagerMockRecorder) GCCommitIterator(ctx, repository interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GCCommitIterator", reflect.TypeOf((*MockRefManager)(nil).GCCommitIterator), ctx, repository)
}

// GetBranch mocks base method.
func (m *MockRefManager) GetBranch(ctx context.Context, repository *graveler.RepositoryRecord, branchID graveler.BranchID) (*graveler.Branch, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBranch", ctx, repository, branchID)
	ret0, _ := ret[0].(*graveler.Branch)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBranch indicates an expected call of GetBranch.
func (mr *MockRefManagerMockRecorder) GetBranch(ctx, repository, branchID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBranch", reflect.TypeOf((*MockRefManager)(nil).GetBranch), ctx, repository, branchID)
}

// GetCommit mocks base method.
func (m *MockRefManager) GetCommit(ctx context.Context, repository *graveler.RepositoryRecord, commitID graveler.CommitID) (*graveler.Commit, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCommit", ctx, repository, commitID)
	ret0, _ := ret[0].(*graveler.Commit)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCommit indicates an expected call of GetCommit.
func (mr *MockRefManagerMockRecorder) GetCommit(ctx, repository, commitID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCommit", reflect.TypeOf((*MockRefManager)(nil).GetCommit), ctx, repository, commitID)
}

// GetCommitByPrefix mocks base method.
func (m *MockRefManager) GetCommitByPrefix(ctx context.Context, repository *graveler.RepositoryRecord, prefix graveler.CommitID) (*graveler.Commit, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCommitByPrefix", ctx, repository, prefix)
	ret0, _ := ret[0].(*graveler.Commit)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCommitByPrefix indicates an expected call of GetCommitByPrefix.
func (mr *MockRefManagerMockRecorder) GetCommitByPrefix(ctx, repository, prefix interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCommitByPrefix", reflect.TypeOf((*MockRefManager)(nil).GetCommitByPrefix), ctx, repository, prefix)
}

// GetRepository mocks base method.
func (m *MockRefManager) GetRepository(ctx context.Context, repositoryID graveler.RepositoryID) (*graveler.RepositoryRecord, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRepository", ctx, repositoryID)
	ret0, _ := ret[0].(*graveler.RepositoryRecord)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetRepository indicates an expected call of GetRepository.
func (mr *MockRefManagerMockRecorder) GetRepository(ctx, repositoryID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRepository", reflect.TypeOf((*MockRefManager)(nil).GetRepository), ctx, repositoryID)
}

// GetRepositoryMetadata mocks base method.
func (m *MockRefManager) GetRepositoryMetadata(ctx context.Context, repositoryID graveler.RepositoryID) (graveler.RepositoryMetadata, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRepositoryMetadata", ctx, repositoryID)
	ret0, _ := ret[0].(graveler.RepositoryMetadata)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetRepositoryMetadata indicates an expected call of GetRepositoryMetadata.
func (mr *MockRefManagerMockRecorder) GetRepositoryMetadata(ctx, repositoryID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRepositoryMetadata", reflect.TypeOf((*MockRefManager)(nil).GetRepositoryMetadata), ctx, repositoryID)
}

// GetTag mocks base method.
func (m *MockRefManager) GetTag(ctx context.Context, repository *graveler.RepositoryRecord, tagID graveler.TagID) (*graveler.CommitID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTag", ctx, repository, tagID)
	ret0, _ := ret[0].(*graveler.CommitID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTag indicates an expected call of GetTag.
func (mr *MockRefManagerMockRecorder) GetTag(ctx, repository, tagID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTag", reflect.TypeOf((*MockRefManager)(nil).GetTag), ctx, repository, tagID)
}

// ListBranches mocks base method.
func (m *MockRefManager) ListBranches(ctx context.Context, repository *graveler.RepositoryRecord) (graveler.BranchIterator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListBranches", ctx, repository)
	ret0, _ := ret[0].(graveler.BranchIterator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListBranches indicates an expected call of ListBranches.
func (mr *MockRefManagerMockRecorder) ListBranches(ctx, repository interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListBranches", reflect.TypeOf((*MockRefManager)(nil).ListBranches), ctx, repository)
}

// ListCommits mocks base method.
func (m *MockRefManager) ListCommits(ctx context.Context, repository *graveler.RepositoryRecord) (graveler.CommitIterator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListCommits", ctx, repository)
	ret0, _ := ret[0].(graveler.CommitIterator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListCommits indicates an expected call of ListCommits.
func (mr *MockRefManagerMockRecorder) ListCommits(ctx, repository interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListCommits", reflect.TypeOf((*MockRefManager)(nil).ListCommits), ctx, repository)
}

// ListRepositories mocks base method.
func (m *MockRefManager) ListRepositories(ctx context.Context) (graveler.RepositoryIterator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListRepositories", ctx)
	ret0, _ := ret[0].(graveler.RepositoryIterator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListRepositories indicates an expected call of ListRepositories.
func (mr *MockRefManagerMockRecorder) ListRepositories(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListRepositories", reflect.TypeOf((*MockRefManager)(nil).ListRepositories), ctx)
}

// ListTags mocks base method.
func (m *MockRefManager) ListTags(ctx context.Context, repository *graveler.RepositoryRecord) (graveler.TagIterator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListTags", ctx, repository)
	ret0, _ := ret[0].(graveler.TagIterator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListTags indicates an expected call of ListTags.
func (mr *MockRefManagerMockRecorder) ListTags(ctx, repository interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListTags", reflect.TypeOf((*MockRefManager)(nil).ListTags), ctx, repository)
}

// Log mocks base method.
func (m *MockRefManager) Log(ctx context.Context, repository *graveler.RepositoryRecord, commitID graveler.CommitID, firstParent bool, since *time.Time) (graveler.CommitIterator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Log", ctx, repository, commitID, firstParent, since)
	ret0, _ := ret[0].(graveler.CommitIterator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Log indicates an expected call of Log.
func (mr *MockRefManagerMockRecorder) Log(ctx, repository, commitID, firstParent, since interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Log", reflect.TypeOf((*MockRefManager)(nil).Log), ctx, repository, commitID, firstParent, since)
}

// ParseRef mocks base method.
func (m *MockRefManager) ParseRef(ref graveler.Ref) (graveler.RawRef, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ParseRef", ref)
	ret0, _ := ret[0].(graveler.RawRef)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ParseRef indicates an expected call of ParseRef.
func (mr *MockRefManagerMockRecorder) ParseRef(ref interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ParseRef", reflect.TypeOf((*MockRefManager)(nil).ParseRef), ref)
}

// RemoveCommit mocks base method.
func (m *MockRefManager) RemoveCommit(ctx context.Context, repository *graveler.RepositoryRecord, commitID graveler.CommitID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveCommit", ctx, repository, commitID)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveCommit indicates an expected call of RemoveCommit.
func (mr *MockRefManagerMockRecorder) RemoveCommit(ctx, repository, commitID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveCommit", reflect.TypeOf((*MockRefManager)(nil).RemoveCommit), ctx, repository, commitID)
}

// ResolveRawRef mocks base method.
func (m *MockRefManager) ResolveRawRef(ctx context.Context, repository *graveler.RepositoryRecord, rawRef graveler.RawRef) (*graveler.ResolvedRef, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ResolveRawRef", ctx, repository, rawRef)
	ret0, _ := ret[0].(*graveler.ResolvedRef)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ResolveRawRef indicates an expected call of ResolveRawRef.
func (mr *MockRefManagerMockRecorder) ResolveRawRef(ctx, repository, rawRef interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResolveRawRef", reflect.TypeOf((*MockRefManager)(nil).ResolveRawRef), ctx, repository, rawRef)
}

// SetBranch mocks base method.
func (m *MockRefManager) SetBranch(ctx context.Context, repository *graveler.RepositoryRecord, branchID graveler.BranchID, branch graveler.Branch) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetBranch", ctx, repository, branchID, branch)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetBranch indicates an expected call of SetBranch.
func (mr *MockRefManagerMockRecorder) SetBranch(ctx, repository, branchID, branch interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetBranch", reflect.TypeOf((*MockRefManager)(nil).SetBranch), ctx, repository, branchID, branch)
}

// SetRepositoryMetadata mocks base method.
func (m *MockRefManager) SetRepositoryMetadata(ctx context.Context, repository *graveler.RepositoryRecord, updateFunc graveler.RepoMetadataUpdateFunc) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetRepositoryMetadata", ctx, repository, updateFunc)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetRepositoryMetadata indicates an expected call of SetRepositoryMetadata.
func (mr *MockRefManagerMockRecorder) SetRepositoryMetadata(ctx, repository, updateFunc interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetRepositoryMetadata", reflect.TypeOf((*MockRefManager)(nil).SetRepositoryMetadata), ctx, repository, updateFunc)
}

// MockCommittedManager is a mock of CommittedManager interface.
type MockCommittedManager struct {
	ctrl     *gomock.Controller
	recorder *MockCommittedManagerMockRecorder
}

// MockCommittedManagerMockRecorder is the mock recorder for MockCommittedManager.
type MockCommittedManagerMockRecorder struct {
	mock *MockCommittedManager
}

// NewMockCommittedManager creates a new mock instance.
func NewMockCommittedManager(ctrl *gomock.Controller) *MockCommittedManager {
	mock := &MockCommittedManager{ctrl: ctrl}
	mock.recorder = &MockCommittedManagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCommittedManager) EXPECT() *MockCommittedManagerMockRecorder {
	return m.recorder
}

// Commit mocks base method.
func (m *MockCommittedManager) Commit(ctx context.Context, ns graveler.StorageNamespace, baseMetaRangeID graveler.MetaRangeID, changes graveler.ValueIterator, allowEmpty bool, opts ...graveler.SetOptionsFunc) (graveler.MetaRangeID, graveler.DiffSummary, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, ns, baseMetaRangeID, changes, allowEmpty}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Commit", varargs...)
	ret0, _ := ret[0].(graveler.MetaRangeID)
	ret1, _ := ret[1].(graveler.DiffSummary)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// Commit indicates an expected call of Commit.
func (mr *MockCommittedManagerMockRecorder) Commit(ctx, ns, baseMetaRangeID, changes, allowEmpty interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, ns, baseMetaRangeID, changes, allowEmpty}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockCommittedManager)(nil).Commit), varargs...)
}

// Compare mocks base method.
func (m *MockCommittedManager) Compare(ctx context.Context, ns graveler.StorageNamespace, destination, source, base graveler.MetaRangeID) (graveler.DiffIterator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Compare", ctx, ns, destination, source, base)
	ret0, _ := ret[0].(graveler.DiffIterator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Compare indicates an expected call of Compare.
func (mr *MockCommittedManagerMockRecorder) Compare(ctx, ns, destination, source, base interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Compare", reflect.TypeOf((*MockCommittedManager)(nil).Compare), ctx, ns, destination, source, base)
}

// Diff mocks base method.
func (m *MockCommittedManager) Diff(ctx context.Context, ns graveler.StorageNamespace, left, right graveler.MetaRangeID) (graveler.DiffIterator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Diff", ctx, ns, left, right)
	ret0, _ := ret[0].(graveler.DiffIterator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Diff indicates an expected call of Diff.
func (mr *MockCommittedManagerMockRecorder) Diff(ctx, ns, left, right interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Diff", reflect.TypeOf((*MockCommittedManager)(nil).Diff), ctx, ns, left, right)
}

// Exists mocks base method.
func (m *MockCommittedManager) Exists(ctx context.Context, ns graveler.StorageNamespace, id graveler.MetaRangeID) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exists", ctx, ns, id)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Exists indicates an expected call of Exists.
func (mr *MockCommittedManagerMockRecorder) Exists(ctx, ns, id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exists", reflect.TypeOf((*MockCommittedManager)(nil).Exists), ctx, ns, id)
}

// Get mocks base method.
func (m *MockCommittedManager) Get(ctx context.Context, ns graveler.StorageNamespace, rangeID graveler.MetaRangeID, key graveler.Key) (*graveler.Value, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, ns, rangeID, key)
	ret0, _ := ret[0].(*graveler.Value)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockCommittedManagerMockRecorder) Get(ctx, ns, rangeID, key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockCommittedManager)(nil).Get), ctx, ns, rangeID, key)
}

// GetMetaRange mocks base method.
func (m *MockCommittedManager) GetMetaRange(ctx context.Context, ns graveler.StorageNamespace, metaRangeID graveler.MetaRangeID) (graveler.MetaRangeAddress, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMetaRange", ctx, ns, metaRangeID)
	ret0, _ := ret[0].(graveler.MetaRangeAddress)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetMetaRange indicates an expected call of GetMetaRange.
func (mr *MockCommittedManagerMockRecorder) GetMetaRange(ctx, ns, metaRangeID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMetaRange", reflect.TypeOf((*MockCommittedManager)(nil).GetMetaRange), ctx, ns, metaRangeID)
}

// GetRange mocks base method.
func (m *MockCommittedManager) GetRange(ctx context.Context, ns graveler.StorageNamespace, rangeID graveler.RangeID) (graveler.RangeAddress, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRange", ctx, ns, rangeID)
	ret0, _ := ret[0].(graveler.RangeAddress)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetRange indicates an expected call of GetRange.
func (mr *MockCommittedManagerMockRecorder) GetRange(ctx, ns, rangeID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRange", reflect.TypeOf((*MockCommittedManager)(nil).GetRange), ctx, ns, rangeID)
}

// GetRangeIDByKey mocks base method.
func (m *MockCommittedManager) GetRangeIDByKey(ctx context.Context, ns graveler.StorageNamespace, id graveler.MetaRangeID, key graveler.Key) (graveler.RangeID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRangeIDByKey", ctx, ns, id, key)
	ret0, _ := ret[0].(graveler.RangeID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetRangeIDByKey indicates an expected call of GetRangeIDByKey.
func (mr *MockCommittedManagerMockRecorder) GetRangeIDByKey(ctx, ns, id, key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRangeIDByKey", reflect.TypeOf((*MockCommittedManager)(nil).GetRangeIDByKey), ctx, ns, id, key)
}

// Import mocks base method.
func (m *MockCommittedManager) Import(ctx context.Context, ns graveler.StorageNamespace, destination, source graveler.MetaRangeID, prefixes []graveler.Prefix, opts ...graveler.SetOptionsFunc) (graveler.MetaRangeID, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, ns, destination, source, prefixes}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Import", varargs...)
	ret0, _ := ret[0].(graveler.MetaRangeID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Import indicates an expected call of Import.
func (mr *MockCommittedManagerMockRecorder) Import(ctx, ns, destination, source, prefixes interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, ns, destination, source, prefixes}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Import", reflect.TypeOf((*MockCommittedManager)(nil).Import), varargs...)
}

// List mocks base method.
func (m *MockCommittedManager) List(ctx context.Context, ns graveler.StorageNamespace, rangeID graveler.MetaRangeID) (graveler.ValueIterator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "List", ctx, ns, rangeID)
	ret0, _ := ret[0].(graveler.ValueIterator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// List indicates an expected call of List.
func (mr *MockCommittedManagerMockRecorder) List(ctx, ns, rangeID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockCommittedManager)(nil).List), ctx, ns, rangeID)
}

// Merge mocks base method.
func (m *MockCommittedManager) Merge(ctx context.Context, ns graveler.StorageNamespace, destination, source, base graveler.MetaRangeID, strategy graveler.MergeStrategy, opts ...graveler.SetOptionsFunc) (graveler.MetaRangeID, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, ns, destination, source, base, strategy}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Merge", varargs...)
	ret0, _ := ret[0].(graveler.MetaRangeID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Merge indicates an expected call of Merge.
func (mr *MockCommittedManagerMockRecorder) Merge(ctx, ns, destination, source, base, strategy interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, ns, destination, source, base, strategy}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Merge", reflect.TypeOf((*MockCommittedManager)(nil).Merge), varargs...)
}

// WriteMetaRange mocks base method.
func (m *MockCommittedManager) WriteMetaRange(ctx context.Context, ns graveler.StorageNamespace, ranges []*graveler.RangeInfo) (*graveler.MetaRangeInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WriteMetaRange", ctx, ns, ranges)
	ret0, _ := ret[0].(*graveler.MetaRangeInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WriteMetaRange indicates an expected call of WriteMetaRange.
func (mr *MockCommittedManagerMockRecorder) WriteMetaRange(ctx, ns, ranges interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteMetaRange", reflect.TypeOf((*MockCommittedManager)(nil).WriteMetaRange), ctx, ns, ranges)
}

// WriteMetaRangeByIterator mocks base method.
func (m *MockCommittedManager) WriteMetaRangeByIterator(ctx context.Context, ns graveler.StorageNamespace, it graveler.ValueIterator, metadata graveler.Metadata) (*graveler.MetaRangeID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WriteMetaRangeByIterator", ctx, ns, it, metadata)
	ret0, _ := ret[0].(*graveler.MetaRangeID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WriteMetaRangeByIterator indicates an expected call of WriteMetaRangeByIterator.
func (mr *MockCommittedManagerMockRecorder) WriteMetaRangeByIterator(ctx, ns, it, metadata interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteMetaRangeByIterator", reflect.TypeOf((*MockCommittedManager)(nil).WriteMetaRangeByIterator), ctx, ns, it, metadata)
}

// WriteRange mocks base method.
func (m *MockCommittedManager) WriteRange(ctx context.Context, ns graveler.StorageNamespace, it graveler.ValueIterator) (*graveler.RangeInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WriteRange", ctx, ns, it)
	ret0, _ := ret[0].(*graveler.RangeInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WriteRange indicates an expected call of WriteRange.
func (mr *MockCommittedManagerMockRecorder) WriteRange(ctx, ns, it interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteRange", reflect.TypeOf((*MockCommittedManager)(nil).WriteRange), ctx, ns, it)
}

// MockStagingManager is a mock of StagingManager interface.
type MockStagingManager struct {
	ctrl     *gomock.Controller
	recorder *MockStagingManagerMockRecorder
}

// MockStagingManagerMockRecorder is the mock recorder for MockStagingManager.
type MockStagingManagerMockRecorder struct {
	mock *MockStagingManager
}

// NewMockStagingManager creates a new mock instance.
func NewMockStagingManager(ctrl *gomock.Controller) *MockStagingManager {
	mock := &MockStagingManager{ctrl: ctrl}
	mock.recorder = &MockStagingManagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStagingManager) EXPECT() *MockStagingManagerMockRecorder {
	return m.recorder
}

// Drop mocks base method.
func (m *MockStagingManager) Drop(ctx context.Context, st graveler.StagingToken) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Drop", ctx, st)
	ret0, _ := ret[0].(error)
	return ret0
}

// Drop indicates an expected call of Drop.
func (mr *MockStagingManagerMockRecorder) Drop(ctx, st interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Drop", reflect.TypeOf((*MockStagingManager)(nil).Drop), ctx, st)
}

// DropAsync mocks base method.
func (m *MockStagingManager) DropAsync(ctx context.Context, st graveler.StagingToken) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DropAsync", ctx, st)
	ret0, _ := ret[0].(error)
	return ret0
}

// DropAsync indicates an expected call of DropAsync.
func (mr *MockStagingManagerMockRecorder) DropAsync(ctx, st interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DropAsync", reflect.TypeOf((*MockStagingManager)(nil).DropAsync), ctx, st)
}

// DropByPrefix mocks base method.
func (m *MockStagingManager) DropByPrefix(ctx context.Context, st graveler.StagingToken, prefix graveler.Key) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DropByPrefix", ctx, st, prefix)
	ret0, _ := ret[0].(error)
	return ret0
}

// DropByPrefix indicates an expected call of DropByPrefix.
func (mr *MockStagingManagerMockRecorder) DropByPrefix(ctx, st, prefix interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DropByPrefix", reflect.TypeOf((*MockStagingManager)(nil).DropByPrefix), ctx, st, prefix)
}

// DropKey mocks base method.
func (m *MockStagingManager) DropKey(ctx context.Context, st graveler.StagingToken, key graveler.Key) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DropKey", ctx, st, key)
	ret0, _ := ret[0].(error)
	return ret0
}

// DropKey indicates an expected call of DropKey.
func (mr *MockStagingManagerMockRecorder) DropKey(ctx, st, key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DropKey", reflect.TypeOf((*MockStagingManager)(nil).DropKey), ctx, st, key)
}

// Get mocks base method.
func (m *MockStagingManager) Get(ctx context.Context, st graveler.StagingToken, key graveler.Key) (*graveler.Value, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, st, key)
	ret0, _ := ret[0].(*graveler.Value)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockStagingManagerMockRecorder) Get(ctx, st, key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockStagingManager)(nil).Get), ctx, st, key)
}

// List mocks base method.
func (m *MockStagingManager) List(ctx context.Context, st graveler.StagingToken, batchSize int) graveler.ValueIterator {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "List", ctx, st, batchSize)
	ret0, _ := ret[0].(graveler.ValueIterator)
	return ret0
}

// List indicates an expected call of List.
func (mr *MockStagingManagerMockRecorder) List(ctx, st, batchSize interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockStagingManager)(nil).List), ctx, st, batchSize)
}

// Set mocks base method.
func (m *MockStagingManager) Set(ctx context.Context, st graveler.StagingToken, key graveler.Key, value *graveler.Value, requireExists bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Set", ctx, st, key, value, requireExists)
	ret0, _ := ret[0].(error)
	return ret0
}

// Set indicates an expected call of Set.
func (mr *MockStagingManagerMockRecorder) Set(ctx, st, key, value, requireExists interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockStagingManager)(nil).Set), ctx, st, key, value, requireExists)
}

// Update mocks base method.
func (m *MockStagingManager) Update(ctx context.Context, st graveler.StagingToken, key graveler.Key, updateFunc graveler.ValueUpdateFunc) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Update", ctx, st, key, updateFunc)
	ret0, _ := ret[0].(error)
	return ret0
}

// Update indicates an expected call of Update.
func (mr *MockStagingManagerMockRecorder) Update(ctx, st, key, updateFunc interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockStagingManager)(nil).Update), ctx, st, key, updateFunc)
}

// MockBranchLocker is a mock of BranchLocker interface.
type MockBranchLocker struct {
	ctrl     *gomock.Controller
	recorder *MockBranchLockerMockRecorder
}

// MockBranchLockerMockRecorder is the mock recorder for MockBranchLocker.
type MockBranchLockerMockRecorder struct {
	mock *MockBranchLocker
}

// NewMockBranchLocker creates a new mock instance.
func NewMockBranchLocker(ctrl *gomock.Controller) *MockBranchLocker {
	mock := &MockBranchLocker{ctrl: ctrl}
	mock.recorder = &MockBranchLockerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBranchLocker) EXPECT() *MockBranchLockerMockRecorder {
	return m.recorder
}

// MetadataUpdater mocks base method.
func (m *MockBranchLocker) MetadataUpdater(ctx context.Context, repository *graveler.RepositoryRecord, branchID graveler.BranchID, lockeFn graveler.BranchLockerFunc) (interface{}, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MetadataUpdater", ctx, repository, branchID, lockeFn)
	ret0, _ := ret[0].(interface{})
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MetadataUpdater indicates an expected call of MetadataUpdater.
func (mr *MockBranchLockerMockRecorder) MetadataUpdater(ctx, repository, branchID, lockeFn interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MetadataUpdater", reflect.TypeOf((*MockBranchLocker)(nil).MetadataUpdater), ctx, repository, branchID, lockeFn)
}

// Writer mocks base method.
func (m *MockBranchLocker) Writer(ctx context.Context, repository *graveler.RepositoryRecord, branchID graveler.BranchID, lockedFn graveler.BranchLockerFunc) (interface{}, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Writer", ctx, repository, branchID, lockedFn)
	ret0, _ := ret[0].(interface{})
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Writer indicates an expected call of Writer.
func (mr *MockBranchLockerMockRecorder) Writer(ctx, repository, branchID, lockedFn interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Writer", reflect.TypeOf((*MockBranchLocker)(nil).Writer), ctx, repository, branchID, lockedFn)
}

// MockGarbageCollectionManager is a mock of GarbageCollectionManager interface.
type MockGarbageCollectionManager struct {
	ctrl     *gomock.Controller
	recorder *MockGarbageCollectionManagerMockRecorder
}

// MockGarbageCollectionManagerMockRecorder is the mock recorder for MockGarbageCollectionManager.
type MockGarbageCollectionManagerMockRecorder struct {
	mock *MockGarbageCollectionManager
}

// NewMockGarbageCollectionManager creates a new mock instance.
func NewMockGarbageCollectionManager(ctrl *gomock.Controller) *MockGarbageCollectionManager {
	mock := &MockGarbageCollectionManager{ctrl: ctrl}
	mock.recorder = &MockGarbageCollectionManagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGarbageCollectionManager) EXPECT() *MockGarbageCollectionManagerMockRecorder {
	return m.recorder
}

// GetAddressesLocation mocks base method.
func (m *MockGarbageCollectionManager) GetAddressesLocation(sn graveler.StorageNamespace) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAddressesLocation", sn)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAddressesLocation indicates an expected call of GetAddressesLocation.
func (mr *MockGarbageCollectionManagerMockRecorder) GetAddressesLocation(sn interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAddressesLocation", reflect.TypeOf((*MockGarbageCollectionManager)(nil).GetAddressesLocation), sn)
}

// GetCommitsCSVLocation mocks base method.
func (m *MockGarbageCollectionManager) GetCommitsCSVLocation(runID string, sn graveler.StorageNamespace) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCommitsCSVLocation", runID, sn)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCommitsCSVLocation indicates an expected call of GetCommitsCSVLocation.
func (mr *MockGarbageCollectionManagerMockRecorder) GetCommitsCSVLocation(runID, sn interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCommitsCSVLocation", reflect.TypeOf((*MockGarbageCollectionManager)(nil).GetCommitsCSVLocation), runID, sn)
}

// GetRules mocks base method.
func (m *MockGarbageCollectionManager) GetRules(ctx context.Context, storageNamespace graveler.StorageNamespace) (*graveler.GarbageCollectionRules, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRules", ctx, storageNamespace)
	ret0, _ := ret[0].(*graveler.GarbageCollectionRules)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetRules indicates an expected call of GetRules.
func (mr *MockGarbageCollectionManagerMockRecorder) GetRules(ctx, storageNamespace interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRules", reflect.TypeOf((*MockGarbageCollectionManager)(nil).GetRules), ctx, storageNamespace)
}

// GetUncommittedLocation mocks base method.
func (m *MockGarbageCollectionManager) GetUncommittedLocation(runID string, sn graveler.StorageNamespace) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUncommittedLocation", runID, sn)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUncommittedLocation indicates an expected call of GetUncommittedLocation.
func (mr *MockGarbageCollectionManagerMockRecorder) GetUncommittedLocation(runID, sn interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUncommittedLocation", reflect.TypeOf((*MockGarbageCollectionManager)(nil).GetUncommittedLocation), runID, sn)
}

// NewID mocks base method.
func (m *MockGarbageCollectionManager) NewID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewID")
	ret0, _ := ret[0].(string)
	return ret0
}

// NewID indicates an expected call of NewID.
func (mr *MockGarbageCollectionManagerMockRecorder) NewID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewID", reflect.TypeOf((*MockGarbageCollectionManager)(nil).NewID))
}

// SaveGarbageCollectionCommits mocks base method.
func (m *MockGarbageCollectionManager) SaveGarbageCollectionCommits(ctx context.Context, repository *graveler.RepositoryRecord, rules *graveler.GarbageCollectionRules) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SaveGarbageCollectionCommits", ctx, repository, rules)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SaveGarbageCollectionCommits indicates an expected call of SaveGarbageCollectionCommits.
func (mr *MockGarbageCollectionManagerMockRecorder) SaveGarbageCollectionCommits(ctx, repository, rules interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveGarbageCollectionCommits", reflect.TypeOf((*MockGarbageCollectionManager)(nil).SaveGarbageCollectionCommits), ctx, repository, rules)
}

// SaveGarbageCollectionUncommitted mocks base method.
func (m *MockGarbageCollectionManager) SaveGarbageCollectionUncommitted(ctx context.Context, repository *graveler.RepositoryRecord, filename, runID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SaveGarbageCollectionUncommitted", ctx, repository, filename, runID)
	ret0, _ := ret[0].(error)
	return ret0
}

// SaveGarbageCollectionUncommitted indicates an expected call of SaveGarbageCollectionUncommitted.
func (mr *MockGarbageCollectionManagerMockRecorder) SaveGarbageCollectionUncommitted(ctx, repository, filename, runID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveGarbageCollectionUncommitted", reflect.TypeOf((*MockGarbageCollectionManager)(nil).SaveGarbageCollectionUncommitted), ctx, repository, filename, runID)
}

// SaveRules mocks base method.
func (m *MockGarbageCollectionManager) SaveRules(ctx context.Context, storageNamespace graveler.StorageNamespace, rules *graveler.GarbageCollectionRules) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SaveRules", ctx, storageNamespace, rules)
	ret0, _ := ret[0].(error)
	return ret0
}

// SaveRules indicates an expected call of SaveRules.
func (mr *MockGarbageCollectionManagerMockRecorder) SaveRules(ctx, storageNamespace, rules interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveRules", reflect.TypeOf((*MockGarbageCollectionManager)(nil).SaveRules), ctx, storageNamespace, rules)
}

// MockProtectedBranchesManager is a mock of ProtectedBranchesManager interface.
type MockProtectedBranchesManager struct {
	ctrl     *gomock.Controller
	recorder *MockProtectedBranchesManagerMockRecorder
}

// MockProtectedBranchesManagerMockRecorder is the mock recorder for MockProtectedBranchesManager.
type MockProtectedBranchesManagerMockRecorder struct {
	mock *MockProtectedBranchesManager
}

// NewMockProtectedBranchesManager creates a new mock instance.
func NewMockProtectedBranchesManager(ctrl *gomock.Controller) *MockProtectedBranchesManager {
	mock := &MockProtectedBranchesManager{ctrl: ctrl}
	mock.recorder = &MockProtectedBranchesManagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockProtectedBranchesManager) EXPECT() *MockProtectedBranchesManagerMockRecorder {
	return m.recorder
}

// GetRules mocks base method.
func (m *MockProtectedBranchesManager) GetRules(ctx context.Context, repository *graveler.RepositoryRecord) (*graveler.BranchProtectionRules, *string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRules", ctx, repository)
	ret0, _ := ret[0].(*graveler.BranchProtectionRules)
	ret1, _ := ret[1].(*string)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetRules indicates an expected call of GetRules.
func (mr *MockProtectedBranchesManagerMockRecorder) GetRules(ctx, repository interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRules", reflect.TypeOf((*MockProtectedBranchesManager)(nil).GetRules), ctx, repository)
}

// IsBlocked mocks base method.
func (m *MockProtectedBranchesManager) IsBlocked(ctx context.Context, repository *graveler.RepositoryRecord, branchID graveler.BranchID, action graveler.BranchProtectionBlockedAction) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsBlocked", ctx, repository, branchID, action)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsBlocked indicates an expected call of IsBlocked.
func (mr *MockProtectedBranchesManagerMockRecorder) IsBlocked(ctx, repository, branchID, action interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsBlocked", reflect.TypeOf((*MockProtectedBranchesManager)(nil).IsBlocked), ctx, repository, branchID, action)
}

// SetRules mocks base method.
func (m *MockProtectedBranchesManager) SetRules(ctx context.Context, repository *graveler.RepositoryRecord, rules *graveler.BranchProtectionRules, lastKnownChecksum *string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetRules", ctx, repository, rules, lastKnownChecksum)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetRules indicates an expected call of SetRules.
func (mr *MockProtectedBranchesManagerMockRecorder) SetRules(ctx, repository, rules, lastKnownChecksum interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetRules", reflect.TypeOf((*MockProtectedBranchesManager)(nil).SetRules), ctx, repository, rules, lastKnownChecksum)
}
