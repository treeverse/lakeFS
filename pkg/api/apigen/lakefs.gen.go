// Package apigen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package apigen

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"runtime/trace"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/pkg/errors"
)

const (
	Basic_authScopes  = "basic_auth.Scopes"
	Cookie_authScopes = "cookie_auth.Scopes"
	Jwt_tokenScopes   = "jwt_token.Scopes"
	Oidc_authScopes   = "oidc_auth.Scopes"
	Saml_authScopes   = "saml_auth.Scopes"
)

// ACL defines model for ACL.
type ACL struct {

	// Permission level to give this ACL.  "Read", "Write", "Super" and
	// "Admin" are all supported.
	Permission string `json:"permission"`
}

// AbortPresignMultipartUpload defines model for AbortPresignMultipartUpload.
type AbortPresignMultipartUpload struct {
	PhysicalAddress string `json:"physical_address"`
}

// AccessKeyCredentials defines model for AccessKeyCredentials.
type AccessKeyCredentials struct {

	// access key ID to set for user for use in integration testing.
	AccessKeyId string `json:"access_key_id"`

	// secret access key to set for user for use in integration testing.
	SecretAccessKey string `json:"secret_access_key"`
}

// ActionRun defines model for ActionRun.
type ActionRun struct {
	Branch    string     `json:"branch"`
	CommitId  string     `json:"commit_id"`
	EndTime   *time.Time `json:"end_time,omitempty"`
	EventType string     `json:"event_type"`
	RunId     string     `json:"run_id"`
	StartTime time.Time  `json:"start_time"`
	Status    string     `json:"status"`
}

// ActionRunList defines model for ActionRunList.
type ActionRunList struct {
	Pagination Pagination  `json:"pagination"`
	Results    []ActionRun `json:"results"`
}

// AsyncTaskStatus defines model for AsyncTaskStatus.
type AsyncTaskStatus struct {

	// true if the task has completed (either successfully or with an error)
	Completed bool   `json:"completed"`
	Error     *Error `json:"error,omitempty"`

	// an http status code that correlates with the underlying error if exists
	StatusCode *int32 `json:"status_code,omitempty"`

	// the id of the async task
	TaskId string `json:"task_id"`

	// last time the task status was updated
	UpdateTime time.Time `json:"update_time"`
}

// AuthCapabilities defines model for AuthCapabilities.
type AuthCapabilities struct {
	ForgotPassword *bool `json:"forgot_password,omitempty"`
	InviteUser     *bool `json:"invite_user,omitempty"`
}

// AuthenticationToken defines model for AuthenticationToken.
type AuthenticationToken struct {

	// a JWT token that could be used to authenticate requests
	Token string `json:"token"`

	// Unix Epoch in seconds
	TokenExpiration *int64 `json:"token_expiration,omitempty"`
}

// BranchCreation defines model for BranchCreation.
type BranchCreation struct {
	Force *bool `json:"force,omitempty"`

	// When set, branch will not show up when listing branches by default. *EXPERIMENTAL*
	Hidden *bool  `json:"hidden,omitempty"`
	Name   string `json:"name"`
	Source string `json:"source"`
}

// BranchProtectionRule defines model for BranchProtectionRule.
type BranchProtectionRule struct {

	// fnmatch pattern for the branch name, supporting * and ? wildcards
	Pattern string `json:"pattern"`
}

// CapabilitiesConfig defines model for CapabilitiesConfig.
type CapabilitiesConfig struct {

	// are async operations enabled in server. *EXPERIMENTAL*
	AsyncOps *bool `json:"async_ops,omitempty"`
}

// CherryPickCreation defines model for CherryPickCreation.
type CherryPickCreation struct {
	CommitOverrides *CommitOverrides `json:"commit_overrides,omitempty"`
	Force           *bool            `json:"force,omitempty"`

	// When cherry-picking a merge commit, the parent number (starting from 1) with which to perform the diff.
	// The default branch is parent 1.
	ParentNumber *int `json:"parent_number,omitempty"`

	// the commit to cherry-pick, given by a ref
	Ref string `json:"ref"`
}

// CommPrefsInput defines model for CommPrefsInput.
type CommPrefsInput struct {

	// the provided email
	Email *string `json:"email,omitempty"`

	// user preference to receive feature updates
	FeatureUpdates bool `json:"featureUpdates"`

	// user preference to receive security updates
	SecurityUpdates bool `json:"securityUpdates"`
}

// Commit defines model for Commit.
type Commit struct {
	Committer string `json:"committer"`

	// Unix Epoch in seconds
	CreationDate int64            `json:"creation_date"`
	Generation   *int64           `json:"generation,omitempty"`
	Id           string           `json:"id"`
	Message      string           `json:"message"`
	MetaRangeId  string           `json:"meta_range_id"`
	Metadata     *Commit_Metadata `json:"metadata,omitempty"`
	Parents      []string         `json:"parents"`
	Version      *int             `json:"version,omitempty"`
}

// Commit_Metadata defines model for Commit.Metadata.
type Commit_Metadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// CommitAsyncStatus defines model for CommitAsyncStatus.
type CommitAsyncStatus struct {
	// Embedded struct due to allOf(#/components/schemas/AsyncTaskStatus)
	AsyncTaskStatus `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Result *Commit `json:"result,omitempty"`
}

// CommitCreation defines model for CommitCreation.
type CommitCreation struct {

	// sets whether a commit can contain no changes
	AllowEmpty *bool `json:"allow_empty,omitempty"`

	// set date to override creation date in the commit (Unix Epoch in seconds)
	Date     *int64                   `json:"date,omitempty"`
	Force    *bool                    `json:"force,omitempty"`
	Message  string                   `json:"message"`
	Metadata *CommitCreation_Metadata `json:"metadata,omitempty"`
}

// CommitCreation_Metadata defines model for CommitCreation.Metadata.
type CommitCreation_Metadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// CommitList defines model for CommitList.
type CommitList struct {
	Pagination Pagination `json:"pagination"`
	Results    []Commit   `json:"results"`
}

// CommitOverrides defines model for CommitOverrides.
type CommitOverrides struct {

	// replace the commit message
	Message *string `json:"message,omitempty"`

	// replace the metadata of the commit
	Metadata *CommitOverrides_Metadata `json:"metadata,omitempty"`
}

// CommitOverrides_Metadata defines model for CommitOverrides.Metadata.
type CommitOverrides_Metadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// CommitRecordCreation defines model for CommitRecordCreation.
type CommitRecordCreation struct {

	// id of the commit record
	CommitId string `json:"commit_id"`

	// committer of the commit record
	Committer string `json:"committer"`

	// Unix Epoch in seconds
	CreationDate int64 `json:"creation_date"`
	Force        *bool `json:"force,omitempty"`

	// generation of the commit record
	Generation int64 `json:"generation"`

	// message of the commit record
	Message string `json:"message"`

	// metadata of the commit record
	Metadata *CommitRecordCreation_Metadata `json:"metadata,omitempty"`

	// metarange_id of the commit record
	MetarangeId string `json:"metarange_id"`

	// parents of the commit record
	Parents []string `json:"parents"`

	// version of the commit record
	Version int `json:"version"`
}

// CommitRecordCreation_Metadata defines model for CommitRecordCreation.Metadata.
type CommitRecordCreation_Metadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// CompletePresignMultipartUpload defines model for CompletePresignMultipartUpload.
type CompletePresignMultipartUpload struct {

	// Object media type
	ContentType *string `json:"content_type,omitempty"`

	// List of uploaded parts, should be ordered by ascending part number
	Parts           []UploadPart                                 `json:"parts"`
	PhysicalAddress string                                       `json:"physical_address"`
	UserMetadata    *CompletePresignMultipartUpload_UserMetadata `json:"user_metadata,omitempty"`
}

// CompletePresignMultipartUpload_UserMetadata defines model for CompletePresignMultipartUpload.UserMetadata.
type CompletePresignMultipartUpload_UserMetadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Config defines model for Config.
type Config struct {
	CapabilitiesConfig *CapabilitiesConfig `json:"capabilities_config,omitempty"`
	StorageConfig      *StorageConfig      `json:"storage_config,omitempty"`
	StorageConfigList  *StorageConfigList  `json:"storage_config_list,omitempty"`
	UiConfig           *UIConfig           `json:"ui_config,omitempty"`
	VersionConfig      *VersionConfig      `json:"version_config,omitempty"`
}

// CopyPartSource defines model for CopyPartSource.
type CopyPartSource struct {
	Path string `json:"path"`

	// Range of bytes to copy
	Range      *string `json:"range,omitempty"`
	Ref        string  `json:"ref"`
	Repository string  `json:"repository"`
}

// Credentials defines model for Credentials.
type Credentials struct {
	AccessKeyId string `json:"access_key_id"`

	// Unix Epoch in seconds
	CreationDate int64 `json:"creation_date"`
}

// CredentialsList defines model for CredentialsList.
type CredentialsList struct {
	Pagination Pagination    `json:"pagination"`
	Results    []Credentials `json:"results"`
}

// CredentialsWithSecret defines model for CredentialsWithSecret.
type CredentialsWithSecret struct {
	AccessKeyId string `json:"access_key_id"`

	// Unix Epoch in seconds
	CreationDate    int64  `json:"creation_date"`
	SecretAccessKey string `json:"secret_access_key"`
}

// CurrentUser defines model for CurrentUser.
type CurrentUser struct {
	User User `json:"user"`
}

// CustomViewer defines model for CustomViewer.
type CustomViewer struct {
	ContentTypes *[]string `json:"content_types,omitempty"`
	Extensions   *[]string `json:"extensions,omitempty"`
	Name         string    `json:"name"`
	Url          string    `json:"url"`
}

// Diff defines model for Diff.
type Diff struct {
	Path     string          `json:"path"`
	PathType string          `json:"path_type"`
	Right    *DiffObjectStat `json:"right,omitempty"`

	// represents the size of the added/changed/deleted entry
	SizeBytes *int64 `json:"size_bytes,omitempty"`
	Type      string `json:"type"`
}

// DiffList defines model for DiffList.
type DiffList struct {
	Pagination Pagination `json:"pagination"`
	Results    []Diff     `json:"results"`
}

// DiffObjectStat defines model for DiffObjectStat.
type DiffObjectStat struct {
	Checksum string `json:"checksum"`

	// Object media type
	ContentType string              `json:"content_type"`
	Metadata    *ObjectUserMetadata `json:"metadata,omitempty"`

	// Unix Epoch in seconds
	Mtime int64 `json:"mtime"`
}

// Error defines model for Error.
type Error struct {

	// short message explaining the error
	Message string `json:"message"`
}

// ErrorNoACL defines model for ErrorNoACL.
type ErrorNoACL struct {

	// short message explaining the error
	Message string `json:"message"`

	// true if the group exists but has no ACL
	NoAcl *bool `json:"no_acl,omitempty"`
}

// ExternalLoginInformation defines model for ExternalLoginInformation.
type ExternalLoginInformation struct {
	IdentityRequest         map[string]interface{} `json:"identityRequest"`
	TokenExpirationDuration *int                   `json:"token_expiration_duration,omitempty"`
}

// ExternalPrincipal defines model for ExternalPrincipal.
type ExternalPrincipal struct {

	// A unique identifier for the external principal i.e aws:sts::123:assumed-role/role-name
	Id       string                  `json:"id"`
	Settings *map[string]interface{} `json:"settings,omitempty"`

	// lakeFS user ID to associate with an external principal.
	UserId string `json:"user_id"`
}

// ExternalPrincipalCreation defines model for ExternalPrincipalCreation.
type ExternalPrincipalCreation struct {
	Settings *map[string]interface{} `json:"settings,omitempty"`
}

// ExternalPrincipalList defines model for ExternalPrincipalList.
type ExternalPrincipalList struct {
	Pagination Pagination          `json:"pagination"`
	Results    []ExternalPrincipal `json:"results"`
}

// ExternalPrincipalSettings defines model for ExternalPrincipalSettings.
type ExternalPrincipalSettings struct {
	AdditionalProperties map[string]string `json:"-"`
}

// FindMergeBaseResult defines model for FindMergeBaseResult.
type FindMergeBaseResult struct {

	// The commit ID of the merge base
	BaseCommitId string `json:"base_commit_id"`

	// The commit ID of the merge destination
	DestinationCommitId string `json:"destination_commit_id"`

	// The commit ID of the merge source
	SourceCommitId string `json:"source_commit_id"`
}

// GarbageCollectionConfig defines model for GarbageCollectionConfig.
type GarbageCollectionConfig struct {

	// Duration in seconds. Objects created in the recent grace_period will not be collected.
	GracePeriod *int `json:"grace_period,omitempty"`
}

// GarbageCollectionPrepareResponse defines model for GarbageCollectionPrepareResponse.
type GarbageCollectionPrepareResponse struct {

	// location to use for expired addresses parquet table (partitioned by run_id)
	GcAddressesLocation string `json:"gc_addresses_location"`

	// location of the resulting commits csv table (partitioned by run_id)
	GcCommitsLocation string `json:"gc_commits_location"`

	// a presigned url to download the commits csv
	GcCommitsPresignedUrl *string `json:"gc_commits_presigned_url,omitempty"`

	// a unique identifier generated for this GC job
	RunId string `json:"run_id"`
}

// GarbageCollectionRule defines model for GarbageCollectionRule.
type GarbageCollectionRule struct {
	BranchId      string `json:"branch_id"`
	RetentionDays int    `json:"retention_days"`
}

// GarbageCollectionRules defines model for GarbageCollectionRules.
type GarbageCollectionRules struct {
	Branches             []GarbageCollectionRule `json:"branches"`
	DefaultRetentionDays int                     `json:"default_retention_days"`
}

// Group defines model for Group.
type Group struct {

	// Unix Epoch in seconds
	CreationDate int64   `json:"creation_date"`
	Description  *string `json:"description,omitempty"`
	Id           string  `json:"id"`
	Name         *string `json:"name,omitempty"`
}

// GroupCreation defines model for GroupCreation.
type GroupCreation struct {
	Description *string `json:"description,omitempty"`
	Id          string  `json:"id"`
}

// GroupList defines model for GroupList.
type GroupList struct {
	Pagination Pagination `json:"pagination"`
	Results    []Group    `json:"results"`
}

// HookRun defines model for HookRun.
type HookRun struct {
	Action    string     `json:"action"`
	EndTime   *time.Time `json:"end_time,omitempty"`
	HookId    string     `json:"hook_id"`
	HookRunId string     `json:"hook_run_id"`
	StartTime time.Time  `json:"start_time"`
	Status    string     `json:"status"`
}

// HookRunList defines model for HookRunList.
type HookRunList struct {
	Pagination Pagination `json:"pagination"`
	Results    []HookRun  `json:"results"`
}

// IcebergLocalTable defines model for IcebergLocalTable.
type IcebergLocalTable struct {

	// Reference to one or more levels of a namespace
	Namespace IcebergNamespaceRef `json:"namespace"`

	// lakeFS reference ID (branch or commit)
	ReferenceId string `json:"reference_id"`

	// lakeFS repository ID
	RepositoryId string `json:"repository_id"`

	// Remote table name
	Table string `json:"table"`
}

// IcebergNamespaceRef defines model for IcebergNamespaceRef.
type IcebergNamespaceRef []string

// IcebergPullRequest defines model for IcebergPullRequest.
type IcebergPullRequest struct {

	// Creates namespace in local catalog if not exist
	CreateNamespace *bool             `json:"create_namespace,omitempty"`
	Destination     IcebergLocalTable `json:"destination"`

	// Override exiting local table if exists
	ForceUpdate *bool              `json:"force_update,omitempty"`
	Source      IcebergRemoteTable `json:"source"`
}

// IcebergPushRequest defines model for IcebergPushRequest.
type IcebergPushRequest struct {

	// Creates namespace in remote catalog if not exist
	CreateNamespace *bool              `json:"create_namespace,omitempty"`
	Destination     IcebergRemoteTable `json:"destination"`

	// Override exiting table in remote if exists
	ForceUpdate *bool             `json:"force_update,omitempty"`
	Source      IcebergLocalTable `json:"source"`
}

// IcebergRemoteTable defines model for IcebergRemoteTable.
type IcebergRemoteTable struct {

	// Reference to one or more levels of a namespace
	Namespace IcebergNamespaceRef `json:"namespace"`

	// Remote table name
	Table string `json:"table"`
}

// ImportCreation defines model for ImportCreation.
type ImportCreation struct {
	Commit CommitCreation   `json:"commit"`
	Force  *bool            `json:"force,omitempty"`
	Paths  []ImportLocation `json:"paths"`
}

// ImportCreationResponse defines model for ImportCreationResponse.
type ImportCreationResponse struct {

	// The id of the import process
	Id string `json:"id"`
}

// ImportLocation defines model for ImportLocation.
type ImportLocation struct {

	// Destination for the imported objects on the branch. Must be a relative path to the branch.
	// If the type is an 'object', the destination is the exact object name under the branch.
	// If the type is a 'common_prefix', the destination is the prefix under the branch.
	Destination string `json:"destination"`

	// A source location to a 'common_prefix' or to a single object. Must match the lakeFS installation blockstore type.
	Path string `json:"path"`

	// Path type, can either be 'common_prefix' or 'object'
	Type string `json:"type"`
}

// ImportStatus defines model for ImportStatus.
type ImportStatus struct {
	Commit    *Commit `json:"commit,omitempty"`
	Completed bool    `json:"completed"`
	Error     *Error  `json:"error,omitempty"`

	// Number of objects processed so far
	IngestedObjects *int64    `json:"ingested_objects,omitempty"`
	MetarangeId     *string   `json:"metarange_id,omitempty"`
	UpdateTime      time.Time `json:"update_time"`
}

// InstallationUsageReport defines model for InstallationUsageReport.
type InstallationUsageReport struct {
	InstallationId string        `json:"installation_id"`
	Reports        []UsageReport `json:"reports"`
}

// License defines model for License.
type License struct {

	// The license JWT token
	Token string `json:"token"`
}

// LoginConfig defines model for LoginConfig.
type LoginConfig struct {

	// RBAC will remain enabled on GUI if "external".  That only works
	// with an external auth service.
	RBAC *string `json:"RBAC,omitempty"`

	// Label to place on fallback_login_url.
	FallbackLoginLabel *string `json:"fallback_login_label,omitempty"`

	// Secondary URL to offer users to use for login.
	FallbackLoginUrl *string `json:"fallback_login_url,omitempty"`

	// Cookie names used to store JWT
	LoginCookieNames []string `json:"login_cookie_names"`

	// Message to display to users who fail to login; a full sentence that is rendered
	// in HTML and may contain a link to a secondary login method
	LoginFailedMessage *string `json:"login_failed_message,omitempty"`

	// Primary URL to use for login.
	LoginUrl string `json:"login_url"`

	// Defines login behavior when login_url is set.
	// - none: For OSS users.
	// - redirect: Auto-redirect to login_url.
	// - select: Show a page to choose between logging in via login_url or with lakeFS credentials.
	// Ignored if login_url is not configured.
	LoginUrlMethod *string `json:"login_url_method,omitempty"`

	// URL to use for logging out.
	LogoutUrl string `json:"logout_url"`

	// Placeholder text to display in the password field of the login form.
	PasswordUiPlaceholder *string `json:"password_ui_placeholder,omitempty"`

	// Placeholder text to display in the username field of the login form.
	UsernameUiPlaceholder *string `json:"username_ui_placeholder,omitempty"`
}

// LoginInformation defines model for LoginInformation.
type LoginInformation struct {
	AccessKeyId     string `json:"access_key_id"`
	SecretAccessKey string `json:"secret_access_key"`
}

// Merge defines model for Merge.
type Merge struct {

	// Allow merge when the branches have the same content
	AllowEmpty *bool `json:"allow_empty,omitempty"`

	// Allow merge into a read-only branch or into a branch with the same content
	Force    *bool           `json:"force,omitempty"`
	Message  *string         `json:"message,omitempty"`
	Metadata *Merge_Metadata `json:"metadata,omitempty"`

	// If set, set only the destination branch as a parent, which "squashes" the merge to
	// appear as a single commit on the destination branch.  The source commit is no longer
	// a part of the merge commit; consider adding it to the 'metadata' or 'message'
	// fields.  This behaves like a GitHub or GitLab "squash merge", or in Git terms 'git
	// merge --squash; git commit ...'.
	SquashMerge *bool `json:"squash_merge,omitempty"`

	// In case of a merge conflict, this option will force the merge process to automatically favor changes from the dest branch ('dest-wins') or from the source branch('source-wins'). In case no selection is made, the merge process will fail in case of a conflict
	Strategy *string `json:"strategy,omitempty"`
}

// Merge_Metadata defines model for Merge.Metadata.
type Merge_Metadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// MergeAsyncStatus defines model for MergeAsyncStatus.
type MergeAsyncStatus struct {
	// Embedded struct due to allOf(#/components/schemas/AsyncTaskStatus)
	AsyncTaskStatus `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Result *MergeResult `json:"result,omitempty"`
}

// MergeResult defines model for MergeResult.
type MergeResult struct {
	Reference string `json:"reference"`
}

// ObjectCopyCreation defines model for ObjectCopyCreation.
type ObjectCopyCreation struct {
	Force *bool `json:"force,omitempty"`

	// Create a shallow copy of the object (without copying the actual data). At the moment shallow copy only works for same repository and branch.
	// Please note that shallow copied objects might be in contention with garbage collection and branch retention policies - use with caution.
	Shallow *bool `json:"shallow,omitempty"`

	// path of the copied object relative to the ref
	SrcPath string `json:"src_path"`

	// a reference, if empty uses the provided branch as ref
	SrcRef *string `json:"src_ref,omitempty"`
}

// ObjectError defines model for ObjectError.
type ObjectError struct {

	// short message explaining status_code
	Message string `json:"message"`

	// affected path
	Path *string `json:"path,omitempty"`

	// HTTP status code associated for operation on path
	StatusCode int `json:"status_code"`
}

// ObjectErrorList defines model for ObjectErrorList.
type ObjectErrorList struct {
	Errors []ObjectError `json:"errors"`
}

// ObjectStageCreation defines model for ObjectStageCreation.
type ObjectStageCreation struct {
	Checksum string `json:"checksum"`

	// Object media type
	ContentType *string             `json:"content_type,omitempty"`
	Force       *bool               `json:"force,omitempty"`
	Metadata    *ObjectUserMetadata `json:"metadata,omitempty"`

	// Unix Epoch in seconds
	Mtime           *int64 `json:"mtime,omitempty"`
	PhysicalAddress string `json:"physical_address"`
	SizeBytes       int64  `json:"size_bytes"`
}

// ObjectStats defines model for ObjectStats.
type ObjectStats struct {
	Checksum string `json:"checksum"`

	// Object media type
	ContentType *string             `json:"content_type,omitempty"`
	Metadata    *ObjectUserMetadata `json:"metadata,omitempty"`

	// Unix Epoch in seconds
	Mtime    int64  `json:"mtime"`
	Path     string `json:"path"`
	PathType string `json:"path_type"`

	// The location of the object on the underlying object store.
	// Formatted as a native URI with the object store type as scheme ("s3://...", "gs://...", etc.)
	// Or, in the case of presign=true, will be an HTTP URL to be consumed via regular HTTP GET
	PhysicalAddress string `json:"physical_address"`

	// If present and nonzero, physical_address is a pre-signed URL and
	// will expire at this Unix Epoch time.  This will be shorter than
	// the pre-signed URL lifetime if an authentication token is about
	// to expire.
	//
	// This field is *optional*.
	PhysicalAddressExpiry *int64 `json:"physical_address_expiry,omitempty"`

	// The number of bytes in the object.  lakeFS always populates this
	// field when returning ObjectStats.  This field is optional _for
	// the client_ to supply, for instance on upload.
	SizeBytes *int64 `json:"size_bytes,omitempty"`
}

// ObjectStatsList defines model for ObjectStatsList.
type ObjectStatsList struct {
	Pagination Pagination    `json:"pagination"`
	Results    []ObjectStats `json:"results"`
}

// ObjectUserMetadata defines model for ObjectUserMetadata.
type ObjectUserMetadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Pagination defines model for Pagination.
type Pagination struct {

	// Next page is available
	HasMore bool `json:"has_more"`

	// Maximal number of entries per page
	MaxPerPage int `json:"max_per_page"`

	// Token used to retrieve the next page
	NextOffset string `json:"next_offset"`

	// Number of values found in the results
	Results int `json:"results"`
}

// PathList defines model for PathList.
type PathList struct {
	Paths []string `json:"paths"`
}

// Policy defines model for Policy.
type Policy struct {

	// Unix Epoch in seconds
	CreationDate *int64      `json:"creation_date,omitempty"`
	Id           string      `json:"id"`
	Statement    []Statement `json:"statement"`
}

// PolicyCondition defines model for PolicyCondition.
type PolicyCondition struct {
	AdditionalProperties map[string][]string `json:"-"`
}

// PolicyList defines model for PolicyList.
type PolicyList struct {
	Pagination Pagination `json:"pagination"`
	Results    []Policy   `json:"results"`
}

// PrepareGCUncommittedRequest defines model for PrepareGCUncommittedRequest.
type PrepareGCUncommittedRequest struct {
	ContinuationToken *string `json:"continuation_token,omitempty"`
}

// PrepareGCUncommittedResponse defines model for PrepareGCUncommittedResponse.
type PrepareGCUncommittedResponse struct {
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// location of uncommitted information data
	GcUncommittedLocation string `json:"gc_uncommitted_location"`
	RunId                 string `json:"run_id"`
}

// PrepareGarbageCollectionCommitsStatus defines model for PrepareGarbageCollectionCommitsStatus.
type PrepareGarbageCollectionCommitsStatus struct {

	// true if the task has completed (either successfully or with an error)
	Completed bool                              `json:"completed"`
	Error     *Error                            `json:"error,omitempty"`
	Result    *GarbageCollectionPrepareResponse `json:"result,omitempty"`

	// the id of the task preparing the GC commits
	TaskId string `json:"task_id"`

	// last time the task status was updated
	UpdateTime time.Time `json:"update_time"`
}

// PresignMultipartUpload defines model for PresignMultipartUpload.
type PresignMultipartUpload struct {
	PhysicalAddress string    `json:"physical_address"`
	PresignedUrls   *[]string `json:"presigned_urls,omitempty"`
	UploadId        string    `json:"upload_id"`
}

// PullRequest defines model for PullRequest.
type PullRequest struct {
	// Embedded struct due to allOf(#/components/schemas/PullRequestBasic)
	PullRequestBasic `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	// Embedded fields due to inline allOf schema
	Author            string     `json:"author"`
	ClosedDate        *time.Time `json:"closed_date,omitempty"`
	CreationDate      time.Time  `json:"creation_date"`
	DestinationBranch string     `json:"destination_branch"`
	Id                string     `json:"id"`

	// the commit id of merged PRs
	MergedCommitId *string `json:"merged_commit_id,omitempty"`
	SourceBranch   string  `json:"source_branch"`
}

// PullRequestBasic defines model for PullRequestBasic.
type PullRequestBasic struct {
	Description *string `json:"description,omitempty"`
	Status      *string `json:"status,omitempty"`
	Title       *string `json:"title,omitempty"`
}

// PullRequestCreation defines model for PullRequestCreation.
type PullRequestCreation struct {
	Description       *string `json:"description,omitempty"`
	DestinationBranch string  `json:"destination_branch"`
	SourceBranch      string  `json:"source_branch"`
	Title             string  `json:"title"`
}

// PullRequestCreationResponse defines model for PullRequestCreationResponse.
type PullRequestCreationResponse struct {

	// ID of the pull request
	Id string `json:"id"`
}

// PullRequestsList defines model for PullRequestsList.
type PullRequestsList struct {
	Pagination Pagination    `json:"pagination"`
	Results    []PullRequest `json:"results"`
}

// Ref defines model for Ref.
type Ref struct {
	CommitId string `json:"commit_id"`
	Id       string `json:"id"`
}

// RefList defines model for RefList.
type RefList struct {
	Pagination Pagination `json:"pagination"`
	Results    []Ref      `json:"results"`
}

// RefsDump defines model for RefsDump.
type RefsDump struct {
	BranchesMetaRangeId string `json:"branches_meta_range_id"`
	CommitsMetaRangeId  string `json:"commits_meta_range_id"`
	TagsMetaRangeId     string `json:"tags_meta_range_id"`
}

// RefsRestore defines model for RefsRestore.
type RefsRestore struct {
	BranchesMetaRangeId string `json:"branches_meta_range_id"`
	CommitsMetaRangeId  string `json:"commits_meta_range_id"`
	Force               *bool  `json:"force,omitempty"`
	TagsMetaRangeId     string `json:"tags_meta_range_id"`
}

// Repository defines model for Repository.
type Repository struct {

	// Unix Epoch in seconds
	CreationDate  int64  `json:"creation_date"`
	DefaultBranch string `json:"default_branch"`
	Id            string `json:"id"`

	// Whether the repository is a read-only repository- not relevant for bare repositories
	ReadOnly *bool `json:"read_only,omitempty"`

	// Unique identifier of the underlying data store. *EXPERIMENTAL*
	StorageId *string `json:"storage_id,omitempty"`

	// Filesystem URI to store the underlying data in (e.g. "s3://my-bucket/some/path/")
	StorageNamespace string `json:"storage_namespace"`
}

// RepositoryCreation defines model for RepositoryCreation.
type RepositoryCreation struct {
	DefaultBranch *string `json:"default_branch,omitempty"`
	Name          string  `json:"name"`
	ReadOnly      *bool   `json:"read_only,omitempty"`
	SampleData    *bool   `json:"sample_data,omitempty"`

	// Unique identifier of the underlying data store. *EXPERIMENTAL*
	StorageId *string `json:"storage_id,omitempty"`

	// Filesystem URI to store the underlying data in (e.g. "s3://my-bucket/some/path/")
	StorageNamespace string `json:"storage_namespace"`
}

// RepositoryDumpStatus defines model for RepositoryDumpStatus.
type RepositoryDumpStatus struct {
	Done  bool    `json:"done"`
	Error *string `json:"error,omitempty"`

	// ID of the task
	Id         string    `json:"id"`
	Refs       *RefsDump `json:"refs,omitempty"`
	UpdateTime time.Time `json:"update_time"`
}

// RepositoryList defines model for RepositoryList.
type RepositoryList struct {
	Pagination Pagination   `json:"pagination"`
	Results    []Repository `json:"results"`
}

// RepositoryMetadata defines model for RepositoryMetadata.
type RepositoryMetadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// RepositoryMetadataKeys defines model for RepositoryMetadataKeys.
type RepositoryMetadataKeys struct {
	Keys []string `json:"keys"`
}

// RepositoryMetadataSet defines model for RepositoryMetadataSet.
type RepositoryMetadataSet struct {
	Metadata RepositoryMetadataSet_Metadata `json:"metadata"`
}

// RepositoryMetadataSet_Metadata defines model for RepositoryMetadataSet.Metadata.
type RepositoryMetadataSet_Metadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// RepositoryRestoreStatus defines model for RepositoryRestoreStatus.
type RepositoryRestoreStatus struct {
	Done  bool    `json:"done"`
	Error *string `json:"error,omitempty"`

	// ID of the task
	Id         string    `json:"id"`
	UpdateTime time.Time `json:"update_time"`
}

// ResetCreation defines model for ResetCreation.
type ResetCreation struct {
	Force *bool   `json:"force,omitempty"`
	Path  *string `json:"path,omitempty"`

	// What to reset according to path.
	Type string `json:"type"`
}

// RevertCreation defines model for RevertCreation.
type RevertCreation struct {

	// allow empty commit (revert without changes)
	AllowEmpty      *bool            `json:"allow_empty,omitempty"`
	CommitOverrides *CommitOverrides `json:"commit_overrides,omitempty"`
	Force           *bool            `json:"force,omitempty"`

	// when reverting a merge commit, the parent number (starting from 1) relative to which to perform the revert.
	ParentNumber int `json:"parent_number"`

	// the commit to revert, given by a ref
	Ref string `json:"ref"`
}

// Setup defines model for Setup.
type Setup struct {
	Key *AccessKeyCredentials `json:"key,omitempty"`

	// an identifier for the user (e.g. jane.doe)
	Username string `json:"username"`
}

// SetupState defines model for SetupState.
type SetupState struct {

	// true if the comm prefs are missing.
	CommPrefsMissing *bool        `json:"comm_prefs_missing,omitempty"`
	LoginConfig      *LoginConfig `json:"login_config,omitempty"`
	State            *string      `json:"state,omitempty"`
}

// StagingLocation defines model for StagingLocation.
type StagingLocation struct {
	PhysicalAddress *string `json:"physical_address,omitempty"`

	// if presign=true is passed in the request, this field will contain a pre-signed URL to use when uploading
	PresignedUrl *string `json:"presigned_url"`

	// If present and nonzero, physical_address is a pre-signed URL and
	// will expire at this Unix Epoch time.  This will be shorter than
	// the pre-signed URL lifetime if an authentication token is about
	// to expire.
	//
	// This field is *optional*.
	PresignedUrlExpiry *int64 `json:"presigned_url_expiry,omitempty"`
}

// StagingMetadata defines model for StagingMetadata.
type StagingMetadata struct {

	// unique identifier of object content on backing store (typically ETag)
	Checksum string `json:"checksum"`

	// Object media type
	ContentType *string `json:"content_type,omitempty"`
	Force       *bool   `json:"force,omitempty"`

	// Unix Epoch in seconds.  May be ignored by server.
	Mtime     *int64 `json:"mtime,omitempty"`
	SizeBytes int64  `json:"size_bytes"`

	// location for placing an object when staging it
	Staging      StagingLocation               `json:"staging"`
	UserMetadata *StagingMetadata_UserMetadata `json:"user_metadata,omitempty"`
}

// StagingMetadata_UserMetadata defines model for StagingMetadata.UserMetadata.
type StagingMetadata_UserMetadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Statement defines model for Statement.
type Statement struct {
	Action []string `json:"action"`

	// Optional conditions for when this statement applies.
	Condition *Statement_Condition `json:"condition,omitempty"`
	Effect    string               `json:"effect"`
	Resource  string               `json:"resource"`
}

// Statement_Condition defines model for Statement.Condition.
type Statement_Condition struct {
	AdditionalProperties map[string]PolicyCondition `json:"-"`
}

// StatsEvent defines model for StatsEvent.
type StatsEvent struct {

	// stats event class (e.g. "s3_gateway", "openapi_request", "experimental-feature", "ui-event")
	Class string `json:"class"`

	// number of events of the class and name
	Count int `json:"count"`

	// stats event name (e.g. "put_object", "create_repository", "<experimental-feature-name>")
	Name string `json:"name"`
}

// StatsEventsList defines model for StatsEventsList.
type StatsEventsList struct {
	Events []StatsEvent `json:"events"`
}

// StorageConfig defines model for StorageConfig.
type StorageConfig struct {
	BlockstoreDescription            *string `json:"blockstore_description,omitempty"`
	BlockstoreId                     *string `json:"blockstore_id,omitempty"`
	BlockstoreNamespaceValidityRegex string  `json:"blockstore_namespace_ValidityRegex"`
	BlockstoreNamespaceExample       string  `json:"blockstore_namespace_example"`
	BlockstoreType                   string  `json:"blockstore_type"`
	DefaultNamespacePrefix           *string `json:"default_namespace_prefix,omitempty"`
	ImportSupport                    bool    `json:"import_support"`
	ImportValidityRegex              string  `json:"import_validity_regex"`
	PreSignMultipartUpload           *bool   `json:"pre_sign_multipart_upload,omitempty"`
	PreSignSupport                   bool    `json:"pre_sign_support"`
	PreSignSupportUi                 bool    `json:"pre_sign_support_ui"`
}

// StorageConfigList defines model for StorageConfigList.
type StorageConfigList []StorageConfig

// StorageURI defines model for StorageURI.
type StorageURI struct {
	Location string `json:"location"`
}

// StsAuthRequest defines model for StsAuthRequest.
type StsAuthRequest struct {
	Code        string `json:"code"`
	RedirectUri string `json:"redirect_uri"`
	State       string `json:"state"`

	// The time-to-live for the generated token in seconds.  The default
	// value is 3600 seconds (1 hour) maximum time allowed is 12 hours.
	TtlSeconds *int64 `json:"ttl_seconds,omitempty"`
}

// TagCreation defines model for TagCreation.
type TagCreation struct {
	Force *bool `json:"force,omitempty"`

	// ID of tag to create
	Id string `json:"id"`

	// the commit to tag
	Ref string `json:"ref"`
}

// TaskCreation defines model for TaskCreation.
type TaskCreation struct {

	// The id of the new task
	Id string `json:"id"`
}

// TaskInfo defines model for TaskInfo.
type TaskInfo struct {

	// ID of the task
	Id string `json:"id"`
}

// UIConfig defines model for UIConfig.
type UIConfig struct {
	CustomViewers *[]CustomViewer `json:"custom_viewers,omitempty"`
}

// UnderlyingObjectProperties defines model for UnderlyingObjectProperties.
type UnderlyingObjectProperties struct {
	StorageClass *string `json:"storage_class"`
}

// UpdateObjectUserMetadata defines model for UpdateObjectUserMetadata.
type UpdateObjectUserMetadata struct {
	Set ObjectUserMetadata `json:"set"`
}

// UploadPart defines model for UploadPart.
type UploadPart struct {
	Etag       string `json:"etag"`
	PartNumber int    `json:"part_number"`
}

// UploadPartCopyFrom defines model for UploadPartCopyFrom.
type UploadPartCopyFrom struct {
	// Embedded struct due to allOf(#/components/schemas/UploadPartFrom)
	UploadPartFrom `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	CopySource CopyPartSource `json:"copy_source"`
}

// UploadPartFrom defines model for UploadPartFrom.
type UploadPartFrom struct {

	// The physical address (of the entire intended object) returned from
	// createPresignMultipartUpload.
	PhysicalAddress string `json:"physical_address"`
}

// UploadTo defines model for UploadTo.
type UploadTo struct {
	PresignedUrl string `json:"presigned_url"`
}

// UsageReport defines model for UsageReport.
type UsageReport struct {
	Count int64 `json:"count"`
	Month int   `json:"month"`
	Year  int   `json:"year"`
}

// User defines model for User.
type User struct {

	// Unix Epoch in seconds
	CreationDate int64 `json:"creation_date"`

	// The email address of the user. If API authentication is enabled, this field is mandatory and will be invited to login.
	// If API authentication is disabled, this field will be ignored. All current APIAuthenticators require the email to be
	// lowercase and unique, although custom authenticators may not enforce this.
	Email *string `json:"email,omitempty"`

	// A shorter name for the user than the id. Unlike id it does not identify the user (it
	// might not be unique). Used in some places in the UI.
	FriendlyName *string `json:"friendly_name,omitempty"`

	// A unique identifier for the user. Cannot be edited.
	Id string `json:"id"`
}

// UserCreation defines model for UserCreation.
type UserCreation struct {

	// a unique identifier for the user.
	Id         string `json:"id"`
	InviteUser *bool  `json:"invite_user,omitempty"`
}

// UserList defines model for UserList.
type UserList struct {
	Pagination Pagination `json:"pagination"`
	Results    []User     `json:"results"`
}

// VersionConfig defines model for VersionConfig.
type VersionConfig struct {
	LatestVersion      *string `json:"latest_version,omitempty"`
	UpgradeRecommended *bool   `json:"upgrade_recommended,omitempty"`
	UpgradeUrl         *string `json:"upgrade_url,omitempty"`
	Version            *string `json:"version,omitempty"`
	VersionContext     *string `json:"version_context,omitempty"`
}

// IfMatch defines model for IfMatch.
type IfMatch string

// IfNoneMatch defines model for IfNoneMatch.
type IfNoneMatch string

// NoTombstone defines model for NoTombstone.
type NoTombstone bool

// PaginationAfter defines model for PaginationAfter.
type PaginationAfter string

// PaginationAmount defines model for PaginationAmount.
type PaginationAmount int

// PaginationDelimiter defines model for PaginationDelimiter.
type PaginationDelimiter string

// PaginationPrefix defines model for PaginationPrefix.
type PaginationPrefix string

// SearchString defines model for SearchString.
type SearchString string

// BadRequest defines model for BadRequest.
type BadRequest Error

// Conflict defines model for Conflict.
type Conflict Error

// Forbidden defines model for Forbidden.
type Forbidden Error

// NotFound defines model for NotFound.
type NotFound Error

// NotFoundOrNoACL defines model for NotFoundOrNoACL.
type NotFoundOrNoACL ErrorNoACL

// NotImplemented defines model for NotImplemented.
type NotImplemented Error

// PreconditionFailed defines model for PreconditionFailed.
type PreconditionFailed Error

// ServerError defines model for ServerError.
type ServerError Error

// Unauthorized defines model for Unauthorized.
type Unauthorized Error

// ValidationError defines model for ValidationError.
type ValidationError Error

// ExternalPrincipalLoginJSONBody defines parameters for ExternalPrincipalLogin.
type ExternalPrincipalLoginJSONBody ExternalLoginInformation

// GetExternalPrincipalParams defines parameters for GetExternalPrincipal.
type GetExternalPrincipalParams struct {
	PrincipalId string `json:"principalId"`
}

// ListGroupsParams defines parameters for ListGroups.
type ListGroupsParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// CreateGroupJSONBody defines parameters for CreateGroup.
type CreateGroupJSONBody GroupCreation

// SetGroupACLJSONBody defines parameters for SetGroupACL.
type SetGroupACLJSONBody ACL

// ListGroupMembersParams defines parameters for ListGroupMembers.
type ListGroupMembersParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// ListGroupPoliciesParams defines parameters for ListGroupPolicies.
type ListGroupPoliciesParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// LoginJSONBody defines parameters for Login.
type LoginJSONBody LoginInformation

// ListPoliciesParams defines parameters for ListPolicies.
type ListPoliciesParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// CreatePolicyJSONBody defines parameters for CreatePolicy.
type CreatePolicyJSONBody Policy

// UpdatePolicyJSONBody defines parameters for UpdatePolicy.
type UpdatePolicyJSONBody Policy

// ListUsersParams defines parameters for ListUsers.
type ListUsersParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// CreateUserJSONBody defines parameters for CreateUser.
type CreateUserJSONBody UserCreation

// ListUserCredentialsParams defines parameters for ListUserCredentials.
type ListUserCredentialsParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// DeleteUserExternalPrincipalParams defines parameters for DeleteUserExternalPrincipal.
type DeleteUserExternalPrincipalParams struct {
	PrincipalId string `json:"principalId"`
}

// CreateUserExternalPrincipalJSONBody defines parameters for CreateUserExternalPrincipal.
type CreateUserExternalPrincipalJSONBody ExternalPrincipalCreation

// CreateUserExternalPrincipalParams defines parameters for CreateUserExternalPrincipal.
type CreateUserExternalPrincipalParams struct {
	PrincipalId string `json:"principalId"`
}

// ListUserExternalPrincipalsParams defines parameters for ListUserExternalPrincipals.
type ListUserExternalPrincipalsParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// ListUserGroupsParams defines parameters for ListUserGroups.
type ListUserGroupsParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// ListUserPoliciesParams defines parameters for ListUserPolicies.
type ListUserPoliciesParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`

	// will return all distinct policies attached to the user or any of its groups
	Effective *bool `json:"effective,omitempty"`
}

// PullIcebergTableJSONBody defines parameters for PullIcebergTable.
type PullIcebergTableJSONBody IcebergPullRequest

// PushIcebergTableJSONBody defines parameters for PushIcebergTable.
type PushIcebergTableJSONBody IcebergPushRequest

// ListRepositoriesParams defines parameters for ListRepositories.
type ListRepositoriesParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`

	// string for searching relevant entries
	Search *SearchString `json:"search,omitempty"`
}

// CreateRepositoryJSONBody defines parameters for CreateRepository.
type CreateRepositoryJSONBody RepositoryCreation

// CreateRepositoryParams defines parameters for CreateRepository.
type CreateRepositoryParams struct {

	// If true, create a bare repository with no initial commit and branch
	Bare *bool `json:"bare,omitempty"`
}

// DeleteRepositoryParams defines parameters for DeleteRepository.
type DeleteRepositoryParams struct {

	// Bypass read-only protection and delete the repository
	Force *bool `json:"force,omitempty"`
}

// ListRepositoryRunsParams defines parameters for ListRepositoryRuns.
type ListRepositoryRunsParams struct {

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
	Branch *string           `json:"branch,omitempty"`
	Commit *string           `json:"commit,omitempty"`
}

// ListRunHooksParams defines parameters for ListRunHooks.
type ListRunHooksParams struct {

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// InternalDeleteBranchProtectionRuleJSONBody defines parameters for InternalDeleteBranchProtectionRule.
type InternalDeleteBranchProtectionRuleJSONBody struct {
	Pattern string `json:"pattern"`
}

// InternalCreateBranchProtectionRuleJSONBody defines parameters for InternalCreateBranchProtectionRule.
type InternalCreateBranchProtectionRuleJSONBody BranchProtectionRule

// ListBranchesParams defines parameters for ListBranches.
type ListBranchesParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount     *PaginationAmount `json:"amount,omitempty"`
	ShowHidden *bool             `json:"show_hidden,omitempty"`
}

// CreateBranchJSONBody defines parameters for CreateBranch.
type CreateBranchJSONBody BranchCreation

// DeleteBranchParams defines parameters for DeleteBranch.
type DeleteBranchParams struct {
	Force *bool `json:"force,omitempty"`
}

// ResetBranchJSONBody defines parameters for ResetBranch.
type ResetBranchJSONBody ResetCreation

// CherryPickJSONBody defines parameters for CherryPick.
type CherryPickJSONBody CherryPickCreation

// CommitJSONBody defines parameters for Commit.
type CommitJSONBody CommitCreation

// CommitParams defines parameters for Commit.
type CommitParams struct {

	// The source metarange to commit. Branch must not have uncommitted changes.
	SourceMetarange *string `json:"source_metarange,omitempty"`
}

// CommitAsyncJSONBody defines parameters for CommitAsync.
type CommitAsyncJSONBody CommitCreation

// CommitAsyncParams defines parameters for CommitAsync.
type CommitAsyncParams struct {

	// The source metarange to commit. Branch must not have uncommitted changes.
	SourceMetarange *string `json:"source_metarange,omitempty"`
}

// DiffBranchParams defines parameters for DiffBranch.
type DiffBranchParams struct {

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// delimiter used to group common prefixes by
	Delimiter *PaginationDelimiter `json:"delimiter,omitempty"`
}

// HardResetBranchParams defines parameters for HardResetBranch.
type HardResetBranchParams struct {

	// After reset, branch will point at this reference.
	Ref   string `json:"ref"`
	Force *bool  `json:"force,omitempty"`
}

// ImportCancelParams defines parameters for ImportCancel.
type ImportCancelParams struct {

	// Unique identifier of the import process
	Id string `json:"id"`
}

// ImportStatusParams defines parameters for ImportStatus.
type ImportStatusParams struct {

	// Unique identifier of the import process
	Id string `json:"id"`
}

// ImportStartJSONBody defines parameters for ImportStart.
type ImportStartJSONBody ImportCreation

// DeleteObjectParams defines parameters for DeleteObject.
type DeleteObjectParams struct {

	// relative to the branch
	Path  string `json:"path"`
	Force *bool  `json:"force,omitempty"`

	// delete entry without tombstone when possible *EXPERIMENTAL*
	NoTombstone *NoTombstone `json:"no_tombstone,omitempty"`
}

// UploadObjectParams defines parameters for UploadObject.
type UploadObjectParams struct {

	// relative to the branch
	Path string `json:"path"`

	// Deprecated, this capability will not be supported in future releases.
	StorageClass *string `json:"storageClass,omitempty"`
	Force        *bool   `json:"force,omitempty"`

	// Set to "*" to atomically allow the upload only if the key has no object yet. Other values are not supported.
	IfNoneMatch *IfNoneMatch `json:"If-None-Match,omitempty"`

	// Set to the object's ETag to atomically allow operations only if the object's current ETag matches the provided value.
	IfMatch *IfMatch `json:"If-Match,omitempty"`
}

// StageObjectJSONBody defines parameters for StageObject.
type StageObjectJSONBody ObjectStageCreation

// StageObjectParams defines parameters for StageObject.
type StageObjectParams struct {

	// relative to the branch
	Path string `json:"path"`
}

// CopyObjectJSONBody defines parameters for CopyObject.
type CopyObjectJSONBody ObjectCopyCreation

// CopyObjectParams defines parameters for CopyObject.
type CopyObjectParams struct {

	// destination path relative to the branch
	DestPath string `json:"dest_path"`
}

// DeleteObjectsJSONBody defines parameters for DeleteObjects.
type DeleteObjectsJSONBody PathList

// DeleteObjectsParams defines parameters for DeleteObjects.
type DeleteObjectsParams struct {
	Force *bool `json:"force,omitempty"`

	// delete entry without tombstone when possible *EXPERIMENTAL*
	NoTombstone *NoTombstone `json:"no_tombstone,omitempty"`
}

// UploadObjectPreflightParams defines parameters for UploadObjectPreflight.
type UploadObjectPreflightParams struct {

	// relative to the branch
	Path string `json:"path"`
}

// UpdateObjectUserMetadataJSONBody defines parameters for UpdateObjectUserMetadata.
type UpdateObjectUserMetadataJSONBody UpdateObjectUserMetadata

// UpdateObjectUserMetadataParams defines parameters for UpdateObjectUserMetadata.
type UpdateObjectUserMetadataParams struct {

	// path to object relative to the branch
	Path string `json:"path"`
}

// RevertBranchJSONBody defines parameters for RevertBranch.
type RevertBranchJSONBody RevertCreation

// GetPhysicalAddressParams defines parameters for GetPhysicalAddress.
type GetPhysicalAddressParams struct {

	// relative to the branch
	Path    string `json:"path"`
	Presign *bool  `json:"presign,omitempty"`
}

// LinkPhysicalAddressJSONBody defines parameters for LinkPhysicalAddress.
type LinkPhysicalAddressJSONBody StagingMetadata

// LinkPhysicalAddressParams defines parameters for LinkPhysicalAddress.
type LinkPhysicalAddressParams struct {

	// relative to the branch
	Path string `json:"path"`

	// Set to "*" to atomically allow the upload only if the key has no object yet. Other values are not supported.
	IfNoneMatch *IfNoneMatch `json:"If-None-Match,omitempty"`

	// Set to the object's ETag to atomically allow operations only if the object's current ETag matches the provided value.
	IfMatch *IfMatch `json:"If-Match,omitempty"`
}

// CreatePresignMultipartUploadParams defines parameters for CreatePresignMultipartUpload.
type CreatePresignMultipartUploadParams struct {

	// relative to the branch
	Path string `json:"path"`

	// number of presigned URL parts required to upload
	Parts *int `json:"parts,omitempty"`
}

// AbortPresignMultipartUploadJSONBody defines parameters for AbortPresignMultipartUpload.
type AbortPresignMultipartUploadJSONBody AbortPresignMultipartUpload

// AbortPresignMultipartUploadParams defines parameters for AbortPresignMultipartUpload.
type AbortPresignMultipartUploadParams struct {

	// relative to the branch
	Path string `json:"path"`
}

// CompletePresignMultipartUploadJSONBody defines parameters for CompletePresignMultipartUpload.
type CompletePresignMultipartUploadJSONBody CompletePresignMultipartUpload

// CompletePresignMultipartUploadParams defines parameters for CompletePresignMultipartUpload.
type CompletePresignMultipartUploadParams struct {

	// relative to the branch
	Path string `json:"path"`
}

// UploadPartJSONBody defines parameters for UploadPart.
type UploadPartJSONBody UploadPartFrom

// UploadPartParams defines parameters for UploadPart.
type UploadPartParams struct {
	Path string `json:"path"`
}

// UploadPartCopyJSONBody defines parameters for UploadPartCopy.
type UploadPartCopyJSONBody UploadPartCopyFrom

// UploadPartCopyParams defines parameters for UploadPartCopy.
type UploadPartCopyParams struct {
	Path string `json:"path"`
}

// CreateCommitRecordJSONBody defines parameters for CreateCommitRecord.
type CreateCommitRecordJSONBody CommitRecordCreation

// DumpStatusParams defines parameters for DumpStatus.
type DumpStatusParams struct {
	TaskId string `json:"task_id"`
}

// PrepareGarbageCollectionCommitsStatusParams defines parameters for PrepareGarbageCollectionCommitsStatus.
type PrepareGarbageCollectionCommitsStatusParams struct {

	// Unique identifier of the prepare GC commits task
	Id string `json:"id"`
}

// PrepareGarbageCollectionUncommittedJSONBody defines parameters for PrepareGarbageCollectionUncommitted.
type PrepareGarbageCollectionUncommittedJSONBody PrepareGCUncommittedRequest

// InternalSetGarbageCollectionRulesJSONBody defines parameters for InternalSetGarbageCollectionRules.
type InternalSetGarbageCollectionRulesJSONBody GarbageCollectionRules

// DeleteRepositoryMetadataJSONBody defines parameters for DeleteRepositoryMetadata.
type DeleteRepositoryMetadataJSONBody RepositoryMetadataKeys

// SetRepositoryMetadataJSONBody defines parameters for SetRepositoryMetadata.
type SetRepositoryMetadataJSONBody RepositoryMetadataSet

// GetMetadataObjectParams defines parameters for GetMetadataObject.
type GetMetadataObjectParams struct {
	Presign *bool `json:"presign,omitempty"`
}

// ListPullRequestsParams defines parameters for ListPullRequests.
type ListPullRequestsParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
	Status *string           `json:"status,omitempty"`
}

// CreatePullRequestJSONBody defines parameters for CreatePullRequest.
type CreatePullRequestJSONBody PullRequestCreation

// UpdatePullRequestJSONBody defines parameters for UpdatePullRequest.
type UpdatePullRequestJSONBody PullRequestBasic

// RestoreRefsJSONBody defines parameters for RestoreRefs.
type RestoreRefsJSONBody RefsRestore

// CreateSymlinkFileParams defines parameters for CreateSymlinkFile.
type CreateSymlinkFileParams struct {

	// path to the table data
	Location *string `json:"location,omitempty"`
}

// DiffRefsParams defines parameters for DiffRefs.
type DiffRefsParams struct {

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// delimiter used to group common prefixes by
	Delimiter *PaginationDelimiter `json:"delimiter,omitempty"`
	Type      *string              `json:"type,omitempty"`

	// If set to true, the diff will include right-side object stats. *EXPERIMENTAL*
	IncludeRightStats *bool `json:"include_right_stats,omitempty"`
}

// LogCommitsParams defines parameters for LogCommits.
type LogCommitsParams struct {

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`

	// list of paths, each element is a path of a specific object
	Objects *[]string `json:"objects,omitempty"`

	// list of paths, each element is a path of a prefix
	Prefixes *[]string `json:"prefixes,omitempty"`

	// limit the number of items in return to 'amount'. Without further indication on actual number of items.
	Limit *bool `json:"limit,omitempty"`

	// if set to true, follow only the first parent upon reaching a merge commit
	FirstParent *bool `json:"first_parent,omitempty"`

	// Show commits more recent than a specific date-time. In case used with stop_at parameter, will stop at the first commit that meets any of the conditions.
	Since *time.Time `json:"since,omitempty"`

	// A reference to stop at. In case used with since parameter, will stop at the first commit that meets any of the conditions.
	StopAt *string `json:"stop_at,omitempty"`
}

// GetObjectParams defines parameters for GetObject.
type GetObjectParams struct {

	// relative to the ref
	Path    string `json:"path"`
	Presign *bool  `json:"presign,omitempty"`

	// Byte range to retrieve
	Range *string `json:"Range,omitempty"`

	// Returns response only if the object does not have a matching ETag
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// HeadObjectParams defines parameters for HeadObject.
type HeadObjectParams struct {

	// relative to the ref
	Path string `json:"path"`

	// Byte range to retrieve
	Range *string `json:"Range,omitempty"`
}

// ListObjectsParams defines parameters for ListObjects.
type ListObjectsParams struct {
	UserMetadata *bool `json:"user_metadata,omitempty"`
	Presign      *bool `json:"presign,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`

	// delimiter used to group common prefixes by
	Delimiter *PaginationDelimiter `json:"delimiter,omitempty"`

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`
}

// StatObjectParams defines parameters for StatObject.
type StatObjectParams struct {

	// relative to the branch
	Path         string `json:"path"`
	UserMetadata *bool  `json:"user_metadata,omitempty"`
	Presign      *bool  `json:"presign,omitempty"`
}

// GetUnderlyingPropertiesParams defines parameters for GetUnderlyingProperties.
type GetUnderlyingPropertiesParams struct {

	// relative to the branch
	Path string `json:"path"`
}

// MergeIntoBranchJSONBody defines parameters for MergeIntoBranch.
type MergeIntoBranchJSONBody Merge

// MergeIntoBranchAsyncJSONBody defines parameters for MergeIntoBranchAsync.
type MergeIntoBranchAsyncJSONBody Merge

// RestoreStatusParams defines parameters for RestoreStatus.
type RestoreStatusParams struct {
	TaskId string `json:"task_id"`
}

// RestoreSubmitJSONBody defines parameters for RestoreSubmit.
type RestoreSubmitJSONBody RefsRestore

// SetBranchProtectionRulesJSONBody defines parameters for SetBranchProtectionRules.
type SetBranchProtectionRulesJSONBody []BranchProtectionRule

// SetBranchProtectionRulesParams defines parameters for SetBranchProtectionRules.
type SetBranchProtectionRulesParams struct {

	// if provided, the branch protection rules will be updated only if the current ETag match the provided value
	IfMatch *string `json:"If-Match,omitempty"`
}

// SetGCRulesJSONBody defines parameters for SetGCRules.
type SetGCRulesJSONBody GarbageCollectionRules

// ListTagsParams defines parameters for ListTags.
type ListTagsParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// CreateTagJSONBody defines parameters for CreateTag.
type CreateTagJSONBody TagCreation

// DeleteTagParams defines parameters for DeleteTag.
type DeleteTagParams struct {
	Force *bool `json:"force,omitempty"`
}

// SetupCommPrefsJSONBody defines parameters for SetupCommPrefs.
type SetupCommPrefsJSONBody CommPrefsInput

// SetupJSONBody defines parameters for Setup.
type SetupJSONBody Setup

// PostStatsEventsJSONBody defines parameters for PostStatsEvents.
type PostStatsEventsJSONBody StatsEventsList

// StsLoginJSONBody defines parameters for StsLogin.
type StsLoginJSONBody StsAuthRequest

// ExternalPrincipalLoginJSONRequestBody defines body for ExternalPrincipalLogin for application/json ContentType.
type ExternalPrincipalLoginJSONRequestBody ExternalPrincipalLoginJSONBody

// CreateGroupJSONRequestBody defines body for CreateGroup for application/json ContentType.
type CreateGroupJSONRequestBody CreateGroupJSONBody

// SetGroupACLJSONRequestBody defines body for SetGroupACL for application/json ContentType.
type SetGroupACLJSONRequestBody SetGroupACLJSONBody

// LoginJSONRequestBody defines body for Login for application/json ContentType.
type LoginJSONRequestBody LoginJSONBody

// CreatePolicyJSONRequestBody defines body for CreatePolicy for application/json ContentType.
type CreatePolicyJSONRequestBody CreatePolicyJSONBody

// UpdatePolicyJSONRequestBody defines body for UpdatePolicy for application/json ContentType.
type UpdatePolicyJSONRequestBody UpdatePolicyJSONBody

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody CreateUserJSONBody

// CreateUserExternalPrincipalJSONRequestBody defines body for CreateUserExternalPrincipal for application/json ContentType.
type CreateUserExternalPrincipalJSONRequestBody CreateUserExternalPrincipalJSONBody

// PullIcebergTableJSONRequestBody defines body for PullIcebergTable for application/json ContentType.
type PullIcebergTableJSONRequestBody PullIcebergTableJSONBody

// PushIcebergTableJSONRequestBody defines body for PushIcebergTable for application/json ContentType.
type PushIcebergTableJSONRequestBody PushIcebergTableJSONBody

// CreateRepositoryJSONRequestBody defines body for CreateRepository for application/json ContentType.
type CreateRepositoryJSONRequestBody CreateRepositoryJSONBody

// InternalDeleteBranchProtectionRuleJSONRequestBody defines body for InternalDeleteBranchProtectionRule for application/json ContentType.
type InternalDeleteBranchProtectionRuleJSONRequestBody InternalDeleteBranchProtectionRuleJSONBody

// InternalCreateBranchProtectionRuleJSONRequestBody defines body for InternalCreateBranchProtectionRule for application/json ContentType.
type InternalCreateBranchProtectionRuleJSONRequestBody InternalCreateBranchProtectionRuleJSONBody

// CreateBranchJSONRequestBody defines body for CreateBranch for application/json ContentType.
type CreateBranchJSONRequestBody CreateBranchJSONBody

// ResetBranchJSONRequestBody defines body for ResetBranch for application/json ContentType.
type ResetBranchJSONRequestBody ResetBranchJSONBody

// CherryPickJSONRequestBody defines body for CherryPick for application/json ContentType.
type CherryPickJSONRequestBody CherryPickJSONBody

// CommitJSONRequestBody defines body for Commit for application/json ContentType.
type CommitJSONRequestBody CommitJSONBody

// CommitAsyncJSONRequestBody defines body for CommitAsync for application/json ContentType.
type CommitAsyncJSONRequestBody CommitAsyncJSONBody

// ImportStartJSONRequestBody defines body for ImportStart for application/json ContentType.
type ImportStartJSONRequestBody ImportStartJSONBody

// StageObjectJSONRequestBody defines body for StageObject for application/json ContentType.
type StageObjectJSONRequestBody StageObjectJSONBody

// CopyObjectJSONRequestBody defines body for CopyObject for application/json ContentType.
type CopyObjectJSONRequestBody CopyObjectJSONBody

// DeleteObjectsJSONRequestBody defines body for DeleteObjects for application/json ContentType.
type DeleteObjectsJSONRequestBody DeleteObjectsJSONBody

// UpdateObjectUserMetadataJSONRequestBody defines body for UpdateObjectUserMetadata for application/json ContentType.
type UpdateObjectUserMetadataJSONRequestBody UpdateObjectUserMetadataJSONBody

// RevertBranchJSONRequestBody defines body for RevertBranch for application/json ContentType.
type RevertBranchJSONRequestBody RevertBranchJSONBody

// LinkPhysicalAddressJSONRequestBody defines body for LinkPhysicalAddress for application/json ContentType.
type LinkPhysicalAddressJSONRequestBody LinkPhysicalAddressJSONBody

// AbortPresignMultipartUploadJSONRequestBody defines body for AbortPresignMultipartUpload for application/json ContentType.
type AbortPresignMultipartUploadJSONRequestBody AbortPresignMultipartUploadJSONBody

// CompletePresignMultipartUploadJSONRequestBody defines body for CompletePresignMultipartUpload for application/json ContentType.
type CompletePresignMultipartUploadJSONRequestBody CompletePresignMultipartUploadJSONBody

// UploadPartJSONRequestBody defines body for UploadPart for application/json ContentType.
type UploadPartJSONRequestBody UploadPartJSONBody

// UploadPartCopyJSONRequestBody defines body for UploadPartCopy for application/json ContentType.
type UploadPartCopyJSONRequestBody UploadPartCopyJSONBody

// CreateCommitRecordJSONRequestBody defines body for CreateCommitRecord for application/json ContentType.
type CreateCommitRecordJSONRequestBody CreateCommitRecordJSONBody

// PrepareGarbageCollectionUncommittedJSONRequestBody defines body for PrepareGarbageCollectionUncommitted for application/json ContentType.
type PrepareGarbageCollectionUncommittedJSONRequestBody PrepareGarbageCollectionUncommittedJSONBody

// InternalSetGarbageCollectionRulesJSONRequestBody defines body for InternalSetGarbageCollectionRules for application/json ContentType.
type InternalSetGarbageCollectionRulesJSONRequestBody InternalSetGarbageCollectionRulesJSONBody

// DeleteRepositoryMetadataJSONRequestBody defines body for DeleteRepositoryMetadata for application/json ContentType.
type DeleteRepositoryMetadataJSONRequestBody DeleteRepositoryMetadataJSONBody

// SetRepositoryMetadataJSONRequestBody defines body for SetRepositoryMetadata for application/json ContentType.
type SetRepositoryMetadataJSONRequestBody SetRepositoryMetadataJSONBody

// CreatePullRequestJSONRequestBody defines body for CreatePullRequest for application/json ContentType.
type CreatePullRequestJSONRequestBody CreatePullRequestJSONBody

// UpdatePullRequestJSONRequestBody defines body for UpdatePullRequest for application/json ContentType.
type UpdatePullRequestJSONRequestBody UpdatePullRequestJSONBody

// RestoreRefsJSONRequestBody defines body for RestoreRefs for application/json ContentType.
type RestoreRefsJSONRequestBody RestoreRefsJSONBody

// MergeIntoBranchJSONRequestBody defines body for MergeIntoBranch for application/json ContentType.
type MergeIntoBranchJSONRequestBody MergeIntoBranchJSONBody

// MergeIntoBranchAsyncJSONRequestBody defines body for MergeIntoBranchAsync for application/json ContentType.
type MergeIntoBranchAsyncJSONRequestBody MergeIntoBranchAsyncJSONBody

// RestoreSubmitJSONRequestBody defines body for RestoreSubmit for application/json ContentType.
type RestoreSubmitJSONRequestBody RestoreSubmitJSONBody

// SetBranchProtectionRulesJSONRequestBody defines body for SetBranchProtectionRules for application/json ContentType.
type SetBranchProtectionRulesJSONRequestBody SetBranchProtectionRulesJSONBody

// SetGCRulesJSONRequestBody defines body for SetGCRules for application/json ContentType.
type SetGCRulesJSONRequestBody SetGCRulesJSONBody

// CreateTagJSONRequestBody defines body for CreateTag for application/json ContentType.
type CreateTagJSONRequestBody CreateTagJSONBody

// SetupCommPrefsJSONRequestBody defines body for SetupCommPrefs for application/json ContentType.
type SetupCommPrefsJSONRequestBody SetupCommPrefsJSONBody

// SetupJSONRequestBody defines body for Setup for application/json ContentType.
type SetupJSONRequestBody SetupJSONBody

// PostStatsEventsJSONRequestBody defines body for PostStatsEvents for application/json ContentType.
type PostStatsEventsJSONRequestBody PostStatsEventsJSONBody

// StsLoginJSONRequestBody defines body for StsLogin for application/json ContentType.
type StsLoginJSONRequestBody StsLoginJSONBody

// Getter for additional properties for Commit_Metadata. Returns the specified
// element and whether it was found
func (a Commit_Metadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Commit_Metadata
func (a *Commit_Metadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Commit_Metadata to handle AdditionalProperties
func (a *Commit_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Commit_Metadata to handle AdditionalProperties
func (a Commit_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CommitCreation_Metadata. Returns the specified
// element and whether it was found
func (a CommitCreation_Metadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CommitCreation_Metadata
func (a *CommitCreation_Metadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CommitCreation_Metadata to handle AdditionalProperties
func (a *CommitCreation_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CommitCreation_Metadata to handle AdditionalProperties
func (a CommitCreation_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CommitOverrides_Metadata. Returns the specified
// element and whether it was found
func (a CommitOverrides_Metadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CommitOverrides_Metadata
func (a *CommitOverrides_Metadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CommitOverrides_Metadata to handle AdditionalProperties
func (a *CommitOverrides_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CommitOverrides_Metadata to handle AdditionalProperties
func (a CommitOverrides_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CommitRecordCreation_Metadata. Returns the specified
// element and whether it was found
func (a CommitRecordCreation_Metadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CommitRecordCreation_Metadata
func (a *CommitRecordCreation_Metadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CommitRecordCreation_Metadata to handle AdditionalProperties
func (a *CommitRecordCreation_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CommitRecordCreation_Metadata to handle AdditionalProperties
func (a CommitRecordCreation_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CompletePresignMultipartUpload_UserMetadata. Returns the specified
// element and whether it was found
func (a CompletePresignMultipartUpload_UserMetadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CompletePresignMultipartUpload_UserMetadata
func (a *CompletePresignMultipartUpload_UserMetadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CompletePresignMultipartUpload_UserMetadata to handle AdditionalProperties
func (a *CompletePresignMultipartUpload_UserMetadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CompletePresignMultipartUpload_UserMetadata to handle AdditionalProperties
func (a CompletePresignMultipartUpload_UserMetadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ExternalPrincipalSettings. Returns the specified
// element and whether it was found
func (a ExternalPrincipalSettings) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ExternalPrincipalSettings
func (a *ExternalPrincipalSettings) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ExternalPrincipalSettings to handle AdditionalProperties
func (a *ExternalPrincipalSettings) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ExternalPrincipalSettings to handle AdditionalProperties
func (a ExternalPrincipalSettings) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Merge_Metadata. Returns the specified
// element and whether it was found
func (a Merge_Metadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Merge_Metadata
func (a *Merge_Metadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Merge_Metadata to handle AdditionalProperties
func (a *Merge_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Merge_Metadata to handle AdditionalProperties
func (a Merge_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ObjectUserMetadata. Returns the specified
// element and whether it was found
func (a ObjectUserMetadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ObjectUserMetadata
func (a *ObjectUserMetadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ObjectUserMetadata to handle AdditionalProperties
func (a *ObjectUserMetadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ObjectUserMetadata to handle AdditionalProperties
func (a ObjectUserMetadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PolicyCondition. Returns the specified
// element and whether it was found
func (a PolicyCondition) Get(fieldName string) (value []string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PolicyCondition
func (a *PolicyCondition) Set(fieldName string, value []string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string][]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PolicyCondition to handle AdditionalProperties
func (a *PolicyCondition) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string][]string)
		for fieldName, fieldBuf := range object {
			var fieldVal []string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PolicyCondition to handle AdditionalProperties
func (a PolicyCondition) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RepositoryMetadata. Returns the specified
// element and whether it was found
func (a RepositoryMetadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RepositoryMetadata
func (a *RepositoryMetadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RepositoryMetadata to handle AdditionalProperties
func (a *RepositoryMetadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RepositoryMetadata to handle AdditionalProperties
func (a RepositoryMetadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RepositoryMetadataSet_Metadata. Returns the specified
// element and whether it was found
func (a RepositoryMetadataSet_Metadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RepositoryMetadataSet_Metadata
func (a *RepositoryMetadataSet_Metadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RepositoryMetadataSet_Metadata to handle AdditionalProperties
func (a *RepositoryMetadataSet_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RepositoryMetadataSet_Metadata to handle AdditionalProperties
func (a RepositoryMetadataSet_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for StagingMetadata_UserMetadata. Returns the specified
// element and whether it was found
func (a StagingMetadata_UserMetadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for StagingMetadata_UserMetadata
func (a *StagingMetadata_UserMetadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for StagingMetadata_UserMetadata to handle AdditionalProperties
func (a *StagingMetadata_UserMetadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for StagingMetadata_UserMetadata to handle AdditionalProperties
func (a StagingMetadata_UserMetadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Statement_Condition. Returns the specified
// element and whether it was found
func (a Statement_Condition) Get(fieldName string) (value PolicyCondition, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Statement_Condition
func (a *Statement_Condition) Set(fieldName string, value PolicyCondition) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]PolicyCondition)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Statement_Condition to handle AdditionalProperties
func (a *Statement_Condition) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]PolicyCondition)
		for fieldName, fieldBuf := range object {
			var fieldVal PolicyCondition
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Statement_Condition to handle AdditionalProperties
func (a Statement_Condition) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = http.DefaultClient
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAuthCapabilities request
	GetAuthCapabilities(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExternalPrincipalLogin request  with any body
	ExternalPrincipalLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExternalPrincipalLogin(ctx context.Context, body ExternalPrincipalLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExternalPrincipal request
	GetExternalPrincipal(ctx context.Context, params *GetExternalPrincipalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTokenFromMailbox request
	GetTokenFromMailbox(ctx context.Context, mailbox string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReleaseTokenToMailbox request
	ReleaseTokenToMailbox(ctx context.Context, loginRequestToken string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTokenRedirect request
	GetTokenRedirect(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGroups request
	ListGroups(ctx context.Context, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGroup request  with any body
	CreateGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGroup(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroup request
	DeleteGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroup request
	GetGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupACL request
	GetGroupACL(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetGroupACL request  with any body
	SetGroupACLWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetGroupACL(ctx context.Context, groupId string, body SetGroupACLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGroupMembers request
	ListGroupMembers(ctx context.Context, groupId string, params *ListGroupMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroupMembership request
	DeleteGroupMembership(ctx context.Context, groupId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddGroupMembership request
	AddGroupMembership(ctx context.Context, groupId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGroupPolicies request
	ListGroupPolicies(ctx context.Context, groupId string, params *ListGroupPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DetachPolicyFromGroup request
	DetachPolicyFromGroup(ctx context.Context, groupId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachPolicyToGroup request
	AttachPolicyToGroup(ctx context.Context, groupId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Login request  with any body
	LoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Login(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPolicies request
	ListPolicies(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePolicy request  with any body
	CreatePolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePolicy(ctx context.Context, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePolicy request
	DeletePolicy(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPolicy request
	GetPolicy(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePolicy request  with any body
	UpdatePolicyWithBody(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePolicy(ctx context.Context, policyId string, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsers request
	ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUser request  with any body
	CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserCredentials request
	ListUserCredentials(ctx context.Context, userId string, params *ListUserCredentialsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCredentials request
	CreateCredentials(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCredentials request
	DeleteCredentials(ctx context.Context, userId string, accessKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCredentials request
	GetCredentials(ctx context.Context, userId string, accessKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserExternalPrincipal request
	DeleteUserExternalPrincipal(ctx context.Context, userId string, params *DeleteUserExternalPrincipalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserExternalPrincipal request  with any body
	CreateUserExternalPrincipalWithBody(ctx context.Context, userId string, params *CreateUserExternalPrincipalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUserExternalPrincipal(ctx context.Context, userId string, params *CreateUserExternalPrincipalParams, body CreateUserExternalPrincipalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserExternalPrincipals request
	ListUserExternalPrincipals(ctx context.Context, userId string, params *ListUserExternalPrincipalsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserGroups request
	ListUserGroups(ctx context.Context, userId string, params *ListUserGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserPolicies request
	ListUserPolicies(ctx context.Context, userId string, params *ListUserPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DetachPolicyFromUser request
	DetachPolicyFromUser(ctx context.Context, userId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachPolicyToUser request
	AttachPolicyToUser(ctx context.Context, userId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfig request
	GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGarbageCollectionConfig request
	GetGarbageCollectionConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStorageConfig request
	GetStorageConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLakeFSVersion request
	GetLakeFSVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HealthCheck request
	HealthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PullIcebergTable request  with any body
	PullIcebergTableWithBody(ctx context.Context, catalog string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PullIcebergTable(ctx context.Context, catalog string, body PullIcebergTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PushIcebergTable request  with any body
	PushIcebergTableWithBody(ctx context.Context, catalog string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PushIcebergTable(ctx context.Context, catalog string, body PushIcebergTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLicense request
	GetLicense(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthCallback request
	OauthCallback(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRepositories request
	ListRepositories(ctx context.Context, params *ListRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRepository request  with any body
	CreateRepositoryWithBody(ctx context.Context, params *CreateRepositoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRepository(ctx context.Context, params *CreateRepositoryParams, body CreateRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRepository request
	DeleteRepository(ctx context.Context, repository string, params *DeleteRepositoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRepository request
	GetRepository(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRepositoryRuns request
	ListRepositoryRuns(ctx context.Context, repository string, params *ListRepositoryRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRun request
	GetRun(ctx context.Context, repository string, runId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRunHooks request
	ListRunHooks(ctx context.Context, repository string, runId string, params *ListRunHooksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRunHookOutput request
	GetRunHookOutput(ctx context.Context, repository string, runId string, hookRunId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalDeleteBranchProtectionRule request  with any body
	InternalDeleteBranchProtectionRuleWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InternalDeleteBranchProtectionRule(ctx context.Context, repository string, body InternalDeleteBranchProtectionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalGetBranchProtectionRules request
	InternalGetBranchProtectionRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalCreateBranchProtectionRule request  with any body
	InternalCreateBranchProtectionRuleWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InternalCreateBranchProtectionRule(ctx context.Context, repository string, body InternalCreateBranchProtectionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBranchProtectionRulePreflight request
	CreateBranchProtectionRulePreflight(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBranches request
	ListBranches(ctx context.Context, repository string, params *ListBranchesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBranch request  with any body
	CreateBranchWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBranch(ctx context.Context, repository string, body CreateBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBranch request
	DeleteBranch(ctx context.Context, repository string, branch string, params *DeleteBranchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBranch request
	GetBranch(ctx context.Context, repository string, branch string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetBranch request  with any body
	ResetBranchWithBody(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResetBranch(ctx context.Context, repository string, branch string, body ResetBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CherryPick request  with any body
	CherryPickWithBody(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CherryPick(ctx context.Context, repository string, branch string, body CherryPickJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Commit request  with any body
	CommitWithBody(ctx context.Context, repository string, branch string, params *CommitParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Commit(ctx context.Context, repository string, branch string, params *CommitParams, body CommitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommitAsync request  with any body
	CommitAsyncWithBody(ctx context.Context, repository string, branch string, params *CommitAsyncParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CommitAsync(ctx context.Context, repository string, branch string, params *CommitAsyncParams, body CommitAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommitAsyncStatus request
	CommitAsyncStatus(ctx context.Context, repository string, branch string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DiffBranch request
	DiffBranch(ctx context.Context, repository string, branch string, params *DiffBranchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HardResetBranch request
	HardResetBranch(ctx context.Context, repository string, branch string, params *HardResetBranchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportCancel request
	ImportCancel(ctx context.Context, repository string, branch string, params *ImportCancelParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportStatus request
	ImportStatus(ctx context.Context, repository string, branch string, params *ImportStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportStart request  with any body
	ImportStartWithBody(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ImportStart(ctx context.Context, repository string, branch string, body ImportStartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteObject request
	DeleteObject(ctx context.Context, repository string, branch string, params *DeleteObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadObject request  with any body
	UploadObjectWithBody(ctx context.Context, repository string, branch string, params *UploadObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StageObject request  with any body
	StageObjectWithBody(ctx context.Context, repository string, branch string, params *StageObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StageObject(ctx context.Context, repository string, branch string, params *StageObjectParams, body StageObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CopyObject request  with any body
	CopyObjectWithBody(ctx context.Context, repository string, branch string, params *CopyObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CopyObject(ctx context.Context, repository string, branch string, params *CopyObjectParams, body CopyObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteObjects request  with any body
	DeleteObjectsWithBody(ctx context.Context, repository string, branch string, params *DeleteObjectsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteObjects(ctx context.Context, repository string, branch string, params *DeleteObjectsParams, body DeleteObjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadObjectPreflight request
	UploadObjectPreflight(ctx context.Context, repository string, branch string, params *UploadObjectPreflightParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateObjectUserMetadata request  with any body
	UpdateObjectUserMetadataWithBody(ctx context.Context, repository string, branch string, params *UpdateObjectUserMetadataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateObjectUserMetadata(ctx context.Context, repository string, branch string, params *UpdateObjectUserMetadataParams, body UpdateObjectUserMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevertBranch request  with any body
	RevertBranchWithBody(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevertBranch(ctx context.Context, repository string, branch string, body RevertBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPhysicalAddress request
	GetPhysicalAddress(ctx context.Context, repository string, branch string, params *GetPhysicalAddressParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkPhysicalAddress request  with any body
	LinkPhysicalAddressWithBody(ctx context.Context, repository string, branch string, params *LinkPhysicalAddressParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkPhysicalAddress(ctx context.Context, repository string, branch string, params *LinkPhysicalAddressParams, body LinkPhysicalAddressJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePresignMultipartUpload request
	CreatePresignMultipartUpload(ctx context.Context, repository string, branch string, params *CreatePresignMultipartUploadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AbortPresignMultipartUpload request  with any body
	AbortPresignMultipartUploadWithBody(ctx context.Context, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AbortPresignMultipartUpload(ctx context.Context, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, body AbortPresignMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CompletePresignMultipartUpload request  with any body
	CompletePresignMultipartUploadWithBody(ctx context.Context, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CompletePresignMultipartUpload(ctx context.Context, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, body CompletePresignMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadPart request  with any body
	UploadPartWithBody(ctx context.Context, repository string, branch string, uploadId string, partNumber int, params *UploadPartParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UploadPart(ctx context.Context, repository string, branch string, uploadId string, partNumber int, params *UploadPartParams, body UploadPartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadPartCopy request  with any body
	UploadPartCopyWithBody(ctx context.Context, repository string, branch string, uploadId string, partNumber int, params *UploadPartCopyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UploadPartCopy(ctx context.Context, repository string, branch string, uploadId string, partNumber int, params *UploadPartCopyParams, body UploadPartCopyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCommitRecord request  with any body
	CreateCommitRecordWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCommitRecord(ctx context.Context, repository string, body CreateCommitRecordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCommit request
	GetCommit(ctx context.Context, repository string, commitId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DumpStatus request
	DumpStatus(ctx context.Context, repository string, params *DumpStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DumpSubmit request
	DumpSubmit(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PrepareGarbageCollectionCommits request
	PrepareGarbageCollectionCommits(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PrepareGarbageCollectionCommitsAsync request
	PrepareGarbageCollectionCommitsAsync(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PrepareGarbageCollectionCommitsStatus request
	PrepareGarbageCollectionCommitsStatus(ctx context.Context, repository string, params *PrepareGarbageCollectionCommitsStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PrepareGarbageCollectionUncommitted request  with any body
	PrepareGarbageCollectionUncommittedWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PrepareGarbageCollectionUncommitted(ctx context.Context, repository string, body PrepareGarbageCollectionUncommittedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalDeleteGarbageCollectionRules request
	InternalDeleteGarbageCollectionRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalGetGarbageCollectionRules request
	InternalGetGarbageCollectionRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalSetGarbageCollectionRules request  with any body
	InternalSetGarbageCollectionRulesWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InternalSetGarbageCollectionRules(ctx context.Context, repository string, body InternalSetGarbageCollectionRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetGarbageCollectionRulesPreflight request
	SetGarbageCollectionRulesPreflight(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRepositoryMetadata request  with any body
	DeleteRepositoryMetadataWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteRepositoryMetadata(ctx context.Context, repository string, body DeleteRepositoryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRepositoryMetadata request
	GetRepositoryMetadata(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetRepositoryMetadata request  with any body
	SetRepositoryMetadataWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetRepositoryMetadata(ctx context.Context, repository string, body SetRepositoryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMetaRange request
	GetMetaRange(ctx context.Context, repository string, metaRange string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMetadataObject request
	GetMetadataObject(ctx context.Context, repository string, pType string, objectId string, params *GetMetadataObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRange request
	GetRange(ctx context.Context, repository string, pRange string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPullRequests request
	ListPullRequests(ctx context.Context, repository string, params *ListPullRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePullRequest request  with any body
	CreatePullRequestWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePullRequest(ctx context.Context, repository string, body CreatePullRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPullRequest request
	GetPullRequest(ctx context.Context, repository string, pullRequest string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePullRequest request  with any body
	UpdatePullRequestWithBody(ctx context.Context, repository string, pullRequest string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePullRequest(ctx context.Context, repository string, pullRequest string, body UpdatePullRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MergePullRequest request
	MergePullRequest(ctx context.Context, repository string, pullRequest string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DumpRefs request
	DumpRefs(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestoreRefs request  with any body
	RestoreRefsWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RestoreRefs(ctx context.Context, repository string, body RestoreRefsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSymlinkFile request
	CreateSymlinkFile(ctx context.Context, repository string, branch string, params *CreateSymlinkFileParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DiffRefs request
	DiffRefs(ctx context.Context, repository string, leftRef string, rightRef string, params *DiffRefsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LogCommits request
	LogCommits(ctx context.Context, repository string, ref string, params *LogCommitsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetObject request
	GetObject(ctx context.Context, repository string, ref string, params *GetObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HeadObject request
	HeadObject(ctx context.Context, repository string, ref string, params *HeadObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListObjects request
	ListObjects(ctx context.Context, repository string, ref string, params *ListObjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StatObject request
	StatObject(ctx context.Context, repository string, ref string, params *StatObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUnderlyingProperties request
	GetUnderlyingProperties(ctx context.Context, repository string, ref string, params *GetUnderlyingPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindMergeBase request
	FindMergeBase(ctx context.Context, repository string, sourceRef string, destinationBranch string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MergeIntoBranch request  with any body
	MergeIntoBranchWithBody(ctx context.Context, repository string, sourceRef string, destinationBranch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MergeIntoBranch(ctx context.Context, repository string, sourceRef string, destinationBranch string, body MergeIntoBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MergeIntoBranchAsync request  with any body
	MergeIntoBranchAsyncWithBody(ctx context.Context, repository string, sourceRef string, destinationBranch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MergeIntoBranchAsync(ctx context.Context, repository string, sourceRef string, destinationBranch string, body MergeIntoBranchAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MergeIntoBranchAsyncStatus request
	MergeIntoBranchAsyncStatus(ctx context.Context, repository string, sourceRef string, destinationBranch string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestoreStatus request
	RestoreStatus(ctx context.Context, repository string, params *RestoreStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestoreSubmit request  with any body
	RestoreSubmitWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RestoreSubmit(ctx context.Context, repository string, body RestoreSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBranchProtectionRules request
	GetBranchProtectionRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetBranchProtectionRules request  with any body
	SetBranchProtectionRulesWithBody(ctx context.Context, repository string, params *SetBranchProtectionRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetBranchProtectionRules(ctx context.Context, repository string, params *SetBranchProtectionRulesParams, body SetBranchProtectionRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGCRules request
	DeleteGCRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGCRules request
	GetGCRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetGCRules request  with any body
	SetGCRulesWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetGCRules(ctx context.Context, repository string, body SetGCRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTags request
	ListTags(ctx context.Context, repository string, params *ListTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTag request  with any body
	CreateTagWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTag(ctx context.Context, repository string, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTag request
	DeleteTag(ctx context.Context, repository string, tag string, params *DeleteTagParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTag request
	GetTag(ctx context.Context, repository string, tag string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetupCommPrefs request  with any body
	SetupCommPrefsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetupCommPrefs(ctx context.Context, body SetupCommPrefsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSetupState request
	GetSetupState(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Setup request  with any body
	SetupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Setup(ctx context.Context, body SetupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostStatsEvents request  with any body
	PostStatsEventsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostStatsEvents(ctx context.Context, body PostStatsEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StsLogin request  with any body
	StsLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StsLogin(ctx context.Context, body StsLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsageReportSummary request
	GetUsageReportSummary(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentUser request
	GetCurrentUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAuthCapabilities(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthCapabilitiesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExternalPrincipalLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExternalPrincipalLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExternalPrincipalLogin(ctx context.Context, body ExternalPrincipalLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExternalPrincipalLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExternalPrincipal(ctx context.Context, params *GetExternalPrincipalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExternalPrincipalRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTokenFromMailbox(ctx context.Context, mailbox string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTokenFromMailboxRequest(c.Server, mailbox)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReleaseTokenToMailbox(ctx context.Context, loginRequestToken string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReleaseTokenToMailboxRequest(c.Server, loginRequestToken)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTokenRedirect(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTokenRedirectRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGroups(ctx context.Context, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroup(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupACL(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupACLRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetGroupACLWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetGroupACLRequestWithBody(c.Server, groupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetGroupACL(ctx context.Context, groupId string, body SetGroupACLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetGroupACLRequest(c.Server, groupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGroupMembers(ctx context.Context, groupId string, params *ListGroupMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGroupMembersRequest(c.Server, groupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroupMembership(ctx context.Context, groupId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupMembershipRequest(c.Server, groupId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddGroupMembership(ctx context.Context, groupId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddGroupMembershipRequest(c.Server, groupId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGroupPolicies(ctx context.Context, groupId string, params *ListGroupPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGroupPoliciesRequest(c.Server, groupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DetachPolicyFromGroup(ctx context.Context, groupId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDetachPolicyFromGroupRequest(c.Server, groupId, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachPolicyToGroup(ctx context.Context, groupId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachPolicyToGroupRequest(c.Server, groupId, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Login(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPolicies(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePolicyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePolicy(ctx context.Context, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePolicyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePolicy(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePolicyRequest(c.Server, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPolicy(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPolicyRequest(c.Server, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePolicyWithBody(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePolicyRequestWithBody(c.Server, policyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePolicy(ctx context.Context, policyId string, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePolicyRequest(c.Server, policyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserCredentials(ctx context.Context, userId string, params *ListUserCredentialsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserCredentialsRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCredentials(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCredentialsRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCredentials(ctx context.Context, userId string, accessKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCredentialsRequest(c.Server, userId, accessKeyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCredentials(ctx context.Context, userId string, accessKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCredentialsRequest(c.Server, userId, accessKeyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserExternalPrincipal(ctx context.Context, userId string, params *DeleteUserExternalPrincipalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserExternalPrincipalRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserExternalPrincipalWithBody(ctx context.Context, userId string, params *CreateUserExternalPrincipalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserExternalPrincipalRequestWithBody(c.Server, userId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserExternalPrincipal(ctx context.Context, userId string, params *CreateUserExternalPrincipalParams, body CreateUserExternalPrincipalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserExternalPrincipalRequest(c.Server, userId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserExternalPrincipals(ctx context.Context, userId string, params *ListUserExternalPrincipalsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserExternalPrincipalsRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserGroups(ctx context.Context, userId string, params *ListUserGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserGroupsRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserPolicies(ctx context.Context, userId string, params *ListUserPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserPoliciesRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DetachPolicyFromUser(ctx context.Context, userId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDetachPolicyFromUserRequest(c.Server, userId, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachPolicyToUser(ctx context.Context, userId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachPolicyToUserRequest(c.Server, userId, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGarbageCollectionConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGarbageCollectionConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStorageConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStorageConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLakeFSVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLakeFSVersionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HealthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthCheckRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullIcebergTableWithBody(ctx context.Context, catalog string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullIcebergTableRequestWithBody(c.Server, catalog, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullIcebergTable(ctx context.Context, catalog string, body PullIcebergTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullIcebergTableRequest(c.Server, catalog, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PushIcebergTableWithBody(ctx context.Context, catalog string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPushIcebergTableRequestWithBody(c.Server, catalog, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PushIcebergTable(ctx context.Context, catalog string, body PushIcebergTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPushIcebergTableRequest(c.Server, catalog, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLicense(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLicenseRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthCallback(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthCallbackRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRepositories(ctx context.Context, params *ListRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRepositoriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRepositoryWithBody(ctx context.Context, params *CreateRepositoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRepositoryRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRepository(ctx context.Context, params *CreateRepositoryParams, body CreateRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRepositoryRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRepository(ctx context.Context, repository string, params *DeleteRepositoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRepositoryRequest(c.Server, repository, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRepository(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRepositoryRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRepositoryRuns(ctx context.Context, repository string, params *ListRepositoryRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRepositoryRunsRequest(c.Server, repository, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRun(ctx context.Context, repository string, runId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRunRequest(c.Server, repository, runId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRunHooks(ctx context.Context, repository string, runId string, params *ListRunHooksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRunHooksRequest(c.Server, repository, runId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRunHookOutput(ctx context.Context, repository string, runId string, hookRunId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRunHookOutputRequest(c.Server, repository, runId, hookRunId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalDeleteBranchProtectionRuleWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalDeleteBranchProtectionRuleRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalDeleteBranchProtectionRule(ctx context.Context, repository string, body InternalDeleteBranchProtectionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalDeleteBranchProtectionRuleRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalGetBranchProtectionRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalGetBranchProtectionRulesRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalCreateBranchProtectionRuleWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalCreateBranchProtectionRuleRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalCreateBranchProtectionRule(ctx context.Context, repository string, body InternalCreateBranchProtectionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalCreateBranchProtectionRuleRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBranchProtectionRulePreflight(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBranchProtectionRulePreflightRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBranches(ctx context.Context, repository string, params *ListBranchesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBranchesRequest(c.Server, repository, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBranchWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBranchRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBranch(ctx context.Context, repository string, body CreateBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBranchRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBranch(ctx context.Context, repository string, branch string, params *DeleteBranchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBranchRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBranch(ctx context.Context, repository string, branch string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBranchRequest(c.Server, repository, branch)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetBranchWithBody(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetBranchRequestWithBody(c.Server, repository, branch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetBranch(ctx context.Context, repository string, branch string, body ResetBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetBranchRequest(c.Server, repository, branch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CherryPickWithBody(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCherryPickRequestWithBody(c.Server, repository, branch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CherryPick(ctx context.Context, repository string, branch string, body CherryPickJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCherryPickRequest(c.Server, repository, branch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitWithBody(ctx context.Context, repository string, branch string, params *CommitParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitRequestWithBody(c.Server, repository, branch, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Commit(ctx context.Context, repository string, branch string, params *CommitParams, body CommitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitRequest(c.Server, repository, branch, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitAsyncWithBody(ctx context.Context, repository string, branch string, params *CommitAsyncParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitAsyncRequestWithBody(c.Server, repository, branch, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitAsync(ctx context.Context, repository string, branch string, params *CommitAsyncParams, body CommitAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitAsyncRequest(c.Server, repository, branch, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitAsyncStatus(ctx context.Context, repository string, branch string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitAsyncStatusRequest(c.Server, repository, branch, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DiffBranch(ctx context.Context, repository string, branch string, params *DiffBranchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDiffBranchRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HardResetBranch(ctx context.Context, repository string, branch string, params *HardResetBranchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHardResetBranchRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportCancel(ctx context.Context, repository string, branch string, params *ImportCancelParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportCancelRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportStatus(ctx context.Context, repository string, branch string, params *ImportStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportStatusRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportStartWithBody(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportStartRequestWithBody(c.Server, repository, branch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportStart(ctx context.Context, repository string, branch string, body ImportStartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportStartRequest(c.Server, repository, branch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteObject(ctx context.Context, repository string, branch string, params *DeleteObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteObjectRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadObjectWithBody(ctx context.Context, repository string, branch string, params *UploadObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadObjectRequestWithBody(c.Server, repository, branch, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StageObjectWithBody(ctx context.Context, repository string, branch string, params *StageObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStageObjectRequestWithBody(c.Server, repository, branch, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StageObject(ctx context.Context, repository string, branch string, params *StageObjectParams, body StageObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStageObjectRequest(c.Server, repository, branch, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CopyObjectWithBody(ctx context.Context, repository string, branch string, params *CopyObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCopyObjectRequestWithBody(c.Server, repository, branch, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CopyObject(ctx context.Context, repository string, branch string, params *CopyObjectParams, body CopyObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCopyObjectRequest(c.Server, repository, branch, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteObjectsWithBody(ctx context.Context, repository string, branch string, params *DeleteObjectsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteObjectsRequestWithBody(c.Server, repository, branch, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteObjects(ctx context.Context, repository string, branch string, params *DeleteObjectsParams, body DeleteObjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteObjectsRequest(c.Server, repository, branch, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadObjectPreflight(ctx context.Context, repository string, branch string, params *UploadObjectPreflightParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadObjectPreflightRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateObjectUserMetadataWithBody(ctx context.Context, repository string, branch string, params *UpdateObjectUserMetadataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateObjectUserMetadataRequestWithBody(c.Server, repository, branch, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateObjectUserMetadata(ctx context.Context, repository string, branch string, params *UpdateObjectUserMetadataParams, body UpdateObjectUserMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateObjectUserMetadataRequest(c.Server, repository, branch, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevertBranchWithBody(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevertBranchRequestWithBody(c.Server, repository, branch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevertBranch(ctx context.Context, repository string, branch string, body RevertBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevertBranchRequest(c.Server, repository, branch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPhysicalAddress(ctx context.Context, repository string, branch string, params *GetPhysicalAddressParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPhysicalAddressRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkPhysicalAddressWithBody(ctx context.Context, repository string, branch string, params *LinkPhysicalAddressParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkPhysicalAddressRequestWithBody(c.Server, repository, branch, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkPhysicalAddress(ctx context.Context, repository string, branch string, params *LinkPhysicalAddressParams, body LinkPhysicalAddressJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkPhysicalAddressRequest(c.Server, repository, branch, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePresignMultipartUpload(ctx context.Context, repository string, branch string, params *CreatePresignMultipartUploadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePresignMultipartUploadRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AbortPresignMultipartUploadWithBody(ctx context.Context, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAbortPresignMultipartUploadRequestWithBody(c.Server, repository, branch, uploadId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AbortPresignMultipartUpload(ctx context.Context, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, body AbortPresignMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAbortPresignMultipartUploadRequest(c.Server, repository, branch, uploadId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompletePresignMultipartUploadWithBody(ctx context.Context, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompletePresignMultipartUploadRequestWithBody(c.Server, repository, branch, uploadId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompletePresignMultipartUpload(ctx context.Context, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, body CompletePresignMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompletePresignMultipartUploadRequest(c.Server, repository, branch, uploadId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadPartWithBody(ctx context.Context, repository string, branch string, uploadId string, partNumber int, params *UploadPartParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadPartRequestWithBody(c.Server, repository, branch, uploadId, partNumber, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadPart(ctx context.Context, repository string, branch string, uploadId string, partNumber int, params *UploadPartParams, body UploadPartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadPartRequest(c.Server, repository, branch, uploadId, partNumber, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadPartCopyWithBody(ctx context.Context, repository string, branch string, uploadId string, partNumber int, params *UploadPartCopyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadPartCopyRequestWithBody(c.Server, repository, branch, uploadId, partNumber, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadPartCopy(ctx context.Context, repository string, branch string, uploadId string, partNumber int, params *UploadPartCopyParams, body UploadPartCopyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadPartCopyRequest(c.Server, repository, branch, uploadId, partNumber, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCommitRecordWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCommitRecordRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCommitRecord(ctx context.Context, repository string, body CreateCommitRecordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCommitRecordRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCommit(ctx context.Context, repository string, commitId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCommitRequest(c.Server, repository, commitId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DumpStatus(ctx context.Context, repository string, params *DumpStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDumpStatusRequest(c.Server, repository, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DumpSubmit(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDumpSubmitRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrepareGarbageCollectionCommits(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareGarbageCollectionCommitsRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrepareGarbageCollectionCommitsAsync(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareGarbageCollectionCommitsAsyncRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrepareGarbageCollectionCommitsStatus(ctx context.Context, repository string, params *PrepareGarbageCollectionCommitsStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareGarbageCollectionCommitsStatusRequest(c.Server, repository, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrepareGarbageCollectionUncommittedWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareGarbageCollectionUncommittedRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrepareGarbageCollectionUncommitted(ctx context.Context, repository string, body PrepareGarbageCollectionUncommittedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareGarbageCollectionUncommittedRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalDeleteGarbageCollectionRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalDeleteGarbageCollectionRulesRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalGetGarbageCollectionRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalGetGarbageCollectionRulesRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalSetGarbageCollectionRulesWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalSetGarbageCollectionRulesRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalSetGarbageCollectionRules(ctx context.Context, repository string, body InternalSetGarbageCollectionRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalSetGarbageCollectionRulesRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetGarbageCollectionRulesPreflight(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetGarbageCollectionRulesPreflightRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRepositoryMetadataWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRepositoryMetadataRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRepositoryMetadata(ctx context.Context, repository string, body DeleteRepositoryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRepositoryMetadataRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRepositoryMetadata(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRepositoryMetadataRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRepositoryMetadataWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRepositoryMetadataRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRepositoryMetadata(ctx context.Context, repository string, body SetRepositoryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRepositoryMetadataRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMetaRange(ctx context.Context, repository string, metaRange string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMetaRangeRequest(c.Server, repository, metaRange)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMetadataObject(ctx context.Context, repository string, pType string, objectId string, params *GetMetadataObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMetadataObjectRequest(c.Server, repository, pType, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRange(ctx context.Context, repository string, pRange string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRangeRequest(c.Server, repository, pRange)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPullRequests(ctx context.Context, repository string, params *ListPullRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPullRequestsRequest(c.Server, repository, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePullRequestWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePullRequestRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePullRequest(ctx context.Context, repository string, body CreatePullRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePullRequestRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPullRequest(ctx context.Context, repository string, pullRequest string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPullRequestRequest(c.Server, repository, pullRequest)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePullRequestWithBody(ctx context.Context, repository string, pullRequest string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePullRequestRequestWithBody(c.Server, repository, pullRequest, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePullRequest(ctx context.Context, repository string, pullRequest string, body UpdatePullRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePullRequestRequest(c.Server, repository, pullRequest, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergePullRequest(ctx context.Context, repository string, pullRequest string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergePullRequestRequest(c.Server, repository, pullRequest)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DumpRefs(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDumpRefsRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreRefsWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreRefsRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreRefs(ctx context.Context, repository string, body RestoreRefsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreRefsRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSymlinkFile(ctx context.Context, repository string, branch string, params *CreateSymlinkFileParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSymlinkFileRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DiffRefs(ctx context.Context, repository string, leftRef string, rightRef string, params *DiffRefsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDiffRefsRequest(c.Server, repository, leftRef, rightRef, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogCommits(ctx context.Context, repository string, ref string, params *LogCommitsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogCommitsRequest(c.Server, repository, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetObject(ctx context.Context, repository string, ref string, params *GetObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetObjectRequest(c.Server, repository, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeadObject(ctx context.Context, repository string, ref string, params *HeadObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeadObjectRequest(c.Server, repository, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListObjects(ctx context.Context, repository string, ref string, params *ListObjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListObjectsRequest(c.Server, repository, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StatObject(ctx context.Context, repository string, ref string, params *StatObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatObjectRequest(c.Server, repository, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUnderlyingProperties(ctx context.Context, repository string, ref string, params *GetUnderlyingPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUnderlyingPropertiesRequest(c.Server, repository, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindMergeBase(ctx context.Context, repository string, sourceRef string, destinationBranch string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindMergeBaseRequest(c.Server, repository, sourceRef, destinationBranch)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeIntoBranchWithBody(ctx context.Context, repository string, sourceRef string, destinationBranch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeIntoBranchRequestWithBody(c.Server, repository, sourceRef, destinationBranch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeIntoBranch(ctx context.Context, repository string, sourceRef string, destinationBranch string, body MergeIntoBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeIntoBranchRequest(c.Server, repository, sourceRef, destinationBranch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeIntoBranchAsyncWithBody(ctx context.Context, repository string, sourceRef string, destinationBranch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeIntoBranchAsyncRequestWithBody(c.Server, repository, sourceRef, destinationBranch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeIntoBranchAsync(ctx context.Context, repository string, sourceRef string, destinationBranch string, body MergeIntoBranchAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeIntoBranchAsyncRequest(c.Server, repository, sourceRef, destinationBranch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeIntoBranchAsyncStatus(ctx context.Context, repository string, sourceRef string, destinationBranch string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeIntoBranchAsyncStatusRequest(c.Server, repository, sourceRef, destinationBranch, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreStatus(ctx context.Context, repository string, params *RestoreStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreStatusRequest(c.Server, repository, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreSubmitWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreSubmitRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreSubmit(ctx context.Context, repository string, body RestoreSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreSubmitRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBranchProtectionRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBranchProtectionRulesRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetBranchProtectionRulesWithBody(ctx context.Context, repository string, params *SetBranchProtectionRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetBranchProtectionRulesRequestWithBody(c.Server, repository, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetBranchProtectionRules(ctx context.Context, repository string, params *SetBranchProtectionRulesParams, body SetBranchProtectionRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetBranchProtectionRulesRequest(c.Server, repository, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGCRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGCRulesRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGCRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGCRulesRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetGCRulesWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetGCRulesRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetGCRules(ctx context.Context, repository string, body SetGCRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetGCRulesRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTags(ctx context.Context, repository string, params *ListTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTagsRequest(c.Server, repository, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTagWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTagRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTag(ctx context.Context, repository string, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTagRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTag(ctx context.Context, repository string, tag string, params *DeleteTagParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTagRequest(c.Server, repository, tag, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTag(ctx context.Context, repository string, tag string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTagRequest(c.Server, repository, tag)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetupCommPrefsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetupCommPrefsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetupCommPrefs(ctx context.Context, body SetupCommPrefsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetupCommPrefsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSetupState(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSetupStateRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Setup(ctx context.Context, body SetupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStatsEventsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStatsEventsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStatsEvents(ctx context.Context, body PostStatsEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStatsEventsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StsLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStsLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StsLogin(ctx context.Context, body StsLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStsLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsageReportSummary(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsageReportSummaryRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAuthCapabilitiesRequest generates requests for GetAuthCapabilities
func NewGetAuthCapabilitiesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/capabilities")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExternalPrincipalLoginRequest calls the generic ExternalPrincipalLogin builder with application/json body
func NewExternalPrincipalLoginRequest(server string, body ExternalPrincipalLoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExternalPrincipalLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewExternalPrincipalLoginRequestWithBody generates requests for ExternalPrincipalLogin with any type of body
func NewExternalPrincipalLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/external/principal/login")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetExternalPrincipalRequest generates requests for GetExternalPrincipal
func NewGetExternalPrincipalRequest(server string, params *GetExternalPrincipalParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/external/principals")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "principalId", runtime.ParamLocationQuery, params.PrincipalId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTokenFromMailboxRequest generates requests for GetTokenFromMailbox
func NewGetTokenFromMailboxRequest(server string, mailbox string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mailbox", runtime.ParamLocationPath, mailbox)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/get-token/mailboxes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReleaseTokenToMailboxRequest generates requests for ReleaseTokenToMailbox
func NewReleaseTokenToMailboxRequest(server string, loginRequestToken string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "loginRequestToken", runtime.ParamLocationPath, loginRequestToken)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/get-token/release-token/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTokenRedirectRequest generates requests for GetTokenRedirect
func NewGetTokenRedirectRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/get-token/start")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListGroupsRequest generates requests for ListGroups
func NewListGroupsRequest(server string, params *ListGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateGroupRequest calls the generic CreateGroup builder with application/json body
func NewCreateGroupRequest(server string, body CreateGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGroupRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateGroupRequestWithBody generates requests for CreateGroup with any type of body
func NewCreateGroupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGroupRequest generates requests for DeleteGroup
func NewDeleteGroupRequest(server string, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupRequest generates requests for GetGroup
func NewGetGroupRequest(server string, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupACLRequest generates requests for GetGroupACL
func NewGetGroupACLRequest(server string, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s/acl", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetGroupACLRequest calls the generic SetGroupACL builder with application/json body
func NewSetGroupACLRequest(server string, groupId string, body SetGroupACLJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetGroupACLRequestWithBody(server, groupId, "application/json", bodyReader)
}

// NewSetGroupACLRequestWithBody generates requests for SetGroupACL with any type of body
func NewSetGroupACLRequestWithBody(server string, groupId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s/acl", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListGroupMembersRequest generates requests for ListGroupMembers
func NewListGroupMembersRequest(server string, groupId string, params *ListGroupMembersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteGroupMembershipRequest generates requests for DeleteGroupMembership
func NewDeleteGroupMembershipRequest(server string, groupId string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddGroupMembershipRequest generates requests for AddGroupMembership
func NewAddGroupMembershipRequest(server string, groupId string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListGroupPoliciesRequest generates requests for ListGroupPolicies
func NewListGroupPoliciesRequest(server string, groupId string, params *ListGroupPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s/policies", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDetachPolicyFromGroupRequest generates requests for DetachPolicyFromGroup
func NewDetachPolicyFromGroupRequest(server string, groupId string, policyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s/policies/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachPolicyToGroupRequest generates requests for AttachPolicyToGroup
func NewAttachPolicyToGroupRequest(server string, groupId string, policyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s/policies/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoginRequest calls the generic Login builder with application/json body
func NewLoginRequest(server string, body LoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewLoginRequestWithBody generates requests for Login with any type of body
func NewLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/login")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPoliciesRequest generates requests for ListPolicies
func NewListPoliciesRequest(server string, params *ListPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/policies")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePolicyRequest calls the generic CreatePolicy builder with application/json body
func NewCreatePolicyRequest(server string, body CreatePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePolicyRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePolicyRequestWithBody generates requests for CreatePolicy with any type of body
func NewCreatePolicyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/policies")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePolicyRequest generates requests for DeletePolicy
func NewDeletePolicyRequest(server string, policyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPolicyRequest generates requests for GetPolicy
func NewGetPolicyRequest(server string, policyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePolicyRequest calls the generic UpdatePolicy builder with application/json body
func NewUpdatePolicyRequest(server string, policyId string, body UpdatePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePolicyRequestWithBody(server, policyId, "application/json", bodyReader)
}

// NewUpdatePolicyRequestWithBody generates requests for UpdatePolicy with any type of body
func NewUpdatePolicyRequestWithBody(server string, policyId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListUsersRequest generates requests for ListUsers
func NewListUsersRequest(server string, params *ListUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserRequest calls the generic CreateUser builder with application/json body
func NewCreateUserRequest(server string, body CreateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateUserRequestWithBody generates requests for CreateUser with any type of body
func NewCreateUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUserCredentialsRequest generates requests for ListUserCredentials
func NewListUserCredentialsRequest(server string, userId string, params *ListUserCredentialsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/credentials", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCredentialsRequest generates requests for CreateCredentials
func NewCreateCredentialsRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/credentials", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteCredentialsRequest generates requests for DeleteCredentials
func NewDeleteCredentialsRequest(server string, userId string, accessKeyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "accessKeyId", runtime.ParamLocationPath, accessKeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/credentials/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCredentialsRequest generates requests for GetCredentials
func NewGetCredentialsRequest(server string, userId string, accessKeyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "accessKeyId", runtime.ParamLocationPath, accessKeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/credentials/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteUserExternalPrincipalRequest generates requests for DeleteUserExternalPrincipal
func NewDeleteUserExternalPrincipalRequest(server string, userId string, params *DeleteUserExternalPrincipalParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/external/principals", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "principalId", runtime.ParamLocationQuery, params.PrincipalId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserExternalPrincipalRequest calls the generic CreateUserExternalPrincipal builder with application/json body
func NewCreateUserExternalPrincipalRequest(server string, userId string, params *CreateUserExternalPrincipalParams, body CreateUserExternalPrincipalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserExternalPrincipalRequestWithBody(server, userId, params, "application/json", bodyReader)
}

// NewCreateUserExternalPrincipalRequestWithBody generates requests for CreateUserExternalPrincipal with any type of body
func NewCreateUserExternalPrincipalRequestWithBody(server string, userId string, params *CreateUserExternalPrincipalParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/external/principals", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "principalId", runtime.ParamLocationQuery, params.PrincipalId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListUserExternalPrincipalsRequest generates requests for ListUserExternalPrincipals
func NewListUserExternalPrincipalsRequest(server string, userId string, params *ListUserExternalPrincipalsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/external/principals/ls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUserGroupsRequest generates requests for ListUserGroups
func NewListUserGroupsRequest(server string, userId string, params *ListUserGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUserPoliciesRequest generates requests for ListUserPolicies
func NewListUserPoliciesRequest(server string, userId string, params *ListUserPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/policies", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Effective != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective", runtime.ParamLocationQuery, *params.Effective); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDetachPolicyFromUserRequest generates requests for DetachPolicyFromUser
func NewDetachPolicyFromUserRequest(server string, userId string, policyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/policies/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachPolicyToUserRequest generates requests for AttachPolicyToUser
func NewAttachPolicyToUserRequest(server string, userId string, policyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/policies/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigRequest generates requests for GetConfig
func NewGetConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/config")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGarbageCollectionConfigRequest generates requests for GetGarbageCollectionConfig
func NewGetGarbageCollectionConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/config/garbage-collection")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStorageConfigRequest generates requests for GetStorageConfig
func NewGetStorageConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/config/storage")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLakeFSVersionRequest generates requests for GetLakeFSVersion
func NewGetLakeFSVersionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/config/version")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHealthCheckRequest generates requests for HealthCheck
func NewHealthCheckRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/healthcheck")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPullIcebergTableRequest calls the generic PullIcebergTable builder with application/json body
func NewPullIcebergTableRequest(server string, catalog string, body PullIcebergTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPullIcebergTableRequestWithBody(server, catalog, "application/json", bodyReader)
}

// NewPullIcebergTableRequestWithBody generates requests for PullIcebergTable with any type of body
func NewPullIcebergTableRequestWithBody(server string, catalog string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "catalog", runtime.ParamLocationPath, catalog)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iceberg/remotes/%s/pull", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPushIcebergTableRequest calls the generic PushIcebergTable builder with application/json body
func NewPushIcebergTableRequest(server string, catalog string, body PushIcebergTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPushIcebergTableRequestWithBody(server, catalog, "application/json", bodyReader)
}

// NewPushIcebergTableRequestWithBody generates requests for PushIcebergTable with any type of body
func NewPushIcebergTableRequestWithBody(server string, catalog string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "catalog", runtime.ParamLocationPath, catalog)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iceberg/remotes/%s/push", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLicenseRequest generates requests for GetLicense
func NewGetLicenseRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/license")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthCallbackRequest generates requests for OauthCallback
func NewOauthCallbackRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oidc/callback")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRepositoriesRequest generates requests for ListRepositories
func NewListRepositoriesRequest(server string, params *ListRepositoriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Search != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRepositoryRequest calls the generic CreateRepository builder with application/json body
func NewCreateRepositoryRequest(server string, params *CreateRepositoryParams, body CreateRepositoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRepositoryRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateRepositoryRequestWithBody generates requests for CreateRepository with any type of body
func NewCreateRepositoryRequestWithBody(server string, params *CreateRepositoryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Bare != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bare", runtime.ParamLocationQuery, *params.Bare); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRepositoryRequest generates requests for DeleteRepository
func NewDeleteRepositoryRequest(server string, repository string, params *DeleteRepositoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRepositoryRequest generates requests for GetRepository
func NewGetRepositoryRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRepositoryRunsRequest generates requests for ListRepositoryRuns
func NewListRepositoryRunsRequest(server string, repository string, params *ListRepositoryRunsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/actions/runs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Branch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "branch", runtime.ParamLocationQuery, *params.Branch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Commit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "commit", runtime.ParamLocationQuery, *params.Commit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRunRequest generates requests for GetRun
func NewGetRunRequest(server string, repository string, runId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/actions/runs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRunHooksRequest generates requests for ListRunHooks
func NewListRunHooksRequest(server string, repository string, runId string, params *ListRunHooksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/actions/runs/%s/hooks", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRunHookOutputRequest generates requests for GetRunHookOutput
func NewGetRunHookOutputRequest(server string, repository string, runId string, hookRunId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "hook_run_id", runtime.ParamLocationPath, hookRunId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/actions/runs/%s/hooks/%s/output", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalDeleteBranchProtectionRuleRequest calls the generic InternalDeleteBranchProtectionRule builder with application/json body
func NewInternalDeleteBranchProtectionRuleRequest(server string, repository string, body InternalDeleteBranchProtectionRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInternalDeleteBranchProtectionRuleRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewInternalDeleteBranchProtectionRuleRequestWithBody generates requests for InternalDeleteBranchProtectionRule with any type of body
func NewInternalDeleteBranchProtectionRuleRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branch_protection", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInternalGetBranchProtectionRulesRequest generates requests for InternalGetBranchProtectionRules
func NewInternalGetBranchProtectionRulesRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branch_protection", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalCreateBranchProtectionRuleRequest calls the generic InternalCreateBranchProtectionRule builder with application/json body
func NewInternalCreateBranchProtectionRuleRequest(server string, repository string, body InternalCreateBranchProtectionRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInternalCreateBranchProtectionRuleRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewInternalCreateBranchProtectionRuleRequestWithBody generates requests for InternalCreateBranchProtectionRule with any type of body
func NewInternalCreateBranchProtectionRuleRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branch_protection", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateBranchProtectionRulePreflightRequest generates requests for CreateBranchProtectionRulePreflight
func NewCreateBranchProtectionRulePreflightRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branch_protection/set_allowed", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBranchesRequest generates requests for ListBranches
func NewListBranchesRequest(server string, repository string, params *ListBranchesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ShowHidden != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_hidden", runtime.ParamLocationQuery, *params.ShowHidden); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBranchRequest calls the generic CreateBranch builder with application/json body
func NewCreateBranchRequest(server string, repository string, body CreateBranchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBranchRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewCreateBranchRequestWithBody generates requests for CreateBranch with any type of body
func NewCreateBranchRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBranchRequest generates requests for DeleteBranch
func NewDeleteBranchRequest(server string, repository string, branch string, params *DeleteBranchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBranchRequest generates requests for GetBranch
func NewGetBranchRequest(server string, repository string, branch string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResetBranchRequest calls the generic ResetBranch builder with application/json body
func NewResetBranchRequest(server string, repository string, branch string, body ResetBranchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResetBranchRequestWithBody(server, repository, branch, "application/json", bodyReader)
}

// NewResetBranchRequestWithBody generates requests for ResetBranch with any type of body
func NewResetBranchRequestWithBody(server string, repository string, branch string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCherryPickRequest calls the generic CherryPick builder with application/json body
func NewCherryPickRequest(server string, repository string, branch string, body CherryPickJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCherryPickRequestWithBody(server, repository, branch, "application/json", bodyReader)
}

// NewCherryPickRequestWithBody generates requests for CherryPick with any type of body
func NewCherryPickRequestWithBody(server string, repository string, branch string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/cherry-pick", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCommitRequest calls the generic Commit builder with application/json body
func NewCommitRequest(server string, repository string, branch string, params *CommitParams, body CommitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCommitRequestWithBody(server, repository, branch, params, "application/json", bodyReader)
}

// NewCommitRequestWithBody generates requests for Commit with any type of body
func NewCommitRequestWithBody(server string, repository string, branch string, params *CommitParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/commits", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.SourceMetarange != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "source_metarange", runtime.ParamLocationQuery, *params.SourceMetarange); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCommitAsyncRequest calls the generic CommitAsync builder with application/json body
func NewCommitAsyncRequest(server string, repository string, branch string, params *CommitAsyncParams, body CommitAsyncJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCommitAsyncRequestWithBody(server, repository, branch, params, "application/json", bodyReader)
}

// NewCommitAsyncRequestWithBody generates requests for CommitAsync with any type of body
func NewCommitAsyncRequestWithBody(server string, repository string, branch string, params *CommitAsyncParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/commits/async", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.SourceMetarange != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "source_metarange", runtime.ParamLocationQuery, *params.SourceMetarange); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCommitAsyncStatusRequest generates requests for CommitAsyncStatus
func NewCommitAsyncStatusRequest(server string, repository string, branch string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/commits/async/%s/status", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDiffBranchRequest generates requests for DiffBranch
func NewDiffBranchRequest(server string, repository string, branch string, params *DiffBranchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/diff", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Delimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delimiter", runtime.ParamLocationQuery, *params.Delimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHardResetBranchRequest generates requests for HardResetBranch
func NewHardResetBranchRequest(server string, repository string, branch string, params *HardResetBranchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/hard_reset", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ref", runtime.ParamLocationQuery, params.Ref); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewImportCancelRequest generates requests for ImportCancel
func NewImportCancelRequest(server string, repository string, branch string, params *ImportCancelParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/import", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewImportStatusRequest generates requests for ImportStatus
func NewImportStatusRequest(server string, repository string, branch string, params *ImportStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/import", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewImportStartRequest calls the generic ImportStart builder with application/json body
func NewImportStartRequest(server string, repository string, branch string, body ImportStartJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewImportStartRequestWithBody(server, repository, branch, "application/json", bodyReader)
}

// NewImportStartRequestWithBody generates requests for ImportStart with any type of body
func NewImportStartRequestWithBody(server string, repository string, branch string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/import", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteObjectRequest generates requests for DeleteObject
func NewDeleteObjectRequest(server string, repository string, branch string, params *DeleteObjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/objects", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NoTombstone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "no_tombstone", runtime.ParamLocationQuery, *params.NoTombstone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadObjectRequestWithBody generates requests for UploadObject with any type of body
func NewUploadObjectRequestWithBody(server string, repository string, branch string, params *UploadObjectParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/objects", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.StorageClass != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storageClass", runtime.ParamLocationQuery, *params.StorageClass); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.IfNoneMatch != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, *params.IfNoneMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-None-Match", headerParam0)
	}

	if params.IfMatch != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-Match", headerParam1)
	}

	return req, nil
}

// NewStageObjectRequest calls the generic StageObject builder with application/json body
func NewStageObjectRequest(server string, repository string, branch string, params *StageObjectParams, body StageObjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStageObjectRequestWithBody(server, repository, branch, params, "application/json", bodyReader)
}

// NewStageObjectRequestWithBody generates requests for StageObject with any type of body
func NewStageObjectRequestWithBody(server string, repository string, branch string, params *StageObjectParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/objects", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCopyObjectRequest calls the generic CopyObject builder with application/json body
func NewCopyObjectRequest(server string, repository string, branch string, params *CopyObjectParams, body CopyObjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCopyObjectRequestWithBody(server, repository, branch, params, "application/json", bodyReader)
}

// NewCopyObjectRequestWithBody generates requests for CopyObject with any type of body
func NewCopyObjectRequestWithBody(server string, repository string, branch string, params *CopyObjectParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/objects/copy", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dest_path", runtime.ParamLocationQuery, params.DestPath); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteObjectsRequest calls the generic DeleteObjects builder with application/json body
func NewDeleteObjectsRequest(server string, repository string, branch string, params *DeleteObjectsParams, body DeleteObjectsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteObjectsRequestWithBody(server, repository, branch, params, "application/json", bodyReader)
}

// NewDeleteObjectsRequestWithBody generates requests for DeleteObjects with any type of body
func NewDeleteObjectsRequestWithBody(server string, repository string, branch string, params *DeleteObjectsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/objects/delete", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NoTombstone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "no_tombstone", runtime.ParamLocationQuery, *params.NoTombstone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUploadObjectPreflightRequest generates requests for UploadObjectPreflight
func NewUploadObjectPreflightRequest(server string, repository string, branch string, params *UploadObjectPreflightParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/objects/stage_allowed", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateObjectUserMetadataRequest calls the generic UpdateObjectUserMetadata builder with application/json body
func NewUpdateObjectUserMetadataRequest(server string, repository string, branch string, params *UpdateObjectUserMetadataParams, body UpdateObjectUserMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateObjectUserMetadataRequestWithBody(server, repository, branch, params, "application/json", bodyReader)
}

// NewUpdateObjectUserMetadataRequestWithBody generates requests for UpdateObjectUserMetadata with any type of body
func NewUpdateObjectUserMetadataRequestWithBody(server string, repository string, branch string, params *UpdateObjectUserMetadataParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/objects/stat/user_metadata", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevertBranchRequest calls the generic RevertBranch builder with application/json body
func NewRevertBranchRequest(server string, repository string, branch string, body RevertBranchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevertBranchRequestWithBody(server, repository, branch, "application/json", bodyReader)
}

// NewRevertBranchRequestWithBody generates requests for RevertBranch with any type of body
func NewRevertBranchRequestWithBody(server string, repository string, branch string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/revert", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPhysicalAddressRequest generates requests for GetPhysicalAddress
func NewGetPhysicalAddressRequest(server string, repository string, branch string, params *GetPhysicalAddressParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/staging/backing", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Presign != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "presign", runtime.ParamLocationQuery, *params.Presign); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLinkPhysicalAddressRequest calls the generic LinkPhysicalAddress builder with application/json body
func NewLinkPhysicalAddressRequest(server string, repository string, branch string, params *LinkPhysicalAddressParams, body LinkPhysicalAddressJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkPhysicalAddressRequestWithBody(server, repository, branch, params, "application/json", bodyReader)
}

// NewLinkPhysicalAddressRequestWithBody generates requests for LinkPhysicalAddress with any type of body
func NewLinkPhysicalAddressRequestWithBody(server string, repository string, branch string, params *LinkPhysicalAddressParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/staging/backing", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.IfNoneMatch != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, *params.IfNoneMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-None-Match", headerParam0)
	}

	if params.IfMatch != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-Match", headerParam1)
	}

	return req, nil
}

// NewCreatePresignMultipartUploadRequest generates requests for CreatePresignMultipartUpload
func NewCreatePresignMultipartUploadRequest(server string, repository string, branch string, params *CreatePresignMultipartUploadParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/staging/pmpu", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Parts != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parts", runtime.ParamLocationQuery, *params.Parts); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAbortPresignMultipartUploadRequest calls the generic AbortPresignMultipartUpload builder with application/json body
func NewAbortPresignMultipartUploadRequest(server string, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, body AbortPresignMultipartUploadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAbortPresignMultipartUploadRequestWithBody(server, repository, branch, uploadId, params, "application/json", bodyReader)
}

// NewAbortPresignMultipartUploadRequestWithBody generates requests for AbortPresignMultipartUpload with any type of body
func NewAbortPresignMultipartUploadRequestWithBody(server string, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "uploadId", runtime.ParamLocationPath, uploadId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/staging/pmpu/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCompletePresignMultipartUploadRequest calls the generic CompletePresignMultipartUpload builder with application/json body
func NewCompletePresignMultipartUploadRequest(server string, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, body CompletePresignMultipartUploadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCompletePresignMultipartUploadRequestWithBody(server, repository, branch, uploadId, params, "application/json", bodyReader)
}

// NewCompletePresignMultipartUploadRequestWithBody generates requests for CompletePresignMultipartUpload with any type of body
func NewCompletePresignMultipartUploadRequestWithBody(server string, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "uploadId", runtime.ParamLocationPath, uploadId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/staging/pmpu/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUploadPartRequest calls the generic UploadPart builder with application/json body
func NewUploadPartRequest(server string, repository string, branch string, uploadId string, partNumber int, params *UploadPartParams, body UploadPartJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUploadPartRequestWithBody(server, repository, branch, uploadId, partNumber, params, "application/json", bodyReader)
}

// NewUploadPartRequestWithBody generates requests for UploadPart with any type of body
func NewUploadPartRequestWithBody(server string, repository string, branch string, uploadId string, partNumber int, params *UploadPartParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "uploadId", runtime.ParamLocationPath, uploadId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "partNumber", runtime.ParamLocationPath, partNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/staging/pmpu/%s/parts/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUploadPartCopyRequest calls the generic UploadPartCopy builder with application/json body
func NewUploadPartCopyRequest(server string, repository string, branch string, uploadId string, partNumber int, params *UploadPartCopyParams, body UploadPartCopyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUploadPartCopyRequestWithBody(server, repository, branch, uploadId, partNumber, params, "application/json", bodyReader)
}

// NewUploadPartCopyRequestWithBody generates requests for UploadPartCopy with any type of body
func NewUploadPartCopyRequestWithBody(server string, repository string, branch string, uploadId string, partNumber int, params *UploadPartCopyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "uploadId", runtime.ParamLocationPath, uploadId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "partNumber", runtime.ParamLocationPath, partNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/staging/pmpu/%s/parts/%s/copy", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateCommitRecordRequest calls the generic CreateCommitRecord builder with application/json body
func NewCreateCommitRecordRequest(server string, repository string, body CreateCommitRecordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCommitRecordRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewCreateCommitRecordRequestWithBody generates requests for CreateCommitRecord with any type of body
func NewCreateCommitRecordRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/commits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCommitRequest generates requests for GetCommit
func NewGetCommitRequest(server string, repository string, commitId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/commits/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDumpStatusRequest generates requests for DumpStatus
func NewDumpStatusRequest(server string, repository string, params *DumpStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/dump", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "task_id", runtime.ParamLocationQuery, params.TaskId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDumpSubmitRequest generates requests for DumpSubmit
func NewDumpSubmitRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/dump", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPrepareGarbageCollectionCommitsRequest generates requests for PrepareGarbageCollectionCommits
func NewPrepareGarbageCollectionCommitsRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/gc/prepare_commits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPrepareGarbageCollectionCommitsAsyncRequest generates requests for PrepareGarbageCollectionCommitsAsync
func NewPrepareGarbageCollectionCommitsAsyncRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/gc/prepare_commits/async", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPrepareGarbageCollectionCommitsStatusRequest generates requests for PrepareGarbageCollectionCommitsStatus
func NewPrepareGarbageCollectionCommitsStatusRequest(server string, repository string, params *PrepareGarbageCollectionCommitsStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/gc/prepare_commits/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPrepareGarbageCollectionUncommittedRequest calls the generic PrepareGarbageCollectionUncommitted builder with application/json body
func NewPrepareGarbageCollectionUncommittedRequest(server string, repository string, body PrepareGarbageCollectionUncommittedJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPrepareGarbageCollectionUncommittedRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewPrepareGarbageCollectionUncommittedRequestWithBody generates requests for PrepareGarbageCollectionUncommitted with any type of body
func NewPrepareGarbageCollectionUncommittedRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/gc/prepare_uncommited", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInternalDeleteGarbageCollectionRulesRequest generates requests for InternalDeleteGarbageCollectionRules
func NewInternalDeleteGarbageCollectionRulesRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/gc/rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalGetGarbageCollectionRulesRequest generates requests for InternalGetGarbageCollectionRules
func NewInternalGetGarbageCollectionRulesRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/gc/rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalSetGarbageCollectionRulesRequest calls the generic InternalSetGarbageCollectionRules builder with application/json body
func NewInternalSetGarbageCollectionRulesRequest(server string, repository string, body InternalSetGarbageCollectionRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInternalSetGarbageCollectionRulesRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewInternalSetGarbageCollectionRulesRequestWithBody generates requests for InternalSetGarbageCollectionRules with any type of body
func NewInternalSetGarbageCollectionRulesRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/gc/rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSetGarbageCollectionRulesPreflightRequest generates requests for SetGarbageCollectionRulesPreflight
func NewSetGarbageCollectionRulesPreflightRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/gc/rules/set_allowed", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteRepositoryMetadataRequest calls the generic DeleteRepositoryMetadata builder with application/json body
func NewDeleteRepositoryMetadataRequest(server string, repository string, body DeleteRepositoryMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteRepositoryMetadataRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewDeleteRepositoryMetadataRequestWithBody generates requests for DeleteRepositoryMetadata with any type of body
func NewDeleteRepositoryMetadataRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/metadata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRepositoryMetadataRequest generates requests for GetRepositoryMetadata
func NewGetRepositoryMetadataRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/metadata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetRepositoryMetadataRequest calls the generic SetRepositoryMetadata builder with application/json body
func NewSetRepositoryMetadataRequest(server string, repository string, body SetRepositoryMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetRepositoryMetadataRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewSetRepositoryMetadataRequestWithBody generates requests for SetRepositoryMetadata with any type of body
func NewSetRepositoryMetadataRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/metadata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMetaRangeRequest generates requests for GetMetaRange
func NewGetMetaRangeRequest(server string, repository string, metaRange string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "meta_range", runtime.ParamLocationPath, metaRange)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/metadata/meta_range/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMetadataObjectRequest generates requests for GetMetadataObject
func NewGetMetadataObjectRequest(server string, repository string, pType string, objectId string, params *GetMetadataObjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/metadata/object/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Presign != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "presign", runtime.ParamLocationQuery, *params.Presign); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRangeRequest generates requests for GetRange
func NewGetRangeRequest(server string, repository string, pRange string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "range", runtime.ParamLocationPath, pRange)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/metadata/range/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPullRequestsRequest generates requests for ListPullRequests
func NewListPullRequestsRequest(server string, repository string, params *ListPullRequestsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/pulls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Status != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePullRequestRequest calls the generic CreatePullRequest builder with application/json body
func NewCreatePullRequestRequest(server string, repository string, body CreatePullRequestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePullRequestRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewCreatePullRequestRequestWithBody generates requests for CreatePullRequest with any type of body
func NewCreatePullRequestRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/pulls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPullRequestRequest generates requests for GetPullRequest
func NewGetPullRequestRequest(server string, repository string, pullRequest string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pull_request", runtime.ParamLocationPath, pullRequest)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/pulls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePullRequestRequest calls the generic UpdatePullRequest builder with application/json body
func NewUpdatePullRequestRequest(server string, repository string, pullRequest string, body UpdatePullRequestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePullRequestRequestWithBody(server, repository, pullRequest, "application/json", bodyReader)
}

// NewUpdatePullRequestRequestWithBody generates requests for UpdatePullRequest with any type of body
func NewUpdatePullRequestRequestWithBody(server string, repository string, pullRequest string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pull_request", runtime.ParamLocationPath, pullRequest)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/pulls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergePullRequestRequest generates requests for MergePullRequest
func NewMergePullRequestRequest(server string, repository string, pullRequest string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pull_request", runtime.ParamLocationPath, pullRequest)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/pulls/%s/merge", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDumpRefsRequest generates requests for DumpRefs
func NewDumpRefsRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/dump", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreRefsRequest calls the generic RestoreRefs builder with application/json body
func NewRestoreRefsRequest(server string, repository string, body RestoreRefsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRestoreRefsRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewRestoreRefsRequestWithBody generates requests for RestoreRefs with any type of body
func NewRestoreRefsRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/restore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateSymlinkFileRequest generates requests for CreateSymlinkFile
func NewCreateSymlinkFileRequest(server string, repository string, branch string, params *CreateSymlinkFileParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/symlink", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Location != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "location", runtime.ParamLocationQuery, *params.Location); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDiffRefsRequest generates requests for DiffRefs
func NewDiffRefsRequest(server string, repository string, leftRef string, rightRef string, params *DiffRefsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "leftRef", runtime.ParamLocationPath, leftRef)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "rightRef", runtime.ParamLocationPath, rightRef)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/diff/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Delimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delimiter", runtime.ParamLocationQuery, *params.Delimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeRightStats != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_right_stats", runtime.ParamLocationQuery, *params.IncludeRightStats); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLogCommitsRequest generates requests for LogCommits
func NewLogCommitsRequest(server string, repository string, ref string, params *LogCommitsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/commits", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Objects != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "objects", runtime.ParamLocationQuery, *params.Objects); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Prefixes != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefixes", runtime.ParamLocationQuery, *params.Prefixes); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FirstParent != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first_parent", runtime.ParamLocationQuery, *params.FirstParent); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Since != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StopAt != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stop_at", runtime.ParamLocationQuery, *params.StopAt); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetObjectRequest generates requests for GetObject
func NewGetObjectRequest(server string, repository string, ref string, params *GetObjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/objects", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Presign != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "presign", runtime.ParamLocationQuery, *params.Presign); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.Range != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Range", runtime.ParamLocationHeader, *params.Range)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Range", headerParam0)
	}

	if params.IfNoneMatch != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, *params.IfNoneMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-None-Match", headerParam1)
	}

	return req, nil
}

// NewHeadObjectRequest generates requests for HeadObject
func NewHeadObjectRequest(server string, repository string, ref string, params *HeadObjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/objects", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.Range != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Range", runtime.ParamLocationHeader, *params.Range)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Range", headerParam0)
	}

	return req, nil
}

// NewListObjectsRequest generates requests for ListObjects
func NewListObjectsRequest(server string, repository string, ref string, params *ListObjectsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/objects/ls", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.UserMetadata != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_metadata", runtime.ParamLocationQuery, *params.UserMetadata); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Presign != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "presign", runtime.ParamLocationQuery, *params.Presign); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Delimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delimiter", runtime.ParamLocationQuery, *params.Delimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStatObjectRequest generates requests for StatObject
func NewStatObjectRequest(server string, repository string, ref string, params *StatObjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/objects/stat", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.UserMetadata != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_metadata", runtime.ParamLocationQuery, *params.UserMetadata); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Presign != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "presign", runtime.ParamLocationQuery, *params.Presign); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUnderlyingPropertiesRequest generates requests for GetUnderlyingProperties
func NewGetUnderlyingPropertiesRequest(server string, repository string, ref string, params *GetUnderlyingPropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/objects/underlyingProperties", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindMergeBaseRequest generates requests for FindMergeBase
func NewFindMergeBaseRequest(server string, repository string, sourceRef string, destinationBranch string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sourceRef", runtime.ParamLocationPath, sourceRef)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "destinationBranch", runtime.ParamLocationPath, destinationBranch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/merge/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMergeIntoBranchRequest calls the generic MergeIntoBranch builder with application/json body
func NewMergeIntoBranchRequest(server string, repository string, sourceRef string, destinationBranch string, body MergeIntoBranchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeIntoBranchRequestWithBody(server, repository, sourceRef, destinationBranch, "application/json", bodyReader)
}

// NewMergeIntoBranchRequestWithBody generates requests for MergeIntoBranch with any type of body
func NewMergeIntoBranchRequestWithBody(server string, repository string, sourceRef string, destinationBranch string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sourceRef", runtime.ParamLocationPath, sourceRef)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "destinationBranch", runtime.ParamLocationPath, destinationBranch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/merge/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergeIntoBranchAsyncRequest calls the generic MergeIntoBranchAsync builder with application/json body
func NewMergeIntoBranchAsyncRequest(server string, repository string, sourceRef string, destinationBranch string, body MergeIntoBranchAsyncJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeIntoBranchAsyncRequestWithBody(server, repository, sourceRef, destinationBranch, "application/json", bodyReader)
}

// NewMergeIntoBranchAsyncRequestWithBody generates requests for MergeIntoBranchAsync with any type of body
func NewMergeIntoBranchAsyncRequestWithBody(server string, repository string, sourceRef string, destinationBranch string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sourceRef", runtime.ParamLocationPath, sourceRef)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "destinationBranch", runtime.ParamLocationPath, destinationBranch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/merge/%s/async", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergeIntoBranchAsyncStatusRequest generates requests for MergeIntoBranchAsyncStatus
func NewMergeIntoBranchAsyncStatusRequest(server string, repository string, sourceRef string, destinationBranch string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sourceRef", runtime.ParamLocationPath, sourceRef)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "destinationBranch", runtime.ParamLocationPath, destinationBranch)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/merge/%s/async/%s/status", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreStatusRequest generates requests for RestoreStatus
func NewRestoreStatusRequest(server string, repository string, params *RestoreStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/restore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "task_id", runtime.ParamLocationQuery, params.TaskId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreSubmitRequest calls the generic RestoreSubmit builder with application/json body
func NewRestoreSubmitRequest(server string, repository string, body RestoreSubmitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRestoreSubmitRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewRestoreSubmitRequestWithBody generates requests for RestoreSubmit with any type of body
func NewRestoreSubmitRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/restore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBranchProtectionRulesRequest generates requests for GetBranchProtectionRules
func NewGetBranchProtectionRulesRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/settings/branch_protection", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetBranchProtectionRulesRequest calls the generic SetBranchProtectionRules builder with application/json body
func NewSetBranchProtectionRulesRequest(server string, repository string, params *SetBranchProtectionRulesParams, body SetBranchProtectionRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetBranchProtectionRulesRequestWithBody(server, repository, params, "application/json", bodyReader)
}

// NewSetBranchProtectionRulesRequestWithBody generates requests for SetBranchProtectionRules with any type of body
func NewSetBranchProtectionRulesRequestWithBody(server string, repository string, params *SetBranchProtectionRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/settings/branch_protection", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.IfMatch != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-Match", headerParam0)
	}

	return req, nil
}

// NewDeleteGCRulesRequest generates requests for DeleteGCRules
func NewDeleteGCRulesRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/settings/gc_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGCRulesRequest generates requests for GetGCRules
func NewGetGCRulesRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/settings/gc_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetGCRulesRequest calls the generic SetGCRules builder with application/json body
func NewSetGCRulesRequest(server string, repository string, body SetGCRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetGCRulesRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewSetGCRulesRequestWithBody generates requests for SetGCRules with any type of body
func NewSetGCRulesRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/settings/gc_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListTagsRequest generates requests for ListTags
func NewListTagsRequest(server string, repository string, params *ListTagsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTagRequest calls the generic CreateTag builder with application/json body
func NewCreateTagRequest(server string, repository string, body CreateTagJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTagRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewCreateTagRequestWithBody generates requests for CreateTag with any type of body
func NewCreateTagRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTagRequest generates requests for DeleteTag
func NewDeleteTagRequest(server string, repository string, tag string, params *DeleteTagParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tag", runtime.ParamLocationPath, tag)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/tags/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTagRequest generates requests for GetTag
func NewGetTagRequest(server string, repository string, tag string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tag", runtime.ParamLocationPath, tag)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/tags/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetupCommPrefsRequest calls the generic SetupCommPrefs builder with application/json body
func NewSetupCommPrefsRequest(server string, body SetupCommPrefsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetupCommPrefsRequestWithBody(server, "application/json", bodyReader)
}

// NewSetupCommPrefsRequestWithBody generates requests for SetupCommPrefs with any type of body
func NewSetupCommPrefsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setup_comm_prefs")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSetupStateRequest generates requests for GetSetupState
func NewGetSetupStateRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setup_lakefs")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetupRequest calls the generic Setup builder with application/json body
func NewSetupRequest(server string, body SetupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetupRequestWithBody(server, "application/json", bodyReader)
}

// NewSetupRequestWithBody generates requests for Setup with any type of body
func NewSetupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setup_lakefs")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostStatsEventsRequest calls the generic PostStatsEvents builder with application/json body
func NewPostStatsEventsRequest(server string, body PostStatsEventsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostStatsEventsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostStatsEventsRequestWithBody generates requests for PostStatsEvents with any type of body
func NewPostStatsEventsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/statistics")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStsLoginRequest calls the generic StsLogin builder with application/json body
func NewStsLoginRequest(server string, body StsLoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStsLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewStsLoginRequestWithBody generates requests for StsLogin with any type of body
func NewStsLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sts/login")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUsageReportSummaryRequest generates requests for GetUsageReportSummary
func NewGetUsageReportSummaryRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/usage-report/summary")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrentUserRequest generates requests for GetCurrentUser
func NewGetCurrentUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAuthCapabilities request
	GetAuthCapabilitiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAuthCapabilitiesResponse, error)

	// ExternalPrincipalLogin request  with any body
	ExternalPrincipalLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExternalPrincipalLoginResponse, error)

	ExternalPrincipalLoginWithResponse(ctx context.Context, body ExternalPrincipalLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*ExternalPrincipalLoginResponse, error)

	// GetExternalPrincipal request
	GetExternalPrincipalWithResponse(ctx context.Context, params *GetExternalPrincipalParams, reqEditors ...RequestEditorFn) (*GetExternalPrincipalResponse, error)

	// GetTokenFromMailbox request
	GetTokenFromMailboxWithResponse(ctx context.Context, mailbox string, reqEditors ...RequestEditorFn) (*GetTokenFromMailboxResponse, error)

	// ReleaseTokenToMailbox request
	ReleaseTokenToMailboxWithResponse(ctx context.Context, loginRequestToken string, reqEditors ...RequestEditorFn) (*ReleaseTokenToMailboxResponse, error)

	// GetTokenRedirect request
	GetTokenRedirectWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTokenRedirectResponse, error)

	// ListGroups request
	ListGroupsWithResponse(ctx context.Context, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*ListGroupsResponse, error)

	// CreateGroup request  with any body
	CreateGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	CreateGroupWithResponse(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	// DeleteGroup request
	DeleteGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error)

	// GetGroup request
	GetGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*GetGroupResponse, error)

	// GetGroupACL request
	GetGroupACLWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*GetGroupACLResponse, error)

	// SetGroupACL request  with any body
	SetGroupACLWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetGroupACLResponse, error)

	SetGroupACLWithResponse(ctx context.Context, groupId string, body SetGroupACLJSONRequestBody, reqEditors ...RequestEditorFn) (*SetGroupACLResponse, error)

	// ListGroupMembers request
	ListGroupMembersWithResponse(ctx context.Context, groupId string, params *ListGroupMembersParams, reqEditors ...RequestEditorFn) (*ListGroupMembersResponse, error)

	// DeleteGroupMembership request
	DeleteGroupMembershipWithResponse(ctx context.Context, groupId string, userId string, reqEditors ...RequestEditorFn) (*DeleteGroupMembershipResponse, error)

	// AddGroupMembership request
	AddGroupMembershipWithResponse(ctx context.Context, groupId string, userId string, reqEditors ...RequestEditorFn) (*AddGroupMembershipResponse, error)

	// ListGroupPolicies request
	ListGroupPoliciesWithResponse(ctx context.Context, groupId string, params *ListGroupPoliciesParams, reqEditors ...RequestEditorFn) (*ListGroupPoliciesResponse, error)

	// DetachPolicyFromGroup request
	DetachPolicyFromGroupWithResponse(ctx context.Context, groupId string, policyId string, reqEditors ...RequestEditorFn) (*DetachPolicyFromGroupResponse, error)

	// AttachPolicyToGroup request
	AttachPolicyToGroupWithResponse(ctx context.Context, groupId string, policyId string, reqEditors ...RequestEditorFn) (*AttachPolicyToGroupResponse, error)

	// Login request  with any body
	LoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	LoginWithResponse(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	// ListPolicies request
	ListPoliciesWithResponse(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*ListPoliciesResponse, error)

	// CreatePolicy request  with any body
	CreatePolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error)

	CreatePolicyWithResponse(ctx context.Context, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error)

	// DeletePolicy request
	DeletePolicyWithResponse(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*DeletePolicyResponse, error)

	// GetPolicy request
	GetPolicyWithResponse(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*GetPolicyResponse, error)

	// UpdatePolicy request  with any body
	UpdatePolicyWithBodyWithResponse(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error)

	UpdatePolicyWithResponse(ctx context.Context, policyId string, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error)

	// ListUsers request
	ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error)

	// CreateUser request  with any body
	CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	// DeleteUser request
	DeleteUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// GetUser request
	GetUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// ListUserCredentials request
	ListUserCredentialsWithResponse(ctx context.Context, userId string, params *ListUserCredentialsParams, reqEditors ...RequestEditorFn) (*ListUserCredentialsResponse, error)

	// CreateCredentials request
	CreateCredentialsWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*CreateCredentialsResponse, error)

	// DeleteCredentials request
	DeleteCredentialsWithResponse(ctx context.Context, userId string, accessKeyId string, reqEditors ...RequestEditorFn) (*DeleteCredentialsResponse, error)

	// GetCredentials request
	GetCredentialsWithResponse(ctx context.Context, userId string, accessKeyId string, reqEditors ...RequestEditorFn) (*GetCredentialsResponse, error)

	// DeleteUserExternalPrincipal request
	DeleteUserExternalPrincipalWithResponse(ctx context.Context, userId string, params *DeleteUserExternalPrincipalParams, reqEditors ...RequestEditorFn) (*DeleteUserExternalPrincipalResponse, error)

	// CreateUserExternalPrincipal request  with any body
	CreateUserExternalPrincipalWithBodyWithResponse(ctx context.Context, userId string, params *CreateUserExternalPrincipalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserExternalPrincipalResponse, error)

	CreateUserExternalPrincipalWithResponse(ctx context.Context, userId string, params *CreateUserExternalPrincipalParams, body CreateUserExternalPrincipalJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserExternalPrincipalResponse, error)

	// ListUserExternalPrincipals request
	ListUserExternalPrincipalsWithResponse(ctx context.Context, userId string, params *ListUserExternalPrincipalsParams, reqEditors ...RequestEditorFn) (*ListUserExternalPrincipalsResponse, error)

	// ListUserGroups request
	ListUserGroupsWithResponse(ctx context.Context, userId string, params *ListUserGroupsParams, reqEditors ...RequestEditorFn) (*ListUserGroupsResponse, error)

	// ListUserPolicies request
	ListUserPoliciesWithResponse(ctx context.Context, userId string, params *ListUserPoliciesParams, reqEditors ...RequestEditorFn) (*ListUserPoliciesResponse, error)

	// DetachPolicyFromUser request
	DetachPolicyFromUserWithResponse(ctx context.Context, userId string, policyId string, reqEditors ...RequestEditorFn) (*DetachPolicyFromUserResponse, error)

	// AttachPolicyToUser request
	AttachPolicyToUserWithResponse(ctx context.Context, userId string, policyId string, reqEditors ...RequestEditorFn) (*AttachPolicyToUserResponse, error)

	// GetConfig request
	GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigResponse, error)

	// GetGarbageCollectionConfig request
	GetGarbageCollectionConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGarbageCollectionConfigResponse, error)

	// GetStorageConfig request
	GetStorageConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStorageConfigResponse, error)

	// GetLakeFSVersion request
	GetLakeFSVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLakeFSVersionResponse, error)

	// HealthCheck request
	HealthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error)

	// PullIcebergTable request  with any body
	PullIcebergTableWithBodyWithResponse(ctx context.Context, catalog string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PullIcebergTableResponse, error)

	PullIcebergTableWithResponse(ctx context.Context, catalog string, body PullIcebergTableJSONRequestBody, reqEditors ...RequestEditorFn) (*PullIcebergTableResponse, error)

	// PushIcebergTable request  with any body
	PushIcebergTableWithBodyWithResponse(ctx context.Context, catalog string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PushIcebergTableResponse, error)

	PushIcebergTableWithResponse(ctx context.Context, catalog string, body PushIcebergTableJSONRequestBody, reqEditors ...RequestEditorFn) (*PushIcebergTableResponse, error)

	// GetLicense request
	GetLicenseWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLicenseResponse, error)

	// OauthCallback request
	OauthCallbackWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*OauthCallbackResponse, error)

	// ListRepositories request
	ListRepositoriesWithResponse(ctx context.Context, params *ListRepositoriesParams, reqEditors ...RequestEditorFn) (*ListRepositoriesResponse, error)

	// CreateRepository request  with any body
	CreateRepositoryWithBodyWithResponse(ctx context.Context, params *CreateRepositoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRepositoryResponse, error)

	CreateRepositoryWithResponse(ctx context.Context, params *CreateRepositoryParams, body CreateRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRepositoryResponse, error)

	// DeleteRepository request
	DeleteRepositoryWithResponse(ctx context.Context, repository string, params *DeleteRepositoryParams, reqEditors ...RequestEditorFn) (*DeleteRepositoryResponse, error)

	// GetRepository request
	GetRepositoryWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*GetRepositoryResponse, error)

	// ListRepositoryRuns request
	ListRepositoryRunsWithResponse(ctx context.Context, repository string, params *ListRepositoryRunsParams, reqEditors ...RequestEditorFn) (*ListRepositoryRunsResponse, error)

	// GetRun request
	GetRunWithResponse(ctx context.Context, repository string, runId string, reqEditors ...RequestEditorFn) (*GetRunResponse, error)

	// ListRunHooks request
	ListRunHooksWithResponse(ctx context.Context, repository string, runId string, params *ListRunHooksParams, reqEditors ...RequestEditorFn) (*ListRunHooksResponse, error)

	// GetRunHookOutput request
	GetRunHookOutputWithResponse(ctx context.Context, repository string, runId string, hookRunId string, reqEditors ...RequestEditorFn) (*GetRunHookOutputResponse, error)

	// InternalDeleteBranchProtectionRule request  with any body
	InternalDeleteBranchProtectionRuleWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalDeleteBranchProtectionRuleResponse, error)

	InternalDeleteBranchProtectionRuleWithResponse(ctx context.Context, repository string, body InternalDeleteBranchProtectionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalDeleteBranchProtectionRuleResponse, error)

	// InternalGetBranchProtectionRules request
	InternalGetBranchProtectionRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*InternalGetBranchProtectionRulesResponse, error)

	// InternalCreateBranchProtectionRule request  with any body
	InternalCreateBranchProtectionRuleWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalCreateBranchProtectionRuleResponse, error)

	InternalCreateBranchProtectionRuleWithResponse(ctx context.Context, repository string, body InternalCreateBranchProtectionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalCreateBranchProtectionRuleResponse, error)

	// CreateBranchProtectionRulePreflight request
	CreateBranchProtectionRulePreflightWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*CreateBranchProtectionRulePreflightResponse, error)

	// ListBranches request
	ListBranchesWithResponse(ctx context.Context, repository string, params *ListBranchesParams, reqEditors ...RequestEditorFn) (*ListBranchesResponse, error)

	// CreateBranch request  with any body
	CreateBranchWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBranchResponse, error)

	CreateBranchWithResponse(ctx context.Context, repository string, body CreateBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBranchResponse, error)

	// DeleteBranch request
	DeleteBranchWithResponse(ctx context.Context, repository string, branch string, params *DeleteBranchParams, reqEditors ...RequestEditorFn) (*DeleteBranchResponse, error)

	// GetBranch request
	GetBranchWithResponse(ctx context.Context, repository string, branch string, reqEditors ...RequestEditorFn) (*GetBranchResponse, error)

	// ResetBranch request  with any body
	ResetBranchWithBodyWithResponse(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetBranchResponse, error)

	ResetBranchWithResponse(ctx context.Context, repository string, branch string, body ResetBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetBranchResponse, error)

	// CherryPick request  with any body
	CherryPickWithBodyWithResponse(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CherryPickResponse, error)

	CherryPickWithResponse(ctx context.Context, repository string, branch string, body CherryPickJSONRequestBody, reqEditors ...RequestEditorFn) (*CherryPickResponse, error)

	// Commit request  with any body
	CommitWithBodyWithResponse(ctx context.Context, repository string, branch string, params *CommitParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommitResponse, error)

	CommitWithResponse(ctx context.Context, repository string, branch string, params *CommitParams, body CommitJSONRequestBody, reqEditors ...RequestEditorFn) (*CommitResponse, error)

	// CommitAsync request  with any body
	CommitAsyncWithBodyWithResponse(ctx context.Context, repository string, branch string, params *CommitAsyncParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommitAsyncResponse, error)

	CommitAsyncWithResponse(ctx context.Context, repository string, branch string, params *CommitAsyncParams, body CommitAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*CommitAsyncResponse, error)

	// CommitAsyncStatus request
	CommitAsyncStatusWithResponse(ctx context.Context, repository string, branch string, id string, reqEditors ...RequestEditorFn) (*CommitAsyncStatusResponse, error)

	// DiffBranch request
	DiffBranchWithResponse(ctx context.Context, repository string, branch string, params *DiffBranchParams, reqEditors ...RequestEditorFn) (*DiffBranchResponse, error)

	// HardResetBranch request
	HardResetBranchWithResponse(ctx context.Context, repository string, branch string, params *HardResetBranchParams, reqEditors ...RequestEditorFn) (*HardResetBranchResponse, error)

	// ImportCancel request
	ImportCancelWithResponse(ctx context.Context, repository string, branch string, params *ImportCancelParams, reqEditors ...RequestEditorFn) (*ImportCancelResponse, error)

	// ImportStatus request
	ImportStatusWithResponse(ctx context.Context, repository string, branch string, params *ImportStatusParams, reqEditors ...RequestEditorFn) (*ImportStatusResponse, error)

	// ImportStart request  with any body
	ImportStartWithBodyWithResponse(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportStartResponse, error)

	ImportStartWithResponse(ctx context.Context, repository string, branch string, body ImportStartJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportStartResponse, error)

	// DeleteObject request
	DeleteObjectWithResponse(ctx context.Context, repository string, branch string, params *DeleteObjectParams, reqEditors ...RequestEditorFn) (*DeleteObjectResponse, error)

	// UploadObject request  with any body
	UploadObjectWithBodyWithResponse(ctx context.Context, repository string, branch string, params *UploadObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadObjectResponse, error)

	// StageObject request  with any body
	StageObjectWithBodyWithResponse(ctx context.Context, repository string, branch string, params *StageObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StageObjectResponse, error)

	StageObjectWithResponse(ctx context.Context, repository string, branch string, params *StageObjectParams, body StageObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*StageObjectResponse, error)

	// CopyObject request  with any body
	CopyObjectWithBodyWithResponse(ctx context.Context, repository string, branch string, params *CopyObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CopyObjectResponse, error)

	CopyObjectWithResponse(ctx context.Context, repository string, branch string, params *CopyObjectParams, body CopyObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CopyObjectResponse, error)

	// DeleteObjects request  with any body
	DeleteObjectsWithBodyWithResponse(ctx context.Context, repository string, branch string, params *DeleteObjectsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteObjectsResponse, error)

	DeleteObjectsWithResponse(ctx context.Context, repository string, branch string, params *DeleteObjectsParams, body DeleteObjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteObjectsResponse, error)

	// UploadObjectPreflight request
	UploadObjectPreflightWithResponse(ctx context.Context, repository string, branch string, params *UploadObjectPreflightParams, reqEditors ...RequestEditorFn) (*UploadObjectPreflightResponse, error)

	// UpdateObjectUserMetadata request  with any body
	UpdateObjectUserMetadataWithBodyWithResponse(ctx context.Context, repository string, branch string, params *UpdateObjectUserMetadataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateObjectUserMetadataResponse, error)

	UpdateObjectUserMetadataWithResponse(ctx context.Context, repository string, branch string, params *UpdateObjectUserMetadataParams, body UpdateObjectUserMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateObjectUserMetadataResponse, error)

	// RevertBranch request  with any body
	RevertBranchWithBodyWithResponse(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevertBranchResponse, error)

	RevertBranchWithResponse(ctx context.Context, repository string, branch string, body RevertBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*RevertBranchResponse, error)

	// GetPhysicalAddress request
	GetPhysicalAddressWithResponse(ctx context.Context, repository string, branch string, params *GetPhysicalAddressParams, reqEditors ...RequestEditorFn) (*GetPhysicalAddressResponse, error)

	// LinkPhysicalAddress request  with any body
	LinkPhysicalAddressWithBodyWithResponse(ctx context.Context, repository string, branch string, params *LinkPhysicalAddressParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkPhysicalAddressResponse, error)

	LinkPhysicalAddressWithResponse(ctx context.Context, repository string, branch string, params *LinkPhysicalAddressParams, body LinkPhysicalAddressJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkPhysicalAddressResponse, error)

	// CreatePresignMultipartUpload request
	CreatePresignMultipartUploadWithResponse(ctx context.Context, repository string, branch string, params *CreatePresignMultipartUploadParams, reqEditors ...RequestEditorFn) (*CreatePresignMultipartUploadResponse, error)

	// AbortPresignMultipartUpload request  with any body
	AbortPresignMultipartUploadWithBodyWithResponse(ctx context.Context, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AbortPresignMultipartUploadResponse, error)

	AbortPresignMultipartUploadWithResponse(ctx context.Context, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, body AbortPresignMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*AbortPresignMultipartUploadResponse, error)

	// CompletePresignMultipartUpload request  with any body
	CompletePresignMultipartUploadWithBodyWithResponse(ctx context.Context, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompletePresignMultipartUploadResponse, error)

	CompletePresignMultipartUploadWithResponse(ctx context.Context, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, body CompletePresignMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*CompletePresignMultipartUploadResponse, error)

	// UploadPart request  with any body
	UploadPartWithBodyWithResponse(ctx context.Context, repository string, branch string, uploadId string, partNumber int, params *UploadPartParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadPartResponse, error)

	UploadPartWithResponse(ctx context.Context, repository string, branch string, uploadId string, partNumber int, params *UploadPartParams, body UploadPartJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadPartResponse, error)

	// UploadPartCopy request  with any body
	UploadPartCopyWithBodyWithResponse(ctx context.Context, repository string, branch string, uploadId string, partNumber int, params *UploadPartCopyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadPartCopyResponse, error)

	UploadPartCopyWithResponse(ctx context.Context, repository string, branch string, uploadId string, partNumber int, params *UploadPartCopyParams, body UploadPartCopyJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadPartCopyResponse, error)

	// CreateCommitRecord request  with any body
	CreateCommitRecordWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCommitRecordResponse, error)

	CreateCommitRecordWithResponse(ctx context.Context, repository string, body CreateCommitRecordJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCommitRecordResponse, error)

	// GetCommit request
	GetCommitWithResponse(ctx context.Context, repository string, commitId string, reqEditors ...RequestEditorFn) (*GetCommitResponse, error)

	// DumpStatus request
	DumpStatusWithResponse(ctx context.Context, repository string, params *DumpStatusParams, reqEditors ...RequestEditorFn) (*DumpStatusResponse, error)

	// DumpSubmit request
	DumpSubmitWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*DumpSubmitResponse, error)

	// PrepareGarbageCollectionCommits request
	PrepareGarbageCollectionCommitsWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*PrepareGarbageCollectionCommitsResponse, error)

	// PrepareGarbageCollectionCommitsAsync request
	PrepareGarbageCollectionCommitsAsyncWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*PrepareGarbageCollectionCommitsAsyncResponse, error)

	// PrepareGarbageCollectionCommitsStatus request
	PrepareGarbageCollectionCommitsStatusWithResponse(ctx context.Context, repository string, params *PrepareGarbageCollectionCommitsStatusParams, reqEditors ...RequestEditorFn) (*PrepareGarbageCollectionCommitsStatusResponse, error)

	// PrepareGarbageCollectionUncommitted request  with any body
	PrepareGarbageCollectionUncommittedWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrepareGarbageCollectionUncommittedResponse, error)

	PrepareGarbageCollectionUncommittedWithResponse(ctx context.Context, repository string, body PrepareGarbageCollectionUncommittedJSONRequestBody, reqEditors ...RequestEditorFn) (*PrepareGarbageCollectionUncommittedResponse, error)

	// InternalDeleteGarbageCollectionRules request
	InternalDeleteGarbageCollectionRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*InternalDeleteGarbageCollectionRulesResponse, error)

	// InternalGetGarbageCollectionRules request
	InternalGetGarbageCollectionRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*InternalGetGarbageCollectionRulesResponse, error)

	// InternalSetGarbageCollectionRules request  with any body
	InternalSetGarbageCollectionRulesWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalSetGarbageCollectionRulesResponse, error)

	InternalSetGarbageCollectionRulesWithResponse(ctx context.Context, repository string, body InternalSetGarbageCollectionRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalSetGarbageCollectionRulesResponse, error)

	// SetGarbageCollectionRulesPreflight request
	SetGarbageCollectionRulesPreflightWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*SetGarbageCollectionRulesPreflightResponse, error)

	// DeleteRepositoryMetadata request  with any body
	DeleteRepositoryMetadataWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteRepositoryMetadataResponse, error)

	DeleteRepositoryMetadataWithResponse(ctx context.Context, repository string, body DeleteRepositoryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteRepositoryMetadataResponse, error)

	// GetRepositoryMetadata request
	GetRepositoryMetadataWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*GetRepositoryMetadataResponse, error)

	// SetRepositoryMetadata request  with any body
	SetRepositoryMetadataWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetRepositoryMetadataResponse, error)

	SetRepositoryMetadataWithResponse(ctx context.Context, repository string, body SetRepositoryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*SetRepositoryMetadataResponse, error)

	// GetMetaRange request
	GetMetaRangeWithResponse(ctx context.Context, repository string, metaRange string, reqEditors ...RequestEditorFn) (*GetMetaRangeResponse, error)

	// GetMetadataObject request
	GetMetadataObjectWithResponse(ctx context.Context, repository string, pType string, objectId string, params *GetMetadataObjectParams, reqEditors ...RequestEditorFn) (*GetMetadataObjectResponse, error)

	// GetRange request
	GetRangeWithResponse(ctx context.Context, repository string, pRange string, reqEditors ...RequestEditorFn) (*GetRangeResponse, error)

	// ListPullRequests request
	ListPullRequestsWithResponse(ctx context.Context, repository string, params *ListPullRequestsParams, reqEditors ...RequestEditorFn) (*ListPullRequestsResponse, error)

	// CreatePullRequest request  with any body
	CreatePullRequestWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePullRequestResponse, error)

	CreatePullRequestWithResponse(ctx context.Context, repository string, body CreatePullRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePullRequestResponse, error)

	// GetPullRequest request
	GetPullRequestWithResponse(ctx context.Context, repository string, pullRequest string, reqEditors ...RequestEditorFn) (*GetPullRequestResponse, error)

	// UpdatePullRequest request  with any body
	UpdatePullRequestWithBodyWithResponse(ctx context.Context, repository string, pullRequest string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePullRequestResponse, error)

	UpdatePullRequestWithResponse(ctx context.Context, repository string, pullRequest string, body UpdatePullRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePullRequestResponse, error)

	// MergePullRequest request
	MergePullRequestWithResponse(ctx context.Context, repository string, pullRequest string, reqEditors ...RequestEditorFn) (*MergePullRequestResponse, error)

	// DumpRefs request
	DumpRefsWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*DumpRefsResponse, error)

	// RestoreRefs request  with any body
	RestoreRefsWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestoreRefsResponse, error)

	RestoreRefsWithResponse(ctx context.Context, repository string, body RestoreRefsJSONRequestBody, reqEditors ...RequestEditorFn) (*RestoreRefsResponse, error)

	// CreateSymlinkFile request
	CreateSymlinkFileWithResponse(ctx context.Context, repository string, branch string, params *CreateSymlinkFileParams, reqEditors ...RequestEditorFn) (*CreateSymlinkFileResponse, error)

	// DiffRefs request
	DiffRefsWithResponse(ctx context.Context, repository string, leftRef string, rightRef string, params *DiffRefsParams, reqEditors ...RequestEditorFn) (*DiffRefsResponse, error)

	// LogCommits request
	LogCommitsWithResponse(ctx context.Context, repository string, ref string, params *LogCommitsParams, reqEditors ...RequestEditorFn) (*LogCommitsResponse, error)

	// GetObject request
	GetObjectWithResponse(ctx context.Context, repository string, ref string, params *GetObjectParams, reqEditors ...RequestEditorFn) (*GetObjectResponse, error)

	// HeadObject request
	HeadObjectWithResponse(ctx context.Context, repository string, ref string, params *HeadObjectParams, reqEditors ...RequestEditorFn) (*HeadObjectResponse, error)

	// ListObjects request
	ListObjectsWithResponse(ctx context.Context, repository string, ref string, params *ListObjectsParams, reqEditors ...RequestEditorFn) (*ListObjectsResponse, error)

	// StatObject request
	StatObjectWithResponse(ctx context.Context, repository string, ref string, params *StatObjectParams, reqEditors ...RequestEditorFn) (*StatObjectResponse, error)

	// GetUnderlyingProperties request
	GetUnderlyingPropertiesWithResponse(ctx context.Context, repository string, ref string, params *GetUnderlyingPropertiesParams, reqEditors ...RequestEditorFn) (*GetUnderlyingPropertiesResponse, error)

	// FindMergeBase request
	FindMergeBaseWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, reqEditors ...RequestEditorFn) (*FindMergeBaseResponse, error)

	// MergeIntoBranch request  with any body
	MergeIntoBranchWithBodyWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeIntoBranchResponse, error)

	MergeIntoBranchWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, body MergeIntoBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeIntoBranchResponse, error)

	// MergeIntoBranchAsync request  with any body
	MergeIntoBranchAsyncWithBodyWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeIntoBranchAsyncResponse, error)

	MergeIntoBranchAsyncWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, body MergeIntoBranchAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeIntoBranchAsyncResponse, error)

	// MergeIntoBranchAsyncStatus request
	MergeIntoBranchAsyncStatusWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, id string, reqEditors ...RequestEditorFn) (*MergeIntoBranchAsyncStatusResponse, error)

	// RestoreStatus request
	RestoreStatusWithResponse(ctx context.Context, repository string, params *RestoreStatusParams, reqEditors ...RequestEditorFn) (*RestoreStatusResponse, error)

	// RestoreSubmit request  with any body
	RestoreSubmitWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestoreSubmitResponse, error)

	RestoreSubmitWithResponse(ctx context.Context, repository string, body RestoreSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*RestoreSubmitResponse, error)

	// GetBranchProtectionRules request
	GetBranchProtectionRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*GetBranchProtectionRulesResponse, error)

	// SetBranchProtectionRules request  with any body
	SetBranchProtectionRulesWithBodyWithResponse(ctx context.Context, repository string, params *SetBranchProtectionRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetBranchProtectionRulesResponse, error)

	SetBranchProtectionRulesWithResponse(ctx context.Context, repository string, params *SetBranchProtectionRulesParams, body SetBranchProtectionRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetBranchProtectionRulesResponse, error)

	// DeleteGCRules request
	DeleteGCRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*DeleteGCRulesResponse, error)

	// GetGCRules request
	GetGCRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*GetGCRulesResponse, error)

	// SetGCRules request  with any body
	SetGCRulesWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetGCRulesResponse, error)

	SetGCRulesWithResponse(ctx context.Context, repository string, body SetGCRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetGCRulesResponse, error)

	// ListTags request
	ListTagsWithResponse(ctx context.Context, repository string, params *ListTagsParams, reqEditors ...RequestEditorFn) (*ListTagsResponse, error)

	// CreateTag request  with any body
	CreateTagWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTagResponse, error)

	CreateTagWithResponse(ctx context.Context, repository string, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTagResponse, error)

	// DeleteTag request
	DeleteTagWithResponse(ctx context.Context, repository string, tag string, params *DeleteTagParams, reqEditors ...RequestEditorFn) (*DeleteTagResponse, error)

	// GetTag request
	GetTagWithResponse(ctx context.Context, repository string, tag string, reqEditors ...RequestEditorFn) (*GetTagResponse, error)

	// SetupCommPrefs request  with any body
	SetupCommPrefsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetupCommPrefsResponse, error)

	SetupCommPrefsWithResponse(ctx context.Context, body SetupCommPrefsJSONRequestBody, reqEditors ...RequestEditorFn) (*SetupCommPrefsResponse, error)

	// GetSetupState request
	GetSetupStateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSetupStateResponse, error)

	// Setup request  with any body
	SetupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetupResponse, error)

	SetupWithResponse(ctx context.Context, body SetupJSONRequestBody, reqEditors ...RequestEditorFn) (*SetupResponse, error)

	// PostStatsEvents request  with any body
	PostStatsEventsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStatsEventsResponse, error)

	PostStatsEventsWithResponse(ctx context.Context, body PostStatsEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStatsEventsResponse, error)

	// StsLogin request  with any body
	StsLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StsLoginResponse, error)

	StsLoginWithResponse(ctx context.Context, body StsLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*StsLoginResponse, error)

	// GetUsageReportSummary request
	GetUsageReportSummaryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUsageReportSummaryResponse, error)

	// GetCurrentUser request
	GetCurrentUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentUserResponse, error)
}

type GetAuthCapabilitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthCapabilities
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetAuthCapabilitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthCapabilitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExternalPrincipalLoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthenticationToken
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ExternalPrincipalLoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExternalPrincipalLoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExternalPrincipalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExternalPrincipal
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetExternalPrincipalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExternalPrincipalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTokenFromMailboxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthenticationToken
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON501      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetTokenFromMailboxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTokenFromMailboxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReleaseTokenToMailboxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON501      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ReleaseTokenToMailboxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReleaseTokenToMailboxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTokenRedirectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON501      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetTokenRedirectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTokenRedirectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupList
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Group
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Group
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupACLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ACL
	JSON400      *Error
	JSON401      *Error
	JSON404      *ErrorNoACL
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetGroupACLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupACLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetGroupACLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SetGroupACLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetGroupACLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGroupMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserList
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListGroupMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGroupMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupMembershipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteGroupMembershipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupMembershipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddGroupMembershipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AddGroupMembershipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddGroupMembershipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGroupPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyList
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListGroupPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGroupPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DetachPolicyFromGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DetachPolicyFromGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DetachPolicyFromGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachPolicyToGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AttachPolicyToGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachPolicyToGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthenticationToken
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r LoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyList
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Policy
	JSON400      *Error
	JSON401      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreatePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeletePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Policy
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Policy
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdatePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserList
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *User
	JSON400      *Error
	JSON401      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CredentialsList
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListUserCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CredentialsWithSecret
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Credentials
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserExternalPrincipalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteUserExternalPrincipalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserExternalPrincipalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserExternalPrincipalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateUserExternalPrincipalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserExternalPrincipalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserExternalPrincipalsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExternalPrincipalList
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListUserExternalPrincipalsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserExternalPrincipalsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupList
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListUserGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyList
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListUserPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DetachPolicyFromUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DetachPolicyFromUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DetachPolicyFromUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachPolicyToUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AttachPolicyToUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachPolicyToUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Config
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r GetConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGarbageCollectionConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GarbageCollectionConfig
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r GetGarbageCollectionConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGarbageCollectionConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStorageConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StorageConfig
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r GetStorageConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStorageConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLakeFSVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VersionConfig
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r GetLakeFSVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLakeFSVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HealthCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HealthCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PullIcebergTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PullIcebergTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PullIcebergTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PushIcebergTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PushIcebergTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PushIcebergTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLicenseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *License
	JSON401      *Error
	JSON501      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetLicenseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLicenseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r OauthCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRepositoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RepositoryList
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListRepositoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRepositoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Repository
	JSON400      *Error
	JSON401      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Repository
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRepositoryRunsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionRunList
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListRepositoryRunsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRepositoryRunsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionRun
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRunHooksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HookRunList
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListRunHooksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRunHooksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRunHookOutputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRunHookOutputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRunHookOutputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalDeleteBranchProtectionRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r InternalDeleteBranchProtectionRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalDeleteBranchProtectionRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalGetBranchProtectionRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]BranchProtectionRule
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r InternalGetBranchProtectionRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalGetBranchProtectionRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalCreateBranchProtectionRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r InternalCreateBranchProtectionRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalCreateBranchProtectionRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBranchProtectionRulePreflightResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateBranchProtectionRulePreflightResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBranchProtectionRulePreflightResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBranchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RefList
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListBranchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBranchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Ref
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ResetBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CherryPickResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Commit
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CherryPickResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CherryPickResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Commit
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	JSON412      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CommitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommitAsyncResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *TaskCreation
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON501      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CommitAsyncResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommitAsyncResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommitAsyncStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommitAsyncStatus
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	JSON412      *Error
	JSON501      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CommitAsyncStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommitAsyncStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DiffBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DiffList
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DiffBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DiffBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HardResetBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r HardResetBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HardResetBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ImportCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ImportStatus
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ImportStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportStartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *ImportCreationResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ImportStartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportStartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ObjectStats
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON412      *Error
	JSON501      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UploadObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StageObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ObjectStats
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r StageObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StageObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CopyObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ObjectStats
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CopyObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CopyObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteObjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectErrorList
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteObjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteObjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadObjectPreflightResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UploadObjectPreflightResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadObjectPreflightResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateObjectUserMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdateObjectUserMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateObjectUserMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevertBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r RevertBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevertBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPhysicalAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StagingLocation
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetPhysicalAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPhysicalAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkPhysicalAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStats
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *StagingLocation
	JSON412      *Error
	JSON501      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r LinkPhysicalAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkPhysicalAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePresignMultipartUploadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PresignMultipartUpload
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreatePresignMultipartUploadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePresignMultipartUploadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AbortPresignMultipartUploadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AbortPresignMultipartUploadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AbortPresignMultipartUploadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompletePresignMultipartUploadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStats
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON409      *StagingLocation
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CompletePresignMultipartUploadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompletePresignMultipartUploadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadPartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UploadTo
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UploadPartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadPartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadPartCopyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UploadPartCopyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadPartCopyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCommitRecordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateCommitRecordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCommitRecordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCommitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Commit
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetCommitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCommitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DumpStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RepositoryDumpStatus
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DumpStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DumpStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DumpSubmitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *TaskInfo
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DumpSubmitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DumpSubmitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PrepareGarbageCollectionCommitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *GarbageCollectionPrepareResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PrepareGarbageCollectionCommitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PrepareGarbageCollectionCommitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PrepareGarbageCollectionCommitsAsyncResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *TaskCreation
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PrepareGarbageCollectionCommitsAsyncResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PrepareGarbageCollectionCommitsAsyncResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PrepareGarbageCollectionCommitsStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PrepareGarbageCollectionCommitsStatus
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PrepareGarbageCollectionCommitsStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PrepareGarbageCollectionCommitsStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PrepareGarbageCollectionUncommittedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PrepareGCUncommittedResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PrepareGarbageCollectionUncommittedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PrepareGarbageCollectionUncommittedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalDeleteGarbageCollectionRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r InternalDeleteGarbageCollectionRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalDeleteGarbageCollectionRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalGetGarbageCollectionRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GarbageCollectionRules
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r InternalGetGarbageCollectionRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalGetGarbageCollectionRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalSetGarbageCollectionRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r InternalSetGarbageCollectionRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalSetGarbageCollectionRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetGarbageCollectionRulesPreflightResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SetGarbageCollectionRulesPreflightResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetGarbageCollectionRulesPreflightResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRepositoryMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteRepositoryMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRepositoryMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRepositoryMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RepositoryMetadata
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRepositoryMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRepositoryMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetRepositoryMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SetRepositoryMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetRepositoryMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMetaRangeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StorageURI
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetMetaRangeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetaRangeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMetadataObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetMetadataObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetadataObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRangeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StorageURI
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRangeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRangeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPullRequestsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PullRequestsList
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListPullRequestsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPullRequestsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePullRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PullRequestCreationResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreatePullRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePullRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPullRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PullRequest
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetPullRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPullRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePullRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdatePullRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePullRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergePullRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MergeResult
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *MergeResult
	JSON412      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r MergePullRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergePullRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DumpRefsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RefsDump
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DumpRefsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DumpRefsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreRefsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r RestoreRefsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreRefsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSymlinkFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *StorageURI
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateSymlinkFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSymlinkFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DiffRefsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DiffList
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DiffRefsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DiffRefsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogCommitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommitList
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r LogCommitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogCommitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON410      *Error
	JSON416      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HeadObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HeadObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HeadObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListObjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStatsList
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListObjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListObjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StatObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStats
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r StatObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StatObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUnderlyingPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UnderlyingObjectProperties
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetUnderlyingPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUnderlyingPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindMergeBaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FindMergeBaseResult
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r FindMergeBaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindMergeBaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeIntoBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MergeResult
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *MergeResult
	JSON412      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r MergeIntoBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeIntoBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeIntoBranchAsyncResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *TaskCreation
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON501      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r MergeIntoBranchAsyncResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeIntoBranchAsyncResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeIntoBranchAsyncStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MergeAsyncStatus
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	JSON412      *Error
	JSON501      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r MergeIntoBranchAsyncStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeIntoBranchAsyncStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RepositoryRestoreStatus
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r RestoreStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreSubmitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *TaskInfo
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r RestoreSubmitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreSubmitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBranchProtectionRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]BranchProtectionRule
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetBranchProtectionRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBranchProtectionRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetBranchProtectionRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON412      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SetBranchProtectionRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetBranchProtectionRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGCRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteGCRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGCRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGCRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GarbageCollectionRules
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetGCRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGCRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetGCRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SetGCRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetGCRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RefList
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Ref
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Ref
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetupCommPrefsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON409      *Error
	JSON412      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SetupCommPrefsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetupCommPrefsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSetupStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SetupState
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSetupStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSetupStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CredentialsWithSecret
	JSON400      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SetupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostStatsEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostStatsEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostStatsEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StsLoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthenticationToken
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r StsLoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StsLoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsageReportSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InstallationUsageReport
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetUsageReportSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsageReportSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CurrentUser
}

// Status returns HTTPResponse.Status
func (r GetCurrentUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAuthCapabilitiesWithResponse request returning *GetAuthCapabilitiesResponse
func (c *ClientWithResponses) GetAuthCapabilitiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAuthCapabilitiesResponse, error) {
	rsp, err := c.GetAuthCapabilities(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthCapabilitiesResponse(rsp)
}

// ExternalPrincipalLoginWithBodyWithResponse request with arbitrary body returning *ExternalPrincipalLoginResponse
func (c *ClientWithResponses) ExternalPrincipalLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExternalPrincipalLoginResponse, error) {
	rsp, err := c.ExternalPrincipalLoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExternalPrincipalLoginResponse(rsp)
}

func (c *ClientWithResponses) ExternalPrincipalLoginWithResponse(ctx context.Context, body ExternalPrincipalLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*ExternalPrincipalLoginResponse, error) {
	rsp, err := c.ExternalPrincipalLogin(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExternalPrincipalLoginResponse(rsp)
}

// GetExternalPrincipalWithResponse request returning *GetExternalPrincipalResponse
func (c *ClientWithResponses) GetExternalPrincipalWithResponse(ctx context.Context, params *GetExternalPrincipalParams, reqEditors ...RequestEditorFn) (*GetExternalPrincipalResponse, error) {
	rsp, err := c.GetExternalPrincipal(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExternalPrincipalResponse(rsp)
}

// GetTokenFromMailboxWithResponse request returning *GetTokenFromMailboxResponse
func (c *ClientWithResponses) GetTokenFromMailboxWithResponse(ctx context.Context, mailbox string, reqEditors ...RequestEditorFn) (*GetTokenFromMailboxResponse, error) {
	rsp, err := c.GetTokenFromMailbox(ctx, mailbox, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTokenFromMailboxResponse(rsp)
}

// ReleaseTokenToMailboxWithResponse request returning *ReleaseTokenToMailboxResponse
func (c *ClientWithResponses) ReleaseTokenToMailboxWithResponse(ctx context.Context, loginRequestToken string, reqEditors ...RequestEditorFn) (*ReleaseTokenToMailboxResponse, error) {
	rsp, err := c.ReleaseTokenToMailbox(ctx, loginRequestToken, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReleaseTokenToMailboxResponse(rsp)
}

// GetTokenRedirectWithResponse request returning *GetTokenRedirectResponse
func (c *ClientWithResponses) GetTokenRedirectWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTokenRedirectResponse, error) {
	rsp, err := c.GetTokenRedirect(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTokenRedirectResponse(rsp)
}

// ListGroupsWithResponse request returning *ListGroupsResponse
func (c *ClientWithResponses) ListGroupsWithResponse(ctx context.Context, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*ListGroupsResponse, error) {
	rsp, err := c.ListGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGroupsResponse(rsp)
}

// CreateGroupWithBodyWithResponse request with arbitrary body returning *CreateGroupResponse
func (c *ClientWithResponses) CreateGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateGroupWithResponse(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

// DeleteGroupWithResponse request returning *DeleteGroupResponse
func (c *ClientWithResponses) DeleteGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error) {
	rsp, err := c.DeleteGroup(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupResponse(rsp)
}

// GetGroupWithResponse request returning *GetGroupResponse
func (c *ClientWithResponses) GetGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*GetGroupResponse, error) {
	rsp, err := c.GetGroup(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupResponse(rsp)
}

// GetGroupACLWithResponse request returning *GetGroupACLResponse
func (c *ClientWithResponses) GetGroupACLWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*GetGroupACLResponse, error) {
	rsp, err := c.GetGroupACL(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupACLResponse(rsp)
}

// SetGroupACLWithBodyWithResponse request with arbitrary body returning *SetGroupACLResponse
func (c *ClientWithResponses) SetGroupACLWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetGroupACLResponse, error) {
	rsp, err := c.SetGroupACLWithBody(ctx, groupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetGroupACLResponse(rsp)
}

func (c *ClientWithResponses) SetGroupACLWithResponse(ctx context.Context, groupId string, body SetGroupACLJSONRequestBody, reqEditors ...RequestEditorFn) (*SetGroupACLResponse, error) {
	rsp, err := c.SetGroupACL(ctx, groupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetGroupACLResponse(rsp)
}

// ListGroupMembersWithResponse request returning *ListGroupMembersResponse
func (c *ClientWithResponses) ListGroupMembersWithResponse(ctx context.Context, groupId string, params *ListGroupMembersParams, reqEditors ...RequestEditorFn) (*ListGroupMembersResponse, error) {
	rsp, err := c.ListGroupMembers(ctx, groupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGroupMembersResponse(rsp)
}

// DeleteGroupMembershipWithResponse request returning *DeleteGroupMembershipResponse
func (c *ClientWithResponses) DeleteGroupMembershipWithResponse(ctx context.Context, groupId string, userId string, reqEditors ...RequestEditorFn) (*DeleteGroupMembershipResponse, error) {
	rsp, err := c.DeleteGroupMembership(ctx, groupId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupMembershipResponse(rsp)
}

// AddGroupMembershipWithResponse request returning *AddGroupMembershipResponse
func (c *ClientWithResponses) AddGroupMembershipWithResponse(ctx context.Context, groupId string, userId string, reqEditors ...RequestEditorFn) (*AddGroupMembershipResponse, error) {
	rsp, err := c.AddGroupMembership(ctx, groupId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddGroupMembershipResponse(rsp)
}

// ListGroupPoliciesWithResponse request returning *ListGroupPoliciesResponse
func (c *ClientWithResponses) ListGroupPoliciesWithResponse(ctx context.Context, groupId string, params *ListGroupPoliciesParams, reqEditors ...RequestEditorFn) (*ListGroupPoliciesResponse, error) {
	rsp, err := c.ListGroupPolicies(ctx, groupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGroupPoliciesResponse(rsp)
}

// DetachPolicyFromGroupWithResponse request returning *DetachPolicyFromGroupResponse
func (c *ClientWithResponses) DetachPolicyFromGroupWithResponse(ctx context.Context, groupId string, policyId string, reqEditors ...RequestEditorFn) (*DetachPolicyFromGroupResponse, error) {
	rsp, err := c.DetachPolicyFromGroup(ctx, groupId, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDetachPolicyFromGroupResponse(rsp)
}

// AttachPolicyToGroupWithResponse request returning *AttachPolicyToGroupResponse
func (c *ClientWithResponses) AttachPolicyToGroupWithResponse(ctx context.Context, groupId string, policyId string, reqEditors ...RequestEditorFn) (*AttachPolicyToGroupResponse, error) {
	rsp, err := c.AttachPolicyToGroup(ctx, groupId, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachPolicyToGroupResponse(rsp)
}

// LoginWithBodyWithResponse request with arbitrary body returning *LoginResponse
func (c *ClientWithResponses) LoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.LoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

func (c *ClientWithResponses) LoginWithResponse(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.Login(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

// ListPoliciesWithResponse request returning *ListPoliciesResponse
func (c *ClientWithResponses) ListPoliciesWithResponse(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*ListPoliciesResponse, error) {
	rsp, err := c.ListPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPoliciesResponse(rsp)
}

// CreatePolicyWithBodyWithResponse request with arbitrary body returning *CreatePolicyResponse
func (c *ClientWithResponses) CreatePolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error) {
	rsp, err := c.CreatePolicyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePolicyResponse(rsp)
}

func (c *ClientWithResponses) CreatePolicyWithResponse(ctx context.Context, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error) {
	rsp, err := c.CreatePolicy(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePolicyResponse(rsp)
}

// DeletePolicyWithResponse request returning *DeletePolicyResponse
func (c *ClientWithResponses) DeletePolicyWithResponse(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*DeletePolicyResponse, error) {
	rsp, err := c.DeletePolicy(ctx, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePolicyResponse(rsp)
}

// GetPolicyWithResponse request returning *GetPolicyResponse
func (c *ClientWithResponses) GetPolicyWithResponse(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*GetPolicyResponse, error) {
	rsp, err := c.GetPolicy(ctx, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPolicyResponse(rsp)
}

// UpdatePolicyWithBodyWithResponse request with arbitrary body returning *UpdatePolicyResponse
func (c *ClientWithResponses) UpdatePolicyWithBodyWithResponse(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error) {
	rsp, err := c.UpdatePolicyWithBody(ctx, policyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePolicyResponse(rsp)
}

func (c *ClientWithResponses) UpdatePolicyWithResponse(ctx context.Context, policyId string, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error) {
	rsp, err := c.UpdatePolicy(ctx, policyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePolicyResponse(rsp)
}

// ListUsersWithResponse request returning *ListUsersResponse
func (c *ClientWithResponses) ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error) {
	rsp, err := c.ListUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersResponse(rsp)
}

// CreateUserWithBodyWithResponse request with arbitrary body returning *CreateUserResponse
func (c *ClientWithResponses) CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

func (c *ClientWithResponses) CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// ListUserCredentialsWithResponse request returning *ListUserCredentialsResponse
func (c *ClientWithResponses) ListUserCredentialsWithResponse(ctx context.Context, userId string, params *ListUserCredentialsParams, reqEditors ...RequestEditorFn) (*ListUserCredentialsResponse, error) {
	rsp, err := c.ListUserCredentials(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserCredentialsResponse(rsp)
}

// CreateCredentialsWithResponse request returning *CreateCredentialsResponse
func (c *ClientWithResponses) CreateCredentialsWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*CreateCredentialsResponse, error) {
	rsp, err := c.CreateCredentials(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCredentialsResponse(rsp)
}

// DeleteCredentialsWithResponse request returning *DeleteCredentialsResponse
func (c *ClientWithResponses) DeleteCredentialsWithResponse(ctx context.Context, userId string, accessKeyId string, reqEditors ...RequestEditorFn) (*DeleteCredentialsResponse, error) {
	rsp, err := c.DeleteCredentials(ctx, userId, accessKeyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCredentialsResponse(rsp)
}

// GetCredentialsWithResponse request returning *GetCredentialsResponse
func (c *ClientWithResponses) GetCredentialsWithResponse(ctx context.Context, userId string, accessKeyId string, reqEditors ...RequestEditorFn) (*GetCredentialsResponse, error) {
	rsp, err := c.GetCredentials(ctx, userId, accessKeyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCredentialsResponse(rsp)
}

// DeleteUserExternalPrincipalWithResponse request returning *DeleteUserExternalPrincipalResponse
func (c *ClientWithResponses) DeleteUserExternalPrincipalWithResponse(ctx context.Context, userId string, params *DeleteUserExternalPrincipalParams, reqEditors ...RequestEditorFn) (*DeleteUserExternalPrincipalResponse, error) {
	rsp, err := c.DeleteUserExternalPrincipal(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserExternalPrincipalResponse(rsp)
}

// CreateUserExternalPrincipalWithBodyWithResponse request with arbitrary body returning *CreateUserExternalPrincipalResponse
func (c *ClientWithResponses) CreateUserExternalPrincipalWithBodyWithResponse(ctx context.Context, userId string, params *CreateUserExternalPrincipalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserExternalPrincipalResponse, error) {
	rsp, err := c.CreateUserExternalPrincipalWithBody(ctx, userId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserExternalPrincipalResponse(rsp)
}

func (c *ClientWithResponses) CreateUserExternalPrincipalWithResponse(ctx context.Context, userId string, params *CreateUserExternalPrincipalParams, body CreateUserExternalPrincipalJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserExternalPrincipalResponse, error) {
	rsp, err := c.CreateUserExternalPrincipal(ctx, userId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserExternalPrincipalResponse(rsp)
}

// ListUserExternalPrincipalsWithResponse request returning *ListUserExternalPrincipalsResponse
func (c *ClientWithResponses) ListUserExternalPrincipalsWithResponse(ctx context.Context, userId string, params *ListUserExternalPrincipalsParams, reqEditors ...RequestEditorFn) (*ListUserExternalPrincipalsResponse, error) {
	rsp, err := c.ListUserExternalPrincipals(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserExternalPrincipalsResponse(rsp)
}

// ListUserGroupsWithResponse request returning *ListUserGroupsResponse
func (c *ClientWithResponses) ListUserGroupsWithResponse(ctx context.Context, userId string, params *ListUserGroupsParams, reqEditors ...RequestEditorFn) (*ListUserGroupsResponse, error) {
	rsp, err := c.ListUserGroups(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserGroupsResponse(rsp)
}

// ListUserPoliciesWithResponse request returning *ListUserPoliciesResponse
func (c *ClientWithResponses) ListUserPoliciesWithResponse(ctx context.Context, userId string, params *ListUserPoliciesParams, reqEditors ...RequestEditorFn) (*ListUserPoliciesResponse, error) {
	rsp, err := c.ListUserPolicies(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserPoliciesResponse(rsp)
}

// DetachPolicyFromUserWithResponse request returning *DetachPolicyFromUserResponse
func (c *ClientWithResponses) DetachPolicyFromUserWithResponse(ctx context.Context, userId string, policyId string, reqEditors ...RequestEditorFn) (*DetachPolicyFromUserResponse, error) {
	rsp, err := c.DetachPolicyFromUser(ctx, userId, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDetachPolicyFromUserResponse(rsp)
}

// AttachPolicyToUserWithResponse request returning *AttachPolicyToUserResponse
func (c *ClientWithResponses) AttachPolicyToUserWithResponse(ctx context.Context, userId string, policyId string, reqEditors ...RequestEditorFn) (*AttachPolicyToUserResponse, error) {
	rsp, err := c.AttachPolicyToUser(ctx, userId, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachPolicyToUserResponse(rsp)
}

// GetConfigWithResponse request returning *GetConfigResponse
func (c *ClientWithResponses) GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigResponse, error) {
	rsp, err := c.GetConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigResponse(rsp)
}

// GetGarbageCollectionConfigWithResponse request returning *GetGarbageCollectionConfigResponse
func (c *ClientWithResponses) GetGarbageCollectionConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGarbageCollectionConfigResponse, error) {
	rsp, err := c.GetGarbageCollectionConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGarbageCollectionConfigResponse(rsp)
}

// GetStorageConfigWithResponse request returning *GetStorageConfigResponse
func (c *ClientWithResponses) GetStorageConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStorageConfigResponse, error) {
	rsp, err := c.GetStorageConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStorageConfigResponse(rsp)
}

// GetLakeFSVersionWithResponse request returning *GetLakeFSVersionResponse
func (c *ClientWithResponses) GetLakeFSVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLakeFSVersionResponse, error) {
	rsp, err := c.GetLakeFSVersion(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLakeFSVersionResponse(rsp)
}

// HealthCheckWithResponse request returning *HealthCheckResponse
func (c *ClientWithResponses) HealthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error) {
	rsp, err := c.HealthCheck(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthCheckResponse(rsp)
}

// PullIcebergTableWithBodyWithResponse request with arbitrary body returning *PullIcebergTableResponse
func (c *ClientWithResponses) PullIcebergTableWithBodyWithResponse(ctx context.Context, catalog string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PullIcebergTableResponse, error) {
	rsp, err := c.PullIcebergTableWithBody(ctx, catalog, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullIcebergTableResponse(rsp)
}

func (c *ClientWithResponses) PullIcebergTableWithResponse(ctx context.Context, catalog string, body PullIcebergTableJSONRequestBody, reqEditors ...RequestEditorFn) (*PullIcebergTableResponse, error) {
	rsp, err := c.PullIcebergTable(ctx, catalog, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullIcebergTableResponse(rsp)
}

// PushIcebergTableWithBodyWithResponse request with arbitrary body returning *PushIcebergTableResponse
func (c *ClientWithResponses) PushIcebergTableWithBodyWithResponse(ctx context.Context, catalog string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PushIcebergTableResponse, error) {
	rsp, err := c.PushIcebergTableWithBody(ctx, catalog, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePushIcebergTableResponse(rsp)
}

func (c *ClientWithResponses) PushIcebergTableWithResponse(ctx context.Context, catalog string, body PushIcebergTableJSONRequestBody, reqEditors ...RequestEditorFn) (*PushIcebergTableResponse, error) {
	rsp, err := c.PushIcebergTable(ctx, catalog, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePushIcebergTableResponse(rsp)
}

// GetLicenseWithResponse request returning *GetLicenseResponse
func (c *ClientWithResponses) GetLicenseWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLicenseResponse, error) {
	rsp, err := c.GetLicense(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLicenseResponse(rsp)
}

// OauthCallbackWithResponse request returning *OauthCallbackResponse
func (c *ClientWithResponses) OauthCallbackWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*OauthCallbackResponse, error) {
	rsp, err := c.OauthCallback(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthCallbackResponse(rsp)
}

// ListRepositoriesWithResponse request returning *ListRepositoriesResponse
func (c *ClientWithResponses) ListRepositoriesWithResponse(ctx context.Context, params *ListRepositoriesParams, reqEditors ...RequestEditorFn) (*ListRepositoriesResponse, error) {
	rsp, err := c.ListRepositories(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRepositoriesResponse(rsp)
}

// CreateRepositoryWithBodyWithResponse request with arbitrary body returning *CreateRepositoryResponse
func (c *ClientWithResponses) CreateRepositoryWithBodyWithResponse(ctx context.Context, params *CreateRepositoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRepositoryResponse, error) {
	rsp, err := c.CreateRepositoryWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRepositoryResponse(rsp)
}

func (c *ClientWithResponses) CreateRepositoryWithResponse(ctx context.Context, params *CreateRepositoryParams, body CreateRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRepositoryResponse, error) {
	rsp, err := c.CreateRepository(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRepositoryResponse(rsp)
}

// DeleteRepositoryWithResponse request returning *DeleteRepositoryResponse
func (c *ClientWithResponses) DeleteRepositoryWithResponse(ctx context.Context, repository string, params *DeleteRepositoryParams, reqEditors ...RequestEditorFn) (*DeleteRepositoryResponse, error) {
	rsp, err := c.DeleteRepository(ctx, repository, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRepositoryResponse(rsp)
}

// GetRepositoryWithResponse request returning *GetRepositoryResponse
func (c *ClientWithResponses) GetRepositoryWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*GetRepositoryResponse, error) {
	rsp, err := c.GetRepository(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRepositoryResponse(rsp)
}

// ListRepositoryRunsWithResponse request returning *ListRepositoryRunsResponse
func (c *ClientWithResponses) ListRepositoryRunsWithResponse(ctx context.Context, repository string, params *ListRepositoryRunsParams, reqEditors ...RequestEditorFn) (*ListRepositoryRunsResponse, error) {
	rsp, err := c.ListRepositoryRuns(ctx, repository, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRepositoryRunsResponse(rsp)
}

// GetRunWithResponse request returning *GetRunResponse
func (c *ClientWithResponses) GetRunWithResponse(ctx context.Context, repository string, runId string, reqEditors ...RequestEditorFn) (*GetRunResponse, error) {
	rsp, err := c.GetRun(ctx, repository, runId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRunResponse(rsp)
}

// ListRunHooksWithResponse request returning *ListRunHooksResponse
func (c *ClientWithResponses) ListRunHooksWithResponse(ctx context.Context, repository string, runId string, params *ListRunHooksParams, reqEditors ...RequestEditorFn) (*ListRunHooksResponse, error) {
	rsp, err := c.ListRunHooks(ctx, repository, runId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRunHooksResponse(rsp)
}

// GetRunHookOutputWithResponse request returning *GetRunHookOutputResponse
func (c *ClientWithResponses) GetRunHookOutputWithResponse(ctx context.Context, repository string, runId string, hookRunId string, reqEditors ...RequestEditorFn) (*GetRunHookOutputResponse, error) {
	rsp, err := c.GetRunHookOutput(ctx, repository, runId, hookRunId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRunHookOutputResponse(rsp)
}

// InternalDeleteBranchProtectionRuleWithBodyWithResponse request with arbitrary body returning *InternalDeleteBranchProtectionRuleResponse
func (c *ClientWithResponses) InternalDeleteBranchProtectionRuleWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalDeleteBranchProtectionRuleResponse, error) {
	rsp, err := c.InternalDeleteBranchProtectionRuleWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalDeleteBranchProtectionRuleResponse(rsp)
}

func (c *ClientWithResponses) InternalDeleteBranchProtectionRuleWithResponse(ctx context.Context, repository string, body InternalDeleteBranchProtectionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalDeleteBranchProtectionRuleResponse, error) {
	rsp, err := c.InternalDeleteBranchProtectionRule(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalDeleteBranchProtectionRuleResponse(rsp)
}

// InternalGetBranchProtectionRulesWithResponse request returning *InternalGetBranchProtectionRulesResponse
func (c *ClientWithResponses) InternalGetBranchProtectionRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*InternalGetBranchProtectionRulesResponse, error) {
	rsp, err := c.InternalGetBranchProtectionRules(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalGetBranchProtectionRulesResponse(rsp)
}

// InternalCreateBranchProtectionRuleWithBodyWithResponse request with arbitrary body returning *InternalCreateBranchProtectionRuleResponse
func (c *ClientWithResponses) InternalCreateBranchProtectionRuleWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalCreateBranchProtectionRuleResponse, error) {
	rsp, err := c.InternalCreateBranchProtectionRuleWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalCreateBranchProtectionRuleResponse(rsp)
}

func (c *ClientWithResponses) InternalCreateBranchProtectionRuleWithResponse(ctx context.Context, repository string, body InternalCreateBranchProtectionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalCreateBranchProtectionRuleResponse, error) {
	rsp, err := c.InternalCreateBranchProtectionRule(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalCreateBranchProtectionRuleResponse(rsp)
}

// CreateBranchProtectionRulePreflightWithResponse request returning *CreateBranchProtectionRulePreflightResponse
func (c *ClientWithResponses) CreateBranchProtectionRulePreflightWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*CreateBranchProtectionRulePreflightResponse, error) {
	rsp, err := c.CreateBranchProtectionRulePreflight(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBranchProtectionRulePreflightResponse(rsp)
}

// ListBranchesWithResponse request returning *ListBranchesResponse
func (c *ClientWithResponses) ListBranchesWithResponse(ctx context.Context, repository string, params *ListBranchesParams, reqEditors ...RequestEditorFn) (*ListBranchesResponse, error) {
	rsp, err := c.ListBranches(ctx, repository, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBranchesResponse(rsp)
}

// CreateBranchWithBodyWithResponse request with arbitrary body returning *CreateBranchResponse
func (c *ClientWithResponses) CreateBranchWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBranchResponse, error) {
	rsp, err := c.CreateBranchWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBranchResponse(rsp)
}

func (c *ClientWithResponses) CreateBranchWithResponse(ctx context.Context, repository string, body CreateBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBranchResponse, error) {
	rsp, err := c.CreateBranch(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBranchResponse(rsp)
}

// DeleteBranchWithResponse request returning *DeleteBranchResponse
func (c *ClientWithResponses) DeleteBranchWithResponse(ctx context.Context, repository string, branch string, params *DeleteBranchParams, reqEditors ...RequestEditorFn) (*DeleteBranchResponse, error) {
	rsp, err := c.DeleteBranch(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBranchResponse(rsp)
}

// GetBranchWithResponse request returning *GetBranchResponse
func (c *ClientWithResponses) GetBranchWithResponse(ctx context.Context, repository string, branch string, reqEditors ...RequestEditorFn) (*GetBranchResponse, error) {
	rsp, err := c.GetBranch(ctx, repository, branch, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBranchResponse(rsp)
}

// ResetBranchWithBodyWithResponse request with arbitrary body returning *ResetBranchResponse
func (c *ClientWithResponses) ResetBranchWithBodyWithResponse(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetBranchResponse, error) {
	rsp, err := c.ResetBranchWithBody(ctx, repository, branch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetBranchResponse(rsp)
}

func (c *ClientWithResponses) ResetBranchWithResponse(ctx context.Context, repository string, branch string, body ResetBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetBranchResponse, error) {
	rsp, err := c.ResetBranch(ctx, repository, branch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetBranchResponse(rsp)
}

// CherryPickWithBodyWithResponse request with arbitrary body returning *CherryPickResponse
func (c *ClientWithResponses) CherryPickWithBodyWithResponse(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CherryPickResponse, error) {
	rsp, err := c.CherryPickWithBody(ctx, repository, branch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCherryPickResponse(rsp)
}

func (c *ClientWithResponses) CherryPickWithResponse(ctx context.Context, repository string, branch string, body CherryPickJSONRequestBody, reqEditors ...RequestEditorFn) (*CherryPickResponse, error) {
	rsp, err := c.CherryPick(ctx, repository, branch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCherryPickResponse(rsp)
}

// CommitWithBodyWithResponse request with arbitrary body returning *CommitResponse
func (c *ClientWithResponses) CommitWithBodyWithResponse(ctx context.Context, repository string, branch string, params *CommitParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommitResponse, error) {
	rsp, err := c.CommitWithBody(ctx, repository, branch, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitResponse(rsp)
}

func (c *ClientWithResponses) CommitWithResponse(ctx context.Context, repository string, branch string, params *CommitParams, body CommitJSONRequestBody, reqEditors ...RequestEditorFn) (*CommitResponse, error) {
	rsp, err := c.Commit(ctx, repository, branch, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitResponse(rsp)
}

// CommitAsyncWithBodyWithResponse request with arbitrary body returning *CommitAsyncResponse
func (c *ClientWithResponses) CommitAsyncWithBodyWithResponse(ctx context.Context, repository string, branch string, params *CommitAsyncParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommitAsyncResponse, error) {
	rsp, err := c.CommitAsyncWithBody(ctx, repository, branch, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitAsyncResponse(rsp)
}

func (c *ClientWithResponses) CommitAsyncWithResponse(ctx context.Context, repository string, branch string, params *CommitAsyncParams, body CommitAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*CommitAsyncResponse, error) {
	rsp, err := c.CommitAsync(ctx, repository, branch, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitAsyncResponse(rsp)
}

// CommitAsyncStatusWithResponse request returning *CommitAsyncStatusResponse
func (c *ClientWithResponses) CommitAsyncStatusWithResponse(ctx context.Context, repository string, branch string, id string, reqEditors ...RequestEditorFn) (*CommitAsyncStatusResponse, error) {
	rsp, err := c.CommitAsyncStatus(ctx, repository, branch, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitAsyncStatusResponse(rsp)
}

// DiffBranchWithResponse request returning *DiffBranchResponse
func (c *ClientWithResponses) DiffBranchWithResponse(ctx context.Context, repository string, branch string, params *DiffBranchParams, reqEditors ...RequestEditorFn) (*DiffBranchResponse, error) {
	rsp, err := c.DiffBranch(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDiffBranchResponse(rsp)
}

// HardResetBranchWithResponse request returning *HardResetBranchResponse
func (c *ClientWithResponses) HardResetBranchWithResponse(ctx context.Context, repository string, branch string, params *HardResetBranchParams, reqEditors ...RequestEditorFn) (*HardResetBranchResponse, error) {
	rsp, err := c.HardResetBranch(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHardResetBranchResponse(rsp)
}

// ImportCancelWithResponse request returning *ImportCancelResponse
func (c *ClientWithResponses) ImportCancelWithResponse(ctx context.Context, repository string, branch string, params *ImportCancelParams, reqEditors ...RequestEditorFn) (*ImportCancelResponse, error) {
	rsp, err := c.ImportCancel(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportCancelResponse(rsp)
}

// ImportStatusWithResponse request returning *ImportStatusResponse
func (c *ClientWithResponses) ImportStatusWithResponse(ctx context.Context, repository string, branch string, params *ImportStatusParams, reqEditors ...RequestEditorFn) (*ImportStatusResponse, error) {
	rsp, err := c.ImportStatus(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportStatusResponse(rsp)
}

// ImportStartWithBodyWithResponse request with arbitrary body returning *ImportStartResponse
func (c *ClientWithResponses) ImportStartWithBodyWithResponse(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportStartResponse, error) {
	rsp, err := c.ImportStartWithBody(ctx, repository, branch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportStartResponse(rsp)
}

func (c *ClientWithResponses) ImportStartWithResponse(ctx context.Context, repository string, branch string, body ImportStartJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportStartResponse, error) {
	rsp, err := c.ImportStart(ctx, repository, branch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportStartResponse(rsp)
}

// DeleteObjectWithResponse request returning *DeleteObjectResponse
func (c *ClientWithResponses) DeleteObjectWithResponse(ctx context.Context, repository string, branch string, params *DeleteObjectParams, reqEditors ...RequestEditorFn) (*DeleteObjectResponse, error) {
	rsp, err := c.DeleteObject(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteObjectResponse(rsp)
}

// UploadObjectWithBodyWithResponse request with arbitrary body returning *UploadObjectResponse
func (c *ClientWithResponses) UploadObjectWithBodyWithResponse(ctx context.Context, repository string, branch string, params *UploadObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadObjectResponse, error) {
	rsp, err := c.UploadObjectWithBody(ctx, repository, branch, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadObjectResponse(rsp)
}

// StageObjectWithBodyWithResponse request with arbitrary body returning *StageObjectResponse
func (c *ClientWithResponses) StageObjectWithBodyWithResponse(ctx context.Context, repository string, branch string, params *StageObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StageObjectResponse, error) {
	rsp, err := c.StageObjectWithBody(ctx, repository, branch, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStageObjectResponse(rsp)
}

func (c *ClientWithResponses) StageObjectWithResponse(ctx context.Context, repository string, branch string, params *StageObjectParams, body StageObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*StageObjectResponse, error) {
	rsp, err := c.StageObject(ctx, repository, branch, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStageObjectResponse(rsp)
}

// CopyObjectWithBodyWithResponse request with arbitrary body returning *CopyObjectResponse
func (c *ClientWithResponses) CopyObjectWithBodyWithResponse(ctx context.Context, repository string, branch string, params *CopyObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CopyObjectResponse, error) {
	rsp, err := c.CopyObjectWithBody(ctx, repository, branch, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCopyObjectResponse(rsp)
}

func (c *ClientWithResponses) CopyObjectWithResponse(ctx context.Context, repository string, branch string, params *CopyObjectParams, body CopyObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CopyObjectResponse, error) {
	rsp, err := c.CopyObject(ctx, repository, branch, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCopyObjectResponse(rsp)
}

// DeleteObjectsWithBodyWithResponse request with arbitrary body returning *DeleteObjectsResponse
func (c *ClientWithResponses) DeleteObjectsWithBodyWithResponse(ctx context.Context, repository string, branch string, params *DeleteObjectsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteObjectsResponse, error) {
	rsp, err := c.DeleteObjectsWithBody(ctx, repository, branch, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteObjectsResponse(rsp)
}

func (c *ClientWithResponses) DeleteObjectsWithResponse(ctx context.Context, repository string, branch string, params *DeleteObjectsParams, body DeleteObjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteObjectsResponse, error) {
	rsp, err := c.DeleteObjects(ctx, repository, branch, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteObjectsResponse(rsp)
}

// UploadObjectPreflightWithResponse request returning *UploadObjectPreflightResponse
func (c *ClientWithResponses) UploadObjectPreflightWithResponse(ctx context.Context, repository string, branch string, params *UploadObjectPreflightParams, reqEditors ...RequestEditorFn) (*UploadObjectPreflightResponse, error) {
	rsp, err := c.UploadObjectPreflight(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadObjectPreflightResponse(rsp)
}

// UpdateObjectUserMetadataWithBodyWithResponse request with arbitrary body returning *UpdateObjectUserMetadataResponse
func (c *ClientWithResponses) UpdateObjectUserMetadataWithBodyWithResponse(ctx context.Context, repository string, branch string, params *UpdateObjectUserMetadataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateObjectUserMetadataResponse, error) {
	rsp, err := c.UpdateObjectUserMetadataWithBody(ctx, repository, branch, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateObjectUserMetadataResponse(rsp)
}

func (c *ClientWithResponses) UpdateObjectUserMetadataWithResponse(ctx context.Context, repository string, branch string, params *UpdateObjectUserMetadataParams, body UpdateObjectUserMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateObjectUserMetadataResponse, error) {
	rsp, err := c.UpdateObjectUserMetadata(ctx, repository, branch, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateObjectUserMetadataResponse(rsp)
}

// RevertBranchWithBodyWithResponse request with arbitrary body returning *RevertBranchResponse
func (c *ClientWithResponses) RevertBranchWithBodyWithResponse(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevertBranchResponse, error) {
	rsp, err := c.RevertBranchWithBody(ctx, repository, branch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevertBranchResponse(rsp)
}

func (c *ClientWithResponses) RevertBranchWithResponse(ctx context.Context, repository string, branch string, body RevertBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*RevertBranchResponse, error) {
	rsp, err := c.RevertBranch(ctx, repository, branch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevertBranchResponse(rsp)
}

// GetPhysicalAddressWithResponse request returning *GetPhysicalAddressResponse
func (c *ClientWithResponses) GetPhysicalAddressWithResponse(ctx context.Context, repository string, branch string, params *GetPhysicalAddressParams, reqEditors ...RequestEditorFn) (*GetPhysicalAddressResponse, error) {
	rsp, err := c.GetPhysicalAddress(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPhysicalAddressResponse(rsp)
}

// LinkPhysicalAddressWithBodyWithResponse request with arbitrary body returning *LinkPhysicalAddressResponse
func (c *ClientWithResponses) LinkPhysicalAddressWithBodyWithResponse(ctx context.Context, repository string, branch string, params *LinkPhysicalAddressParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkPhysicalAddressResponse, error) {
	rsp, err := c.LinkPhysicalAddressWithBody(ctx, repository, branch, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkPhysicalAddressResponse(rsp)
}

func (c *ClientWithResponses) LinkPhysicalAddressWithResponse(ctx context.Context, repository string, branch string, params *LinkPhysicalAddressParams, body LinkPhysicalAddressJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkPhysicalAddressResponse, error) {
	rsp, err := c.LinkPhysicalAddress(ctx, repository, branch, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkPhysicalAddressResponse(rsp)
}

// CreatePresignMultipartUploadWithResponse request returning *CreatePresignMultipartUploadResponse
func (c *ClientWithResponses) CreatePresignMultipartUploadWithResponse(ctx context.Context, repository string, branch string, params *CreatePresignMultipartUploadParams, reqEditors ...RequestEditorFn) (*CreatePresignMultipartUploadResponse, error) {
	rsp, err := c.CreatePresignMultipartUpload(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePresignMultipartUploadResponse(rsp)
}

// AbortPresignMultipartUploadWithBodyWithResponse request with arbitrary body returning *AbortPresignMultipartUploadResponse
func (c *ClientWithResponses) AbortPresignMultipartUploadWithBodyWithResponse(ctx context.Context, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AbortPresignMultipartUploadResponse, error) {
	rsp, err := c.AbortPresignMultipartUploadWithBody(ctx, repository, branch, uploadId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAbortPresignMultipartUploadResponse(rsp)
}

func (c *ClientWithResponses) AbortPresignMultipartUploadWithResponse(ctx context.Context, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, body AbortPresignMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*AbortPresignMultipartUploadResponse, error) {
	rsp, err := c.AbortPresignMultipartUpload(ctx, repository, branch, uploadId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAbortPresignMultipartUploadResponse(rsp)
}

// CompletePresignMultipartUploadWithBodyWithResponse request with arbitrary body returning *CompletePresignMultipartUploadResponse
func (c *ClientWithResponses) CompletePresignMultipartUploadWithBodyWithResponse(ctx context.Context, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompletePresignMultipartUploadResponse, error) {
	rsp, err := c.CompletePresignMultipartUploadWithBody(ctx, repository, branch, uploadId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompletePresignMultipartUploadResponse(rsp)
}

func (c *ClientWithResponses) CompletePresignMultipartUploadWithResponse(ctx context.Context, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, body CompletePresignMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*CompletePresignMultipartUploadResponse, error) {
	rsp, err := c.CompletePresignMultipartUpload(ctx, repository, branch, uploadId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompletePresignMultipartUploadResponse(rsp)
}

// UploadPartWithBodyWithResponse request with arbitrary body returning *UploadPartResponse
func (c *ClientWithResponses) UploadPartWithBodyWithResponse(ctx context.Context, repository string, branch string, uploadId string, partNumber int, params *UploadPartParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadPartResponse, error) {
	rsp, err := c.UploadPartWithBody(ctx, repository, branch, uploadId, partNumber, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadPartResponse(rsp)
}

func (c *ClientWithResponses) UploadPartWithResponse(ctx context.Context, repository string, branch string, uploadId string, partNumber int, params *UploadPartParams, body UploadPartJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadPartResponse, error) {
	rsp, err := c.UploadPart(ctx, repository, branch, uploadId, partNumber, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadPartResponse(rsp)
}

// UploadPartCopyWithBodyWithResponse request with arbitrary body returning *UploadPartCopyResponse
func (c *ClientWithResponses) UploadPartCopyWithBodyWithResponse(ctx context.Context, repository string, branch string, uploadId string, partNumber int, params *UploadPartCopyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadPartCopyResponse, error) {
	rsp, err := c.UploadPartCopyWithBody(ctx, repository, branch, uploadId, partNumber, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadPartCopyResponse(rsp)
}

func (c *ClientWithResponses) UploadPartCopyWithResponse(ctx context.Context, repository string, branch string, uploadId string, partNumber int, params *UploadPartCopyParams, body UploadPartCopyJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadPartCopyResponse, error) {
	rsp, err := c.UploadPartCopy(ctx, repository, branch, uploadId, partNumber, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadPartCopyResponse(rsp)
}

// CreateCommitRecordWithBodyWithResponse request with arbitrary body returning *CreateCommitRecordResponse
func (c *ClientWithResponses) CreateCommitRecordWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCommitRecordResponse, error) {
	rsp, err := c.CreateCommitRecordWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCommitRecordResponse(rsp)
}

func (c *ClientWithResponses) CreateCommitRecordWithResponse(ctx context.Context, repository string, body CreateCommitRecordJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCommitRecordResponse, error) {
	rsp, err := c.CreateCommitRecord(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCommitRecordResponse(rsp)
}

// GetCommitWithResponse request returning *GetCommitResponse
func (c *ClientWithResponses) GetCommitWithResponse(ctx context.Context, repository string, commitId string, reqEditors ...RequestEditorFn) (*GetCommitResponse, error) {
	rsp, err := c.GetCommit(ctx, repository, commitId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCommitResponse(rsp)
}

// DumpStatusWithResponse request returning *DumpStatusResponse
func (c *ClientWithResponses) DumpStatusWithResponse(ctx context.Context, repository string, params *DumpStatusParams, reqEditors ...RequestEditorFn) (*DumpStatusResponse, error) {
	rsp, err := c.DumpStatus(ctx, repository, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDumpStatusResponse(rsp)
}

// DumpSubmitWithResponse request returning *DumpSubmitResponse
func (c *ClientWithResponses) DumpSubmitWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*DumpSubmitResponse, error) {
	rsp, err := c.DumpSubmit(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDumpSubmitResponse(rsp)
}

// PrepareGarbageCollectionCommitsWithResponse request returning *PrepareGarbageCollectionCommitsResponse
func (c *ClientWithResponses) PrepareGarbageCollectionCommitsWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*PrepareGarbageCollectionCommitsResponse, error) {
	rsp, err := c.PrepareGarbageCollectionCommits(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareGarbageCollectionCommitsResponse(rsp)
}

// PrepareGarbageCollectionCommitsAsyncWithResponse request returning *PrepareGarbageCollectionCommitsAsyncResponse
func (c *ClientWithResponses) PrepareGarbageCollectionCommitsAsyncWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*PrepareGarbageCollectionCommitsAsyncResponse, error) {
	rsp, err := c.PrepareGarbageCollectionCommitsAsync(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareGarbageCollectionCommitsAsyncResponse(rsp)
}

// PrepareGarbageCollectionCommitsStatusWithResponse request returning *PrepareGarbageCollectionCommitsStatusResponse
func (c *ClientWithResponses) PrepareGarbageCollectionCommitsStatusWithResponse(ctx context.Context, repository string, params *PrepareGarbageCollectionCommitsStatusParams, reqEditors ...RequestEditorFn) (*PrepareGarbageCollectionCommitsStatusResponse, error) {
	rsp, err := c.PrepareGarbageCollectionCommitsStatus(ctx, repository, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareGarbageCollectionCommitsStatusResponse(rsp)
}

// PrepareGarbageCollectionUncommittedWithBodyWithResponse request with arbitrary body returning *PrepareGarbageCollectionUncommittedResponse
func (c *ClientWithResponses) PrepareGarbageCollectionUncommittedWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrepareGarbageCollectionUncommittedResponse, error) {
	rsp, err := c.PrepareGarbageCollectionUncommittedWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareGarbageCollectionUncommittedResponse(rsp)
}

func (c *ClientWithResponses) PrepareGarbageCollectionUncommittedWithResponse(ctx context.Context, repository string, body PrepareGarbageCollectionUncommittedJSONRequestBody, reqEditors ...RequestEditorFn) (*PrepareGarbageCollectionUncommittedResponse, error) {
	rsp, err := c.PrepareGarbageCollectionUncommitted(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareGarbageCollectionUncommittedResponse(rsp)
}

// InternalDeleteGarbageCollectionRulesWithResponse request returning *InternalDeleteGarbageCollectionRulesResponse
func (c *ClientWithResponses) InternalDeleteGarbageCollectionRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*InternalDeleteGarbageCollectionRulesResponse, error) {
	rsp, err := c.InternalDeleteGarbageCollectionRules(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalDeleteGarbageCollectionRulesResponse(rsp)
}

// InternalGetGarbageCollectionRulesWithResponse request returning *InternalGetGarbageCollectionRulesResponse
func (c *ClientWithResponses) InternalGetGarbageCollectionRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*InternalGetGarbageCollectionRulesResponse, error) {
	rsp, err := c.InternalGetGarbageCollectionRules(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalGetGarbageCollectionRulesResponse(rsp)
}

// InternalSetGarbageCollectionRulesWithBodyWithResponse request with arbitrary body returning *InternalSetGarbageCollectionRulesResponse
func (c *ClientWithResponses) InternalSetGarbageCollectionRulesWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalSetGarbageCollectionRulesResponse, error) {
	rsp, err := c.InternalSetGarbageCollectionRulesWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalSetGarbageCollectionRulesResponse(rsp)
}

func (c *ClientWithResponses) InternalSetGarbageCollectionRulesWithResponse(ctx context.Context, repository string, body InternalSetGarbageCollectionRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalSetGarbageCollectionRulesResponse, error) {
	rsp, err := c.InternalSetGarbageCollectionRules(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalSetGarbageCollectionRulesResponse(rsp)
}

// SetGarbageCollectionRulesPreflightWithResponse request returning *SetGarbageCollectionRulesPreflightResponse
func (c *ClientWithResponses) SetGarbageCollectionRulesPreflightWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*SetGarbageCollectionRulesPreflightResponse, error) {
	rsp, err := c.SetGarbageCollectionRulesPreflight(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetGarbageCollectionRulesPreflightResponse(rsp)
}

// DeleteRepositoryMetadataWithBodyWithResponse request with arbitrary body returning *DeleteRepositoryMetadataResponse
func (c *ClientWithResponses) DeleteRepositoryMetadataWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteRepositoryMetadataResponse, error) {
	rsp, err := c.DeleteRepositoryMetadataWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRepositoryMetadataResponse(rsp)
}

func (c *ClientWithResponses) DeleteRepositoryMetadataWithResponse(ctx context.Context, repository string, body DeleteRepositoryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteRepositoryMetadataResponse, error) {
	rsp, err := c.DeleteRepositoryMetadata(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRepositoryMetadataResponse(rsp)
}

// GetRepositoryMetadataWithResponse request returning *GetRepositoryMetadataResponse
func (c *ClientWithResponses) GetRepositoryMetadataWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*GetRepositoryMetadataResponse, error) {
	rsp, err := c.GetRepositoryMetadata(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRepositoryMetadataResponse(rsp)
}

// SetRepositoryMetadataWithBodyWithResponse request with arbitrary body returning *SetRepositoryMetadataResponse
func (c *ClientWithResponses) SetRepositoryMetadataWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetRepositoryMetadataResponse, error) {
	rsp, err := c.SetRepositoryMetadataWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRepositoryMetadataResponse(rsp)
}

func (c *ClientWithResponses) SetRepositoryMetadataWithResponse(ctx context.Context, repository string, body SetRepositoryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*SetRepositoryMetadataResponse, error) {
	rsp, err := c.SetRepositoryMetadata(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRepositoryMetadataResponse(rsp)
}

// GetMetaRangeWithResponse request returning *GetMetaRangeResponse
func (c *ClientWithResponses) GetMetaRangeWithResponse(ctx context.Context, repository string, metaRange string, reqEditors ...RequestEditorFn) (*GetMetaRangeResponse, error) {
	rsp, err := c.GetMetaRange(ctx, repository, metaRange, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMetaRangeResponse(rsp)
}

// GetMetadataObjectWithResponse request returning *GetMetadataObjectResponse
func (c *ClientWithResponses) GetMetadataObjectWithResponse(ctx context.Context, repository string, pType string, objectId string, params *GetMetadataObjectParams, reqEditors ...RequestEditorFn) (*GetMetadataObjectResponse, error) {
	rsp, err := c.GetMetadataObject(ctx, repository, pType, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMetadataObjectResponse(rsp)
}

// GetRangeWithResponse request returning *GetRangeResponse
func (c *ClientWithResponses) GetRangeWithResponse(ctx context.Context, repository string, pRange string, reqEditors ...RequestEditorFn) (*GetRangeResponse, error) {
	rsp, err := c.GetRange(ctx, repository, pRange, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRangeResponse(rsp)
}

// ListPullRequestsWithResponse request returning *ListPullRequestsResponse
func (c *ClientWithResponses) ListPullRequestsWithResponse(ctx context.Context, repository string, params *ListPullRequestsParams, reqEditors ...RequestEditorFn) (*ListPullRequestsResponse, error) {
	rsp, err := c.ListPullRequests(ctx, repository, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPullRequestsResponse(rsp)
}

// CreatePullRequestWithBodyWithResponse request with arbitrary body returning *CreatePullRequestResponse
func (c *ClientWithResponses) CreatePullRequestWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePullRequestResponse, error) {
	rsp, err := c.CreatePullRequestWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePullRequestResponse(rsp)
}

func (c *ClientWithResponses) CreatePullRequestWithResponse(ctx context.Context, repository string, body CreatePullRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePullRequestResponse, error) {
	rsp, err := c.CreatePullRequest(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePullRequestResponse(rsp)
}

// GetPullRequestWithResponse request returning *GetPullRequestResponse
func (c *ClientWithResponses) GetPullRequestWithResponse(ctx context.Context, repository string, pullRequest string, reqEditors ...RequestEditorFn) (*GetPullRequestResponse, error) {
	rsp, err := c.GetPullRequest(ctx, repository, pullRequest, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPullRequestResponse(rsp)
}

// UpdatePullRequestWithBodyWithResponse request with arbitrary body returning *UpdatePullRequestResponse
func (c *ClientWithResponses) UpdatePullRequestWithBodyWithResponse(ctx context.Context, repository string, pullRequest string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePullRequestResponse, error) {
	rsp, err := c.UpdatePullRequestWithBody(ctx, repository, pullRequest, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePullRequestResponse(rsp)
}

func (c *ClientWithResponses) UpdatePullRequestWithResponse(ctx context.Context, repository string, pullRequest string, body UpdatePullRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePullRequestResponse, error) {
	rsp, err := c.UpdatePullRequest(ctx, repository, pullRequest, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePullRequestResponse(rsp)
}

// MergePullRequestWithResponse request returning *MergePullRequestResponse
func (c *ClientWithResponses) MergePullRequestWithResponse(ctx context.Context, repository string, pullRequest string, reqEditors ...RequestEditorFn) (*MergePullRequestResponse, error) {
	rsp, err := c.MergePullRequest(ctx, repository, pullRequest, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergePullRequestResponse(rsp)
}

// DumpRefsWithResponse request returning *DumpRefsResponse
func (c *ClientWithResponses) DumpRefsWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*DumpRefsResponse, error) {
	rsp, err := c.DumpRefs(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDumpRefsResponse(rsp)
}

// RestoreRefsWithBodyWithResponse request with arbitrary body returning *RestoreRefsResponse
func (c *ClientWithResponses) RestoreRefsWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestoreRefsResponse, error) {
	rsp, err := c.RestoreRefsWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreRefsResponse(rsp)
}

func (c *ClientWithResponses) RestoreRefsWithResponse(ctx context.Context, repository string, body RestoreRefsJSONRequestBody, reqEditors ...RequestEditorFn) (*RestoreRefsResponse, error) {
	rsp, err := c.RestoreRefs(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreRefsResponse(rsp)
}

// CreateSymlinkFileWithResponse request returning *CreateSymlinkFileResponse
func (c *ClientWithResponses) CreateSymlinkFileWithResponse(ctx context.Context, repository string, branch string, params *CreateSymlinkFileParams, reqEditors ...RequestEditorFn) (*CreateSymlinkFileResponse, error) {
	rsp, err := c.CreateSymlinkFile(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSymlinkFileResponse(rsp)
}

// DiffRefsWithResponse request returning *DiffRefsResponse
func (c *ClientWithResponses) DiffRefsWithResponse(ctx context.Context, repository string, leftRef string, rightRef string, params *DiffRefsParams, reqEditors ...RequestEditorFn) (*DiffRefsResponse, error) {
	rsp, err := c.DiffRefs(ctx, repository, leftRef, rightRef, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDiffRefsResponse(rsp)
}

// LogCommitsWithResponse request returning *LogCommitsResponse
func (c *ClientWithResponses) LogCommitsWithResponse(ctx context.Context, repository string, ref string, params *LogCommitsParams, reqEditors ...RequestEditorFn) (*LogCommitsResponse, error) {
	rsp, err := c.LogCommits(ctx, repository, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogCommitsResponse(rsp)
}

// GetObjectWithResponse request returning *GetObjectResponse
func (c *ClientWithResponses) GetObjectWithResponse(ctx context.Context, repository string, ref string, params *GetObjectParams, reqEditors ...RequestEditorFn) (*GetObjectResponse, error) {
	rsp, err := c.GetObject(ctx, repository, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetObjectResponse(rsp)
}

// HeadObjectWithResponse request returning *HeadObjectResponse
func (c *ClientWithResponses) HeadObjectWithResponse(ctx context.Context, repository string, ref string, params *HeadObjectParams, reqEditors ...RequestEditorFn) (*HeadObjectResponse, error) {
	rsp, err := c.HeadObject(ctx, repository, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeadObjectResponse(rsp)
}

// ListObjectsWithResponse request returning *ListObjectsResponse
func (c *ClientWithResponses) ListObjectsWithResponse(ctx context.Context, repository string, ref string, params *ListObjectsParams, reqEditors ...RequestEditorFn) (*ListObjectsResponse, error) {
	rsp, err := c.ListObjects(ctx, repository, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListObjectsResponse(rsp)
}

// StatObjectWithResponse request returning *StatObjectResponse
func (c *ClientWithResponses) StatObjectWithResponse(ctx context.Context, repository string, ref string, params *StatObjectParams, reqEditors ...RequestEditorFn) (*StatObjectResponse, error) {
	rsp, err := c.StatObject(ctx, repository, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatObjectResponse(rsp)
}

// GetUnderlyingPropertiesWithResponse request returning *GetUnderlyingPropertiesResponse
func (c *ClientWithResponses) GetUnderlyingPropertiesWithResponse(ctx context.Context, repository string, ref string, params *GetUnderlyingPropertiesParams, reqEditors ...RequestEditorFn) (*GetUnderlyingPropertiesResponse, error) {
	rsp, err := c.GetUnderlyingProperties(ctx, repository, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUnderlyingPropertiesResponse(rsp)
}

// FindMergeBaseWithResponse request returning *FindMergeBaseResponse
func (c *ClientWithResponses) FindMergeBaseWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, reqEditors ...RequestEditorFn) (*FindMergeBaseResponse, error) {
	rsp, err := c.FindMergeBase(ctx, repository, sourceRef, destinationBranch, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindMergeBaseResponse(rsp)
}

// MergeIntoBranchWithBodyWithResponse request with arbitrary body returning *MergeIntoBranchResponse
func (c *ClientWithResponses) MergeIntoBranchWithBodyWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeIntoBranchResponse, error) {
	rsp, err := c.MergeIntoBranchWithBody(ctx, repository, sourceRef, destinationBranch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeIntoBranchResponse(rsp)
}

func (c *ClientWithResponses) MergeIntoBranchWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, body MergeIntoBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeIntoBranchResponse, error) {
	rsp, err := c.MergeIntoBranch(ctx, repository, sourceRef, destinationBranch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeIntoBranchResponse(rsp)
}

// MergeIntoBranchAsyncWithBodyWithResponse request with arbitrary body returning *MergeIntoBranchAsyncResponse
func (c *ClientWithResponses) MergeIntoBranchAsyncWithBodyWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeIntoBranchAsyncResponse, error) {
	rsp, err := c.MergeIntoBranchAsyncWithBody(ctx, repository, sourceRef, destinationBranch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeIntoBranchAsyncResponse(rsp)
}

func (c *ClientWithResponses) MergeIntoBranchAsyncWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, body MergeIntoBranchAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeIntoBranchAsyncResponse, error) {
	rsp, err := c.MergeIntoBranchAsync(ctx, repository, sourceRef, destinationBranch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeIntoBranchAsyncResponse(rsp)
}

// MergeIntoBranchAsyncStatusWithResponse request returning *MergeIntoBranchAsyncStatusResponse
func (c *ClientWithResponses) MergeIntoBranchAsyncStatusWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, id string, reqEditors ...RequestEditorFn) (*MergeIntoBranchAsyncStatusResponse, error) {
	rsp, err := c.MergeIntoBranchAsyncStatus(ctx, repository, sourceRef, destinationBranch, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeIntoBranchAsyncStatusResponse(rsp)
}

// RestoreStatusWithResponse request returning *RestoreStatusResponse
func (c *ClientWithResponses) RestoreStatusWithResponse(ctx context.Context, repository string, params *RestoreStatusParams, reqEditors ...RequestEditorFn) (*RestoreStatusResponse, error) {
	rsp, err := c.RestoreStatus(ctx, repository, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreStatusResponse(rsp)
}

// RestoreSubmitWithBodyWithResponse request with arbitrary body returning *RestoreSubmitResponse
func (c *ClientWithResponses) RestoreSubmitWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestoreSubmitResponse, error) {
	rsp, err := c.RestoreSubmitWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreSubmitResponse(rsp)
}

func (c *ClientWithResponses) RestoreSubmitWithResponse(ctx context.Context, repository string, body RestoreSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*RestoreSubmitResponse, error) {
	rsp, err := c.RestoreSubmit(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreSubmitResponse(rsp)
}

// GetBranchProtectionRulesWithResponse request returning *GetBranchProtectionRulesResponse
func (c *ClientWithResponses) GetBranchProtectionRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*GetBranchProtectionRulesResponse, error) {
	rsp, err := c.GetBranchProtectionRules(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBranchProtectionRulesResponse(rsp)
}

// SetBranchProtectionRulesWithBodyWithResponse request with arbitrary body returning *SetBranchProtectionRulesResponse
func (c *ClientWithResponses) SetBranchProtectionRulesWithBodyWithResponse(ctx context.Context, repository string, params *SetBranchProtectionRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetBranchProtectionRulesResponse, error) {
	rsp, err := c.SetBranchProtectionRulesWithBody(ctx, repository, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetBranchProtectionRulesResponse(rsp)
}

func (c *ClientWithResponses) SetBranchProtectionRulesWithResponse(ctx context.Context, repository string, params *SetBranchProtectionRulesParams, body SetBranchProtectionRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetBranchProtectionRulesResponse, error) {
	rsp, err := c.SetBranchProtectionRules(ctx, repository, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetBranchProtectionRulesResponse(rsp)
}

// DeleteGCRulesWithResponse request returning *DeleteGCRulesResponse
func (c *ClientWithResponses) DeleteGCRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*DeleteGCRulesResponse, error) {
	rsp, err := c.DeleteGCRules(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGCRulesResponse(rsp)
}

// GetGCRulesWithResponse request returning *GetGCRulesResponse
func (c *ClientWithResponses) GetGCRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*GetGCRulesResponse, error) {
	rsp, err := c.GetGCRules(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGCRulesResponse(rsp)
}

// SetGCRulesWithBodyWithResponse request with arbitrary body returning *SetGCRulesResponse
func (c *ClientWithResponses) SetGCRulesWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetGCRulesResponse, error) {
	rsp, err := c.SetGCRulesWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetGCRulesResponse(rsp)
}

func (c *ClientWithResponses) SetGCRulesWithResponse(ctx context.Context, repository string, body SetGCRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetGCRulesResponse, error) {
	rsp, err := c.SetGCRules(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetGCRulesResponse(rsp)
}

// ListTagsWithResponse request returning *ListTagsResponse
func (c *ClientWithResponses) ListTagsWithResponse(ctx context.Context, repository string, params *ListTagsParams, reqEditors ...RequestEditorFn) (*ListTagsResponse, error) {
	rsp, err := c.ListTags(ctx, repository, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTagsResponse(rsp)
}

// CreateTagWithBodyWithResponse request with arbitrary body returning *CreateTagResponse
func (c *ClientWithResponses) CreateTagWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTagResponse, error) {
	rsp, err := c.CreateTagWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTagResponse(rsp)
}

func (c *ClientWithResponses) CreateTagWithResponse(ctx context.Context, repository string, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTagResponse, error) {
	rsp, err := c.CreateTag(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTagResponse(rsp)
}

// DeleteTagWithResponse request returning *DeleteTagResponse
func (c *ClientWithResponses) DeleteTagWithResponse(ctx context.Context, repository string, tag string, params *DeleteTagParams, reqEditors ...RequestEditorFn) (*DeleteTagResponse, error) {
	rsp, err := c.DeleteTag(ctx, repository, tag, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTagResponse(rsp)
}

// GetTagWithResponse request returning *GetTagResponse
func (c *ClientWithResponses) GetTagWithResponse(ctx context.Context, repository string, tag string, reqEditors ...RequestEditorFn) (*GetTagResponse, error) {
	rsp, err := c.GetTag(ctx, repository, tag, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTagResponse(rsp)
}

// SetupCommPrefsWithBodyWithResponse request with arbitrary body returning *SetupCommPrefsResponse
func (c *ClientWithResponses) SetupCommPrefsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetupCommPrefsResponse, error) {
	rsp, err := c.SetupCommPrefsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetupCommPrefsResponse(rsp)
}

func (c *ClientWithResponses) SetupCommPrefsWithResponse(ctx context.Context, body SetupCommPrefsJSONRequestBody, reqEditors ...RequestEditorFn) (*SetupCommPrefsResponse, error) {
	rsp, err := c.SetupCommPrefs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetupCommPrefsResponse(rsp)
}

// GetSetupStateWithResponse request returning *GetSetupStateResponse
func (c *ClientWithResponses) GetSetupStateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSetupStateResponse, error) {
	rsp, err := c.GetSetupState(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSetupStateResponse(rsp)
}

// SetupWithBodyWithResponse request with arbitrary body returning *SetupResponse
func (c *ClientWithResponses) SetupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetupResponse, error) {
	rsp, err := c.SetupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetupResponse(rsp)
}

func (c *ClientWithResponses) SetupWithResponse(ctx context.Context, body SetupJSONRequestBody, reqEditors ...RequestEditorFn) (*SetupResponse, error) {
	rsp, err := c.Setup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetupResponse(rsp)
}

// PostStatsEventsWithBodyWithResponse request with arbitrary body returning *PostStatsEventsResponse
func (c *ClientWithResponses) PostStatsEventsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStatsEventsResponse, error) {
	rsp, err := c.PostStatsEventsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStatsEventsResponse(rsp)
}

func (c *ClientWithResponses) PostStatsEventsWithResponse(ctx context.Context, body PostStatsEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStatsEventsResponse, error) {
	rsp, err := c.PostStatsEvents(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStatsEventsResponse(rsp)
}

// StsLoginWithBodyWithResponse request with arbitrary body returning *StsLoginResponse
func (c *ClientWithResponses) StsLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StsLoginResponse, error) {
	rsp, err := c.StsLoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStsLoginResponse(rsp)
}

func (c *ClientWithResponses) StsLoginWithResponse(ctx context.Context, body StsLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*StsLoginResponse, error) {
	rsp, err := c.StsLogin(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStsLoginResponse(rsp)
}

// GetUsageReportSummaryWithResponse request returning *GetUsageReportSummaryResponse
func (c *ClientWithResponses) GetUsageReportSummaryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUsageReportSummaryResponse, error) {
	rsp, err := c.GetUsageReportSummary(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsageReportSummaryResponse(rsp)
}

// GetCurrentUserWithResponse request returning *GetCurrentUserResponse
func (c *ClientWithResponses) GetCurrentUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentUserResponse, error) {
	rsp, err := c.GetCurrentUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentUserResponse(rsp)
}

// ParseGetAuthCapabilitiesResponse parses an HTTP response from a GetAuthCapabilitiesWithResponse call
func ParseGetAuthCapabilitiesResponse(rsp *http.Response) (*GetAuthCapabilitiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetAuthCapabilitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthCapabilities
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseExternalPrincipalLoginResponse parses an HTTP response from a ExternalPrincipalLoginWithResponse call
func ParseExternalPrincipalLoginResponse(rsp *http.Response) (*ExternalPrincipalLoginResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ExternalPrincipalLoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthenticationToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetExternalPrincipalResponse parses an HTTP response from a GetExternalPrincipalWithResponse call
func ParseGetExternalPrincipalResponse(rsp *http.Response) (*GetExternalPrincipalResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetExternalPrincipalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExternalPrincipal
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTokenFromMailboxResponse parses an HTTP response from a GetTokenFromMailboxWithResponse call
func ParseGetTokenFromMailboxResponse(rsp *http.Response) (*GetTokenFromMailboxResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetTokenFromMailboxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthenticationToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReleaseTokenToMailboxResponse parses an HTTP response from a ReleaseTokenToMailboxWithResponse call
func ParseReleaseTokenToMailboxResponse(rsp *http.Response) (*ReleaseTokenToMailboxResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ReleaseTokenToMailboxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTokenRedirectResponse parses an HTTP response from a GetTokenRedirectWithResponse call
func ParseGetTokenRedirectResponse(rsp *http.Response) (*GetTokenRedirectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetTokenRedirectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListGroupsResponse parses an HTTP response from a ListGroupsWithResponse call
func ParseListGroupsResponse(rsp *http.Response) (*ListGroupsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateGroupResponse parses an HTTP response from a CreateGroupWithResponse call
func ParseCreateGroupResponse(rsp *http.Response) (*CreateGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteGroupResponse parses an HTTP response from a DeleteGroupWithResponse call
func ParseDeleteGroupResponse(rsp *http.Response) (*DeleteGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetGroupResponse parses an HTTP response from a GetGroupWithResponse call
func ParseGetGroupResponse(rsp *http.Response) (*GetGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetGroupACLResponse parses an HTTP response from a GetGroupACLWithResponse call
func ParseGetGroupACLResponse(rsp *http.Response) (*GetGroupACLResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetGroupACLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ACL
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNoACL
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetGroupACLResponse parses an HTTP response from a SetGroupACLWithResponse call
func ParseSetGroupACLResponse(rsp *http.Response) (*SetGroupACLResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SetGroupACLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListGroupMembersResponse parses an HTTP response from a ListGroupMembersWithResponse call
func ParseListGroupMembersResponse(rsp *http.Response) (*ListGroupMembersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListGroupMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteGroupMembershipResponse parses an HTTP response from a DeleteGroupMembershipWithResponse call
func ParseDeleteGroupMembershipResponse(rsp *http.Response) (*DeleteGroupMembershipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupMembershipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddGroupMembershipResponse parses an HTTP response from a AddGroupMembershipWithResponse call
func ParseAddGroupMembershipResponse(rsp *http.Response) (*AddGroupMembershipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AddGroupMembershipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListGroupPoliciesResponse parses an HTTP response from a ListGroupPoliciesWithResponse call
func ParseListGroupPoliciesResponse(rsp *http.Response) (*ListGroupPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListGroupPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDetachPolicyFromGroupResponse parses an HTTP response from a DetachPolicyFromGroupWithResponse call
func ParseDetachPolicyFromGroupResponse(rsp *http.Response) (*DetachPolicyFromGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DetachPolicyFromGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAttachPolicyToGroupResponse parses an HTTP response from a AttachPolicyToGroupWithResponse call
func ParseAttachPolicyToGroupResponse(rsp *http.Response) (*AttachPolicyToGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AttachPolicyToGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseLoginResponse parses an HTTP response from a LoginWithResponse call
func ParseLoginResponse(rsp *http.Response) (*LoginResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &LoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthenticationToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListPoliciesResponse parses an HTTP response from a ListPoliciesWithResponse call
func ParseListPoliciesResponse(rsp *http.Response) (*ListPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreatePolicyResponse parses an HTTP response from a CreatePolicyWithResponse call
func ParseCreatePolicyResponse(rsp *http.Response) (*CreatePolicyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreatePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeletePolicyResponse parses an HTTP response from a DeletePolicyWithResponse call
func ParseDeletePolicyResponse(rsp *http.Response) (*DeletePolicyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeletePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPolicyResponse parses an HTTP response from a GetPolicyWithResponse call
func ParseGetPolicyResponse(rsp *http.Response) (*GetPolicyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdatePolicyResponse parses an HTTP response from a UpdatePolicyWithResponse call
func ParseUpdatePolicyResponse(rsp *http.Response) (*UpdatePolicyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdatePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListUsersResponse parses an HTTP response from a ListUsersWithResponse call
func ParseListUsersResponse(rsp *http.Response) (*ListUsersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateUserResponse parses an HTTP response from a CreateUserWithResponse call
func ParseCreateUserResponse(rsp *http.Response) (*CreateUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListUserCredentialsResponse parses an HTTP response from a ListUserCredentialsWithResponse call
func ParseListUserCredentialsResponse(rsp *http.Response) (*ListUserCredentialsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListUserCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CredentialsList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateCredentialsResponse parses an HTTP response from a CreateCredentialsWithResponse call
func ParseCreateCredentialsResponse(rsp *http.Response) (*CreateCredentialsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CredentialsWithSecret
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteCredentialsResponse parses an HTTP response from a DeleteCredentialsWithResponse call
func ParseDeleteCredentialsResponse(rsp *http.Response) (*DeleteCredentialsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCredentialsResponse parses an HTTP response from a GetCredentialsWithResponse call
func ParseGetCredentialsResponse(rsp *http.Response) (*GetCredentialsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Credentials
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteUserExternalPrincipalResponse parses an HTTP response from a DeleteUserExternalPrincipalWithResponse call
func ParseDeleteUserExternalPrincipalResponse(rsp *http.Response) (*DeleteUserExternalPrincipalResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserExternalPrincipalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateUserExternalPrincipalResponse parses an HTTP response from a CreateUserExternalPrincipalWithResponse call
func ParseCreateUserExternalPrincipalResponse(rsp *http.Response) (*CreateUserExternalPrincipalResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateUserExternalPrincipalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListUserExternalPrincipalsResponse parses an HTTP response from a ListUserExternalPrincipalsWithResponse call
func ParseListUserExternalPrincipalsResponse(rsp *http.Response) (*ListUserExternalPrincipalsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListUserExternalPrincipalsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExternalPrincipalList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListUserGroupsResponse parses an HTTP response from a ListUserGroupsWithResponse call
func ParseListUserGroupsResponse(rsp *http.Response) (*ListUserGroupsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListUserGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListUserPoliciesResponse parses an HTTP response from a ListUserPoliciesWithResponse call
func ParseListUserPoliciesResponse(rsp *http.Response) (*ListUserPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListUserPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDetachPolicyFromUserResponse parses an HTTP response from a DetachPolicyFromUserWithResponse call
func ParseDetachPolicyFromUserResponse(rsp *http.Response) (*DetachPolicyFromUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DetachPolicyFromUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAttachPolicyToUserResponse parses an HTTP response from a AttachPolicyToUserWithResponse call
func ParseAttachPolicyToUserResponse(rsp *http.Response) (*AttachPolicyToUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AttachPolicyToUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetConfigResponse parses an HTTP response from a GetConfigWithResponse call
func ParseGetConfigResponse(rsp *http.Response) (*GetConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Config
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetGarbageCollectionConfigResponse parses an HTTP response from a GetGarbageCollectionConfigWithResponse call
func ParseGetGarbageCollectionConfigResponse(rsp *http.Response) (*GetGarbageCollectionConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetGarbageCollectionConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GarbageCollectionConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetStorageConfigResponse parses an HTTP response from a GetStorageConfigWithResponse call
func ParseGetStorageConfigResponse(rsp *http.Response) (*GetStorageConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetStorageConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StorageConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetLakeFSVersionResponse parses an HTTP response from a GetLakeFSVersionWithResponse call
func ParseGetLakeFSVersionResponse(rsp *http.Response) (*GetLakeFSVersionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetLakeFSVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VersionConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseHealthCheckResponse parses an HTTP response from a HealthCheckWithResponse call
func ParseHealthCheckResponse(rsp *http.Response) (*HealthCheckResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &HealthCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParsePullIcebergTableResponse parses an HTTP response from a PullIcebergTableWithResponse call
func ParsePullIcebergTableResponse(rsp *http.Response) (*PullIcebergTableResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PullIcebergTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePushIcebergTableResponse parses an HTTP response from a PushIcebergTableWithResponse call
func ParsePushIcebergTableResponse(rsp *http.Response) (*PushIcebergTableResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PushIcebergTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLicenseResponse parses an HTTP response from a GetLicenseWithResponse call
func ParseGetLicenseResponse(rsp *http.Response) (*GetLicenseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetLicenseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest License
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOauthCallbackResponse parses an HTTP response from a OauthCallbackWithResponse call
func ParseOauthCallbackResponse(rsp *http.Response) (*OauthCallbackResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &OauthCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListRepositoriesResponse parses an HTTP response from a ListRepositoriesWithResponse call
func ParseListRepositoriesResponse(rsp *http.Response) (*ListRepositoriesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListRepositoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RepositoryList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateRepositoryResponse parses an HTTP response from a CreateRepositoryWithResponse call
func ParseCreateRepositoryResponse(rsp *http.Response) (*CreateRepositoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Repository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteRepositoryResponse parses an HTTP response from a DeleteRepositoryWithResponse call
func ParseDeleteRepositoryResponse(rsp *http.Response) (*DeleteRepositoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRepositoryResponse parses an HTTP response from a GetRepositoryWithResponse call
func ParseGetRepositoryResponse(rsp *http.Response) (*GetRepositoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Repository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListRepositoryRunsResponse parses an HTTP response from a ListRepositoryRunsWithResponse call
func ParseListRepositoryRunsResponse(rsp *http.Response) (*ListRepositoryRunsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListRepositoryRunsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionRunList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRunResponse parses an HTTP response from a GetRunWithResponse call
func ParseGetRunResponse(rsp *http.Response) (*GetRunResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListRunHooksResponse parses an HTTP response from a ListRunHooksWithResponse call
func ParseListRunHooksResponse(rsp *http.Response) (*ListRunHooksResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListRunHooksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HookRunList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRunHookOutputResponse parses an HTTP response from a GetRunHookOutputWithResponse call
func ParseGetRunHookOutputResponse(rsp *http.Response) (*GetRunHookOutputResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetRunHookOutputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInternalDeleteBranchProtectionRuleResponse parses an HTTP response from a InternalDeleteBranchProtectionRuleWithResponse call
func ParseInternalDeleteBranchProtectionRuleResponse(rsp *http.Response) (*InternalDeleteBranchProtectionRuleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &InternalDeleteBranchProtectionRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInternalGetBranchProtectionRulesResponse parses an HTTP response from a InternalGetBranchProtectionRulesWithResponse call
func ParseInternalGetBranchProtectionRulesResponse(rsp *http.Response) (*InternalGetBranchProtectionRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &InternalGetBranchProtectionRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []BranchProtectionRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInternalCreateBranchProtectionRuleResponse parses an HTTP response from a InternalCreateBranchProtectionRuleWithResponse call
func ParseInternalCreateBranchProtectionRuleResponse(rsp *http.Response) (*InternalCreateBranchProtectionRuleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &InternalCreateBranchProtectionRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBranchProtectionRulePreflightResponse parses an HTTP response from a CreateBranchProtectionRulePreflightWithResponse call
func ParseCreateBranchProtectionRulePreflightResponse(rsp *http.Response) (*CreateBranchProtectionRulePreflightResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateBranchProtectionRulePreflightResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListBranchesResponse parses an HTTP response from a ListBranchesWithResponse call
func ParseListBranchesResponse(rsp *http.Response) (*ListBranchesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListBranchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RefList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBranchResponse parses an HTTP response from a CreateBranchWithResponse call
func ParseCreateBranchResponse(rsp *http.Response) (*CreateBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteBranchResponse parses an HTTP response from a DeleteBranchWithResponse call
func ParseDeleteBranchResponse(rsp *http.Response) (*DeleteBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBranchResponse parses an HTTP response from a GetBranchWithResponse call
func ParseGetBranchResponse(rsp *http.Response) (*GetBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Ref
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseResetBranchResponse parses an HTTP response from a ResetBranchWithResponse call
func ParseResetBranchResponse(rsp *http.Response) (*ResetBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ResetBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCherryPickResponse parses an HTTP response from a CherryPickWithResponse call
func ParseCherryPickResponse(rsp *http.Response) (*CherryPickResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CherryPickResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Commit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCommitResponse parses an HTTP response from a CommitWithResponse call
func ParseCommitResponse(rsp *http.Response) (*CommitResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CommitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Commit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCommitAsyncResponse parses an HTTP response from a CommitAsyncWithResponse call
func ParseCommitAsyncResponse(rsp *http.Response) (*CommitAsyncResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CommitAsyncResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TaskCreation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCommitAsyncStatusResponse parses an HTTP response from a CommitAsyncStatusWithResponse call
func ParseCommitAsyncStatusResponse(rsp *http.Response) (*CommitAsyncStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CommitAsyncStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommitAsyncStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDiffBranchResponse parses an HTTP response from a DiffBranchWithResponse call
func ParseDiffBranchResponse(rsp *http.Response) (*DiffBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DiffBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DiffList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseHardResetBranchResponse parses an HTTP response from a HardResetBranchWithResponse call
func ParseHardResetBranchResponse(rsp *http.Response) (*HardResetBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &HardResetBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseImportCancelResponse parses an HTTP response from a ImportCancelWithResponse call
func ParseImportCancelResponse(rsp *http.Response) (*ImportCancelResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ImportCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseImportStatusResponse parses an HTTP response from a ImportStatusWithResponse call
func ParseImportStatusResponse(rsp *http.Response) (*ImportStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ImportStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ImportStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseImportStartResponse parses an HTTP response from a ImportStartWithResponse call
func ParseImportStartResponse(rsp *http.Response) (*ImportStartResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ImportStartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ImportCreationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteObjectResponse parses an HTTP response from a DeleteObjectWithResponse call
func ParseDeleteObjectResponse(rsp *http.Response) (*DeleteObjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUploadObjectResponse parses an HTTP response from a UploadObjectWithResponse call
func ParseUploadObjectResponse(rsp *http.Response) (*UploadObjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UploadObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ObjectStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStageObjectResponse parses an HTTP response from a StageObjectWithResponse call
func ParseStageObjectResponse(rsp *http.Response) (*StageObjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &StageObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ObjectStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCopyObjectResponse parses an HTTP response from a CopyObjectWithResponse call
func ParseCopyObjectResponse(rsp *http.Response) (*CopyObjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CopyObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ObjectStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteObjectsResponse parses an HTTP response from a DeleteObjectsWithResponse call
func ParseDeleteObjectsResponse(rsp *http.Response) (*DeleteObjectsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteObjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUploadObjectPreflightResponse parses an HTTP response from a UploadObjectPreflightWithResponse call
func ParseUploadObjectPreflightResponse(rsp *http.Response) (*UploadObjectPreflightResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UploadObjectPreflightResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateObjectUserMetadataResponse parses an HTTP response from a UpdateObjectUserMetadataWithResponse call
func ParseUpdateObjectUserMetadataResponse(rsp *http.Response) (*UpdateObjectUserMetadataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdateObjectUserMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRevertBranchResponse parses an HTTP response from a RevertBranchWithResponse call
func ParseRevertBranchResponse(rsp *http.Response) (*RevertBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &RevertBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPhysicalAddressResponse parses an HTTP response from a GetPhysicalAddressWithResponse call
func ParseGetPhysicalAddressResponse(rsp *http.Response) (*GetPhysicalAddressResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetPhysicalAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StagingLocation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseLinkPhysicalAddressResponse parses an HTTP response from a LinkPhysicalAddressWithResponse call
func ParseLinkPhysicalAddressResponse(rsp *http.Response) (*LinkPhysicalAddressResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &LinkPhysicalAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest StagingLocation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreatePresignMultipartUploadResponse parses an HTTP response from a CreatePresignMultipartUploadWithResponse call
func ParseCreatePresignMultipartUploadResponse(rsp *http.Response) (*CreatePresignMultipartUploadResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreatePresignMultipartUploadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PresignMultipartUpload
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAbortPresignMultipartUploadResponse parses an HTTP response from a AbortPresignMultipartUploadWithResponse call
func ParseAbortPresignMultipartUploadResponse(rsp *http.Response) (*AbortPresignMultipartUploadResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AbortPresignMultipartUploadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCompletePresignMultipartUploadResponse parses an HTTP response from a CompletePresignMultipartUploadWithResponse call
func ParseCompletePresignMultipartUploadResponse(rsp *http.Response) (*CompletePresignMultipartUploadResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CompletePresignMultipartUploadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest StagingLocation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUploadPartResponse parses an HTTP response from a UploadPartWithResponse call
func ParseUploadPartResponse(rsp *http.Response) (*UploadPartResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UploadPartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UploadTo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUploadPartCopyResponse parses an HTTP response from a UploadPartCopyWithResponse call
func ParseUploadPartCopyResponse(rsp *http.Response) (*UploadPartCopyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UploadPartCopyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateCommitRecordResponse parses an HTTP response from a CreateCommitRecordWithResponse call
func ParseCreateCommitRecordResponse(rsp *http.Response) (*CreateCommitRecordResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateCommitRecordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCommitResponse parses an HTTP response from a GetCommitWithResponse call
func ParseGetCommitResponse(rsp *http.Response) (*GetCommitResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetCommitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Commit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDumpStatusResponse parses an HTTP response from a DumpStatusWithResponse call
func ParseDumpStatusResponse(rsp *http.Response) (*DumpStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DumpStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RepositoryDumpStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDumpSubmitResponse parses an HTTP response from a DumpSubmitWithResponse call
func ParseDumpSubmitResponse(rsp *http.Response) (*DumpSubmitResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DumpSubmitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TaskInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePrepareGarbageCollectionCommitsResponse parses an HTTP response from a PrepareGarbageCollectionCommitsWithResponse call
func ParsePrepareGarbageCollectionCommitsResponse(rsp *http.Response) (*PrepareGarbageCollectionCommitsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PrepareGarbageCollectionCommitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest GarbageCollectionPrepareResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePrepareGarbageCollectionCommitsAsyncResponse parses an HTTP response from a PrepareGarbageCollectionCommitsAsyncWithResponse call
func ParsePrepareGarbageCollectionCommitsAsyncResponse(rsp *http.Response) (*PrepareGarbageCollectionCommitsAsyncResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PrepareGarbageCollectionCommitsAsyncResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TaskCreation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePrepareGarbageCollectionCommitsStatusResponse parses an HTTP response from a PrepareGarbageCollectionCommitsStatusWithResponse call
func ParsePrepareGarbageCollectionCommitsStatusResponse(rsp *http.Response) (*PrepareGarbageCollectionCommitsStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PrepareGarbageCollectionCommitsStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PrepareGarbageCollectionCommitsStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePrepareGarbageCollectionUncommittedResponse parses an HTTP response from a PrepareGarbageCollectionUncommittedWithResponse call
func ParsePrepareGarbageCollectionUncommittedResponse(rsp *http.Response) (*PrepareGarbageCollectionUncommittedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PrepareGarbageCollectionUncommittedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PrepareGCUncommittedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInternalDeleteGarbageCollectionRulesResponse parses an HTTP response from a InternalDeleteGarbageCollectionRulesWithResponse call
func ParseInternalDeleteGarbageCollectionRulesResponse(rsp *http.Response) (*InternalDeleteGarbageCollectionRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &InternalDeleteGarbageCollectionRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInternalGetGarbageCollectionRulesResponse parses an HTTP response from a InternalGetGarbageCollectionRulesWithResponse call
func ParseInternalGetGarbageCollectionRulesResponse(rsp *http.Response) (*InternalGetGarbageCollectionRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &InternalGetGarbageCollectionRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GarbageCollectionRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInternalSetGarbageCollectionRulesResponse parses an HTTP response from a InternalSetGarbageCollectionRulesWithResponse call
func ParseInternalSetGarbageCollectionRulesResponse(rsp *http.Response) (*InternalSetGarbageCollectionRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &InternalSetGarbageCollectionRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetGarbageCollectionRulesPreflightResponse parses an HTTP response from a SetGarbageCollectionRulesPreflightWithResponse call
func ParseSetGarbageCollectionRulesPreflightResponse(rsp *http.Response) (*SetGarbageCollectionRulesPreflightResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SetGarbageCollectionRulesPreflightResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteRepositoryMetadataResponse parses an HTTP response from a DeleteRepositoryMetadataWithResponse call
func ParseDeleteRepositoryMetadataResponse(rsp *http.Response) (*DeleteRepositoryMetadataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteRepositoryMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRepositoryMetadataResponse parses an HTTP response from a GetRepositoryMetadataWithResponse call
func ParseGetRepositoryMetadataResponse(rsp *http.Response) (*GetRepositoryMetadataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetRepositoryMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RepositoryMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetRepositoryMetadataResponse parses an HTTP response from a SetRepositoryMetadataWithResponse call
func ParseSetRepositoryMetadataResponse(rsp *http.Response) (*SetRepositoryMetadataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SetRepositoryMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMetaRangeResponse parses an HTTP response from a GetMetaRangeWithResponse call
func ParseGetMetaRangeResponse(rsp *http.Response) (*GetMetaRangeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetMetaRangeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StorageURI
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMetadataObjectResponse parses an HTTP response from a GetMetadataObjectWithResponse call
func ParseGetMetadataObjectResponse(rsp *http.Response) (*GetMetadataObjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetMetadataObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRangeResponse parses an HTTP response from a GetRangeWithResponse call
func ParseGetRangeResponse(rsp *http.Response) (*GetRangeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetRangeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StorageURI
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListPullRequestsResponse parses an HTTP response from a ListPullRequestsWithResponse call
func ParseListPullRequestsResponse(rsp *http.Response) (*ListPullRequestsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListPullRequestsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PullRequestsList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreatePullRequestResponse parses an HTTP response from a CreatePullRequestWithResponse call
func ParseCreatePullRequestResponse(rsp *http.Response) (*CreatePullRequestResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreatePullRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PullRequestCreationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPullRequestResponse parses an HTTP response from a GetPullRequestWithResponse call
func ParseGetPullRequestResponse(rsp *http.Response) (*GetPullRequestResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetPullRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PullRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdatePullRequestResponse parses an HTTP response from a UpdatePullRequestWithResponse call
func ParseUpdatePullRequestResponse(rsp *http.Response) (*UpdatePullRequestResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdatePullRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMergePullRequestResponse parses an HTTP response from a MergePullRequestWithResponse call
func ParseMergePullRequestResponse(rsp *http.Response) (*MergePullRequestResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &MergePullRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MergeResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest MergeResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDumpRefsResponse parses an HTTP response from a DumpRefsWithResponse call
func ParseDumpRefsResponse(rsp *http.Response) (*DumpRefsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DumpRefsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RefsDump
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRestoreRefsResponse parses an HTTP response from a RestoreRefsWithResponse call
func ParseRestoreRefsResponse(rsp *http.Response) (*RestoreRefsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &RestoreRefsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSymlinkFileResponse parses an HTTP response from a CreateSymlinkFileWithResponse call
func ParseCreateSymlinkFileResponse(rsp *http.Response) (*CreateSymlinkFileResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateSymlinkFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest StorageURI
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDiffRefsResponse parses an HTTP response from a DiffRefsWithResponse call
func ParseDiffRefsResponse(rsp *http.Response) (*DiffRefsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DiffRefsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DiffList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseLogCommitsResponse parses an HTTP response from a LogCommitsWithResponse call
func ParseLogCommitsResponse(rsp *http.Response) (*LogCommitsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &LogCommitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommitList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetObjectResponse parses an HTTP response from a GetObjectWithResponse call
func ParseGetObjectResponse(rsp *http.Response) (*GetObjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 416:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON416 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseHeadObjectResponse parses an HTTP response from a HeadObjectWithResponse call
func ParseHeadObjectResponse(rsp *http.Response) (*HeadObjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &HeadObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseListObjectsResponse parses an HTTP response from a ListObjectsWithResponse call
func ParseListObjectsResponse(rsp *http.Response) (*ListObjectsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListObjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStatsList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStatObjectResponse parses an HTTP response from a StatObjectWithResponse call
func ParseStatObjectResponse(rsp *http.Response) (*StatObjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &StatObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUnderlyingPropertiesResponse parses an HTTP response from a GetUnderlyingPropertiesWithResponse call
func ParseGetUnderlyingPropertiesResponse(rsp *http.Response) (*GetUnderlyingPropertiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetUnderlyingPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UnderlyingObjectProperties
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseFindMergeBaseResponse parses an HTTP response from a FindMergeBaseWithResponse call
func ParseFindMergeBaseResponse(rsp *http.Response) (*FindMergeBaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &FindMergeBaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FindMergeBaseResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMergeIntoBranchResponse parses an HTTP response from a MergeIntoBranchWithResponse call
func ParseMergeIntoBranchResponse(rsp *http.Response) (*MergeIntoBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &MergeIntoBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MergeResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest MergeResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMergeIntoBranchAsyncResponse parses an HTTP response from a MergeIntoBranchAsyncWithResponse call
func ParseMergeIntoBranchAsyncResponse(rsp *http.Response) (*MergeIntoBranchAsyncResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &MergeIntoBranchAsyncResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TaskCreation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMergeIntoBranchAsyncStatusResponse parses an HTTP response from a MergeIntoBranchAsyncStatusWithResponse call
func ParseMergeIntoBranchAsyncStatusResponse(rsp *http.Response) (*MergeIntoBranchAsyncStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &MergeIntoBranchAsyncStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MergeAsyncStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRestoreStatusResponse parses an HTTP response from a RestoreStatusWithResponse call
func ParseRestoreStatusResponse(rsp *http.Response) (*RestoreStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &RestoreStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RepositoryRestoreStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRestoreSubmitResponse parses an HTTP response from a RestoreSubmitWithResponse call
func ParseRestoreSubmitResponse(rsp *http.Response) (*RestoreSubmitResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &RestoreSubmitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TaskInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBranchProtectionRulesResponse parses an HTTP response from a GetBranchProtectionRulesWithResponse call
func ParseGetBranchProtectionRulesResponse(rsp *http.Response) (*GetBranchProtectionRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetBranchProtectionRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []BranchProtectionRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetBranchProtectionRulesResponse parses an HTTP response from a SetBranchProtectionRulesWithResponse call
func ParseSetBranchProtectionRulesResponse(rsp *http.Response) (*SetBranchProtectionRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SetBranchProtectionRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteGCRulesResponse parses an HTTP response from a DeleteGCRulesWithResponse call
func ParseDeleteGCRulesResponse(rsp *http.Response) (*DeleteGCRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteGCRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetGCRulesResponse parses an HTTP response from a GetGCRulesWithResponse call
func ParseGetGCRulesResponse(rsp *http.Response) (*GetGCRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetGCRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GarbageCollectionRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetGCRulesResponse parses an HTTP response from a SetGCRulesWithResponse call
func ParseSetGCRulesResponse(rsp *http.Response) (*SetGCRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SetGCRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListTagsResponse parses an HTTP response from a ListTagsWithResponse call
func ParseListTagsResponse(rsp *http.Response) (*ListTagsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RefList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTagResponse parses an HTTP response from a CreateTagWithResponse call
func ParseCreateTagResponse(rsp *http.Response) (*CreateTagResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Ref
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTagResponse parses an HTTP response from a DeleteTagWithResponse call
func ParseDeleteTagResponse(rsp *http.Response) (*DeleteTagResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTagResponse parses an HTTP response from a GetTagWithResponse call
func ParseGetTagResponse(rsp *http.Response) (*GetTagResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Ref
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetupCommPrefsResponse parses an HTTP response from a SetupCommPrefsWithResponse call
func ParseSetupCommPrefsResponse(rsp *http.Response) (*SetupCommPrefsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SetupCommPrefsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSetupStateResponse parses an HTTP response from a GetSetupStateWithResponse call
func ParseGetSetupStateResponse(rsp *http.Response) (*GetSetupStateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetSetupStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SetupState
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetupResponse parses an HTTP response from a SetupWithResponse call
func ParseSetupResponse(rsp *http.Response) (*SetupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SetupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CredentialsWithSecret
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostStatsEventsResponse parses an HTTP response from a PostStatsEventsWithResponse call
func ParsePostStatsEventsResponse(rsp *http.Response) (*PostStatsEventsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostStatsEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStsLoginResponse parses an HTTP response from a StsLoginWithResponse call
func ParseStsLoginResponse(rsp *http.Response) (*StsLoginResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &StsLoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthenticationToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUsageReportSummaryResponse parses an HTTP response from a GetUsageReportSummaryWithResponse call
func ParseGetUsageReportSummaryResponse(rsp *http.Response) (*GetUsageReportSummaryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetUsageReportSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InstallationUsageReport
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/text) unsupported

	}

	return response, nil
}

// ParseGetCurrentUserResponse parses an HTTP response from a GetCurrentUserWithResponse call
func ParseGetCurrentUserResponse(rsp *http.Response) (*GetCurrentUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CurrentUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// chi-interface.tmpl based on https://github.com/deepmap/oapi-codegen/tree/master/pkg/codegen/templates

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// list authentication capabilities supported
	// (GET /auth/capabilities)
	GetAuthCapabilities(w http.ResponseWriter, r *http.Request)
	// perform a login using an external authenticator
	// (POST /auth/external/principal/login)
	ExternalPrincipalLogin(w http.ResponseWriter, r *http.Request, body ExternalPrincipalLoginJSONRequestBody)
	// describe external principal by id
	// (GET /auth/external/principals)
	GetExternalPrincipal(w http.ResponseWriter, r *http.Request, params GetExternalPrincipalParams)
	// receive the token after user has authenticated on redirect URL.
	// (GET /auth/get-token/mailboxes/{mailbox})
	GetTokenFromMailbox(w http.ResponseWriter, r *http.Request, mailbox string)
	// release a token for the current (authenticated) user to the mailbox of this login request.
	// (GET /auth/get-token/release-token/{loginRequestToken})
	ReleaseTokenToMailbox(w http.ResponseWriter, r *http.Request, loginRequestToken string)
	// start acquiring a token by logging in on a browser
	// (GET /auth/get-token/start)
	GetTokenRedirect(w http.ResponseWriter, r *http.Request)
	// list groups
	// (GET /auth/groups)
	ListGroups(w http.ResponseWriter, r *http.Request, params ListGroupsParams)
	// create group
	// (POST /auth/groups)
	CreateGroup(w http.ResponseWriter, r *http.Request, body CreateGroupJSONRequestBody)
	// delete group
	// (DELETE /auth/groups/{groupId})
	DeleteGroup(w http.ResponseWriter, r *http.Request, groupId string)
	// get group
	// (GET /auth/groups/{groupId})
	GetGroup(w http.ResponseWriter, r *http.Request, groupId string)
	// get ACL of group
	// (GET /auth/groups/{groupId}/acl)
	GetGroupACL(w http.ResponseWriter, r *http.Request, groupId string)
	// set ACL of group
	// (POST /auth/groups/{groupId}/acl)
	SetGroupACL(w http.ResponseWriter, r *http.Request, body SetGroupACLJSONRequestBody, groupId string)
	// list group members
	// (GET /auth/groups/{groupId}/members)
	ListGroupMembers(w http.ResponseWriter, r *http.Request, groupId string, params ListGroupMembersParams)
	// delete group membership
	// (DELETE /auth/groups/{groupId}/members/{userId})
	DeleteGroupMembership(w http.ResponseWriter, r *http.Request, groupId string, userId string)
	// add group membership
	// (PUT /auth/groups/{groupId}/members/{userId})
	AddGroupMembership(w http.ResponseWriter, r *http.Request, groupId string, userId string)
	// list group policies
	// (GET /auth/groups/{groupId}/policies)
	ListGroupPolicies(w http.ResponseWriter, r *http.Request, groupId string, params ListGroupPoliciesParams)
	// detach policy from group
	// (DELETE /auth/groups/{groupId}/policies/{policyId})
	DetachPolicyFromGroup(w http.ResponseWriter, r *http.Request, groupId string, policyId string)
	// attach policy to group
	// (PUT /auth/groups/{groupId}/policies/{policyId})
	AttachPolicyToGroup(w http.ResponseWriter, r *http.Request, groupId string, policyId string)
	// perform a login
	// (POST /auth/login)
	Login(w http.ResponseWriter, r *http.Request, body LoginJSONRequestBody)
	// list policies
	// (GET /auth/policies)
	ListPolicies(w http.ResponseWriter, r *http.Request, params ListPoliciesParams)
	// create policy
	// (POST /auth/policies)
	CreatePolicy(w http.ResponseWriter, r *http.Request, body CreatePolicyJSONRequestBody)
	// delete policy
	// (DELETE /auth/policies/{policyId})
	DeletePolicy(w http.ResponseWriter, r *http.Request, policyId string)
	// get policy
	// (GET /auth/policies/{policyId})
	GetPolicy(w http.ResponseWriter, r *http.Request, policyId string)
	// update policy
	// (PUT /auth/policies/{policyId})
	UpdatePolicy(w http.ResponseWriter, r *http.Request, body UpdatePolicyJSONRequestBody, policyId string)
	// list users
	// (GET /auth/users)
	ListUsers(w http.ResponseWriter, r *http.Request, params ListUsersParams)
	// create user
	// (POST /auth/users)
	CreateUser(w http.ResponseWriter, r *http.Request, body CreateUserJSONRequestBody)
	// delete user
	// (DELETE /auth/users/{userId})
	DeleteUser(w http.ResponseWriter, r *http.Request, userId string)
	// get user
	// (GET /auth/users/{userId})
	GetUser(w http.ResponseWriter, r *http.Request, userId string)
	// list user credentials
	// (GET /auth/users/{userId}/credentials)
	ListUserCredentials(w http.ResponseWriter, r *http.Request, userId string, params ListUserCredentialsParams)
	// create credentials
	// (POST /auth/users/{userId}/credentials)
	CreateCredentials(w http.ResponseWriter, r *http.Request, userId string)
	// delete credentials
	// (DELETE /auth/users/{userId}/credentials/{accessKeyId})
	DeleteCredentials(w http.ResponseWriter, r *http.Request, userId string, accessKeyId string)
	// get credentials
	// (GET /auth/users/{userId}/credentials/{accessKeyId})
	GetCredentials(w http.ResponseWriter, r *http.Request, userId string, accessKeyId string)
	// delete external principal from user
	// (DELETE /auth/users/{userId}/external/principals)
	DeleteUserExternalPrincipal(w http.ResponseWriter, r *http.Request, userId string, params DeleteUserExternalPrincipalParams)
	// attach external principal to user
	// (POST /auth/users/{userId}/external/principals)
	CreateUserExternalPrincipal(w http.ResponseWriter, r *http.Request, body CreateUserExternalPrincipalJSONRequestBody, userId string, params CreateUserExternalPrincipalParams)
	// list user external policies attached to a user
	// (GET /auth/users/{userId}/external/principals/ls)
	ListUserExternalPrincipals(w http.ResponseWriter, r *http.Request, userId string, params ListUserExternalPrincipalsParams)
	// list user groups
	// (GET /auth/users/{userId}/groups)
	ListUserGroups(w http.ResponseWriter, r *http.Request, userId string, params ListUserGroupsParams)
	// list user policies
	// (GET /auth/users/{userId}/policies)
	ListUserPolicies(w http.ResponseWriter, r *http.Request, userId string, params ListUserPoliciesParams)
	// detach policy from user
	// (DELETE /auth/users/{userId}/policies/{policyId})
	DetachPolicyFromUser(w http.ResponseWriter, r *http.Request, userId string, policyId string)
	// attach policy to user
	// (PUT /auth/users/{userId}/policies/{policyId})
	AttachPolicyToUser(w http.ResponseWriter, r *http.Request, userId string, policyId string)

	// (GET /config)
	GetConfig(w http.ResponseWriter, r *http.Request)

	// (GET /config/garbage-collection)
	GetGarbageCollectionConfig(w http.ResponseWriter, r *http.Request)

	// (GET /config/storage)
	GetStorageConfig(w http.ResponseWriter, r *http.Request)

	// (GET /config/version)
	GetLakeFSVersion(w http.ResponseWriter, r *http.Request)

	// (GET /healthcheck)
	HealthCheck(w http.ResponseWriter, r *http.Request)
	// take a table previously pushed from lakeFS into a remote catalog, and pull its state back into the originating lakeFS repository
	// (POST /iceberg/remotes/{catalog}/pull)
	PullIcebergTable(w http.ResponseWriter, r *http.Request, body PullIcebergTableJSONRequestBody, catalog string)
	// register existing lakeFS table in remote catalog
	// (POST /iceberg/remotes/{catalog}/push)
	PushIcebergTable(w http.ResponseWriter, r *http.Request, body PushIcebergTableJSONRequestBody, catalog string)

	// (GET /license)
	GetLicense(w http.ResponseWriter, r *http.Request)

	// (GET /oidc/callback)
	OauthCallback(w http.ResponseWriter, r *http.Request)
	// list repositories
	// (GET /repositories)
	ListRepositories(w http.ResponseWriter, r *http.Request, params ListRepositoriesParams)
	// create repository
	// (POST /repositories)
	CreateRepository(w http.ResponseWriter, r *http.Request, body CreateRepositoryJSONRequestBody, params CreateRepositoryParams)
	// delete repository
	// (DELETE /repositories/{repository})
	DeleteRepository(w http.ResponseWriter, r *http.Request, repository string, params DeleteRepositoryParams)
	// get repository
	// (GET /repositories/{repository})
	GetRepository(w http.ResponseWriter, r *http.Request, repository string)
	// list runs
	// (GET /repositories/{repository}/actions/runs)
	ListRepositoryRuns(w http.ResponseWriter, r *http.Request, repository string, params ListRepositoryRunsParams)
	// get a run
	// (GET /repositories/{repository}/actions/runs/{run_id})
	GetRun(w http.ResponseWriter, r *http.Request, repository string, runId string)
	// list run hooks
	// (GET /repositories/{repository}/actions/runs/{run_id}/hooks)
	ListRunHooks(w http.ResponseWriter, r *http.Request, repository string, runId string, params ListRunHooksParams)
	// get run hook output
	// (GET /repositories/{repository}/actions/runs/{run_id}/hooks/{hook_run_id}/output)
	GetRunHookOutput(w http.ResponseWriter, r *http.Request, repository string, runId string, hookRunId string)

	// (DELETE /repositories/{repository}/branch_protection)
	InternalDeleteBranchProtectionRule(w http.ResponseWriter, r *http.Request, body InternalDeleteBranchProtectionRuleJSONRequestBody, repository string)
	// get branch protection rules
	// (GET /repositories/{repository}/branch_protection)
	InternalGetBranchProtectionRules(w http.ResponseWriter, r *http.Request, repository string)

	// (POST /repositories/{repository}/branch_protection)
	InternalCreateBranchProtectionRule(w http.ResponseWriter, r *http.Request, body InternalCreateBranchProtectionRuleJSONRequestBody, repository string)

	// (GET /repositories/{repository}/branch_protection/set_allowed)
	CreateBranchProtectionRulePreflight(w http.ResponseWriter, r *http.Request, repository string)
	// list branches
	// (GET /repositories/{repository}/branches)
	ListBranches(w http.ResponseWriter, r *http.Request, repository string, params ListBranchesParams)
	// create branch
	// (POST /repositories/{repository}/branches)
	CreateBranch(w http.ResponseWriter, r *http.Request, body CreateBranchJSONRequestBody, repository string)
	// delete branch
	// (DELETE /repositories/{repository}/branches/{branch})
	DeleteBranch(w http.ResponseWriter, r *http.Request, repository string, branch string, params DeleteBranchParams)
	// get branch
	// (GET /repositories/{repository}/branches/{branch})
	GetBranch(w http.ResponseWriter, r *http.Request, repository string, branch string)
	// reset branch
	// (PUT /repositories/{repository}/branches/{branch})
	ResetBranch(w http.ResponseWriter, r *http.Request, body ResetBranchJSONRequestBody, repository string, branch string)
	// Replay the changes from the given commit on the branch
	// (POST /repositories/{repository}/branches/{branch}/cherry-pick)
	CherryPick(w http.ResponseWriter, r *http.Request, body CherryPickJSONRequestBody, repository string, branch string)
	// create commit
	// (POST /repositories/{repository}/branches/{branch}/commits)
	Commit(w http.ResponseWriter, r *http.Request, body CommitJSONRequestBody, repository string, branch string, params CommitParams)
	// create commit asynchronously
	// (POST /repositories/{repository}/branches/{branch}/commits/async)
	CommitAsync(w http.ResponseWriter, r *http.Request, body CommitAsyncJSONRequestBody, repository string, branch string, params CommitAsyncParams)
	// get status of async commit operation
	// (GET /repositories/{repository}/branches/{branch}/commits/async/{id}/status)
	CommitAsyncStatus(w http.ResponseWriter, r *http.Request, repository string, branch string, id string)
	// diff branch
	// (GET /repositories/{repository}/branches/{branch}/diff)
	DiffBranch(w http.ResponseWriter, r *http.Request, repository string, branch string, params DiffBranchParams)
	// hard reset branch
	// (PUT /repositories/{repository}/branches/{branch}/hard_reset)
	HardResetBranch(w http.ResponseWriter, r *http.Request, repository string, branch string, params HardResetBranchParams)
	// cancel ongoing import
	// (DELETE /repositories/{repository}/branches/{branch}/import)
	ImportCancel(w http.ResponseWriter, r *http.Request, repository string, branch string, params ImportCancelParams)
	// get import status
	// (GET /repositories/{repository}/branches/{branch}/import)
	ImportStatus(w http.ResponseWriter, r *http.Request, repository string, branch string, params ImportStatusParams)
	// import data from object store
	// (POST /repositories/{repository}/branches/{branch}/import)
	ImportStart(w http.ResponseWriter, r *http.Request, body ImportStartJSONRequestBody, repository string, branch string)
	// delete object. Missing objects will not return a NotFound error.
	// (DELETE /repositories/{repository}/branches/{branch}/objects)
	DeleteObject(w http.ResponseWriter, r *http.Request, repository string, branch string, params DeleteObjectParams)

	// (POST /repositories/{repository}/branches/{branch}/objects)
	UploadObject(w http.ResponseWriter, r *http.Request, repository string, branch string, params UploadObjectParams)
	// stage an object's metadata for the given branch
	// (PUT /repositories/{repository}/branches/{branch}/objects)
	StageObject(w http.ResponseWriter, r *http.Request, body StageObjectJSONRequestBody, repository string, branch string, params StageObjectParams)
	// create a copy of an object
	// (POST /repositories/{repository}/branches/{branch}/objects/copy)
	CopyObject(w http.ResponseWriter, r *http.Request, body CopyObjectJSONRequestBody, repository string, branch string, params CopyObjectParams)
	// delete objects. Missing objects will not return a NotFound error.
	// (POST /repositories/{repository}/branches/{branch}/objects/delete)
	DeleteObjects(w http.ResponseWriter, r *http.Request, body DeleteObjectsJSONRequestBody, repository string, branch string, params DeleteObjectsParams)

	// (GET /repositories/{repository}/branches/{branch}/objects/stage_allowed)
	UploadObjectPreflight(w http.ResponseWriter, r *http.Request, repository string, branch string, params UploadObjectPreflightParams)
	// rewrite (all) object metadata
	// (PUT /repositories/{repository}/branches/{branch}/objects/stat/user_metadata)
	UpdateObjectUserMetadata(w http.ResponseWriter, r *http.Request, body UpdateObjectUserMetadataJSONRequestBody, repository string, branch string, params UpdateObjectUserMetadataParams)
	// revert
	// (POST /repositories/{repository}/branches/{branch}/revert)
	RevertBranch(w http.ResponseWriter, r *http.Request, body RevertBranchJSONRequestBody, repository string, branch string)
	// generate an address to which the client can upload an object
	// (GET /repositories/{repository}/branches/{branch}/staging/backing)
	GetPhysicalAddress(w http.ResponseWriter, r *http.Request, repository string, branch string, params GetPhysicalAddressParams)
	// associate staging on this physical address with a path
	// (PUT /repositories/{repository}/branches/{branch}/staging/backing)
	LinkPhysicalAddress(w http.ResponseWriter, r *http.Request, body LinkPhysicalAddressJSONRequestBody, repository string, branch string, params LinkPhysicalAddressParams)
	// Initiate a multipart upload
	// (POST /repositories/{repository}/branches/{branch}/staging/pmpu)
	CreatePresignMultipartUpload(w http.ResponseWriter, r *http.Request, repository string, branch string, params CreatePresignMultipartUploadParams)
	// Abort a presign multipart upload
	// (DELETE /repositories/{repository}/branches/{branch}/staging/pmpu/{uploadId})
	AbortPresignMultipartUpload(w http.ResponseWriter, r *http.Request, body AbortPresignMultipartUploadJSONRequestBody, repository string, branch string, uploadId string, params AbortPresignMultipartUploadParams)
	// Complete a presign multipart upload request
	// (PUT /repositories/{repository}/branches/{branch}/staging/pmpu/{uploadId})
	CompletePresignMultipartUpload(w http.ResponseWriter, r *http.Request, body CompletePresignMultipartUploadJSONRequestBody, repository string, branch string, uploadId string, params CompletePresignMultipartUploadParams)

	// (PUT /repositories/{repository}/branches/{branch}/staging/pmpu/{uploadId}/parts/{partNumber})
	UploadPart(w http.ResponseWriter, r *http.Request, body UploadPartJSONRequestBody, repository string, branch string, uploadId string, partNumber int, params UploadPartParams)

	// (PUT /repositories/{repository}/branches/{branch}/staging/pmpu/{uploadId}/parts/{partNumber}/copy)
	UploadPartCopy(w http.ResponseWriter, r *http.Request, body UploadPartCopyJSONRequestBody, repository string, branch string, uploadId string, partNumber int, params UploadPartCopyParams)
	// create commit record
	// (POST /repositories/{repository}/commits)
	CreateCommitRecord(w http.ResponseWriter, r *http.Request, body CreateCommitRecordJSONRequestBody, repository string)
	// get commit
	// (GET /repositories/{repository}/commits/{commitId})
	GetCommit(w http.ResponseWriter, r *http.Request, repository string, commitId string)
	// Status of a repository dump task
	// (GET /repositories/{repository}/dump)
	DumpStatus(w http.ResponseWriter, r *http.Request, repository string, params DumpStatusParams)
	// Backup the repository metadata (tags, commits, branches) and save the backup to the object store.
	// (POST /repositories/{repository}/dump)
	DumpSubmit(w http.ResponseWriter, r *http.Request, repository string)
	// save lists of active commits for garbage collection
	// (POST /repositories/{repository}/gc/prepare_commits)
	PrepareGarbageCollectionCommits(w http.ResponseWriter, r *http.Request, repository string)
	// prepare gc commits
	// (POST /repositories/{repository}/gc/prepare_commits/async)
	PrepareGarbageCollectionCommitsAsync(w http.ResponseWriter, r *http.Request, repository string)
	// get status of prepare gc commits operation
	// (GET /repositories/{repository}/gc/prepare_commits/status)
	PrepareGarbageCollectionCommitsStatus(w http.ResponseWriter, r *http.Request, repository string, params PrepareGarbageCollectionCommitsStatusParams)
	// save repository uncommitted metadata for garbage collection
	// (POST /repositories/{repository}/gc/prepare_uncommited)
	PrepareGarbageCollectionUncommitted(w http.ResponseWriter, r *http.Request, body PrepareGarbageCollectionUncommittedJSONRequestBody, repository string)

	// (DELETE /repositories/{repository}/gc/rules)
	InternalDeleteGarbageCollectionRules(w http.ResponseWriter, r *http.Request, repository string)

	// (GET /repositories/{repository}/gc/rules)
	InternalGetGarbageCollectionRules(w http.ResponseWriter, r *http.Request, repository string)

	// (POST /repositories/{repository}/gc/rules)
	InternalSetGarbageCollectionRules(w http.ResponseWriter, r *http.Request, body InternalSetGarbageCollectionRulesJSONRequestBody, repository string)

	// (GET /repositories/{repository}/gc/rules/set_allowed)
	SetGarbageCollectionRulesPreflight(w http.ResponseWriter, r *http.Request, repository string)
	// delete repository metadata
	// (DELETE /repositories/{repository}/metadata)
	DeleteRepositoryMetadata(w http.ResponseWriter, r *http.Request, body DeleteRepositoryMetadataJSONRequestBody, repository string)
	// get repository metadata
	// (GET /repositories/{repository}/metadata)
	GetRepositoryMetadata(w http.ResponseWriter, r *http.Request, repository string)
	// set repository metadata
	// (POST /repositories/{repository}/metadata)
	SetRepositoryMetadata(w http.ResponseWriter, r *http.Request, body SetRepositoryMetadataJSONRequestBody, repository string)
	// return URI to a meta-range file
	// (GET /repositories/{repository}/metadata/meta_range/{meta_range})
	GetMetaRange(w http.ResponseWriter, r *http.Request, repository string, metaRange string)
	// return a lakeFS metadata object by ID
	// (GET /repositories/{repository}/metadata/object/{type}/{object_id})
	GetMetadataObject(w http.ResponseWriter, r *http.Request, repository string, pType string, objectId string, params GetMetadataObjectParams)
	// return URI to a range file
	// (GET /repositories/{repository}/metadata/range/{range})
	GetRange(w http.ResponseWriter, r *http.Request, repository string, pRange string)
	// list pull requests
	// (GET /repositories/{repository}/pulls)
	ListPullRequests(w http.ResponseWriter, r *http.Request, repository string, params ListPullRequestsParams)
	// create pull request
	// (POST /repositories/{repository}/pulls)
	CreatePullRequest(w http.ResponseWriter, r *http.Request, body CreatePullRequestJSONRequestBody, repository string)
	// get pull request
	// (GET /repositories/{repository}/pulls/{pull_request})
	GetPullRequest(w http.ResponseWriter, r *http.Request, repository string, pullRequest string)
	// update pull request
	// (PATCH /repositories/{repository}/pulls/{pull_request})
	UpdatePullRequest(w http.ResponseWriter, r *http.Request, body UpdatePullRequestJSONRequestBody, repository string, pullRequest string)
	// merge pull request
	// (PUT /repositories/{repository}/pulls/{pull_request}/merge)
	MergePullRequest(w http.ResponseWriter, r *http.Request, repository string, pullRequest string)
	// Dump repository refs (tags, commits, branches) to object store
	// Deprecated: a new API will introduce long running operations
	// (PUT /repositories/{repository}/refs/dump)
	DumpRefs(w http.ResponseWriter, r *http.Request, repository string)
	// Restore repository refs (tags, commits, branches) from object store.
	// Deprecated: a new API will introduce long running operations
	// (PUT /repositories/{repository}/refs/restore)
	RestoreRefs(w http.ResponseWriter, r *http.Request, body RestoreRefsJSONRequestBody, repository string)
	// creates symlink files corresponding to the given directory
	// (POST /repositories/{repository}/refs/{branch}/symlink)
	CreateSymlinkFile(w http.ResponseWriter, r *http.Request, repository string, branch string, params CreateSymlinkFileParams)
	// diff references
	// (GET /repositories/{repository}/refs/{leftRef}/diff/{rightRef})
	DiffRefs(w http.ResponseWriter, r *http.Request, repository string, leftRef string, rightRef string, params DiffRefsParams)
	// get commit log from ref. If both objects and prefixes are empty, return all commits.
	// (GET /repositories/{repository}/refs/{ref}/commits)
	LogCommits(w http.ResponseWriter, r *http.Request, repository string, ref string, params LogCommitsParams)
	// get object content
	// (GET /repositories/{repository}/refs/{ref}/objects)
	GetObject(w http.ResponseWriter, r *http.Request, repository string, ref string, params GetObjectParams)
	// check if object exists
	// (HEAD /repositories/{repository}/refs/{ref}/objects)
	HeadObject(w http.ResponseWriter, r *http.Request, repository string, ref string, params HeadObjectParams)
	// list objects under a given prefix
	// (GET /repositories/{repository}/refs/{ref}/objects/ls)
	ListObjects(w http.ResponseWriter, r *http.Request, repository string, ref string, params ListObjectsParams)
	// get object metadata
	// (GET /repositories/{repository}/refs/{ref}/objects/stat)
	StatObject(w http.ResponseWriter, r *http.Request, repository string, ref string, params StatObjectParams)
	// get object properties on underlying storage
	// (GET /repositories/{repository}/refs/{ref}/objects/underlyingProperties)
	GetUnderlyingProperties(w http.ResponseWriter, r *http.Request, repository string, ref string, params GetUnderlyingPropertiesParams)
	// find the merge base for 2 references
	// (GET /repositories/{repository}/refs/{sourceRef}/merge/{destinationBranch})
	FindMergeBase(w http.ResponseWriter, r *http.Request, repository string, sourceRef string, destinationBranch string)
	// merge references
	// (POST /repositories/{repository}/refs/{sourceRef}/merge/{destinationBranch})
	MergeIntoBranch(w http.ResponseWriter, r *http.Request, body MergeIntoBranchJSONRequestBody, repository string, sourceRef string, destinationBranch string)
	// merge references asynchronously
	// (POST /repositories/{repository}/refs/{sourceRef}/merge/{destinationBranch}/async)
	MergeIntoBranchAsync(w http.ResponseWriter, r *http.Request, body MergeIntoBranchAsyncJSONRequestBody, repository string, sourceRef string, destinationBranch string)
	// get status of async merge operation
	// (GET /repositories/{repository}/refs/{sourceRef}/merge/{destinationBranch}/async/{id}/status)
	MergeIntoBranchAsyncStatus(w http.ResponseWriter, r *http.Request, repository string, sourceRef string, destinationBranch string, id string)
	// Status of a restore request
	// (GET /repositories/{repository}/restore)
	RestoreStatus(w http.ResponseWriter, r *http.Request, repository string, params RestoreStatusParams)
	// Restore repository from a dump in the object store
	// (POST /repositories/{repository}/restore)
	RestoreSubmit(w http.ResponseWriter, r *http.Request, body RestoreSubmitJSONRequestBody, repository string)
	// get branch protection rules
	// (GET /repositories/{repository}/settings/branch_protection)
	GetBranchProtectionRules(w http.ResponseWriter, r *http.Request, repository string)

	// (PUT /repositories/{repository}/settings/branch_protection)
	SetBranchProtectionRules(w http.ResponseWriter, r *http.Request, body SetBranchProtectionRulesJSONRequestBody, repository string, params SetBranchProtectionRulesParams)

	// (DELETE /repositories/{repository}/settings/gc_rules)
	DeleteGCRules(w http.ResponseWriter, r *http.Request, repository string)
	// get repository GC rules
	// (GET /repositories/{repository}/settings/gc_rules)
	GetGCRules(w http.ResponseWriter, r *http.Request, repository string)

	// (PUT /repositories/{repository}/settings/gc_rules)
	SetGCRules(w http.ResponseWriter, r *http.Request, body SetGCRulesJSONRequestBody, repository string)
	// list tags
	// (GET /repositories/{repository}/tags)
	ListTags(w http.ResponseWriter, r *http.Request, repository string, params ListTagsParams)
	// create tag
	// (POST /repositories/{repository}/tags)
	CreateTag(w http.ResponseWriter, r *http.Request, body CreateTagJSONRequestBody, repository string)
	// delete tag
	// (DELETE /repositories/{repository}/tags/{tag})
	DeleteTag(w http.ResponseWriter, r *http.Request, repository string, tag string, params DeleteTagParams)
	// get tag
	// (GET /repositories/{repository}/tags/{tag})
	GetTag(w http.ResponseWriter, r *http.Request, repository string, tag string)
	// setup communications preferences
	// (POST /setup_comm_prefs)
	SetupCommPrefs(w http.ResponseWriter, r *http.Request, body SetupCommPrefsJSONRequestBody)
	// check if the lakeFS installation is already set up
	// (GET /setup_lakefs)
	GetSetupState(w http.ResponseWriter, r *http.Request)
	// setup lakeFS and create a first user
	// (POST /setup_lakefs)
	Setup(w http.ResponseWriter, r *http.Request, body SetupJSONRequestBody)
	// post stats events, this endpoint is meant for internal use only
	// (POST /statistics)
	PostStatsEvents(w http.ResponseWriter, r *http.Request, body PostStatsEventsJSONRequestBody)
	// perform a login with STS
	// (POST /sts/login)
	StsLogin(w http.ResponseWriter, r *http.Request, body StsLoginJSONRequestBody)
	// get usage report summary
	// (GET /usage-report/summary)
	GetUsageReportSummary(w http.ResponseWriter, r *http.Request)
	// get current user
	// (GET /user)
	GetCurrentUser(w http.ResponseWriter, r *http.Request)
}

// chi-middleware.tmpl based on https://github.com/deepmap/oapi-codegen/tree/master/pkg/codegen/templates

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// GetAuthCapabilities operation middleware
func (siw *ServerInterfaceWrapper) GetAuthCapabilities(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetAuthCapabilities")
	defer task.End()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAuthCapabilities(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ExternalPrincipalLogin operation middleware
func (siw *ServerInterfaceWrapper) ExternalPrincipalLogin(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ExternalPrincipalLogin")
	defer task.End()

	// ------------- Body parse -------------
	var body ExternalPrincipalLoginJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'ExternalPrincipalLogin' as JSON", http.StatusBadRequest)
			return
		}
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ExternalPrincipalLogin(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetExternalPrincipal operation middleware
func (siw *ServerInterfaceWrapper) GetExternalPrincipal(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetExternalPrincipal")
	defer task.End()

	var err error

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetExternalPrincipalParams

	// ------------- Required query parameter "principalId" -------------
	if paramValue := r.URL.Query().Get("principalId"); paramValue != "" {

	} else {
		http.Error(w, "Query argument principalId is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "principalId", r.URL.Query(), &params.PrincipalId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter principalId: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetExternalPrincipal(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetTokenFromMailbox operation middleware
func (siw *ServerInterfaceWrapper) GetTokenFromMailbox(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetTokenFromMailbox")
	defer task.End()

	var err error

	// ------------- Path parameter "mailbox" -------------
	var mailbox string

	err = runtime.BindStyledParameter("simple", false, "mailbox", chi.URLParam(r, "mailbox"), &mailbox)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter mailbox: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTokenFromMailbox(w, r, mailbox)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ReleaseTokenToMailbox operation middleware
func (siw *ServerInterfaceWrapper) ReleaseTokenToMailbox(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ReleaseTokenToMailbox")
	defer task.End()

	var err error

	// ------------- Path parameter "loginRequestToken" -------------
	var loginRequestToken string

	err = runtime.BindStyledParameter("simple", false, "loginRequestToken", chi.URLParam(r, "loginRequestToken"), &loginRequestToken)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter loginRequestToken: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ReleaseTokenToMailbox(w, r, loginRequestToken)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetTokenRedirect operation middleware
func (siw *ServerInterfaceWrapper) GetTokenRedirect(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetTokenRedirect")
	defer task.End()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTokenRedirect(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListGroups operation middleware
func (siw *ServerInterfaceWrapper) ListGroups(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListGroups")
	defer task.End()

	var err error

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListGroupsParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListGroups(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateGroup operation middleware
func (siw *ServerInterfaceWrapper) CreateGroup(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CreateGroup")
	defer task.End()

	// ------------- Body parse -------------
	var body CreateGroupJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreateGroup' as JSON", http.StatusBadRequest)
			return
		}
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateGroup(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteGroup operation middleware
func (siw *ServerInterfaceWrapper) DeleteGroup(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DeleteGroup")
	defer task.End()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGroup(w, r, groupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetGroup operation middleware
func (siw *ServerInterfaceWrapper) GetGroup(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetGroup")
	defer task.End()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGroup(w, r, groupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetGroupACL operation middleware
func (siw *ServerInterfaceWrapper) GetGroupACL(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetGroupACL")
	defer task.End()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGroupACL(w, r, groupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SetGroupACL operation middleware
func (siw *ServerInterfaceWrapper) SetGroupACL(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:SetGroupACL")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body SetGroupACLJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'SetGroupACL' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetGroupACL(w, r, body, groupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListGroupMembers operation middleware
func (siw *ServerInterfaceWrapper) ListGroupMembers(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListGroupMembers")
	defer task.End()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListGroupMembersParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListGroupMembers(w, r, groupId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteGroupMembership operation middleware
func (siw *ServerInterfaceWrapper) DeleteGroupMembership(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DeleteGroupMembership")
	defer task.End()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGroupMembership(w, r, groupId, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddGroupMembership operation middleware
func (siw *ServerInterfaceWrapper) AddGroupMembership(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:AddGroupMembership")
	defer task.End()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddGroupMembership(w, r, groupId, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListGroupPolicies operation middleware
func (siw *ServerInterfaceWrapper) ListGroupPolicies(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListGroupPolicies")
	defer task.End()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListGroupPoliciesParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListGroupPolicies(w, r, groupId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DetachPolicyFromGroup operation middleware
func (siw *ServerInterfaceWrapper) DetachPolicyFromGroup(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DetachPolicyFromGroup")
	defer task.End()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DetachPolicyFromGroup(w, r, groupId, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AttachPolicyToGroup operation middleware
func (siw *ServerInterfaceWrapper) AttachPolicyToGroup(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:AttachPolicyToGroup")
	defer task.End()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachPolicyToGroup(w, r, groupId, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Login operation middleware
func (siw *ServerInterfaceWrapper) Login(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:Login")
	defer task.End()

	// ------------- Body parse -------------
	var body LoginJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'Login' as JSON", http.StatusBadRequest)
			return
		}
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Login(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListPolicies operation middleware
func (siw *ServerInterfaceWrapper) ListPolicies(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListPolicies")
	defer task.End()

	var err error

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPoliciesParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListPolicies(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreatePolicy operation middleware
func (siw *ServerInterfaceWrapper) CreatePolicy(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CreatePolicy")
	defer task.End()

	// ------------- Body parse -------------
	var body CreatePolicyJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreatePolicy' as JSON", http.StatusBadRequest)
			return
		}
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreatePolicy(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeletePolicy operation middleware
func (siw *ServerInterfaceWrapper) DeletePolicy(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DeletePolicy")
	defer task.End()

	var err error

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeletePolicy(w, r, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetPolicy operation middleware
func (siw *ServerInterfaceWrapper) GetPolicy(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetPolicy")
	defer task.End()

	var err error

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPolicy(w, r, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdatePolicy operation middleware
func (siw *ServerInterfaceWrapper) UpdatePolicy(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:UpdatePolicy")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body UpdatePolicyJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'UpdatePolicy' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdatePolicy(w, r, body, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListUsers operation middleware
func (siw *ServerInterfaceWrapper) ListUsers(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListUsers")
	defer task.End()

	var err error

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUsersParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUsers(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateUser operation middleware
func (siw *ServerInterfaceWrapper) CreateUser(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CreateUser")
	defer task.End()

	// ------------- Body parse -------------
	var body CreateUserJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreateUser' as JSON", http.StatusBadRequest)
			return
		}
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateUser(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteUser operation middleware
func (siw *ServerInterfaceWrapper) DeleteUser(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DeleteUser")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUser(w, r, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetUser operation middleware
func (siw *ServerInterfaceWrapper) GetUser(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetUser")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUser(w, r, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListUserCredentials operation middleware
func (siw *ServerInterfaceWrapper) ListUserCredentials(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListUserCredentials")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUserCredentialsParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUserCredentials(w, r, userId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateCredentials operation middleware
func (siw *ServerInterfaceWrapper) CreateCredentials(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CreateCredentials")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateCredentials(w, r, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteCredentials operation middleware
func (siw *ServerInterfaceWrapper) DeleteCredentials(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DeleteCredentials")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "accessKeyId" -------------
	var accessKeyId string

	err = runtime.BindStyledParameter("simple", false, "accessKeyId", chi.URLParam(r, "accessKeyId"), &accessKeyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter accessKeyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteCredentials(w, r, userId, accessKeyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetCredentials operation middleware
func (siw *ServerInterfaceWrapper) GetCredentials(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetCredentials")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "accessKeyId" -------------
	var accessKeyId string

	err = runtime.BindStyledParameter("simple", false, "accessKeyId", chi.URLParam(r, "accessKeyId"), &accessKeyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter accessKeyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCredentials(w, r, userId, accessKeyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteUserExternalPrincipal operation middleware
func (siw *ServerInterfaceWrapper) DeleteUserExternalPrincipal(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DeleteUserExternalPrincipal")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteUserExternalPrincipalParams

	// ------------- Required query parameter "principalId" -------------
	if paramValue := r.URL.Query().Get("principalId"); paramValue != "" {

	} else {
		http.Error(w, "Query argument principalId is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "principalId", r.URL.Query(), &params.PrincipalId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter principalId: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUserExternalPrincipal(w, r, userId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateUserExternalPrincipal operation middleware
func (siw *ServerInterfaceWrapper) CreateUserExternalPrincipal(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CreateUserExternalPrincipal")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body CreateUserExternalPrincipalJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreateUserExternalPrincipal' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateUserExternalPrincipalParams

	// ------------- Required query parameter "principalId" -------------
	if paramValue := r.URL.Query().Get("principalId"); paramValue != "" {

	} else {
		http.Error(w, "Query argument principalId is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "principalId", r.URL.Query(), &params.PrincipalId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter principalId: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateUserExternalPrincipal(w, r, body, userId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListUserExternalPrincipals operation middleware
func (siw *ServerInterfaceWrapper) ListUserExternalPrincipals(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListUserExternalPrincipals")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUserExternalPrincipalsParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUserExternalPrincipals(w, r, userId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListUserGroups operation middleware
func (siw *ServerInterfaceWrapper) ListUserGroups(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListUserGroups")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUserGroupsParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUserGroups(w, r, userId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListUserPolicies operation middleware
func (siw *ServerInterfaceWrapper) ListUserPolicies(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListUserPolicies")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUserPoliciesParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "effective" -------------
	if paramValue := r.URL.Query().Get("effective"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "effective", r.URL.Query(), &params.Effective)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter effective: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUserPolicies(w, r, userId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DetachPolicyFromUser operation middleware
func (siw *ServerInterfaceWrapper) DetachPolicyFromUser(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DetachPolicyFromUser")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DetachPolicyFromUser(w, r, userId, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AttachPolicyToUser operation middleware
func (siw *ServerInterfaceWrapper) AttachPolicyToUser(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:AttachPolicyToUser")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachPolicyToUser(w, r, userId, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetConfig operation middleware
func (siw *ServerInterfaceWrapper) GetConfig(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetConfig")
	defer task.End()

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetConfig(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetGarbageCollectionConfig operation middleware
func (siw *ServerInterfaceWrapper) GetGarbageCollectionConfig(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetGarbageCollectionConfig")
	defer task.End()

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGarbageCollectionConfig(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetStorageConfig operation middleware
func (siw *ServerInterfaceWrapper) GetStorageConfig(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetStorageConfig")
	defer task.End()

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetStorageConfig(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetLakeFSVersion operation middleware
func (siw *ServerInterfaceWrapper) GetLakeFSVersion(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetLakeFSVersion")
	defer task.End()

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLakeFSVersion(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// HealthCheck operation middleware
func (siw *ServerInterfaceWrapper) HealthCheck(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:HealthCheck")
	defer task.End()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HealthCheck(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PullIcebergTable operation middleware
func (siw *ServerInterfaceWrapper) PullIcebergTable(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:PullIcebergTable")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body PullIcebergTableJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'PullIcebergTable' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "catalog" -------------
	var catalog string

	err = runtime.BindStyledParameter("simple", false, "catalog", chi.URLParam(r, "catalog"), &catalog)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter catalog: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PullIcebergTable(w, r, body, catalog)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PushIcebergTable operation middleware
func (siw *ServerInterfaceWrapper) PushIcebergTable(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:PushIcebergTable")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body PushIcebergTableJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'PushIcebergTable' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "catalog" -------------
	var catalog string

	err = runtime.BindStyledParameter("simple", false, "catalog", chi.URLParam(r, "catalog"), &catalog)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter catalog: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PushIcebergTable(w, r, body, catalog)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetLicense operation middleware
func (siw *ServerInterfaceWrapper) GetLicense(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetLicense")
	defer task.End()

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLicense(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// OauthCallback operation middleware
func (siw *ServerInterfaceWrapper) OauthCallback(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:OauthCallback")
	defer task.End()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.OauthCallback(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListRepositories operation middleware
func (siw *ServerInterfaceWrapper) ListRepositories(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListRepositories")
	defer task.End()

	var err error

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRepositoriesParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "search" -------------
	if paramValue := r.URL.Query().Get("search"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter search: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListRepositories(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateRepository operation middleware
func (siw *ServerInterfaceWrapper) CreateRepository(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CreateRepository")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body CreateRepositoryJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreateRepository' as JSON", http.StatusBadRequest)
			return
		}
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateRepositoryParams

	// ------------- Optional query parameter "bare" -------------
	if paramValue := r.URL.Query().Get("bare"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "bare", r.URL.Query(), &params.Bare)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter bare: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateRepository(w, r, body, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteRepository operation middleware
func (siw *ServerInterfaceWrapper) DeleteRepository(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DeleteRepository")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteRepositoryParams

	// ------------- Optional query parameter "force" -------------
	if paramValue := r.URL.Query().Get("force"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "force", r.URL.Query(), &params.Force)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter force: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteRepository(w, r, repository, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetRepository operation middleware
func (siw *ServerInterfaceWrapper) GetRepository(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetRepository")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRepository(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListRepositoryRuns operation middleware
func (siw *ServerInterfaceWrapper) ListRepositoryRuns(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListRepositoryRuns")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRepositoryRunsParams

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "branch" -------------
	if paramValue := r.URL.Query().Get("branch"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "branch", r.URL.Query(), &params.Branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "commit" -------------
	if paramValue := r.URL.Query().Get("commit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "commit", r.URL.Query(), &params.Commit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter commit: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListRepositoryRuns(w, r, repository, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetRun operation middleware
func (siw *ServerInterfaceWrapper) GetRun(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetRun")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "run_id" -------------
	var runId string

	err = runtime.BindStyledParameter("simple", false, "run_id", chi.URLParam(r, "run_id"), &runId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter run_id: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRun(w, r, repository, runId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListRunHooks operation middleware
func (siw *ServerInterfaceWrapper) ListRunHooks(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListRunHooks")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "run_id" -------------
	var runId string

	err = runtime.BindStyledParameter("simple", false, "run_id", chi.URLParam(r, "run_id"), &runId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter run_id: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRunHooksParams

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListRunHooks(w, r, repository, runId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetRunHookOutput operation middleware
func (siw *ServerInterfaceWrapper) GetRunHookOutput(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetRunHookOutput")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "run_id" -------------
	var runId string

	err = runtime.BindStyledParameter("simple", false, "run_id", chi.URLParam(r, "run_id"), &runId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter run_id: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "hook_run_id" -------------
	var hookRunId string

	err = runtime.BindStyledParameter("simple", false, "hook_run_id", chi.URLParam(r, "hook_run_id"), &hookRunId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter hook_run_id: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRunHookOutput(w, r, repository, runId, hookRunId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// InternalDeleteBranchProtectionRule operation middleware
func (siw *ServerInterfaceWrapper) InternalDeleteBranchProtectionRule(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:InternalDeleteBranchProtectionRule")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body InternalDeleteBranchProtectionRuleJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'InternalDeleteBranchProtectionRule' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.InternalDeleteBranchProtectionRule(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// InternalGetBranchProtectionRules operation middleware
func (siw *ServerInterfaceWrapper) InternalGetBranchProtectionRules(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:InternalGetBranchProtectionRules")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.InternalGetBranchProtectionRules(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// InternalCreateBranchProtectionRule operation middleware
func (siw *ServerInterfaceWrapper) InternalCreateBranchProtectionRule(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:InternalCreateBranchProtectionRule")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body InternalCreateBranchProtectionRuleJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'InternalCreateBranchProtectionRule' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.InternalCreateBranchProtectionRule(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateBranchProtectionRulePreflight operation middleware
func (siw *ServerInterfaceWrapper) CreateBranchProtectionRulePreflight(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CreateBranchProtectionRulePreflight")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateBranchProtectionRulePreflight(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListBranches operation middleware
func (siw *ServerInterfaceWrapper) ListBranches(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListBranches")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListBranchesParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "show_hidden" -------------
	if paramValue := r.URL.Query().Get("show_hidden"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "show_hidden", r.URL.Query(), &params.ShowHidden)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter show_hidden: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListBranches(w, r, repository, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateBranch operation middleware
func (siw *ServerInterfaceWrapper) CreateBranch(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CreateBranch")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body CreateBranchJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreateBranch' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateBranch(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteBranch operation middleware
func (siw *ServerInterfaceWrapper) DeleteBranch(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DeleteBranch")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteBranchParams

	// ------------- Optional query parameter "force" -------------
	if paramValue := r.URL.Query().Get("force"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "force", r.URL.Query(), &params.Force)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter force: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteBranch(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetBranch operation middleware
func (siw *ServerInterfaceWrapper) GetBranch(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetBranch")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetBranch(w, r, repository, branch)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ResetBranch operation middleware
func (siw *ServerInterfaceWrapper) ResetBranch(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ResetBranch")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body ResetBranchJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'ResetBranch' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ResetBranch(w, r, body, repository, branch)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CherryPick operation middleware
func (siw *ServerInterfaceWrapper) CherryPick(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CherryPick")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body CherryPickJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CherryPick' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CherryPick(w, r, body, repository, branch)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Commit operation middleware
func (siw *ServerInterfaceWrapper) Commit(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:Commit")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body CommitJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'Commit' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CommitParams

	// ------------- Optional query parameter "source_metarange" -------------
	if paramValue := r.URL.Query().Get("source_metarange"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "source_metarange", r.URL.Query(), &params.SourceMetarange)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter source_metarange: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Commit(w, r, body, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CommitAsync operation middleware
func (siw *ServerInterfaceWrapper) CommitAsync(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CommitAsync")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body CommitAsyncJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CommitAsync' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CommitAsyncParams

	// ------------- Optional query parameter "source_metarange" -------------
	if paramValue := r.URL.Query().Get("source_metarange"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "source_metarange", r.URL.Query(), &params.SourceMetarange)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter source_metarange: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CommitAsync(w, r, body, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CommitAsyncStatus operation middleware
func (siw *ServerInterfaceWrapper) CommitAsyncStatus(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CommitAsyncStatus")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", chi.URLParam(r, "id"), &id)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter id: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CommitAsyncStatus(w, r, repository, branch, id)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DiffBranch operation middleware
func (siw *ServerInterfaceWrapper) DiffBranch(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DiffBranch")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DiffBranchParams

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "delimiter" -------------
	if paramValue := r.URL.Query().Get("delimiter"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "delimiter", r.URL.Query(), &params.Delimiter)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter delimiter: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DiffBranch(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// HardResetBranch operation middleware
func (siw *ServerInterfaceWrapper) HardResetBranch(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:HardResetBranch")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params HardResetBranchParams

	// ------------- Required query parameter "ref" -------------
	if paramValue := r.URL.Query().Get("ref"); paramValue != "" {

	} else {
		http.Error(w, "Query argument ref is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "ref", r.URL.Query(), &params.Ref)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ref: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "force" -------------
	if paramValue := r.URL.Query().Get("force"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "force", r.URL.Query(), &params.Force)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter force: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HardResetBranch(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ImportCancel operation middleware
func (siw *ServerInterfaceWrapper) ImportCancel(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ImportCancel")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ImportCancelParams

	// ------------- Required query parameter "id" -------------
	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		http.Error(w, "Query argument id is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter id: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ImportCancel(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ImportStatus operation middleware
func (siw *ServerInterfaceWrapper) ImportStatus(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ImportStatus")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ImportStatusParams

	// ------------- Required query parameter "id" -------------
	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		http.Error(w, "Query argument id is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter id: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ImportStatus(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ImportStart operation middleware
func (siw *ServerInterfaceWrapper) ImportStart(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ImportStart")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body ImportStartJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'ImportStart' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ImportStart(w, r, body, repository, branch)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteObject operation middleware
func (siw *ServerInterfaceWrapper) DeleteObject(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DeleteObject")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteObjectParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "force" -------------
	if paramValue := r.URL.Query().Get("force"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "force", r.URL.Query(), &params.Force)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter force: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "no_tombstone" -------------
	if paramValue := r.URL.Query().Get("no_tombstone"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "no_tombstone", r.URL.Query(), &params.NoTombstone)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter no_tombstone: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteObject(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UploadObject operation middleware
func (siw *ServerInterfaceWrapper) UploadObject(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:UploadObject")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UploadObjectParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "storageClass" -------------
	if paramValue := r.URL.Query().Get("storageClass"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "storageClass", r.URL.Query(), &params.StorageClass)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter storageClass: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "force" -------------
	if paramValue := r.URL.Query().Get("force"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "force", r.URL.Query(), &params.Force)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter force: %s", err), http.StatusBadRequest)
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch IfNoneMatch
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for If-None-Match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "If-None-Match", valueList[0], &IfNoneMatch)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter If-None-Match: %s", err), http.StatusBadRequest)
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch IfMatch
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for If-Match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "If-Match", valueList[0], &IfMatch)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter If-Match: %s", err), http.StatusBadRequest)
			return
		}

		params.IfMatch = &IfMatch

	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UploadObject(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// StageObject operation middleware
func (siw *ServerInterfaceWrapper) StageObject(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:StageObject")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body StageObjectJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'StageObject' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params StageObjectParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.StageObject(w, r, body, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CopyObject operation middleware
func (siw *ServerInterfaceWrapper) CopyObject(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CopyObject")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body CopyObjectJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CopyObject' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CopyObjectParams

	// ------------- Required query parameter "dest_path" -------------
	if paramValue := r.URL.Query().Get("dest_path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument dest_path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "dest_path", r.URL.Query(), &params.DestPath)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter dest_path: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CopyObject(w, r, body, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteObjects operation middleware
func (siw *ServerInterfaceWrapper) DeleteObjects(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DeleteObjects")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body DeleteObjectsJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'DeleteObjects' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteObjectsParams

	// ------------- Optional query parameter "force" -------------
	if paramValue := r.URL.Query().Get("force"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "force", r.URL.Query(), &params.Force)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter force: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "no_tombstone" -------------
	if paramValue := r.URL.Query().Get("no_tombstone"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "no_tombstone", r.URL.Query(), &params.NoTombstone)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter no_tombstone: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteObjects(w, r, body, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UploadObjectPreflight operation middleware
func (siw *ServerInterfaceWrapper) UploadObjectPreflight(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:UploadObjectPreflight")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UploadObjectPreflightParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UploadObjectPreflight(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateObjectUserMetadata operation middleware
func (siw *ServerInterfaceWrapper) UpdateObjectUserMetadata(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:UpdateObjectUserMetadata")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body UpdateObjectUserMetadataJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'UpdateObjectUserMetadata' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateObjectUserMetadataParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateObjectUserMetadata(w, r, body, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RevertBranch operation middleware
func (siw *ServerInterfaceWrapper) RevertBranch(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:RevertBranch")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body RevertBranchJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'RevertBranch' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RevertBranch(w, r, body, repository, branch)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetPhysicalAddress operation middleware
func (siw *ServerInterfaceWrapper) GetPhysicalAddress(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetPhysicalAddress")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPhysicalAddressParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "presign" -------------
	if paramValue := r.URL.Query().Get("presign"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "presign", r.URL.Query(), &params.Presign)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter presign: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPhysicalAddress(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// LinkPhysicalAddress operation middleware
func (siw *ServerInterfaceWrapper) LinkPhysicalAddress(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:LinkPhysicalAddress")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body LinkPhysicalAddressJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'LinkPhysicalAddress' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params LinkPhysicalAddressParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch IfNoneMatch
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for If-None-Match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "If-None-Match", valueList[0], &IfNoneMatch)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter If-None-Match: %s", err), http.StatusBadRequest)
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch IfMatch
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for If-Match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "If-Match", valueList[0], &IfMatch)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter If-Match: %s", err), http.StatusBadRequest)
			return
		}

		params.IfMatch = &IfMatch

	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LinkPhysicalAddress(w, r, body, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreatePresignMultipartUpload operation middleware
func (siw *ServerInterfaceWrapper) CreatePresignMultipartUpload(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CreatePresignMultipartUpload")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreatePresignMultipartUploadParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "parts" -------------
	if paramValue := r.URL.Query().Get("parts"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "parts", r.URL.Query(), &params.Parts)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter parts: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreatePresignMultipartUpload(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AbortPresignMultipartUpload operation middleware
func (siw *ServerInterfaceWrapper) AbortPresignMultipartUpload(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:AbortPresignMultipartUpload")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body AbortPresignMultipartUploadJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'AbortPresignMultipartUpload' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "uploadId" -------------
	var uploadId string

	err = runtime.BindStyledParameter("simple", false, "uploadId", chi.URLParam(r, "uploadId"), &uploadId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uploadId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AbortPresignMultipartUploadParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AbortPresignMultipartUpload(w, r, body, repository, branch, uploadId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CompletePresignMultipartUpload operation middleware
func (siw *ServerInterfaceWrapper) CompletePresignMultipartUpload(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CompletePresignMultipartUpload")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body CompletePresignMultipartUploadJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CompletePresignMultipartUpload' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "uploadId" -------------
	var uploadId string

	err = runtime.BindStyledParameter("simple", false, "uploadId", chi.URLParam(r, "uploadId"), &uploadId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uploadId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CompletePresignMultipartUploadParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CompletePresignMultipartUpload(w, r, body, repository, branch, uploadId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UploadPart operation middleware
func (siw *ServerInterfaceWrapper) UploadPart(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:UploadPart")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body UploadPartJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'UploadPart' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "uploadId" -------------
	var uploadId string

	err = runtime.BindStyledParameter("simple", false, "uploadId", chi.URLParam(r, "uploadId"), &uploadId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uploadId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "partNumber" -------------
	var partNumber int

	err = runtime.BindStyledParameter("simple", false, "partNumber", chi.URLParam(r, "partNumber"), &partNumber)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter partNumber: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UploadPartParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UploadPart(w, r, body, repository, branch, uploadId, partNumber, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UploadPartCopy operation middleware
func (siw *ServerInterfaceWrapper) UploadPartCopy(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:UploadPartCopy")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body UploadPartCopyJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'UploadPartCopy' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "uploadId" -------------
	var uploadId string

	err = runtime.BindStyledParameter("simple", false, "uploadId", chi.URLParam(r, "uploadId"), &uploadId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uploadId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "partNumber" -------------
	var partNumber int

	err = runtime.BindStyledParameter("simple", false, "partNumber", chi.URLParam(r, "partNumber"), &partNumber)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter partNumber: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UploadPartCopyParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UploadPartCopy(w, r, body, repository, branch, uploadId, partNumber, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateCommitRecord operation middleware
func (siw *ServerInterfaceWrapper) CreateCommitRecord(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CreateCommitRecord")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body CreateCommitRecordJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreateCommitRecord' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateCommitRecord(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetCommit operation middleware
func (siw *ServerInterfaceWrapper) GetCommit(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetCommit")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "commitId" -------------
	var commitId string

	err = runtime.BindStyledParameter("simple", false, "commitId", chi.URLParam(r, "commitId"), &commitId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter commitId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCommit(w, r, repository, commitId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DumpStatus operation middleware
func (siw *ServerInterfaceWrapper) DumpStatus(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DumpStatus")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DumpStatusParams

	// ------------- Required query parameter "task_id" -------------
	if paramValue := r.URL.Query().Get("task_id"); paramValue != "" {

	} else {
		http.Error(w, "Query argument task_id is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "task_id", r.URL.Query(), &params.TaskId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter task_id: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DumpStatus(w, r, repository, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DumpSubmit operation middleware
func (siw *ServerInterfaceWrapper) DumpSubmit(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DumpSubmit")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DumpSubmit(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PrepareGarbageCollectionCommits operation middleware
func (siw *ServerInterfaceWrapper) PrepareGarbageCollectionCommits(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:PrepareGarbageCollectionCommits")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PrepareGarbageCollectionCommits(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PrepareGarbageCollectionCommitsAsync operation middleware
func (siw *ServerInterfaceWrapper) PrepareGarbageCollectionCommitsAsync(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:PrepareGarbageCollectionCommitsAsync")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PrepareGarbageCollectionCommitsAsync(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PrepareGarbageCollectionCommitsStatus operation middleware
func (siw *ServerInterfaceWrapper) PrepareGarbageCollectionCommitsStatus(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:PrepareGarbageCollectionCommitsStatus")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PrepareGarbageCollectionCommitsStatusParams

	// ------------- Required query parameter "id" -------------
	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		http.Error(w, "Query argument id is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter id: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PrepareGarbageCollectionCommitsStatus(w, r, repository, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PrepareGarbageCollectionUncommitted operation middleware
func (siw *ServerInterfaceWrapper) PrepareGarbageCollectionUncommitted(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:PrepareGarbageCollectionUncommitted")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body PrepareGarbageCollectionUncommittedJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'PrepareGarbageCollectionUncommitted' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PrepareGarbageCollectionUncommitted(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// InternalDeleteGarbageCollectionRules operation middleware
func (siw *ServerInterfaceWrapper) InternalDeleteGarbageCollectionRules(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:InternalDeleteGarbageCollectionRules")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.InternalDeleteGarbageCollectionRules(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// InternalGetGarbageCollectionRules operation middleware
func (siw *ServerInterfaceWrapper) InternalGetGarbageCollectionRules(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:InternalGetGarbageCollectionRules")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.InternalGetGarbageCollectionRules(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// InternalSetGarbageCollectionRules operation middleware
func (siw *ServerInterfaceWrapper) InternalSetGarbageCollectionRules(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:InternalSetGarbageCollectionRules")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body InternalSetGarbageCollectionRulesJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'InternalSetGarbageCollectionRules' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.InternalSetGarbageCollectionRules(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SetGarbageCollectionRulesPreflight operation middleware
func (siw *ServerInterfaceWrapper) SetGarbageCollectionRulesPreflight(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:SetGarbageCollectionRulesPreflight")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetGarbageCollectionRulesPreflight(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteRepositoryMetadata operation middleware
func (siw *ServerInterfaceWrapper) DeleteRepositoryMetadata(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DeleteRepositoryMetadata")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body DeleteRepositoryMetadataJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'DeleteRepositoryMetadata' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteRepositoryMetadata(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetRepositoryMetadata operation middleware
func (siw *ServerInterfaceWrapper) GetRepositoryMetadata(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetRepositoryMetadata")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRepositoryMetadata(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SetRepositoryMetadata operation middleware
func (siw *ServerInterfaceWrapper) SetRepositoryMetadata(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:SetRepositoryMetadata")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body SetRepositoryMetadataJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'SetRepositoryMetadata' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetRepositoryMetadata(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetMetaRange operation middleware
func (siw *ServerInterfaceWrapper) GetMetaRange(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetMetaRange")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "meta_range" -------------
	var metaRange string

	err = runtime.BindStyledParameter("simple", false, "meta_range", chi.URLParam(r, "meta_range"), &metaRange)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter meta_range: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMetaRange(w, r, repository, metaRange)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetMetadataObject operation middleware
func (siw *ServerInterfaceWrapper) GetMetadataObject(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetMetadataObject")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "type" -------------
	var pType string

	err = runtime.BindStyledParameter("simple", false, "type", chi.URLParam(r, "type"), &pType)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter type: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "object_id" -------------
	var objectId string

	err = runtime.BindStyledParameter("simple", false, "object_id", chi.URLParam(r, "object_id"), &objectId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter object_id: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetMetadataObjectParams

	// ------------- Optional query parameter "presign" -------------
	if paramValue := r.URL.Query().Get("presign"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "presign", r.URL.Query(), &params.Presign)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter presign: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMetadataObject(w, r, repository, pType, objectId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetRange operation middleware
func (siw *ServerInterfaceWrapper) GetRange(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetRange")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "range" -------------
	var pRange string

	err = runtime.BindStyledParameter("simple", false, "range", chi.URLParam(r, "range"), &pRange)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter range: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRange(w, r, repository, pRange)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListPullRequests operation middleware
func (siw *ServerInterfaceWrapper) ListPullRequests(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListPullRequests")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPullRequestsParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "status" -------------
	if paramValue := r.URL.Query().Get("status"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter status: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListPullRequests(w, r, repository, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreatePullRequest operation middleware
func (siw *ServerInterfaceWrapper) CreatePullRequest(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CreatePullRequest")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body CreatePullRequestJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreatePullRequest' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreatePullRequest(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetPullRequest operation middleware
func (siw *ServerInterfaceWrapper) GetPullRequest(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetPullRequest")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "pull_request" -------------
	var pullRequest string

	err = runtime.BindStyledParameter("simple", false, "pull_request", chi.URLParam(r, "pull_request"), &pullRequest)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter pull_request: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPullRequest(w, r, repository, pullRequest)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdatePullRequest operation middleware
func (siw *ServerInterfaceWrapper) UpdatePullRequest(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:UpdatePullRequest")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body UpdatePullRequestJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'UpdatePullRequest' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "pull_request" -------------
	var pullRequest string

	err = runtime.BindStyledParameter("simple", false, "pull_request", chi.URLParam(r, "pull_request"), &pullRequest)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter pull_request: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdatePullRequest(w, r, body, repository, pullRequest)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// MergePullRequest operation middleware
func (siw *ServerInterfaceWrapper) MergePullRequest(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:MergePullRequest")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "pull_request" -------------
	var pullRequest string

	err = runtime.BindStyledParameter("simple", false, "pull_request", chi.URLParam(r, "pull_request"), &pullRequest)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter pull_request: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.MergePullRequest(w, r, repository, pullRequest)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DumpRefs operation middleware
func (siw *ServerInterfaceWrapper) DumpRefs(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DumpRefs")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DumpRefs(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RestoreRefs operation middleware
func (siw *ServerInterfaceWrapper) RestoreRefs(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:RestoreRefs")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body RestoreRefsJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'RestoreRefs' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RestoreRefs(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateSymlinkFile operation middleware
func (siw *ServerInterfaceWrapper) CreateSymlinkFile(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CreateSymlinkFile")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateSymlinkFileParams

	// ------------- Optional query parameter "location" -------------
	if paramValue := r.URL.Query().Get("location"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "location", r.URL.Query(), &params.Location)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter location: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateSymlinkFile(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DiffRefs operation middleware
func (siw *ServerInterfaceWrapper) DiffRefs(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DiffRefs")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "leftRef" -------------
	var leftRef string

	err = runtime.BindStyledParameter("simple", false, "leftRef", chi.URLParam(r, "leftRef"), &leftRef)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter leftRef: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "rightRef" -------------
	var rightRef string

	err = runtime.BindStyledParameter("simple", false, "rightRef", chi.URLParam(r, "rightRef"), &rightRef)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter rightRef: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DiffRefsParams

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "delimiter" -------------
	if paramValue := r.URL.Query().Get("delimiter"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "delimiter", r.URL.Query(), &params.Delimiter)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter delimiter: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "type" -------------
	if paramValue := r.URL.Query().Get("type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "type", r.URL.Query(), &params.Type)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter type: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "include_right_stats" -------------
	if paramValue := r.URL.Query().Get("include_right_stats"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include_right_stats", r.URL.Query(), &params.IncludeRightStats)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter include_right_stats: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DiffRefs(w, r, repository, leftRef, rightRef, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// LogCommits operation middleware
func (siw *ServerInterfaceWrapper) LogCommits(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:LogCommits")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameter("simple", false, "ref", chi.URLParam(r, "ref"), &ref)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ref: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params LogCommitsParams

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "objects" -------------
	if paramValue := r.URL.Query().Get("objects"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "objects", r.URL.Query(), &params.Objects)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter objects: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "prefixes" -------------
	if paramValue := r.URL.Query().Get("prefixes"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefixes", r.URL.Query(), &params.Prefixes)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefixes: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "first_parent" -------------
	if paramValue := r.URL.Query().Get("first_parent"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "first_parent", r.URL.Query(), &params.FirstParent)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter first_parent: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "since" -------------
	if paramValue := r.URL.Query().Get("since"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "since", r.URL.Query(), &params.Since)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter since: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "stop_at" -------------
	if paramValue := r.URL.Query().Get("stop_at"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "stop_at", r.URL.Query(), &params.StopAt)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter stop_at: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LogCommits(w, r, repository, ref, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetObject operation middleware
func (siw *ServerInterfaceWrapper) GetObject(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetObject")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameter("simple", false, "ref", chi.URLParam(r, "ref"), &ref)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ref: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetObjectParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "presign" -------------
	if paramValue := r.URL.Query().Get("presign"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "presign", r.URL.Query(), &params.Presign)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter presign: %s", err), http.StatusBadRequest)
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "Range" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Range")]; found {
		var Range string
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for Range, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "Range", valueList[0], &Range)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter Range: %s", err), http.StatusBadRequest)
			return
		}

		params.Range = &Range

	}

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for If-None-Match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "If-None-Match", valueList[0], &IfNoneMatch)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter If-None-Match: %s", err), http.StatusBadRequest)
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetObject(w, r, repository, ref, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// HeadObject operation middleware
func (siw *ServerInterfaceWrapper) HeadObject(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:HeadObject")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameter("simple", false, "ref", chi.URLParam(r, "ref"), &ref)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ref: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params HeadObjectParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "Range" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Range")]; found {
		var Range string
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for Range, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "Range", valueList[0], &Range)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter Range: %s", err), http.StatusBadRequest)
			return
		}

		params.Range = &Range

	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HeadObject(w, r, repository, ref, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListObjects operation middleware
func (siw *ServerInterfaceWrapper) ListObjects(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListObjects")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameter("simple", false, "ref", chi.URLParam(r, "ref"), &ref)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ref: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListObjectsParams

	// ------------- Optional query parameter "user_metadata" -------------
	if paramValue := r.URL.Query().Get("user_metadata"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "user_metadata", r.URL.Query(), &params.UserMetadata)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter user_metadata: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "presign" -------------
	if paramValue := r.URL.Query().Get("presign"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "presign", r.URL.Query(), &params.Presign)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter presign: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "delimiter" -------------
	if paramValue := r.URL.Query().Get("delimiter"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "delimiter", r.URL.Query(), &params.Delimiter)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter delimiter: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListObjects(w, r, repository, ref, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// StatObject operation middleware
func (siw *ServerInterfaceWrapper) StatObject(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:StatObject")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameter("simple", false, "ref", chi.URLParam(r, "ref"), &ref)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ref: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params StatObjectParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "user_metadata" -------------
	if paramValue := r.URL.Query().Get("user_metadata"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "user_metadata", r.URL.Query(), &params.UserMetadata)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter user_metadata: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "presign" -------------
	if paramValue := r.URL.Query().Get("presign"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "presign", r.URL.Query(), &params.Presign)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter presign: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.StatObject(w, r, repository, ref, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetUnderlyingProperties operation middleware
func (siw *ServerInterfaceWrapper) GetUnderlyingProperties(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetUnderlyingProperties")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameter("simple", false, "ref", chi.URLParam(r, "ref"), &ref)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ref: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUnderlyingPropertiesParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUnderlyingProperties(w, r, repository, ref, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindMergeBase operation middleware
func (siw *ServerInterfaceWrapper) FindMergeBase(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:FindMergeBase")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "sourceRef" -------------
	var sourceRef string

	err = runtime.BindStyledParameter("simple", false, "sourceRef", chi.URLParam(r, "sourceRef"), &sourceRef)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter sourceRef: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "destinationBranch" -------------
	var destinationBranch string

	err = runtime.BindStyledParameter("simple", false, "destinationBranch", chi.URLParam(r, "destinationBranch"), &destinationBranch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter destinationBranch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindMergeBase(w, r, repository, sourceRef, destinationBranch)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// MergeIntoBranch operation middleware
func (siw *ServerInterfaceWrapper) MergeIntoBranch(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:MergeIntoBranch")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body MergeIntoBranchJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'MergeIntoBranch' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "sourceRef" -------------
	var sourceRef string

	err = runtime.BindStyledParameter("simple", false, "sourceRef", chi.URLParam(r, "sourceRef"), &sourceRef)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter sourceRef: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "destinationBranch" -------------
	var destinationBranch string

	err = runtime.BindStyledParameter("simple", false, "destinationBranch", chi.URLParam(r, "destinationBranch"), &destinationBranch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter destinationBranch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.MergeIntoBranch(w, r, body, repository, sourceRef, destinationBranch)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// MergeIntoBranchAsync operation middleware
func (siw *ServerInterfaceWrapper) MergeIntoBranchAsync(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:MergeIntoBranchAsync")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body MergeIntoBranchAsyncJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'MergeIntoBranchAsync' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "sourceRef" -------------
	var sourceRef string

	err = runtime.BindStyledParameter("simple", false, "sourceRef", chi.URLParam(r, "sourceRef"), &sourceRef)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter sourceRef: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "destinationBranch" -------------
	var destinationBranch string

	err = runtime.BindStyledParameter("simple", false, "destinationBranch", chi.URLParam(r, "destinationBranch"), &destinationBranch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter destinationBranch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.MergeIntoBranchAsync(w, r, body, repository, sourceRef, destinationBranch)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// MergeIntoBranchAsyncStatus operation middleware
func (siw *ServerInterfaceWrapper) MergeIntoBranchAsyncStatus(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:MergeIntoBranchAsyncStatus")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "sourceRef" -------------
	var sourceRef string

	err = runtime.BindStyledParameter("simple", false, "sourceRef", chi.URLParam(r, "sourceRef"), &sourceRef)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter sourceRef: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "destinationBranch" -------------
	var destinationBranch string

	err = runtime.BindStyledParameter("simple", false, "destinationBranch", chi.URLParam(r, "destinationBranch"), &destinationBranch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter destinationBranch: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", chi.URLParam(r, "id"), &id)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter id: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.MergeIntoBranchAsyncStatus(w, r, repository, sourceRef, destinationBranch, id)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RestoreStatus operation middleware
func (siw *ServerInterfaceWrapper) RestoreStatus(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:RestoreStatus")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RestoreStatusParams

	// ------------- Required query parameter "task_id" -------------
	if paramValue := r.URL.Query().Get("task_id"); paramValue != "" {

	} else {
		http.Error(w, "Query argument task_id is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "task_id", r.URL.Query(), &params.TaskId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter task_id: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RestoreStatus(w, r, repository, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RestoreSubmit operation middleware
func (siw *ServerInterfaceWrapper) RestoreSubmit(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:RestoreSubmit")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body RestoreSubmitJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'RestoreSubmit' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RestoreSubmit(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetBranchProtectionRules operation middleware
func (siw *ServerInterfaceWrapper) GetBranchProtectionRules(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetBranchProtectionRules")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetBranchProtectionRules(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SetBranchProtectionRules operation middleware
func (siw *ServerInterfaceWrapper) SetBranchProtectionRules(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:SetBranchProtectionRules")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body SetBranchProtectionRulesJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'SetBranchProtectionRules' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SetBranchProtectionRulesParams

	headers := r.Header

	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch string
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for If-Match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "If-Match", valueList[0], &IfMatch)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter If-Match: %s", err), http.StatusBadRequest)
			return
		}

		params.IfMatch = &IfMatch

	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetBranchProtectionRules(w, r, body, repository, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteGCRules operation middleware
func (siw *ServerInterfaceWrapper) DeleteGCRules(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DeleteGCRules")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGCRules(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetGCRules operation middleware
func (siw *ServerInterfaceWrapper) GetGCRules(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetGCRules")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGCRules(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SetGCRules operation middleware
func (siw *ServerInterfaceWrapper) SetGCRules(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:SetGCRules")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body SetGCRulesJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'SetGCRules' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetGCRules(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListTags operation middleware
func (siw *ServerInterfaceWrapper) ListTags(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListTags")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListTagsParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListTags(w, r, repository, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateTag operation middleware
func (siw *ServerInterfaceWrapper) CreateTag(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CreateTag")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body CreateTagJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreateTag' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateTag(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteTag operation middleware
func (siw *ServerInterfaceWrapper) DeleteTag(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DeleteTag")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "tag" -------------
	var tag string

	err = runtime.BindStyledParameter("simple", false, "tag", chi.URLParam(r, "tag"), &tag)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter tag: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteTagParams

	// ------------- Optional query parameter "force" -------------
	if paramValue := r.URL.Query().Get("force"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "force", r.URL.Query(), &params.Force)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter force: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteTag(w, r, repository, tag, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetTag operation middleware
func (siw *ServerInterfaceWrapper) GetTag(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetTag")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "tag" -------------
	var tag string

	err = runtime.BindStyledParameter("simple", false, "tag", chi.URLParam(r, "tag"), &tag)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter tag: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTag(w, r, repository, tag)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SetupCommPrefs operation middleware
func (siw *ServerInterfaceWrapper) SetupCommPrefs(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:SetupCommPrefs")
	defer task.End()

	// ------------- Body parse -------------
	var body SetupCommPrefsJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'SetupCommPrefs' as JSON", http.StatusBadRequest)
			return
		}
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetupCommPrefs(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetSetupState operation middleware
func (siw *ServerInterfaceWrapper) GetSetupState(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetSetupState")
	defer task.End()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSetupState(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Setup operation middleware
func (siw *ServerInterfaceWrapper) Setup(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:Setup")
	defer task.End()

	// ------------- Body parse -------------
	var body SetupJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'Setup' as JSON", http.StatusBadRequest)
			return
		}
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Setup(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostStatsEvents operation middleware
func (siw *ServerInterfaceWrapper) PostStatsEvents(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:PostStatsEvents")
	defer task.End()

	// ------------- Body parse -------------
	var body PostStatsEventsJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'PostStatsEvents' as JSON", http.StatusBadRequest)
			return
		}
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostStatsEvents(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// StsLogin operation middleware
func (siw *ServerInterfaceWrapper) StsLogin(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:StsLogin")
	defer task.End()

	// ------------- Body parse -------------
	var body StsLoginJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'StsLogin' as JSON", http.StatusBadRequest)
			return
		}
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.StsLogin(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetUsageReportSummary operation middleware
func (siw *ServerInterfaceWrapper) GetUsageReportSummary(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetUsageReportSummary")
	defer task.End()

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUsageReportSummary(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetCurrentUser operation middleware
func (siw *ServerInterfaceWrapper) GetCurrentUser(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetCurrentUser")
	defer task.End()

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCurrentUser(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL     string
	BaseRouter  chi.Router
	Middlewares []MiddlewareFunc
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/capabilities", wrapper.GetAuthCapabilities)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/external/principal/login", wrapper.ExternalPrincipalLogin)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/external/principals", wrapper.GetExternalPrincipal)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/get-token/mailboxes/{mailbox}", wrapper.GetTokenFromMailbox)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/get-token/release-token/{loginRequestToken}", wrapper.ReleaseTokenToMailbox)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/get-token/start", wrapper.GetTokenRedirect)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/groups", wrapper.ListGroups)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/groups", wrapper.CreateGroup)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/groups/{groupId}", wrapper.DeleteGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/groups/{groupId}", wrapper.GetGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/groups/{groupId}/acl", wrapper.GetGroupACL)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/groups/{groupId}/acl", wrapper.SetGroupACL)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/groups/{groupId}/members", wrapper.ListGroupMembers)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/groups/{groupId}/members/{userId}", wrapper.DeleteGroupMembership)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/auth/groups/{groupId}/members/{userId}", wrapper.AddGroupMembership)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/groups/{groupId}/policies", wrapper.ListGroupPolicies)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/groups/{groupId}/policies/{policyId}", wrapper.DetachPolicyFromGroup)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/auth/groups/{groupId}/policies/{policyId}", wrapper.AttachPolicyToGroup)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/login", wrapper.Login)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/policies", wrapper.ListPolicies)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/policies", wrapper.CreatePolicy)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/policies/{policyId}", wrapper.DeletePolicy)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/policies/{policyId}", wrapper.GetPolicy)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/auth/policies/{policyId}", wrapper.UpdatePolicy)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/users", wrapper.ListUsers)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/users", wrapper.CreateUser)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/users/{userId}", wrapper.DeleteUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/users/{userId}", wrapper.GetUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/users/{userId}/credentials", wrapper.ListUserCredentials)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/users/{userId}/credentials", wrapper.CreateCredentials)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/users/{userId}/credentials/{accessKeyId}", wrapper.DeleteCredentials)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/users/{userId}/credentials/{accessKeyId}", wrapper.GetCredentials)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/users/{userId}/external/principals", wrapper.DeleteUserExternalPrincipal)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/users/{userId}/external/principals", wrapper.CreateUserExternalPrincipal)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/users/{userId}/external/principals/ls", wrapper.ListUserExternalPrincipals)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/users/{userId}/groups", wrapper.ListUserGroups)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/users/{userId}/policies", wrapper.ListUserPolicies)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/users/{userId}/policies/{policyId}", wrapper.DetachPolicyFromUser)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/auth/users/{userId}/policies/{policyId}", wrapper.AttachPolicyToUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/config", wrapper.GetConfig)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/config/garbage-collection", wrapper.GetGarbageCollectionConfig)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/config/storage", wrapper.GetStorageConfig)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/config/version", wrapper.GetLakeFSVersion)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/healthcheck", wrapper.HealthCheck)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/iceberg/remotes/{catalog}/pull", wrapper.PullIcebergTable)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/iceberg/remotes/{catalog}/push", wrapper.PushIcebergTable)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/license", wrapper.GetLicense)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/oidc/callback", wrapper.OauthCallback)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories", wrapper.ListRepositories)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories", wrapper.CreateRepository)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}", wrapper.DeleteRepository)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}", wrapper.GetRepository)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/actions/runs", wrapper.ListRepositoryRuns)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/actions/runs/{run_id}", wrapper.GetRun)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/actions/runs/{run_id}/hooks", wrapper.ListRunHooks)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/actions/runs/{run_id}/hooks/{hook_run_id}/output", wrapper.GetRunHookOutput)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/branch_protection", wrapper.InternalDeleteBranchProtectionRule)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/branch_protection", wrapper.InternalGetBranchProtectionRules)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branch_protection", wrapper.InternalCreateBranchProtectionRule)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/branch_protection/set_allowed", wrapper.CreateBranchProtectionRulePreflight)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/branches", wrapper.ListBranches)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches", wrapper.CreateBranch)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/branches/{branch}", wrapper.DeleteBranch)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/branches/{branch}", wrapper.GetBranch)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/branches/{branch}", wrapper.ResetBranch)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches/{branch}/cherry-pick", wrapper.CherryPick)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches/{branch}/commits", wrapper.Commit)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches/{branch}/commits/async", wrapper.CommitAsync)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/branches/{branch}/commits/async/{id}/status", wrapper.CommitAsyncStatus)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/branches/{branch}/diff", wrapper.DiffBranch)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/branches/{branch}/hard_reset", wrapper.HardResetBranch)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/branches/{branch}/import", wrapper.ImportCancel)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/branches/{branch}/import", wrapper.ImportStatus)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches/{branch}/import", wrapper.ImportStart)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/branches/{branch}/objects", wrapper.DeleteObject)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches/{branch}/objects", wrapper.UploadObject)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/branches/{branch}/objects", wrapper.StageObject)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches/{branch}/objects/copy", wrapper.CopyObject)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches/{branch}/objects/delete", wrapper.DeleteObjects)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/branches/{branch}/objects/stage_allowed", wrapper.UploadObjectPreflight)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/branches/{branch}/objects/stat/user_metadata", wrapper.UpdateObjectUserMetadata)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches/{branch}/revert", wrapper.RevertBranch)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/branches/{branch}/staging/backing", wrapper.GetPhysicalAddress)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/branches/{branch}/staging/backing", wrapper.LinkPhysicalAddress)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches/{branch}/staging/pmpu", wrapper.CreatePresignMultipartUpload)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/branches/{branch}/staging/pmpu/{uploadId}", wrapper.AbortPresignMultipartUpload)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/branches/{branch}/staging/pmpu/{uploadId}", wrapper.CompletePresignMultipartUpload)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/branches/{branch}/staging/pmpu/{uploadId}/parts/{partNumber}", wrapper.UploadPart)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/branches/{branch}/staging/pmpu/{uploadId}/parts/{partNumber}/copy", wrapper.UploadPartCopy)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/commits", wrapper.CreateCommitRecord)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/commits/{commitId}", wrapper.GetCommit)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/dump", wrapper.DumpStatus)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/dump", wrapper.DumpSubmit)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/gc/prepare_commits", wrapper.PrepareGarbageCollectionCommits)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/gc/prepare_commits/async", wrapper.PrepareGarbageCollectionCommitsAsync)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/gc/prepare_commits/status", wrapper.PrepareGarbageCollectionCommitsStatus)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/gc/prepare_uncommited", wrapper.PrepareGarbageCollectionUncommitted)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/gc/rules", wrapper.InternalDeleteGarbageCollectionRules)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/gc/rules", wrapper.InternalGetGarbageCollectionRules)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/gc/rules", wrapper.InternalSetGarbageCollectionRules)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/gc/rules/set_allowed", wrapper.SetGarbageCollectionRulesPreflight)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/metadata", wrapper.DeleteRepositoryMetadata)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/metadata", wrapper.GetRepositoryMetadata)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/metadata", wrapper.SetRepositoryMetadata)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/metadata/meta_range/{meta_range}", wrapper.GetMetaRange)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/metadata/object/{type}/{object_id}", wrapper.GetMetadataObject)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/metadata/range/{range}", wrapper.GetRange)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/pulls", wrapper.ListPullRequests)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/pulls", wrapper.CreatePullRequest)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/pulls/{pull_request}", wrapper.GetPullRequest)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/repositories/{repository}/pulls/{pull_request}", wrapper.UpdatePullRequest)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/pulls/{pull_request}/merge", wrapper.MergePullRequest)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/refs/dump", wrapper.DumpRefs)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/refs/restore", wrapper.RestoreRefs)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/refs/{branch}/symlink", wrapper.CreateSymlinkFile)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/refs/{leftRef}/diff/{rightRef}", wrapper.DiffRefs)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/refs/{ref}/commits", wrapper.LogCommits)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/refs/{ref}/objects", wrapper.GetObject)
	})
	r.Group(func(r chi.Router) {
		r.Head(options.BaseURL+"/repositories/{repository}/refs/{ref}/objects", wrapper.HeadObject)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/refs/{ref}/objects/ls", wrapper.ListObjects)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/refs/{ref}/objects/stat", wrapper.StatObject)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/refs/{ref}/objects/underlyingProperties", wrapper.GetUnderlyingProperties)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/refs/{sourceRef}/merge/{destinationBranch}", wrapper.FindMergeBase)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/refs/{sourceRef}/merge/{destinationBranch}", wrapper.MergeIntoBranch)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/refs/{sourceRef}/merge/{destinationBranch}/async", wrapper.MergeIntoBranchAsync)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/refs/{sourceRef}/merge/{destinationBranch}/async/{id}/status", wrapper.MergeIntoBranchAsyncStatus)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/restore", wrapper.RestoreStatus)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/restore", wrapper.RestoreSubmit)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/settings/branch_protection", wrapper.GetBranchProtectionRules)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/settings/branch_protection", wrapper.SetBranchProtectionRules)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/settings/gc_rules", wrapper.DeleteGCRules)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/settings/gc_rules", wrapper.GetGCRules)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/settings/gc_rules", wrapper.SetGCRules)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/tags", wrapper.ListTags)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/tags", wrapper.CreateTag)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/tags/{tag}", wrapper.DeleteTag)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/tags/{tag}", wrapper.GetTag)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/setup_comm_prefs", wrapper.SetupCommPrefs)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/setup_lakefs", wrapper.GetSetupState)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/setup_lakefs", wrapper.Setup)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/statistics", wrapper.PostStatsEvents)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/sts/login", wrapper.StsLogin)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/usage-report/summary", wrapper.GetUsageReportSummary)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/user", wrapper.GetCurrentUser)
	})

	return r
}

// inline.tmpl based on https://github.com/deepmap/oapi-codegen/tree/master/pkg/codegen/templates

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9a3MbudEo/Ffw8k3V2nsoUrK9m6xTqZQsX6Insq2S5GxOrfywwJkmiWg4mAAYyYyj",
	"/34KDWAuHMyFEknJXn7ZtTgzQKPRNzT68rUX8HnCY4iV7L382kuooHNQIPCv48l7qoKZ/mcIMhAsUYzH",
	"vZe9c1BEcaJmQPj4XxCoHyR5c0Gn+keq+JwFNIoWhEYRvyE8AUH1h5LwOFoQNil/GKRCQKzMAHM9IUh8",
	"IxH8moUQkmsapTDo9Xvwhc6TCHove8/gFwieH/wRDn75I+w/gxfPfn4RHjz7U/AM/gg//+mg1+8xDekM",
	"aAii1+/FdK6/O57smTX1ezKYwZzqxalFop9JJVg87d3e9nvHkw88hubVX/Z+vOx5V6yBT5OI07C04itY",
	"kBmVJOZ28WQBakA+qhkIs0ZJqAASc0VkmiRcKAjLy/6xYV0a4k6L+8Av+HwsFY+hurgQIlBAIFZiQW6Y",
	"mvFUr9a+T25mEJOES8nGEZAf3/zz9M3Z8fs3Hy4OTzLY/p2CWOSgxXyUfV+CLIQJTSPVezmhkYS+g3TM",
	"eQQ0RlBP6ZTFSDyHEwVCf4UofjNP1OIfGmW9l0qk0F9ahQCVipgwBXNJqP6UqBmTBss1cOJrLagrwDPn",
	"aayq+JvxGzKn8cLOrTgxsNRNaobxouVgf7/fm9MvbJ7O8S/9J4vNn3sHGcJYrGAKYgnA1xCxOVsFaaH7",
	"gqQSQg36VPA0IQGfz3lMEgET9gUkGS9qFpMN0BmLpzjm3bbVwhMilbZvr3m9BbJzoCKYnZsfukJlvicT",
	"LojE7/VfAiK4prFCTmIga6AyHzRCddvvCZAJjyWgVH5FwzP4dwoSqS/gsQJDiDRJIhYgXof/khq0r4Vh",
	"/yBg0nvZ+/+HucQfmqdy+EYILsxU5aW9oiFxk932e0c8nkQs2MLEZyB5KgIgbkpJftXbfEHFFBCWt1yM",
	"WRhCvHlg8qlQeqq3PI3DLeLgA1fEzFmY/6P4wA+PTtYLhhnSA8s7lARaM0305H3ChZUO+DcZp8rpNhwB",
	"4TzWWmsOsYItYEsjqTihljMCAh6HTL/xlrJoG2AU5yR2UhQs4hqE+WrjMBzHCkRMI2JmJfbFfu9TTFM1",
	"44L9ZxuoKM122+/9g0YsxBm2hId8QoeCWydoUZJa9kmENlEVM+I1ATFnUjIDwdLmZs9IBNcQoY5k12C0",
	"z+HRyYCQy94Z0PCy1yeXvV8FU2D+eZ4mIC57hMbhZXzZOwznLNZ/CtBGY8Heu9SmQlUzCfh3yoTett+K",
	"IH7O3jUmpcbz4ZgLdSpAsmn8Po0US6hQn9Ae9Sx3tpDaeB3RMBQgpV8vlmZf/sILQxCAlH+HxZGAEGLF",
	"aCSrk1N8a3QFixELq+g2j9FuPn6tcS1BoZpNJQj3D8JighaQOWQQBVKxeFq2mw//fnx4/PH87cfXHz78",
	"8c0/D9+fnrzpoTV1AvFUzXovDypI7/ckBALUKIeyCqJ5hRQgvQ+YN/9DI/HPTyp+++b98fDvf3z/+s2H",
	"d8Px6ZezCTv6vxbuv7/5v22gL+1YGc2+dfm3UAN6lsbVfRsLGpuTUQVn2lhkym5n5SnE4UixOZ47JlzM",
	"qdJmI1Wwh7969gCuIVYj87NnQJHGdXNJRYVacTapqEpxiRBrK/u33sSIcFxYoo9GYQFZNfi2QPUdnkqw",
	"FFFUWl42e+NmnDBj9y1xcWZRtwnL3PbuGcMyjczRH43qtq9zmrjNgKRC0EVVSuTz5NN4VyYXcXBB5dV5",
	"hvvy2nLEV7hPW+PudK2ovEITJHufPAGGZ2uZIqVPUn1E58IcGGhMQCuFp73qybPfA6ehOiget3GjgIee",
	"EzWNyUyphJiXiH6JqBlVJOBCQEQVSHeEAZLGIYhooU8QCIJeHXxhUukDREbDLFbPn/WqB8B+T2PBK0v1",
	"4Cwk3CCLaqQjynxckCaaSTLWKQ8UUamIfpRj3a7shkpiPg2LwDYw3BLNOOCLzFaGxktAqZod0YSOWcQy",
	"fihR0ISLKVejhEp5w0VRWhR2nMXXTMFIy2zfC7c1M2vdZqyWC34FHlmp3M9LVEH+59cLgg8dNaRRSMaQ",
	"Hb5pPjoQYQ5h0rddOMgIviRMZCJg2RJjX8ibhAczrYYkWqjLBPXzi57Xo1DaIFyLbxNeoaQ7EpBBUNmC",
	"ALo4ffq9WXaqW363vKhfZ6DXovrEiFlyw6LIOM9m/IakiXFWRQwVrX0J3RfEDjyoOrCq4JiDuk+/4OGs",
	"3V7CAbLX65F3KrgCK18j8Ml4pc366u5OYvSaEvsCWhyaNy1a9Px9Z2BqTPyojVDyV42vMKACKSG3QaSi",
	"4whGP65oYzjofOsrcqc+z7OpxxTUEmnEE+lhFeEEVsGVDLEGMzT0rE85HTbTx8NHMxBiccqCq3ritQqb",
	"X4MQLIRWLXmE73/MXr/tr0L/CRXaJojT+diIIg/ZBwj1XsKCK72jlMxBTIEYQPvGe47DEDMMeYIWCLqp",
	"BJ+Tg6dG5dzMWDDTwiYBoYUBfhmyyWRwGV/ofxpoHSkx6YY9KJ1TCgoI0eJTPgY2PVcB+D4en2LNk5To",
	"T1tNK5j4SYzP56cCJvI4TlKPgQRzyiI/YNk1g3nHI2AnQFUq4BMqIg+Bop2fCJiAgDgA4/QNQB8M7adW",
	"L0qvhJEQpIKpxV3Gd982TLCEwaXFVKevQy9TdZyhSiqzcBawHDXSA69RK/V7U4ghV3YdPqg5I8xBSjqF",
	"mmeKjgSNpzCq/VrRkCp0UNDQ+HxodFpW/xVtvYxbw1FlG7zuK2tr93vXIJyLIr8hKFwP7LfqcrSz3Nz9",
	"wk7mWFnewWWc1FMKGvW5QU+j6OOk9/K3lsPF0kngtr9MbuYc0U38+sT95wzAemGPLv8RzBO1aLdBJCip",
	"zQw8ZlAn4wIak4DHirKYxFreaYT5ed/PGRIU0U80pzutQ9xemCcsJgWp+sTLS0+7MdMKuqmNX+7LDUs0",
	"6qarJ7SHPQ47SlvXWXjZcKgsrID/5ZuxJKIBFGki5+L1bFX9hG44d7o0APR8u1uz5DMIuAhbLTDfwTY/",
	"1Np1CxzLt+yStiqPkj3qPtjGlNsK/FjWg2UI8md1a+oASy3B2Qed0bUGkvOTWWXOnLb0B0UFXh3OPe28",
	"jIKyLo9mH9QNdCfNXp7BPqib4Y5mQNEZ6aauswZK+KwaB7kxUSDLGjGH3p2udxT2lijzApfx8tHE0swh",
	"ZJRYT6pv33y7ptWHRqiJ1oGQ4Ht9ImfOG8NFCAJCPKHIAOJQn6H0W/ZkVdzbJlVh1nZKhfJteodbmD4e",
	"A0Yb0LKVyR26/HvnP78HhTP+KMheatSeVbcA+lK5oFPoOMa5ebvu81Fk7YPOY6BBoZHNOkLw6Tif3DJQ",
	"xy//Yd52n/u1Y7LQNHOe+ZoqPiH/NQyyaZXez/TPmuDHCwUYnRTwZIEbbp1Lvf/FR3958uTyMvxxT/+n",
	"/1fy16f/5+kffHxlj/ue3xMumeJi0e4gK7xrBuybdXnJb6XrxK0p7WWhuiQZy4C1rOuBTdoCgtdn1+aD",
	"/srU7BzvHx/T/tXc9a52rbq8692uWY9M+Osne+9Qxoi7jWgUQNJDgfihfzqp+PwfDG588xU17YoeCfii",
	"INbybMXvav3rqYg6O9f1u77VvmaTyQpSUz/IrAx3A2zCH0dZ/KAd/bNPGrLprFXdaJiMzXKuKEIp2X9g",
	"hGLXe7ATING01FaffjW7xAtDCIfGuxAOTeBuaCJ3u9H88kpxQGTlOb82l95mcLQIbehf30ZSjtyz1utw",
	"a5Mh1os4rtuwhxWASDJrk3xLm11luBkEV1Kj3xtLcW+7t2guNq3aDKZFyXv3hf7afwW8NjXpFu9mWlqy",
	"D6FZ6FhHx4iccZH5Qgh8SSLKYm3Daw4yt/xt9NvkhSpETW4Wpn4v5iMaRM1BECYk0wQMLMdktt4MNK7z",
	"iwkpPOFTFh/HZqe9rhqGml4tCjHKldGWb6xHYZp7MVr91uXxm6A9FSwOWEIjH5hVTB6SNGb/1tjEOSbM",
	"hm/httghSeLGJGwAhN7Il1LJly8Pnj1/SaVM5xDuCR7BUP9nz6onT2SZUiyedpdKlRWduxF8xwY8KfpW",
	"GNEreHtuAtNMSB2VkgeMKsijYior7RKT6KbEq5ZOe1Lv7dsodm67wPawKqhKvmvTR/WYurtf7jD7jLid",
	"05Q1BhLwGDmCjBfIRNqwUFCMbCmKuhzKtywO34OYwisq4Sy79FkKQqRSH/NrHcMXuZPs+LWzmcw9uf7U",
	"x5YhBmUakXS3kQsjePkez/F3HNtGkLRxYmWOunX1l1HoI5h3VIzRORJFJjilzgE0FTSAUQKCcc+yXlsB",
	"XzAYBsQYHdLcbJlYDkMlAcSKFAfMY3uQqhAWkxvn0RbtazgVkFChKQvTajyLCZwzDOQo4kGNi9090eSe",
	"SkBlgVoNQpJ9TxIq/p2CIhhYQ54kVCjkF8MXJlj0aTkG5/nL4XC+2LPOLFQjMqEBDEdagk/kUIA2kxiP",
	"h9k8PnqbBnZ7O63CUpuRH9oesd+SQF5vCHo7QwvsiXEUQziyh8LlWLrsBZIKjMoP+U2MCZi5qxyX4fVh",
	"ZTHEy8NWzQHr2YbQGgZMkndH5F98XMLAzy+A0oP953vhH5/9vPeCPn++Nw7Gf9r7Y7A/fkHHE9j/pZ2P",
	"syhi3yb2a0i0Ewv748tMjE+d5yXbslFIF7KDnZYPV/m4M5CyDkrorkz9q/c4Iuxt22jlldZ82M9h9S5Y",
	"m+qeA+HGPFylgTw7XLPxNf6ZFo9nnTbRi643/O4EYjWupXbmhzXrzI63mXJu1H4RLt+K/sb5lTc7gwa1",
	"CFw9/2LG+VWdTMBnjzIDowhZ3yEkX8xSQkZD3oVF8sMSjtvptZ0CjgMYg5ie8IBGF1qvV9eWKe024OxY",
	"H9z7ZzCxF0MmWrHpHJqHNB6/Jk9skCkXVmE/9V84ucui5oHdW+T4tTdm3q16OeUWDyjG1vEf3j0OaIMn",
	"N+gyjEu4aNiPEg49sBXiP3kMGlFzLsCkImLkASVFcDJ7BK8qeBprmw7B/KKh6O6it+CdplFU8Op49BaM",
	"SmTTHDuHagBkDrLWaNqQiUhAFY34lLAJ2vzoz/KHzxWOW93otEDzLtRmZGJn2yF2gVkaILSPDbSGWoqJ",
	"Op4Y3+wCtwOMhgotkN7TXflM10RTp6mcbXrT7LF+g7tWwsi9t81uWAb4GreuSF733Lnimtcunjco/7xL",
	"midclIJuM+HkgvtKHnP7gTmDOsNdmtyF8+fuqk5iSHGJmnqF14fu0ik/ko7T4ArUMBE8TAN7AC29byEv",
	"3/nd9ptmmbAIDladyn3kCVD2RT52C0TN8LtqwgmisqMxYnbmxB04220SPbiLKOtAHPVOmTp3WR6+x3Ak",
	"kggemDimOx0VllboO6UUxdeSoyt/mN0dGLAgtGWfJOFxIUFrQN6nEh1blGA+KLsGotHmSmzZ1y7jY5vp",
	"ukiAMEloTH6wVbRMyk8BMP3cXFvQQLlyU5pXTYZp87jkhxL9149unvuGLLlD/DxWvnb33cbY8idFL1sF",
	"Nm0F4e+SxdPIlRWzODV5cRowaxeyWCoaRWa4ccSDK6m0CaVBGnidWF0lxrL1VCkdgRu6SKCP6QE2M3kM",
	"vvW4XdUArRqE0Hj33qp5kFAbErE7iyIbbp0nbt83xZrFU5AKwpHloSqGP5hMNz7J2MzKAQiJ5GRCRdeQ",
	"53LUcFt69B0SnYsj+M+1hT0pkOwnrR3PQG+SRzwWXqz34ulvuwv74oRtkn55/nw237JOWABeKV+TL60F",
	"fWS+yTOn2zPKaxOW8SK77i7j7NXhkcc4enV4ZC4iBMwpi7McVB6Td5+OtRl52XO3p5e9ASEXM6pMCcAb",
	"Lq7kZVy5Y6WpmmECKwvAik3L8bEtl8fmScQmDD0gzBb26fWzebxxSBMaRWMaXI0ivcpRRMfgcZuf6J8x",
	"+RMzObTCKn+XimjQax/e65M/R9ckFQvy6ewET6yTiaksJ2TxugSH8M5iBg84v2L2iFKd5QifmtNIljhv",
	"RPr//HqxUty9mc44m0a1oRvvbdCG4iRkMonowi5GSHIz01KGIUpxtD8TSiZpFBEJsTInd00QTBIBMYaV",
	"X8YsJn+7eH+CKdlzusjyxiiJWHxlVVuGSxyWzEHNeHgZ12PNuyWngs0LG9J1B1IRjcyMPmtnwmKQFq4x",
	"zOg148Im3ruv9YIlqMFlvEc0Vb8kb7kgH89NHILE3wWETECgXpLDVPE992eGSqRF/aKECF87n/EbQkli",
	"NyOYcS6BjEHdgJl7qg8PLCbXjBZAcdU/rD0Q5IGp2g6axlxAqBm5BLw+zZqQ7lS4Ck1LbOoAxrDPqC4+",
	"MOJTnir/7lR3BVfAUzXw20ymmMUoZSPk3xmPQl9m02n+kCj4ooqkay9c3VhkwiDKjGmzp1q7DfykpndP",
	"c946QHBjrQTCkrDPSd8rPEror1UJjbFN7QHKawgj7hY2jOER98xePcRqtSa4AFk2N+FBkhm9Nul9Uu+L",
	"q9TmO0DWnjXrp2MxSjYBNNxDBZk7f+2jrKiHrYzTCsWmc1P7PfnvlMrZaO5Q37zc44mpTiLB2gDLhyi7",
	"QipRjgmIVd8WZLi0U4G87BUCQBS/jGmSABXmI3vkseEi9lBZnQENERc+4t5GsUYiHk9BXMbUpDSVwk3M",
	"i3/GIB6mWVcjTsvUrPbzDw6t5tRiN+CHyxiZWOK8TBq1oJUEu9Jn3HdM/S0d6y/eMXVCx9lqzbyXvb6h",
	"Av2YKBBzSX6YMnUZG7D29szbfyZTptxqBoPBDyURUfTfKUEVTD3F245jElAJxnPuFm3CnPvmbp/jq8bo",
	"Qyov4MeeLmypHq5lhikCPaHXXLisb+Ozchvj9vzJD/qvvRsWyx+e6uVmb9ldMu89+cH8aV8cEAdxzK0i",
	"tIfxOQ2h74HNAK5tElZcayGYuyqb/KLmQTP6EQIbB1aT1l985WV1Fnt10iUZyb3qk7omYumIJ4u1lDqS",
	"M5TXXd3umuXNF5i25djVeneeuGrd+pmLJqaBSmlENJM+HZBDZWiEzyFWS2NlpxRTyFhL28ItmjZPnTS5",
	"jE8jMFSorElbGIoV/FxzNp2hZ4vFTnQbdlIzMjVxGQX/bmESksVSkIRHLGAgyR7aRvhtQFP9rJbjRTDy",
	"+5TQrZYl0BZgzT1vVrZ5i9GYob0lbmh+mdnHCwWtgjXES7Xsc6HfpdxNtpJ6YlxbQHyxiF1nJx2dTDAU",
	"j1gPU819fk1pvL9dXJyW6uJl0cgmviqr96SVW3mGumCc8iqaQtoL6PNf76ODqruvpLgdbb4SO3Q9WOeK",
	"TqGhHsKG00ZWKgnymDJMOqZSlzOuVs1b8SRMF1JZCmM37q+Sv/d0oP7mMvF8VOBxKC5FvlpdYC3pQi1O",
	"+wA9S4PL+C2uTEsptMNjozk+nR3nx5XiF+ZmhUqC6AXy5NJcLwwGA1Mceirzv0AFg6eX8UfRz2r8WLvN",
	"Brn+BXsQGNNuDITGBMWo9R8Uo+6vmdZK0zSiwrzz7s2F/yi/jC6Tm+MzmQ0Y2nzQ2jrm8X9A8D5ZHsDc",
	"IyUC9mxcrgYPa18j3CZImlBlzOwCBWkScwcHt0RUWXjDROPL2F48FQeO2ASwJCmbaHzQUl1OW2RTAzTm",
	"qbrUx0sz/+AyvoxxJuN1YJL8aCx+Gv1ojIsumcMN2ZuayOLsXsIk3dtddRdVzhVFoxu6kCThSWpqwmrM",
	"2KOUOZ2b7heaHAsyxOEqW4FbABlNuDDYCiKm5Qb6RtMkiRZ91K7osI+N59cUwOi45vo0Pm8piaW0TydH",
	"WoTjw4bcFaX02sLuPFL1Xv6I0xIyyoiaUTmac+ER1x/gizJ+U80S15RFNmzNo9vpl1ECYpT4feH0C5vT",
	"qEDgttcJSUDgDL3mUjT9Xgxf1IhPJhI8rXSwoG7m1Regx7YuqditwR8imO113Q2h7bZkeldkaScu8HaF",
	"8jkZmpeQ1S/E8RYX+dm7jWpWR+3LkRlenV9ne3cIzPDCo09ci22GptfHDyts59GZbc+zL25xG4/NRwdt",
	"V5c2JNh+W4+UI9fao4lxu985LV9mub4h5tzDBXkCg+mgT46TQyNPS4k2X3vZ73oRB788Gxz8/KfB/uBg",
	"iNXB8x+e6R8+39Yu62FlraW3tYlZm9317uhT7OpYhfUhkDxWLE4NYWd3zx28Yv5Z6mKXOk2DST1pPlzH",
	"nK3CF4Tl1xfo9GnOd+qegOSFqgn51bRBzGD6hov8d3NVtuYadi/Sj4tN8HPnznt3RBoy5r6tuv1r7FCD",
	"NUnyDMEVpbCxfTuxRP5qv1sfnKWY+W5u88JHr6hkAfrNq04uvS9MRTakONvqz1Uvu+nD5HcqRFxCmKn0",
	"bkk6FUug22fFNOSGFjK11ZbFFMKm3OlCWUTDReYTcnomG5KxayHxGQmVyl4Gs8uDedf62XtxUdnslbPi",
	"qilTPMHYKLO3PYc6r6PEUFBHlZeDevccvo5E0LY5jZCXhJNlkTttkHfNq0Uo51n8SYqhY0YY3DE2uQDO",
	"A5+Qi5JtbaabTXxqKP5715zQYtulmpkfFp8uMWNdeJSv03lSnz89ai9v75LO299UdNr+mjc/vAKId7A6",
	"WOqWfgbod93S6le4LHlciCqW6NxeFrpJll9d/wug4YjH0cLbEwXPAMaNk11aow86DzHKn+xhSF/WonfC",
	"BRlTUfiW1bXqsNVlfYL+U6VYhJX7hXsELF9tbhFq29UUFbuZbSk/r9SalkUgF1LBHK8fsuhX37wsNv4E",
	"crmc3SD5HIYJVbPhZe9pq2ry5PpX9tUHfDMRNlkUyySTp2nMKfNeaLiqBYW6tr/Rvf/s7/3y2f5/7/PX",
	"Z/2fn93WlLUt0VqZrbPZTTNoD5Xg85Fz8K7+/e+DypaSbeyf7u1yUeIn8vl/p/K/M6US+df/zmH+X8y9",
	"/a8SNJYMYvX05XA4+PEPnfIV70CdWpnW+S5C20i/wcFQI+PqLMW6xnwCJl3sCKP615KpYnjbxDi3Hehz",
	"bD20JZUptjUaVG7M9VzdVMf7Oyw8tHVlf625AMhaIlzBYuUbABy722LPfeWaN9LwxQ7ZDJa17x6eIbfN",
	"YBLUWgIPa+Mu/LElv86oMndw0jQ75gJDgRXHu6dBIR/CQtuvBGvgtx0TFv2Lvwaxrr5NJlrRxOi5FkoC",
	"JyBZFKWJ3/V7jh9VR0AbHKChv2szwGL0o7cnoBl+cNeWf+bzlbv9lRfer+3+dw7KV0vLpl80NzT29Ckv",
	"5LZ42/l6ysNiRVVj9/yLxjAIOTztVDMVJ6ldE95n+j0iyFlyhI3g42nztYl+H5O1JTact98MvKTtMme6",
	"dLAoJlG6+9qiH5LFTGOU/Qe9kDFXo+IvnztFn58rraOnJ+1XYXovkogGyASxi8BC7pBmEMJM/fL7XS94",
	"elCVg7NMn0xMPM5iC9BRZrMKbEwPi6JCut9SSJNNBUPoza2DKd4Tp5GJ1yifHmpA3cVx/dg9pqmO9IoW",
	"39K+F25bEai8kVCmB+sDPJeafPoOdpaGbeQn4TEZU9Py1RzAnqhFYrNO3lzQ6VN/17OthgOvECM6IOQ9",
	"XWB+gM28HC9cN9+7xN51+cBsaYc4kpLQ2WD3JQfRKjHE58XAmLrif/UXoA2BMUgu7SEu7eEceaRMJc7l",
	"o4tQzKYyOSc2BZFJkoXiEJokEQM58FWJBsw9KDWwwGwaPV+88DfogK5du+3ghU+yOoJ1OyLfXHu3JIio",
	"LwBZL1IS0N8QfKXgNxlNqYIbujDhwTyBmCZsZLWI+RG+JCCYRhKN9mxTX/MkZXs4qteXpzc4jT3RdoUo",
	"vutSJzsEDZVEqR5UMYrPaygV14epvW55SapsFQ8Dr61Clrtnzc+X6f7+88C3TKwojI+hk78S8d93rh+z",
	"/uZNrLlbM5hZKRrNEkVrQogZ2Q9VscVZ9Uojq2Izart6Lbxa42MvvJF5xkb/oBELsePCFL50/6wQp9b0",
	"gVNLnoti4/bNR7RnSe/xHSvXjGyXe//h375zbZczErXrSQSMtFkymrvglFGaRad4zmfu9cbpl98apcz3",
	"4vLtzxKmWpDdaQs9EPvBq+C1DomtdOv4qSPfLDX1W9ZR9oVPZ8e+OgrHpmoG5vqhaW2dvS4JT5Qd1Mbf",
	"fGA804oPnWh6WjHeiuF4baUIGkLkzpU8TFVDVUabK+fRXqbIxCgVrD5g1m+DqGjk7um8WQrabNtTfC/C",
	"rvX2VJtXO7e2d9F0u8CcZuTRyxgDqrXh/fzn/X33EnlyQGY8FU+JbU5q4s9QSwOa6QfP8AV5x8QDk+Rn",
	"Vr2EHh/iL+i06D9ajma/AqLolBy/Jgln2vawp5qzN28HFVpYwSRucC1S9KEZBdjQXrHJtaLotJuTsc55",
	"ckHlVb1brb3oXgw3Nf7RbiEtev7jeMJXDae5z5xZ084q82F/vNE1NshboW1isa2eT9lXQcjuzcwRrGxg",
	"LzXEcU1NnSXZ4gXwzofOZX8KSqX9zl3yA5fPNTXZDoVGuFX7ShOzPx1QFP2fbfmZhbf7ZtBmSI54sngr",
	"+Lx7iGb+LX5XDbkMeLIYdSsdu9TktSrl8pH8IYRLwHSKoK1ytHvLdS4hTyyjQayYwJItEOeujac2Hw1C",
	"9CJfxkaK+aN6u5Tv6RRPa4a78AiLiouuZbbS696pmortZYeoLgUFeVy6bSk8WgDtQtD4mhuo6QTj7yK6",
	"uWgemFMW+ckJH2W05IIUJIgBOZ6Qw9PjZfcek66gXslNitVN4pBmZSicN5HF18yYJraEGRYy9Q8cMlkd",
	"ORvIOJ8G5DCKSGDasepxDottqiSxG2JYYm7rvI2BXMbanBGYpavhM468PqGRmvF0OiNGpZS7Xkks9oZl",
	"smNXWIbJmkJbE8EgDqPFyH/QPswcq6aCVvFKQs2o8UCzcEA+xViCh4WEKRJyMJXNrMdxUbjHwGo7WLvD",
	"tlwya3o6IJ+sU1vyOZi6gVlC66fjGvBXbbVniOSIxnZyCFm52VP3AO06HlnN3qFtwHpXjeQ5ch18W455",
	"dXaKBPGwwRSmu/C6wijKLc8ri8LEZzWybdRriq9OBQ1hJECbwKiQ/Mdt96JfG2S92puejdB1/kV1Co83",
	"xd9SwdTiHNP8XZM6Fow066NlhQ80nBjpn40xUyoxrjmsV+deZ6bUuP7Nua9eZjVA8a2RBClLveZowv4O",
	"eEj+143KM83GQAWIt06im+KYOTj4tAoPZ2HQDE32RhMkks6j5mGyN+qHuUWeMscEb88PrHBweHrc6/ei",
	"vLisneAwocEMyLPBvu0WbRYpXw6HNzc3A4qPB1xMh/ZbOTw5Pnrz4fzN3rPB/mCm5lEh58BNaWbLKKl3",
	"MNgf7CPijMe297L3HH8qFFkf6mUOA5rQMYtY1nDO2NxZwZvjsPey9w6U1kFHxXeRvzD9AL97tr9f6NuN",
	"9muSRFbzDf8lDYEbZm69C1+eC3G+JApTLL9UfKnfe/HsF88plXOtuBfu7lMWfHp1kGRLG57jLZDNvSuw",
	"Vu/lb5/7PZnO51Qs9EYwqZb1fRE8Yj1X4AKmzbW0q52rhzYb4urpDrOup0O0KlBIcenZnWrTUHzfSEaQ",
	"6hUPF2vbm9r+u7e3RhhvkCZy1GJGvo8s8uTLvLSxQZ8mDwNP84a/omEhm+TF/kH7J59ik32FwQT40fP2",
	"j95yMWZhCBayF+1ffODqLU/j8IEp3UXj2Gq2JJU2zqFUS7rUVtWSe1Yqul+6NLLZa81M0Cicqn1qN0iJ",
	"nqa4VTqs9i7eLgE+QnLKCMjMMva2sh4vCCtKSCSMfi3lfDYuGToHhU6y36xa/3cKYpFr9Wz847BXNBiN",
	"zyrf9mXb6nNGkFNQe2jDDPWBa8y/gBx+tf+8bSJNlFRvBZ+/Ny/3Hl5G4tGqlKUe8ekUj1PfCZH+1AWe",
	"D1wdz5MIr/cNRGsXlQICYLZSjLm4oBNli89j9YCCpDTl+7N645/OTgY+Pmgm/qWgbENyuX9svCBTS5Jn",
	"eZ1w5gpS5gwzLxDrfZhFABbotH99RYVh6QahqGedM/MlvnXBa5nnhY8irjAMFb8P706ej5faCvRl6p9S",
	"S13OF+B8R09K9PXUemJMXVFHHOgQY65yvl3XvUmvNBpxW1JPhgM/HVYIppEi5/TLCcRTfbw72H/2ot+J",
	"RDEEuVWCF9ilRIHPjannWzy3MUQJnUKf0BvKlCvt5Ar7uT34dHbS6/dmQEN71VMfZKoPdDbG8ewk79/E",
	"bySem+vZs9/7594Jnhb3HDdVBn/35qIgq2wpaPR74gcDQv4OkJRAP39zdPbm4v9rnPr2O+TBGomP1ERo",
	"oEnUxMAbXI4XxVYQPMa68m7Tmjktp1nB06TeDj5hUr0zr1SY07e4/JWCZ+40bzTX+ZtDrdNW/GSONwe3",
	"nzdoDeWNlj02EOKSRMzZL1syebZpZqNHYuoIokRjKL69vgRT39s0iN6MA6HcedvrNThY72S1+787kjla",
	"MVemhlqqxLIkgYZf8f/H4a0BMAJzmVempNf4e05JbWab4UgzWlg6nuy2KT85a+zUbVO/1oSp2YX9HZ9t",
	"eQOnoOp3z+fIKJvDlu/ueixb4t4hDaImwxc39fDoZKMui6MTH9kcHp3og8njpp6P4gNH+B+AiEoI2h4t",
	"1ZkN50vUsn6zISOUMrQ1xkOVmkr+LpNSG+7kUnZsaSWpeikyh/nYHlubzyXv7Yu704kNZ2g+nBi8/l7O",
	"KGSeUcfDK0YLy/BrKkF0t3Mtgc9YN4t3nr2+M3s7m71kXkTylkil7x3JEMfKCjT1yMjDMGyloINGCqJh",
	"uKOfGvqhYdiBeOrFgev81a7iTt2bOx2XJeDWaTnE6mL7+u1Rk2pBISY5LT28RnTADL+abWtViooGM7P/",
	"bwWfd3cDWaoIcYCdRKvViBo9xCILL2q2fBT0q0RHHOtRiionogteQ0IHtSRE1Y6EmpSiKpKQ4q0Hv5Yo",
	"xE0GHT7+YMPIrr5wh3sOau/IhBeXJs6rTdrO2nhD+Bc6DkI4ePb8p5//TE6pmv1l+GfyN6WSj3Hkqahn",
	"71S/nyNht2DDBvLsZKTt7LPHb59t3dxqNLQabkltu6DNiDzXi6izy3Pts/qooTMhYJ0HhCBrW3NHHfpL",
	"+0dHrov4A12bJo4Q2mRTZ+tZ/14gr85G886L1OpFqtus+tvTuo3Yf3xs97u4QK3fwfajzloPKKaSwaNR",
	"A/vfsxp4zERpyiW3q4FUtt2TfZK7C7IOF2QYx/z9G6aprLsQa7BKP0lboXj9wqiUsL7hyD2T7u3f+sKu",
	"ryejy25AZbLrTHyZ7o3ftxmbeqKRl6XXCleiGSG2Wa/IzTvbtYPt6t+hesvVvwX722bSnc1au3PtFutd",
	"bplreHYYFGrLt5khxTr0O4OEymEBIXV2SY7f3bWm35whQYmstsQPzRZTmdI3ZtEUpvmVqdk5BAJaqEju",
	"KGjJRmkknw5ib/iVukYbnYyYRtrw2DKFqXYmTReTpkUe1Fk2jfuyEZm/49QVzJ2HkPL+iIQCu6/Hhqop",
	"TdJ+FupQpMQjUDw1MnaxMV0EiwdxGCeT1uTcrlZgZG3Uuq5KJe1OIT/9ba5CVDZPB5dRK81/g8E8j9rl",
	"Y6N/PJg2/Z5WYpEVROWww8mzQkC7A6ifseqOodVdlbvzaM15NMeVvaPPRQ02b3gk6qLWHOlQFELz1K4w",
	"xOMuDPGNcEtDOYmtUn2nYD9N999ewF+/0lWVRZGtnURoFJGQScXiQPklVlY7mwuiSYFPCFMy3zif0Wla",
	"jLFrKFXxaesnsksdeaxcer/MkU3w6R3TRjpfIe6yRu6YNbLVe6mt54z46WeXMrKulJH6iIG8bbNVz2UI",
	"BSjB4BqIrV9uXk+FK91f9fea8Tbp6rVN3qraxgvj3Xb4NkeWxVARXcMpFWM6hb2ARxFk/VO9GJyCIsWu",
	"v3xCpgGRoBSLp9KHwndm8KNs7M3jtG7KeiRbDJAcAxbv90f4UrF1i3Lb0aqE50QAFsx0YqiZdl1Tv1Ya",
	"LncT3CDal9oW1iLbD/mGEF1oc9ER0ZrE7VeavB3QKJ58+DXVLW1nj03it9w8pB6/bsnrxugMaKRm2KW5",
	"Vj7gU6Jm2DsQsBuRwRxhkqQJNggSaRybjs9lXP4Nxz/C8btYXx/4kUVrNZXLLWFWGNOsggUwBjEdCphz",
	"pU3EgCoa8entMEmjyLSWaTNC7CfrcZWfplF0bIC6wJ52m/GP2yn0bJm54HOMexBdKmKksaTPfBpUY8wZ",
	"TD5qe2UNVoiiV1jxGNedCLhmPJWIDzmzPeCcrGAx+vAMXogllj7SvsYenoyxaSd2szeva27hgpljeTx1",
	"Q+VNoQsGjyXdDgQtZw9C0HK2TYKWs3sSNG6g2VjFfyfkLGDKpEJPNDp2MoozeMAq2kXyrSW/Qq+hTja3",
	"fb9oRXq1qh12g/rUTbFZ23v7RaLdPkUZCj0XZ5yFwTCgUaRFUK0/8yPFnkj2rUoR8mctrDXltgh7AXfl",
	"1yeURcaDCF9MeTzikGebGfHQtvRz46wp2dtzesyEbZuL96z44rfk4m355hyoCGbnVsJv0tGaYbDW2Zpr",
	"vt9Byo0oE1QuaQs/t2XgnBVNhcYuCccTgsrdNt4mlIypgIKtQW6YmpGYExYzDCu27ba1BTMWNA5mNS59",
	"Pc4dvPnrNw5yZBTDQLaZ017Yjkbq3uW2+wJua+zeEjssi+zh1/yrDjG23fnl1SKhUhIBNNzjsTYZBVfW",
	"TaRZwoZ+aRO+BLePQ0zf/HteeL3wmVkZ8+4CgDvE6XUhsPo44BLtbEFJPjoR8tgjgbttb/vBWJQ3eqWb",
	"yVrZNKQoO+RQpHFHQ3Nxpl/dIMTbs0FpFPGbN/NELf5BoxQcaF5zwtkajXCvMKCxY3otbo3NFfjCfT9L",
	"4zqj17RzNZoFiWMntktmsmGC7Ohm2KjNFCix2/CrSOMRCxu7J56l8YZ5zTcYwrWqC27ztOptg5yRqO0t",
	"tiPUovahGjPrItThjPOrFjWRxn/Dl74Fov0OQjk1stukuEwgYBMWIJOYLdzxyJIwt3hZK6MMv+r/jdxv",
	"PFU2YqdB2Ov9/Ghe/EY4yDNQYdkbVCI8UKD2pBJA52WGMe58bbWxmApv8dDKEcaSALG7tGOQ4hFmCTmr",
	"c4kxn0e5t6LsFKkGQpR549he/xt3ySsc7DQb6yy9181eIvRkynraE6r0XP4Gojkp/5a9+DmjLj7+FwSq",
	"m3fP4zcxOCp6dEQawc6H0nCvVAgL6dcH1fhp6R0oHyHdO5uaKZjLNrXtJeHbjJKoENTrafHTyE6fl8RV",
	"HZJq6GZzrpf8lqQrUZr7kzULuNUJcb0SzDjSdxKsRYKtqEGHEtQIHU56j2qMynp6OhUwidh0pjoFuH1y",
	"/foTEHMmpVb6RPHCtZ1/65lt1X0HD/EuZblB1z2Uu9hsc0tMwiv30rcUj+Dz0coZvxnNWBhi2/36e7Ly",
	"9v86g5hIUGSPGCdqFBGHN8LiIEpDFk+JGTd7MiA/vvnn6Zuz4/dvPlwcnvzY23K+2RlM6pwIlrd3yWYV",
	"x8E4p3THptlP2zIt6gX+Rk2G+wUzKPiihjM1j8rTth/TYQIC4gAe4KLxeftHb7kYG3Hx/RXMsKo+uwjz",
	"EHw33TH8av7VITAio2MfI20pnMFKv4c/hm+e/h4g+KGJnOqDHgrybXPqsF4V7rRg9bi9dRXodz2Pi5rv",
	"fpm0ZyBLlLaJ0ECJhfxWUKTeeCttbOZyaSeV7pOLIFsoekUdNwxmIMRiL2Emtv3bYAe/aYkrOWU2/H79",
	"7JBP8FCRskcmKMcj+NUMSGErbRjyd2yFbravgLNiycOw+RkkEV0Qs6k0noI0WXP6hym7htiFmfMYf1ur",
	"QMCR5bcuDFz4WmO48sUMiOSpCIDMQVGBWTWKW+wOiNGuZJ5KRWKuyIxeA0lj81hb23Z3BjUhzGbsUTZ2",
	"ezjdBqQWAvv4JNZ3L6FWOCcfPGv/4FRAwOOQaRS8xVywByvx7Xgrr5RhRMadhc2QykUcfBci5xBXspM7",
	"d5I7z9Y2+wWVS1aaT/oQReUVkYoK5aTDdyaKOouHbafe1kgVgpJgJniMNQMKQsaTmXtnSTP8ysLboVRU",
	"pfVXRQV+PjdvbrS40fJk7USLb+3U53bU58PxxxSU3W3CJ4Y/MvPfEWw9n3wLHq5KRc1PMft3CoRhi4IJ",
	"A6FXjqehgpBAPnAKsAwDCzdxqZwLk5BNJrVy4zWbTDbvANaz1F2IavA0xuzVgMdw2HmIMz+/xtVKLuLH",
	"UYDgfrEIryFic+bAe4xW9qosOaMiHKF79Ns5RqSeIjBnEPEgv8g0ZXYmIOw/BqRyONDihLK4xOYhVXRQ",
	"LRtGRVi+NWg8pSD9EsRp34GDtY4TzmJFsHAZxk7ZO++604gmyjV03thcPvjufmJd0lRzIam5pLinAc/m",
	"CReq6U7+GN84onEAURtt11oYZhqSCK7JoYai75034iFDO3GA4H/nF/mPO5AEd4DweMpZPLUEUQzONj/U",
	"3v8bMsyOjI+ZDNdnjpYW7TFJ7XpWPLX+LuITyqjx0tk37BXNCEOoTVU3NGL/gRyN5dnP7DQ+FjjO9nnn",
	"bVwD61i20ZauuRw16W1YMxl8bLSqwWHG69A78KPJq9tUFGD7ue4Dv+DzsVQ8hl43Y8Piahc0uJGgQYPd",
	"AXnPpNQmhKUkc3jSRzbXLIY4SAno0QYFsnXU94168AREVLFrcB1vGmvh2enXoG0+JRGnYR1DtrDR8eQD",
	"j+E9VRhB2eH1/NW2Sumvs+d9c2gOaELHLGJqkVPFGIhMEy2tICQsJpNUpVhsMAIqGy77bDH5iKKhuLVz",
	"dRdNfp8c+H5vnkaKJVSooX57T4v6ptToAgxl7H+MowWhRPNiBGTCIiAJCJIisZCbGXPulDEQjZSQXLrB",
	"Lnsa7V2ArSRZbzKswlC4Nre91rYV73NQFJH2Pdoa3+OlT0X493tf9q6zTdmDL0GUhrA3Rq6zpm3mRmxO",
	"4T1XdJqbKpswxDOinMJDhRvt+GKr9o7Ue01obC2cH2SGWlOIOgtXrDgDV8wr9tjlw4Ani037+pfu1UAq",
	"e4Hi/OFumQhMf1PWVHFiPTpZybzSX4/WZ2Md8WSxBTmip3mkYkSD5o6bIjvx72TJOsKAKLISRjo4seI9",
	"Fd1VauRH+W/iVPVgPgQ/7xcdHnJD7H9K1SyPbGhj+v01Mz2SZl1gxevi+V6uzvs7l0mzy0Suy2dyV+mA",
	"Bk1r1ZKil2E9dUrsURRdA857dKH/CDlIXP40pYLGCiBvGebOrxpD6DtwTjzCBQFtdiVcSjaOYECOFWFx",
	"qBkDJMHK7HqEHApix1RsDlr4BjSK9DYgRBCHeOW/o/PHXRzlm3Xn3YNdFXY0HmVHuq0eCPIYnTQJqYLN",
	"nQDQ6lc8tzo37V5NvXJPL9LIPS3J3jukb8YQqJ2u+2nAI32zE6rZsnB3GZ0nF98IpoA8oVH0lCz7Sqpq",
	"tn/fkB4B1yDUN572c4aL2HAevp5iDYn4epi7RLrt0oMfVXqw5Zu1pPtqi5fF0+GYBlea0hvKP5/OFpIF",
	"NDoMQ2GCkjpceCcCJJvGvoup7RQOOzcLPOFBbTJYYhdGqFkZevUsYggVQHc6Ig9YijVVoNPXYUtxe4eG",
	"jtCIQYxhjO584vPjWOTuzOFVQsNPWHxljm3L9IpN6PCJNhNZbDuI2rZ1SMWxJw1kcBlfZC56N5beuTEQ",
	"HgNxmx2S8YJMKwKgr8+ZBTrgqZIsXO7u9YPM2phrhMiEBnriSnC6Xl2rhNnQDf6GUmCt6FnNbt3fXYbd",
	"yxgoya712gMdVEngLANkSWoT1vpEiQWZgYDfQb4ilZIHTOsIp0K5rbLrl1uUWAlZVQ53NWaSeZJ+My7+",
	"baqWynRxOh+bqHNrqEFIPp2dkIQKdHCbgXMXZS0gQnmDj1isYApiudp4KS4WO6cqkISSLOInNx5C6/mV",
	"JDcpjl8b0inBbMw2oMEMoSdPOM5Ao6eDy/hU/2IWK00IrqW+gwF5k30CXwJIjCM0olKhEpxRSeYsZvN0",
	"TiT7D5AQEohD6WrvpHEIIlpoOh9HPLjC+FPCHFuhpBhcxm81bF+o/pnccKFtbQPA+fPCd/3yVEySn96/",
	"Ik9M3Ifxx1rQNLxPfXrUVFg9NZh57/D5ye3exu5Ma2b0yEj7ZnWzmaWEnU8mE6aOOTy8sb7UqqLYHH41",
	"ox+Ht8s9UEq5gWOuWYg6FqxAV80+xE8a6HL99lfTjN4APY/TpJZY6ZiLHakWSBWx3UAR33yNAs9Ajle+",
	"xePkEdfKyOjduj3TBz8qJczHkdM+5gGExkSosrkbdquc3jKpl9m3dtCqFSGBhTr8FppOPKoT1DblmqOt",
	"JjaxU25cJQ+R6YZf9f8+oDV7+22FMq1HfK7rLOQBKcds42Bz+kWb6b2XB/v7+/2etdp7Lw/6/pOPv9SD",
	"jWgpH73ycBAWK1563G5kGYF3urlsy3yCt4LPt+3SMrNfcK8Xv4JFCXgktObHrqPTdgXTVgK0d9JpU9Lp",
	"kz3mGM/IeIFxudoIxL8xPperGQgXr9Ygio5McPxmxZGepLtI8pz0cF0BTxjoHZ8BDZFiv/beXNBpGaLy",
	"h/q5q9tQso77JKFSEhY7S89WalvuIrOTTKtLpm2UqW7pYmRqNp5BwMUGzzXZFPeO/7DF8wSO5roe7vIW",
	"1lq+VDhqWDnRyRUo/Wr+Yf1vdbEYWX3zDVckXUPl7t9FEZeGmthb9245AlpnDG6YzpP6ipfpPKmrd+Qz",
	"hhSVV6NHVLzoLFtoYSW+uprpPHng6ruPmQ/O8yK1hfgPkmGtwB1FQnugToS41enYK0XXW4f8OJ7wZnJi",
	"sakwgNr9sdPUGijlFQ2u0mQpUCiPzH6iyaRvZarsZ20sn+J1sKTXJsZobEcxTvNi+Z9BPak1i7lpMEwE",
	"JFTA6EENzFMDxDsqxnQKRzyKTNfiIwvUBu9xK3NaWJpKW2lkyLyBARZlkrDLF7pPar2m8ohJZQRqgPdD",
	"libRqzU1+0SCbKPuYnVWCX4LvTjuSvaut8aDdY14d0QstnadI9ZJ7A6pU1fZXq6JlltaPLTQ2z1reLpV",
	"vTvKGLdYsv7xFvPshha/C9634gcp+/l9cUi5CUSVX7ytIB5FS/4CV7oIdJNa/XjUy6c8Mn5TNQ3szEeF",
	"qTIS32ypMP/Um7PldjquwaArnHaK6RilqklrM+xEGoFcDuLrWqfwz3h9ar58d3Smh6pe8RxbaExdjApf",
	"4Ved6iK4QqTVtRNcxQNWKP1GigpY+2bVDZ6Cat3dd6C6bu3+5o6hZkaPwJoGSCN4WNqRxlY1fzGkfzW6",
	"kx3o7ryR7tavpJtI7g7XbRLUTp7dkWi76bahBNVarKeWitZTuadxl13iU4G/dnv9eI4mxaIxdYkOtuSX",
	"TCDQh/uQXMGi0I27lOfqxvOl5Zhx8pumDddOqU70d1jIe5SOqHrpEREPXkH+AWqVeZDRa7bKKtf3NXSw",
	"8fvNcipy6x7v7viL/pfmfX+QK83y4s/9QNpSclgnDku/0TAkGBcbUgXWVcmvWWilWx+v2QqF9+b8GohG",
	"KnxhEssJ6Nd8Uu68lrS3IeLOQa1VwpX7wu0MtYIzo5UdOhtz7lv8xwjblQ+/5v9ujILSG39mG5xvsIAM",
	"Vq/4dHbsk5oa0j3TwF2/UQoczdJcPNQWMgGB0hbk+fPGrg23O6LLyh5hvsSns2OCeREF1E9YVOz5k9Hj",
	"A0Rf5aS7CVPVlj4cftXf3w6/mj9HLGzlE/31Kp2KNlC46T7dQOrKl7ipSox3ZH7cO4F4qmY1U7FY/fyi",
	"54mI13M9N7fKywk7OddiWs5eIeHEVYLPah3VCIIdp3fmdGrrGOUa2W76eEGOX/ceR3nVjAPXMBa+1TQM",
	"xOkcjU0rXwrC5nP/zjLFKt12ffvAunanZh9CzT46Dbt25ZqkUVQfJHLCpDpNo+jMofnuHeHv0qr9fl3k",
	"/Q3DbFiLp4FAj0ZRb5nvJixSIIhGU0ZsWgZnAzmxxBPQBkMQcYlX6Xown1zaZOxKYafqyvhHTGIGW2lB",
	"u8OdEwCInjJucsY3vNLfYgmPliyswoZvKngjn+GhGtJ4QGiM4Shs3ned6PW4G4mbzLDiZrQzUgdNNfyq",
	"/zeyQzYabMvMsXmh20aOu5yZil95NQLpb7G/QUmOsNDf3qBIjCsLdqy/WtNoYKuS/RWVLFihnEUDomxj",
	"gbu5jnfhc35GsZcVmxamwzmIKWy3i8jmuczXzOO9XuiW9APOdQZS04DXhy4wemLVali/07YELdh09s5l",
	"nAddvXR+UmIGMbd79qSPyCPGL4pXfzHX/ycwT9SCFGa7jAvlizfbYSEplD8mkzvUP16DyDFkuU6JI2Ai",
	"s1TqjR6Y0pqM1zOYbDR7UI+v5/EHGEwkZgPvbMASnWl8FW9TEU/1ObB5FyjMdS2zOSUx3JDD02PD4SxW",
	"godpACTi8ZSINI6xILejC3l5p+BypGMBOP+DkPKZmTuj5k1EF0ykneXOViFuZNEKJKY40I7+S/Rv0bwC",
	"C2D4XSnh+8G4IC+MtphHLL76RsvOu/5y2AOSjiMgNp7D50CO3IXLPdx25wZdb821wsb0UfOFklvIyj6y",
	"794HbBAiiaVqvP6RJODCfGxq0fNCh3dz0WYI+o6cFMFEncHkdhiyyWT4VbDpDP+urzvDJhO/QbO+o4ue",
	"o+4eQcNJxqBuAGIUWTv6yUJlNWoETEBAHIAsxUlO5JbdWDSHhDwJeBqFZAwEGJYvpK6VPxdZtWFy/Pqp",
	"/xhuafQB4LEpmZj3S6eUxXgc8WHN8s2qMG7pRnKjl6WvIWJz5sDz1p4yIRa+q081EwCjkKvCjaa64faX",
	"/KnnRrOyxccTjB7VIlJjHgUl8oQ1SIIoDYHgVu1h06zMmqFKDsiPb/55+ubs+P2bDxeHJz/WVQwwo4xw",
	"lBF+uVpX+M9dpLLQErlQDMd/R86neWmau96O34+uaq54qZrJvukKA6YjC2HS9hwypapsakeQR275kJ03",
	"Pc0RzBTMpYebMlRTIejCRx4rgJcYNujXBelN2BdYH1ha2GhazfsC4WiExc5bpDj5gSLafxiQX5ma8VSR",
	"SSpQeNke49qk4jGhgUpptDzWoM6qZKYWV0O4YQVgtsRmEx5F/CZvcD5hwvTK0YhNE65XQYMZdsQjmdvR",
	"zOuDCb8fme9bQcNMtDfzRC3+QaMU/ImQ5zN+kxVtmJtjT6ChUzMaF6kxpAr2FJvDgBzHJKASSCohNGXx",
	"peLJiOLKDFP0jWDRv7tW7mbtVoFg0/g5gJIYyG8rlGQuttpNkSwOyvIyi5/MAOx55WEnbBwWNKHiDnzv",
	"ijUgW1ivQWzvoUqvGClaZ3DaxUV8urM0q9U3NV6Ma0DAZECOJ2TMtRQ1khs9205eEm1FoX+77+QajSLH",
	"l4Ntm6vewSbrDHEr6HKnyRrCBurixMs7+mqhwEYHKq7RKBhcA/rEsc+Zlo8LBfIv+3sH+8+eO44zkZv5",
	"Sl1Qab62hCp9cOy97P2vGeDJk8vL8Mc9/Z/+X8lfn/6fp3/odTDCzmzjOEdGRi+wSbFeYMhB4oXHjF5j",
	"ly2qjH7Aqt/FtTx/Tn9+EU5++ungxbOfJkHw00/wInzxjB68+NMff/kp/GXy7KfJn34JX9St83iy94HH",
	"sGd6jt6lhvzvNiK/76nBXkFa74RKtfeeh5in2x5q/2z/521hJqFCMRqRTWLIfW/YqfT5XflpE1h/qMSK",
	"576kP4sz5P+5W8Kj1qwH+5u/e7VUCl8SVD047c+bn9YiE0KCJEw+cEXOqWJywug4ggcxLCoM68wCp0S1",
	"2tX0WFWjfwMafpt69HOXu62MSJiJD/4mZH0XqYzFmH+XovmFb59f0ZBUxdxyBUyvWPMSjBa1kyVx1lH8",
	"bEdcLDkY7BUGkSgnCPjuSmYQXGmzcpknfMLim/R6i/t6vJc7XJoB19PectWDz7Al1+dj5unbRsPIuqO+",
	"paXIFFzYHfdLySnuSI+9twm1V5CZp/T3zHc+nkoliFGhRoPnisCM7PNq3vkk+givlMrXQyvfRK0uaqSi",
	"qr4ymaK5p+WhmtNaOfNtVPxpMBemPAbyZJyazvjarMuSxud0oTmQXlMWadPg6UMeJTylUnbmwWYbYD8q",
	"qbi6DEElFy1YPD0VWoAoBo3O20++9zfZkzWbz4iawqzt8obwmOQLxGA+OoWdueORHEmG1xqk7STK1lrq",
	"d2FiyVMRAAa04U3z8GsI2phHHntlokZr+fgti0PMvHhF5UYrbpQmqk8qQepHTJpb87EGaxfGXGTVCatg",
	"CH3Xzx5NHJyhyOLhuzxPRrH3m6ZA5o7pcQLvnBWeWE9tACTp41jx0qDrThLAWfwNHHbJc7vkuUeUPEee",
	"wGA6sJdrhmRmnF/ZVUBIKL6Yigc4HRlwmoTkutTtFnqb7YRuJnTzdm1blbzbawdnCHfXCc7Jgp+6rOAD",
	"V8daV80htgjbgAghyOgzwWOeyqiYk7J6vu4KkmX4lYW3bU3nfFySdZrbrBVRnKuVnh+mwfEjrBlkVHbz",
	"B6cFlfv2DunqD8c65c5ySMb2BONrKfeAxWi+P0Xa79xK0myI2ZxiD8kyNCxcrxcjy+/2yjGbtvt9NH4v",
	"L8ZbvMAkKe/av3dr/+5SupfrZjyCzu9ur/Pm74+gfMB2Ws6XqPg7Lgy4maoEmFtAsYQJYXGl6/xdm85L",
	"UIrFUzk06maUCK5s48eGax6jb06zd9fSkS9LHWsiMN/MnuyyCvFZbZovz3TJKsfaVePayoPo504r1g+4",
	"q+7cZO414O1BpHTqb9tWR+FLsHRKNGOTrMdNv4l2jG9vDFkRv2LKSJAKTCREGsREkXLznGucvz79oz3z",
	"4/PdtdGaWfcOLXT8KHVq5gE76Wz+TLmNI+K9e+7dTSlNg5GnkbCvuZ1t6PmtN/z9Hupm1srxOmuidu8e",
	"oqNvweR6d2R1006B+zvRZQh6ZMq7SFC7Vr07SbSS8jEfNcToX+gXvpk+HJt1YdWWp1J0umuKXk0eUIZ2",
	"HGHi/x+ygYXJM9+ElLyg04dqWHEGkxqS3N0pPVAfCoV0tkT27XJ4+FXR6W279W/IuMMlwISLpZIyHYoY",
	"eJS2Fm8P3n76O6uybztce0ml/vDgJNjmVNx9Zcnv4lRQs2tbLlyjMnW2wi2kBJUmo4DP56MEY75efq3R",
	"mef6zSM+n5+KzRV/zsY/jvX55q71n/V60tgVREsK4SmSXq9Lav2y+XhC3B1yQyWhkQAaLpbCTbcR03gj",
	"eDwlBhKptD4zdUGYLMQpbInrIEgFU4vey98+LzXFThNS2nRZ3PX6yriG/CN6ZUm/TtAi8Z/r1W+0CWc+",
	"i69msmnJWtiJB0Z7ln6vZuAaxrJYKhpFhvFYTrf6oJ8mtZ1j6yXOhgSNGbu7fFmPdBOAASY0kr8yNTuH",
	"QID3AJlKEOt13z+MsKLRFtuHNAoHS540Di1eCbV1CzWuGwSEoopJxYIGzXjKpUnzfXOtYdwUxeYz5H6H",
	"O7jctM0hHtR036Z5pnfM1PYlgLjrG9UFcZhwZoq+zoHGCrVaVnQktTXrmghDDiM+ZXGDxaTkCb6xKYKQ",
	"h6maldr/bU+W6am1LDMfX/Ar8EZq50RGzi/OicHYd0ZsNYInATHhYk6oWbWppnp+cd4cE51KOoU9w6TD",
	"bLCGpGP9/hm+fm7f3uCuHxfUe2FmxENxVAVfVEvdo2VKweGIsON9t2fFtLBMIrMdq5EyqJwadv/IBEZ8",
	"Mjpsc4ZLYZoac8VXHNZGbSxpWL1jenll1vna+9eNGimUIy9/+6zPuGMqWTDC1+0vAedXDEo/cRaW35F0",
	"HuU/aI7E/fDVf8ssalNhyqqEXr+Xiqj3sjekCRteH/RuP9/+vwAAAP//fVYA2IVNAgA=",
}

// GetSwaggerSpecReader returns a reader to the Swagger specification corresponding to the generated code in this file.
func GetSwaggerSpecReader() (io.Reader, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	return zr, err
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.T, error) {
	zr, err := GetSwaggerSpecReader()
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	swagger, err := openapi3.NewLoader().LoadFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
