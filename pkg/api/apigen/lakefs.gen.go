// Package apigen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package apigen

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"runtime/trace"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/pkg/errors"
)

const (
	Basic_authScopes  = "basic_auth.Scopes"
	Cookie_authScopes = "cookie_auth.Scopes"
	Jwt_tokenScopes   = "jwt_token.Scopes"
	Oidc_authScopes   = "oidc_auth.Scopes"
	Saml_authScopes   = "saml_auth.Scopes"
)

// ACL defines model for ACL.
type ACL struct {

	// Permission level to give this ACL.  "Read", "Write", "Super" and
	// "Admin" are all supported.
	Permission string `json:"permission"`
}

// AbortPresignMultipartUpload defines model for AbortPresignMultipartUpload.
type AbortPresignMultipartUpload struct {
	PhysicalAddress string `json:"physical_address"`
}

// AccessKeyCredentials defines model for AccessKeyCredentials.
type AccessKeyCredentials struct {

	// access key ID to set for user for use in integration testing.
	AccessKeyId string `json:"access_key_id"`

	// secret access key to set for user for use in integration testing.
	SecretAccessKey string `json:"secret_access_key"`
}

// ActionRun defines model for ActionRun.
type ActionRun struct {
	Branch    string     `json:"branch"`
	CommitId  string     `json:"commit_id"`
	EndTime   *time.Time `json:"end_time,omitempty"`
	EventType string     `json:"event_type"`
	RunId     string     `json:"run_id"`
	StartTime time.Time  `json:"start_time"`
	Status    string     `json:"status"`
}

// ActionRunList defines model for ActionRunList.
type ActionRunList struct {
	Pagination Pagination  `json:"pagination"`
	Results    []ActionRun `json:"results"`
}

// AsyncTaskStatus defines model for AsyncTaskStatus.
type AsyncTaskStatus struct {

	// true if the task has completed (either successfully or with an error)
	Completed bool   `json:"completed"`
	Error     *Error `json:"error,omitempty"`

	// an http status code that correlates with the underlying error if exists
	StatusCode *int32 `json:"status_code,omitempty"`

	// the id of the async task
	TaskId string `json:"task_id"`

	// last time the task status was updated
	UpdateTime time.Time `json:"update_time"`
}

// AuthCapabilities defines model for AuthCapabilities.
type AuthCapabilities struct {
	ForgotPassword *bool `json:"forgot_password,omitempty"`
	InviteUser     *bool `json:"invite_user,omitempty"`
}

// AuthenticationToken defines model for AuthenticationToken.
type AuthenticationToken struct {

	// a JWT token that could be used to authenticate requests
	Token string `json:"token"`

	// Unix Epoch in seconds
	TokenExpiration *int64 `json:"token_expiration,omitempty"`
}

// BranchCreation defines model for BranchCreation.
type BranchCreation struct {
	Force *bool `json:"force,omitempty"`

	// When set, branch will not show up when listing branches by default. *EXPERIMENTAL*
	Hidden *bool  `json:"hidden,omitempty"`
	Name   string `json:"name"`
	Source string `json:"source"`
}

// BranchProtectionRule defines model for BranchProtectionRule.
type BranchProtectionRule struct {

	// fnmatch pattern for the branch name, supporting * and ? wildcards
	Pattern string `json:"pattern"`
}

// CapabilitiesConfig defines model for CapabilitiesConfig.
type CapabilitiesConfig struct {

	// are async operations enabled in server. *EXPERIMENTAL*
	AsyncOps *bool `json:"async_ops,omitempty"`
}

// CherryPickCreation defines model for CherryPickCreation.
type CherryPickCreation struct {
	CommitOverrides *CommitOverrides `json:"commit_overrides,omitempty"`
	Force           *bool            `json:"force,omitempty"`

	// When cherry-picking a merge commit, the parent number (starting from 1) with which to perform the diff.
	// The default branch is parent 1.
	ParentNumber *int `json:"parent_number,omitempty"`

	// the commit to cherry-pick, given by a ref
	Ref string `json:"ref"`
}

// CommPrefsInput defines model for CommPrefsInput.
type CommPrefsInput struct {

	// the provided email
	Email *string `json:"email,omitempty"`

	// user preference to receive feature updates
	FeatureUpdates bool `json:"featureUpdates"`

	// user preference to receive security updates
	SecurityUpdates bool `json:"securityUpdates"`
}

// Commit defines model for Commit.
type Commit struct {
	Committer string `json:"committer"`

	// Unix Epoch in seconds
	CreationDate int64            `json:"creation_date"`
	Generation   *int64           `json:"generation,omitempty"`
	Id           string           `json:"id"`
	Message      string           `json:"message"`
	MetaRangeId  string           `json:"meta_range_id"`
	Metadata     *Commit_Metadata `json:"metadata,omitempty"`
	Parents      []string         `json:"parents"`
	Version      *int             `json:"version,omitempty"`
}

// Commit_Metadata defines model for Commit.Metadata.
type Commit_Metadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// CommitAsyncStatus defines model for CommitAsyncStatus.
type CommitAsyncStatus struct {
	// Embedded struct due to allOf(#/components/schemas/AsyncTaskStatus)
	AsyncTaskStatus `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Result *Commit `json:"result,omitempty"`
}

// CommitCreation defines model for CommitCreation.
type CommitCreation struct {

	// sets whether a commit can contain no changes
	AllowEmpty *bool `json:"allow_empty,omitempty"`

	// set date to override creation date in the commit (Unix Epoch in seconds)
	Date     *int64                   `json:"date,omitempty"`
	Force    *bool                    `json:"force,omitempty"`
	Message  string                   `json:"message"`
	Metadata *CommitCreation_Metadata `json:"metadata,omitempty"`
}

// CommitCreation_Metadata defines model for CommitCreation.Metadata.
type CommitCreation_Metadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// CommitList defines model for CommitList.
type CommitList struct {
	Pagination Pagination `json:"pagination"`
	Results    []Commit   `json:"results"`
}

// CommitOverrides defines model for CommitOverrides.
type CommitOverrides struct {

	// replace the commit message
	Message *string `json:"message,omitempty"`

	// replace the metadata of the commit
	Metadata *CommitOverrides_Metadata `json:"metadata,omitempty"`
}

// CommitOverrides_Metadata defines model for CommitOverrides.Metadata.
type CommitOverrides_Metadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// CommitRecordCreation defines model for CommitRecordCreation.
type CommitRecordCreation struct {

	// id of the commit record
	CommitId string `json:"commit_id"`

	// committer of the commit record
	Committer string `json:"committer"`

	// Unix Epoch in seconds
	CreationDate int64 `json:"creation_date"`
	Force        *bool `json:"force,omitempty"`

	// generation of the commit record
	Generation int64 `json:"generation"`

	// message of the commit record
	Message string `json:"message"`

	// metadata of the commit record
	Metadata *CommitRecordCreation_Metadata `json:"metadata,omitempty"`

	// metarange_id of the commit record
	MetarangeId string `json:"metarange_id"`

	// parents of the commit record
	Parents []string `json:"parents"`

	// version of the commit record
	Version int `json:"version"`
}

// CommitRecordCreation_Metadata defines model for CommitRecordCreation.Metadata.
type CommitRecordCreation_Metadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// CompletePresignMultipartUpload defines model for CompletePresignMultipartUpload.
type CompletePresignMultipartUpload struct {

	// Object media type
	ContentType *string `json:"content_type,omitempty"`

	// List of uploaded parts, should be ordered by ascending part number
	Parts           []UploadPart                                 `json:"parts"`
	PhysicalAddress string                                       `json:"physical_address"`
	UserMetadata    *CompletePresignMultipartUpload_UserMetadata `json:"user_metadata,omitempty"`
}

// CompletePresignMultipartUpload_UserMetadata defines model for CompletePresignMultipartUpload.UserMetadata.
type CompletePresignMultipartUpload_UserMetadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Config defines model for Config.
type Config struct {
	CapabilitiesConfig *CapabilitiesConfig `json:"capabilities_config,omitempty"`
	StorageConfig      *StorageConfig      `json:"storage_config,omitempty"`
	StorageConfigList  *StorageConfigList  `json:"storage_config_list,omitempty"`
	UiConfig           *UIConfig           `json:"ui_config,omitempty"`
	VersionConfig      *VersionConfig      `json:"version_config,omitempty"`
}

// CopyPartSource defines model for CopyPartSource.
type CopyPartSource struct {
	Path string `json:"path"`

	// Range of bytes to copy
	Range      *string `json:"range,omitempty"`
	Ref        string  `json:"ref"`
	Repository string  `json:"repository"`
}

// Credentials defines model for Credentials.
type Credentials struct {
	AccessKeyId string `json:"access_key_id"`

	// Unix Epoch in seconds
	CreationDate int64 `json:"creation_date"`
}

// CredentialsList defines model for CredentialsList.
type CredentialsList struct {
	Pagination Pagination    `json:"pagination"`
	Results    []Credentials `json:"results"`
}

// CredentialsWithSecret defines model for CredentialsWithSecret.
type CredentialsWithSecret struct {
	AccessKeyId string `json:"access_key_id"`

	// Unix Epoch in seconds
	CreationDate    int64  `json:"creation_date"`
	SecretAccessKey string `json:"secret_access_key"`
}

// CurrentUser defines model for CurrentUser.
type CurrentUser struct {
	User User `json:"user"`
}

// CustomViewer defines model for CustomViewer.
type CustomViewer struct {
	ContentTypes *[]string `json:"content_types,omitempty"`
	Extensions   *[]string `json:"extensions,omitempty"`
	Name         string    `json:"name"`
	Url          string    `json:"url"`
}

// Diff defines model for Diff.
type Diff struct {
	Path     string          `json:"path"`
	PathType string          `json:"path_type"`
	Right    *DiffObjectStat `json:"right,omitempty"`

	// represents the size of the added/changed/deleted entry
	SizeBytes *int64 `json:"size_bytes,omitempty"`
	Type      string `json:"type"`
}

// DiffList defines model for DiffList.
type DiffList struct {
	Pagination Pagination `json:"pagination"`
	Results    []Diff     `json:"results"`
}

// DiffObjectStat defines model for DiffObjectStat.
type DiffObjectStat struct {
	Checksum string `json:"checksum"`

	// Object media type
	ContentType string              `json:"content_type"`
	Metadata    *ObjectUserMetadata `json:"metadata,omitempty"`

	// Unix Epoch in seconds
	Mtime int64 `json:"mtime"`
}

// Error defines model for Error.
type Error struct {

	// short message explaining the error
	Message string `json:"message"`
}

// ErrorNoACL defines model for ErrorNoACL.
type ErrorNoACL struct {

	// short message explaining the error
	Message string `json:"message"`

	// true if the group exists but has no ACL
	NoAcl *bool `json:"no_acl,omitempty"`
}

// ExternalLoginInformation defines model for ExternalLoginInformation.
type ExternalLoginInformation struct {
	IdentityRequest         map[string]interface{} `json:"identityRequest"`
	TokenExpirationDuration *int                   `json:"token_expiration_duration,omitempty"`
}

// ExternalPrincipal defines model for ExternalPrincipal.
type ExternalPrincipal struct {

	// A unique identifier for the external principal i.e aws:sts::123:assumed-role/role-name
	Id       string                  `json:"id"`
	Settings *map[string]interface{} `json:"settings,omitempty"`

	// lakeFS user ID to associate with an external principal.
	UserId string `json:"user_id"`
}

// ExternalPrincipalCreation defines model for ExternalPrincipalCreation.
type ExternalPrincipalCreation struct {
	Settings *map[string]interface{} `json:"settings,omitempty"`
}

// ExternalPrincipalList defines model for ExternalPrincipalList.
type ExternalPrincipalList struct {
	Pagination Pagination          `json:"pagination"`
	Results    []ExternalPrincipal `json:"results"`
}

// ExternalPrincipalSettings defines model for ExternalPrincipalSettings.
type ExternalPrincipalSettings struct {
	AdditionalProperties map[string]string `json:"-"`
}

// FindMergeBaseResult defines model for FindMergeBaseResult.
type FindMergeBaseResult struct {

	// The commit ID of the merge base
	BaseCommitId string `json:"base_commit_id"`

	// The commit ID of the merge destination
	DestinationCommitId string `json:"destination_commit_id"`

	// The commit ID of the merge source
	SourceCommitId string `json:"source_commit_id"`
}

// GarbageCollectionConfig defines model for GarbageCollectionConfig.
type GarbageCollectionConfig struct {

	// Duration in seconds. Objects created in the recent grace_period will not be collected.
	GracePeriod *int `json:"grace_period,omitempty"`
}

// GarbageCollectionPrepareResponse defines model for GarbageCollectionPrepareResponse.
type GarbageCollectionPrepareResponse struct {

	// location to use for expired addresses parquet table (partitioned by run_id)
	GcAddressesLocation string `json:"gc_addresses_location"`

	// location of the resulting commits csv table (partitioned by run_id)
	GcCommitsLocation string `json:"gc_commits_location"`

	// a presigned url to download the commits csv
	GcCommitsPresignedUrl *string `json:"gc_commits_presigned_url,omitempty"`

	// a unique identifier generated for this GC job
	RunId string `json:"run_id"`
}

// GarbageCollectionRule defines model for GarbageCollectionRule.
type GarbageCollectionRule struct {
	BranchId      string `json:"branch_id"`
	RetentionDays int    `json:"retention_days"`
}

// GarbageCollectionRules defines model for GarbageCollectionRules.
type GarbageCollectionRules struct {
	Branches             []GarbageCollectionRule `json:"branches"`
	DefaultRetentionDays int                     `json:"default_retention_days"`
}

// Group defines model for Group.
type Group struct {

	// Unix Epoch in seconds
	CreationDate int64   `json:"creation_date"`
	Description  *string `json:"description,omitempty"`
	Id           string  `json:"id"`
	Name         *string `json:"name,omitempty"`
}

// GroupCreation defines model for GroupCreation.
type GroupCreation struct {
	Description *string `json:"description,omitempty"`
	Id          string  `json:"id"`
}

// GroupList defines model for GroupList.
type GroupList struct {
	Pagination Pagination `json:"pagination"`
	Results    []Group    `json:"results"`
}

// HookRun defines model for HookRun.
type HookRun struct {
	Action    string     `json:"action"`
	EndTime   *time.Time `json:"end_time,omitempty"`
	HookId    string     `json:"hook_id"`
	HookRunId string     `json:"hook_run_id"`
	StartTime time.Time  `json:"start_time"`
	Status    string     `json:"status"`
}

// HookRunList defines model for HookRunList.
type HookRunList struct {
	Pagination Pagination `json:"pagination"`
	Results    []HookRun  `json:"results"`
}

// IcebergLocalTable defines model for IcebergLocalTable.
type IcebergLocalTable struct {

	// Reference to one or more levels of a namespace
	Namespace IcebergNamespaceRef `json:"namespace"`

	// lakeFS reference ID (branch or commit)
	ReferenceId string `json:"reference_id"`

	// lakeFS repository ID
	RepositoryId string `json:"repository_id"`

	// Remote table name
	Table string `json:"table"`
}

// IcebergNamespaceRef defines model for IcebergNamespaceRef.
type IcebergNamespaceRef []string

// IcebergPullRequest defines model for IcebergPullRequest.
type IcebergPullRequest struct {

	// Creates namespace in local catalog if not exist
	CreateNamespace *bool             `json:"create_namespace,omitempty"`
	Destination     IcebergLocalTable `json:"destination"`

	// Override exiting local table if exists
	ForceUpdate *bool              `json:"force_update,omitempty"`
	Source      IcebergRemoteTable `json:"source"`
}

// IcebergPushRequest defines model for IcebergPushRequest.
type IcebergPushRequest struct {

	// Creates namespace in remote catalog if not exist
	CreateNamespace *bool              `json:"create_namespace,omitempty"`
	Destination     IcebergRemoteTable `json:"destination"`

	// Override exiting table in remote if exists
	ForceUpdate *bool             `json:"force_update,omitempty"`
	Source      IcebergLocalTable `json:"source"`
}

// IcebergRemoteTable defines model for IcebergRemoteTable.
type IcebergRemoteTable struct {

	// Reference to one or more levels of a namespace
	Namespace IcebergNamespaceRef `json:"namespace"`

	// Remote table name
	Table string `json:"table"`
}

// ImportCreation defines model for ImportCreation.
type ImportCreation struct {
	Commit CommitCreation   `json:"commit"`
	Force  *bool            `json:"force,omitempty"`
	Paths  []ImportLocation `json:"paths"`
}

// ImportCreationResponse defines model for ImportCreationResponse.
type ImportCreationResponse struct {

	// The id of the import process
	Id string `json:"id"`
}

// ImportLocation defines model for ImportLocation.
type ImportLocation struct {

	// Destination for the imported objects on the branch. Must be a relative path to the branch.
	// If the type is an 'object', the destination is the exact object name under the branch.
	// If the type is a 'common_prefix', the destination is the prefix under the branch.
	Destination string `json:"destination"`

	// A source location to a 'common_prefix' or to a single object. Must match the lakeFS installation blockstore type.
	Path string `json:"path"`

	// Path type, can either be 'common_prefix' or 'object'
	Type string `json:"type"`
}

// ImportStatus defines model for ImportStatus.
type ImportStatus struct {
	Commit    *Commit `json:"commit,omitempty"`
	Completed bool    `json:"completed"`
	Error     *Error  `json:"error,omitempty"`

	// Number of objects processed so far
	IngestedObjects *int64    `json:"ingested_objects,omitempty"`
	MetarangeId     *string   `json:"metarange_id,omitempty"`
	UpdateTime      time.Time `json:"update_time"`
}

// InstallationUsageReport defines model for InstallationUsageReport.
type InstallationUsageReport struct {
	InstallationId string        `json:"installation_id"`
	Reports        []UsageReport `json:"reports"`
}

// License defines model for License.
type License struct {

	// The license JWT token
	Token string `json:"token"`
}

// LoginConfig defines model for LoginConfig.
type LoginConfig struct {

	// RBAC will remain enabled on GUI if "external".  That only works
	// with an external auth service.
	RBAC *string `json:"RBAC,omitempty"`

	// Label to place on fallback_login_url.
	FallbackLoginLabel *string `json:"fallback_login_label,omitempty"`

	// Secondary URL to offer users to use for login.
	FallbackLoginUrl *string `json:"fallback_login_url,omitempty"`

	// Cookie names used to store JWT
	LoginCookieNames []string `json:"login_cookie_names"`

	// Message to display to users who fail to login; a full sentence that is rendered
	// in HTML and may contain a link to a secondary login method
	LoginFailedMessage *string `json:"login_failed_message,omitempty"`

	// Primary URL to use for login.
	LoginUrl string `json:"login_url"`

	// Defines login behavior when login_url is set.
	// - none: For OSS users.
	// - redirect: Auto-redirect to login_url.
	// - select: Show a page to choose between logging in via login_url or with lakeFS credentials.
	// Ignored if login_url is not configured.
	LoginUrlMethod *string `json:"login_url_method,omitempty"`

	// URL to use for logging out.
	LogoutUrl string `json:"logout_url"`

	// Placeholder text to display in the password field of the login form.
	PasswordUiPlaceholder *string `json:"password_ui_placeholder,omitempty"`

	// Placeholder text to display in the username field of the login form.
	UsernameUiPlaceholder *string `json:"username_ui_placeholder,omitempty"`
}

// LoginInformation defines model for LoginInformation.
type LoginInformation struct {
	AccessKeyId     string `json:"access_key_id"`
	SecretAccessKey string `json:"secret_access_key"`
}

// Merge defines model for Merge.
type Merge struct {

	// Allow merge when the branches have the same content
	AllowEmpty *bool `json:"allow_empty,omitempty"`

	// Allow merge into a read-only branch or into a branch with the same content
	Force    *bool           `json:"force,omitempty"`
	Message  *string         `json:"message,omitempty"`
	Metadata *Merge_Metadata `json:"metadata,omitempty"`

	// If set, set only the destination branch as a parent, which "squashes" the merge to
	// appear as a single commit on the destination branch.  The source commit is no longer
	// a part of the merge commit; consider adding it to the 'metadata' or 'message'
	// fields.  This behaves like a GitHub or GitLab "squash merge", or in Git terms 'git
	// merge --squash; git commit ...'.
	SquashMerge *bool `json:"squash_merge,omitempty"`

	// In case of a merge conflict, this option will force the merge process to automatically favor changes from the dest branch ('dest-wins') or from the source branch('source-wins'). In case no selection is made, the merge process will fail in case of a conflict
	Strategy *string `json:"strategy,omitempty"`
}

// Merge_Metadata defines model for Merge.Metadata.
type Merge_Metadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// MergeAsyncStatus defines model for MergeAsyncStatus.
type MergeAsyncStatus struct {
	// Embedded struct due to allOf(#/components/schemas/AsyncTaskStatus)
	AsyncTaskStatus `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Result *MergeResult `json:"result,omitempty"`
}

// MergeResult defines model for MergeResult.
type MergeResult struct {
	Reference string `json:"reference"`
}

// ObjectCopyCreation defines model for ObjectCopyCreation.
type ObjectCopyCreation struct {
	Force *bool `json:"force,omitempty"`

	// path of the copied object relative to the ref
	SrcPath string `json:"src_path"`

	// a reference, if empty uses the provided branch as ref
	SrcRef *string `json:"src_ref,omitempty"`
}

// ObjectError defines model for ObjectError.
type ObjectError struct {

	// short message explaining status_code
	Message string `json:"message"`

	// affected path
	Path *string `json:"path,omitempty"`

	// HTTP status code associated for operation on path
	StatusCode int `json:"status_code"`
}

// ObjectErrorList defines model for ObjectErrorList.
type ObjectErrorList struct {
	Errors []ObjectError `json:"errors"`
}

// ObjectStageCreation defines model for ObjectStageCreation.
type ObjectStageCreation struct {
	Checksum string `json:"checksum"`

	// Object media type
	ContentType *string             `json:"content_type,omitempty"`
	Force       *bool               `json:"force,omitempty"`
	Metadata    *ObjectUserMetadata `json:"metadata,omitempty"`

	// Unix Epoch in seconds
	Mtime           *int64 `json:"mtime,omitempty"`
	PhysicalAddress string `json:"physical_address"`
	SizeBytes       int64  `json:"size_bytes"`
}

// ObjectStats defines model for ObjectStats.
type ObjectStats struct {
	Checksum string `json:"checksum"`

	// Object media type
	ContentType *string             `json:"content_type,omitempty"`
	Metadata    *ObjectUserMetadata `json:"metadata,omitempty"`

	// Unix Epoch in seconds
	Mtime    int64  `json:"mtime"`
	Path     string `json:"path"`
	PathType string `json:"path_type"`

	// The location of the object on the underlying object store.
	// Formatted as a native URI with the object store type as scheme ("s3://...", "gs://...", etc.)
	// Or, in the case of presign=true, will be an HTTP URL to be consumed via regular HTTP GET
	PhysicalAddress string `json:"physical_address"`

	// If present and nonzero, physical_address is a pre-signed URL and
	// will expire at this Unix Epoch time.  This will be shorter than
	// the pre-signed URL lifetime if an authentication token is about
	// to expire.
	//
	// This field is *optional*.
	PhysicalAddressExpiry *int64 `json:"physical_address_expiry,omitempty"`

	// The number of bytes in the object.  lakeFS always populates this
	// field when returning ObjectStats.  This field is optional _for
	// the client_ to supply, for instance on upload.
	SizeBytes *int64 `json:"size_bytes,omitempty"`
}

// ObjectStatsList defines model for ObjectStatsList.
type ObjectStatsList struct {
	Pagination Pagination    `json:"pagination"`
	Results    []ObjectStats `json:"results"`
}

// ObjectUserMetadata defines model for ObjectUserMetadata.
type ObjectUserMetadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Pagination defines model for Pagination.
type Pagination struct {

	// Next page is available
	HasMore bool `json:"has_more"`

	// Maximal number of entries per page
	MaxPerPage int `json:"max_per_page"`

	// Token used to retrieve the next page
	NextOffset string `json:"next_offset"`

	// Number of values found in the results
	Results int `json:"results"`
}

// PathList defines model for PathList.
type PathList struct {
	Paths []string `json:"paths"`
}

// Policy defines model for Policy.
type Policy struct {

	// Unix Epoch in seconds
	CreationDate *int64      `json:"creation_date,omitempty"`
	Id           string      `json:"id"`
	Statement    []Statement `json:"statement"`
}

// PolicyCondition defines model for PolicyCondition.
type PolicyCondition struct {
	AdditionalProperties map[string][]string `json:"-"`
}

// PolicyList defines model for PolicyList.
type PolicyList struct {
	Pagination Pagination `json:"pagination"`
	Results    []Policy   `json:"results"`
}

// PrepareGCUncommittedRequest defines model for PrepareGCUncommittedRequest.
type PrepareGCUncommittedRequest struct {
	ContinuationToken *string `json:"continuation_token,omitempty"`
}

// PrepareGCUncommittedResponse defines model for PrepareGCUncommittedResponse.
type PrepareGCUncommittedResponse struct {
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// location of uncommitted information data
	GcUncommittedLocation string `json:"gc_uncommitted_location"`
	RunId                 string `json:"run_id"`
}

// PrepareGarbageCollectionCommitsStatus defines model for PrepareGarbageCollectionCommitsStatus.
type PrepareGarbageCollectionCommitsStatus struct {

	// true if the task has completed (either successfully or with an error)
	Completed bool                              `json:"completed"`
	Error     *Error                            `json:"error,omitempty"`
	Result    *GarbageCollectionPrepareResponse `json:"result,omitempty"`

	// the id of the task preparing the GC commits
	TaskId string `json:"task_id"`

	// last time the task status was updated
	UpdateTime time.Time `json:"update_time"`
}

// PresignMultipartUpload defines model for PresignMultipartUpload.
type PresignMultipartUpload struct {
	PhysicalAddress string    `json:"physical_address"`
	PresignedUrls   *[]string `json:"presigned_urls,omitempty"`
	UploadId        string    `json:"upload_id"`
}

// PullRequest defines model for PullRequest.
type PullRequest struct {
	// Embedded struct due to allOf(#/components/schemas/PullRequestBasic)
	PullRequestBasic `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	// Embedded fields due to inline allOf schema
	Author            string     `json:"author"`
	ClosedDate        *time.Time `json:"closed_date,omitempty"`
	CreationDate      time.Time  `json:"creation_date"`
	DestinationBranch string     `json:"destination_branch"`
	Id                string     `json:"id"`

	// the commit id of merged PRs
	MergedCommitId *string `json:"merged_commit_id,omitempty"`
	SourceBranch   string  `json:"source_branch"`
}

// PullRequestBasic defines model for PullRequestBasic.
type PullRequestBasic struct {
	Description *string `json:"description,omitempty"`
	Status      *string `json:"status,omitempty"`
	Title       *string `json:"title,omitempty"`
}

// PullRequestCreation defines model for PullRequestCreation.
type PullRequestCreation struct {
	Description       *string `json:"description,omitempty"`
	DestinationBranch string  `json:"destination_branch"`
	SourceBranch      string  `json:"source_branch"`
	Title             string  `json:"title"`
}

// PullRequestCreationResponse defines model for PullRequestCreationResponse.
type PullRequestCreationResponse struct {

	// ID of the pull request
	Id string `json:"id"`
}

// PullRequestsList defines model for PullRequestsList.
type PullRequestsList struct {
	Pagination Pagination    `json:"pagination"`
	Results    []PullRequest `json:"results"`
}

// Ref defines model for Ref.
type Ref struct {
	CommitId string `json:"commit_id"`
	Id       string `json:"id"`
}

// RefList defines model for RefList.
type RefList struct {
	Pagination Pagination `json:"pagination"`
	Results    []Ref      `json:"results"`
}

// RefsDump defines model for RefsDump.
type RefsDump struct {
	BranchesMetaRangeId string `json:"branches_meta_range_id"`
	CommitsMetaRangeId  string `json:"commits_meta_range_id"`
	TagsMetaRangeId     string `json:"tags_meta_range_id"`
}

// RefsRestore defines model for RefsRestore.
type RefsRestore struct {
	BranchesMetaRangeId string `json:"branches_meta_range_id"`
	CommitsMetaRangeId  string `json:"commits_meta_range_id"`
	Force               *bool  `json:"force,omitempty"`
	TagsMetaRangeId     string `json:"tags_meta_range_id"`
}

// Repository defines model for Repository.
type Repository struct {

	// Unix Epoch in seconds
	CreationDate  int64  `json:"creation_date"`
	DefaultBranch string `json:"default_branch"`
	Id            string `json:"id"`

	// Whether the repository is a read-only repository- not relevant for bare repositories
	ReadOnly *bool `json:"read_only,omitempty"`

	// Unique identifier of the underlying data store. *EXPERIMENTAL*
	StorageId *string `json:"storage_id,omitempty"`

	// Filesystem URI to store the underlying data in (e.g. "s3://my-bucket/some/path/")
	StorageNamespace string `json:"storage_namespace"`
}

// RepositoryCreation defines model for RepositoryCreation.
type RepositoryCreation struct {
	DefaultBranch *string `json:"default_branch,omitempty"`
	Name          string  `json:"name"`
	ReadOnly      *bool   `json:"read_only,omitempty"`
	SampleData    *bool   `json:"sample_data,omitempty"`

	// Unique identifier of the underlying data store. *EXPERIMENTAL*
	StorageId *string `json:"storage_id,omitempty"`

	// Filesystem URI to store the underlying data in (e.g. "s3://my-bucket/some/path/")
	StorageNamespace string `json:"storage_namespace"`
}

// RepositoryDumpStatus defines model for RepositoryDumpStatus.
type RepositoryDumpStatus struct {
	Done  bool    `json:"done"`
	Error *string `json:"error,omitempty"`

	// ID of the task
	Id         string    `json:"id"`
	Refs       *RefsDump `json:"refs,omitempty"`
	UpdateTime time.Time `json:"update_time"`
}

// RepositoryList defines model for RepositoryList.
type RepositoryList struct {
	Pagination Pagination   `json:"pagination"`
	Results    []Repository `json:"results"`
}

// RepositoryMetadata defines model for RepositoryMetadata.
type RepositoryMetadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// RepositoryMetadataKeys defines model for RepositoryMetadataKeys.
type RepositoryMetadataKeys struct {
	Keys []string `json:"keys"`
}

// RepositoryMetadataSet defines model for RepositoryMetadataSet.
type RepositoryMetadataSet struct {
	Metadata RepositoryMetadataSet_Metadata `json:"metadata"`
}

// RepositoryMetadataSet_Metadata defines model for RepositoryMetadataSet.Metadata.
type RepositoryMetadataSet_Metadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// RepositoryRestoreStatus defines model for RepositoryRestoreStatus.
type RepositoryRestoreStatus struct {
	Done  bool    `json:"done"`
	Error *string `json:"error,omitempty"`

	// ID of the task
	Id         string    `json:"id"`
	UpdateTime time.Time `json:"update_time"`
}

// ResetCreation defines model for ResetCreation.
type ResetCreation struct {
	Force *bool   `json:"force,omitempty"`
	Path  *string `json:"path,omitempty"`

	// What to reset according to path.
	Type string `json:"type"`
}

// RevertCreation defines model for RevertCreation.
type RevertCreation struct {

	// allow empty commit (revert without changes)
	AllowEmpty      *bool            `json:"allow_empty,omitempty"`
	CommitOverrides *CommitOverrides `json:"commit_overrides,omitempty"`
	Force           *bool            `json:"force,omitempty"`

	// when reverting a merge commit, the parent number (starting from 1) relative to which to perform the revert.
	ParentNumber int `json:"parent_number"`

	// the commit to revert, given by a ref
	Ref string `json:"ref"`
}

// Setup defines model for Setup.
type Setup struct {
	Key *AccessKeyCredentials `json:"key,omitempty"`

	// an identifier for the user (e.g. jane.doe)
	Username string `json:"username"`
}

// SetupState defines model for SetupState.
type SetupState struct {

	// true if the comm prefs are missing.
	CommPrefsMissing *bool        `json:"comm_prefs_missing,omitempty"`
	LoginConfig      *LoginConfig `json:"login_config,omitempty"`
	State            *string      `json:"state,omitempty"`
}

// StagingLocation defines model for StagingLocation.
type StagingLocation struct {
	PhysicalAddress *string `json:"physical_address,omitempty"`

	// if presign=true is passed in the request, this field will contain a pre-signed URL to use when uploading
	PresignedUrl *string `json:"presigned_url"`

	// If present and nonzero, physical_address is a pre-signed URL and
	// will expire at this Unix Epoch time.  This will be shorter than
	// the pre-signed URL lifetime if an authentication token is about
	// to expire.
	//
	// This field is *optional*.
	PresignedUrlExpiry *int64 `json:"presigned_url_expiry,omitempty"`
}

// StagingMetadata defines model for StagingMetadata.
type StagingMetadata struct {

	// unique identifier of object content on backing store (typically ETag)
	Checksum string `json:"checksum"`

	// Object media type
	ContentType *string `json:"content_type,omitempty"`
	Force       *bool   `json:"force,omitempty"`

	// Unix Epoch in seconds.  May be ignored by server.
	Mtime     *int64 `json:"mtime,omitempty"`
	SizeBytes int64  `json:"size_bytes"`

	// location for placing an object when staging it
	Staging      StagingLocation               `json:"staging"`
	UserMetadata *StagingMetadata_UserMetadata `json:"user_metadata,omitempty"`
}

// StagingMetadata_UserMetadata defines model for StagingMetadata.UserMetadata.
type StagingMetadata_UserMetadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Statement defines model for Statement.
type Statement struct {
	Action []string `json:"action"`

	// Optional conditions for when this statement applies.
	Condition *Statement_Condition `json:"condition,omitempty"`
	Effect    string               `json:"effect"`
	Resource  string               `json:"resource"`
}

// Statement_Condition defines model for Statement.Condition.
type Statement_Condition struct {
	AdditionalProperties map[string]PolicyCondition `json:"-"`
}

// StatsEvent defines model for StatsEvent.
type StatsEvent struct {

	// stats event class (e.g. "s3_gateway", "openapi_request", "experimental-feature", "ui-event")
	Class string `json:"class"`

	// number of events of the class and name
	Count int `json:"count"`

	// stats event name (e.g. "put_object", "create_repository", "<experimental-feature-name>")
	Name string `json:"name"`
}

// StatsEventsList defines model for StatsEventsList.
type StatsEventsList struct {
	Events []StatsEvent `json:"events"`
}

// StorageConfig defines model for StorageConfig.
type StorageConfig struct {
	BlockstoreDescription            *string `json:"blockstore_description,omitempty"`
	BlockstoreId                     *string `json:"blockstore_id,omitempty"`
	BlockstoreNamespaceValidityRegex string  `json:"blockstore_namespace_ValidityRegex"`
	BlockstoreNamespaceExample       string  `json:"blockstore_namespace_example"`
	BlockstoreType                   string  `json:"blockstore_type"`
	DefaultNamespacePrefix           *string `json:"default_namespace_prefix,omitempty"`
	ImportSupport                    bool    `json:"import_support"`
	ImportValidityRegex              string  `json:"import_validity_regex"`
	PreSignMultipartUpload           *bool   `json:"pre_sign_multipart_upload,omitempty"`
	PreSignSupport                   bool    `json:"pre_sign_support"`
	PreSignSupportUi                 bool    `json:"pre_sign_support_ui"`
}

// StorageConfigList defines model for StorageConfigList.
type StorageConfigList []StorageConfig

// StorageURI defines model for StorageURI.
type StorageURI struct {
	Location string `json:"location"`
}

// StsAuthRequest defines model for StsAuthRequest.
type StsAuthRequest struct {
	Code        string `json:"code"`
	RedirectUri string `json:"redirect_uri"`
	State       string `json:"state"`

	// The time-to-live for the generated token in seconds.  The default
	// value is 3600 seconds (1 hour) maximum time allowed is 12 hours.
	TtlSeconds *int64 `json:"ttl_seconds,omitempty"`
}

// TagCreation defines model for TagCreation.
type TagCreation struct {
	Force *bool `json:"force,omitempty"`

	// ID of tag to create
	Id string `json:"id"`

	// the commit to tag
	Ref string `json:"ref"`
}

// TaskCreation defines model for TaskCreation.
type TaskCreation struct {

	// The id of the new task
	Id string `json:"id"`
}

// TaskInfo defines model for TaskInfo.
type TaskInfo struct {

	// ID of the task
	Id string `json:"id"`
}

// UIConfig defines model for UIConfig.
type UIConfig struct {
	CustomViewers *[]CustomViewer `json:"custom_viewers,omitempty"`
}

// UnderlyingObjectProperties defines model for UnderlyingObjectProperties.
type UnderlyingObjectProperties struct {
	StorageClass *string `json:"storage_class"`
}

// UpdateObjectUserMetadata defines model for UpdateObjectUserMetadata.
type UpdateObjectUserMetadata struct {
	Set ObjectUserMetadata `json:"set"`
}

// UploadPart defines model for UploadPart.
type UploadPart struct {
	Etag       string `json:"etag"`
	PartNumber int    `json:"part_number"`
}

// UploadPartCopyFrom defines model for UploadPartCopyFrom.
type UploadPartCopyFrom struct {
	// Embedded struct due to allOf(#/components/schemas/UploadPartFrom)
	UploadPartFrom `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	CopySource CopyPartSource `json:"copy_source"`
}

// UploadPartFrom defines model for UploadPartFrom.
type UploadPartFrom struct {

	// The physical address (of the entire intended object) returned from
	// createPresignMultipartUpload.
	PhysicalAddress string `json:"physical_address"`
}

// UploadTo defines model for UploadTo.
type UploadTo struct {
	PresignedUrl string `json:"presigned_url"`
}

// UsageReport defines model for UsageReport.
type UsageReport struct {
	Count int64 `json:"count"`
	Month int   `json:"month"`
	Year  int   `json:"year"`
}

// User defines model for User.
type User struct {

	// Unix Epoch in seconds
	CreationDate int64 `json:"creation_date"`

	// The email address of the user. If API authentication is enabled, this field is mandatory and will be invited to login.
	// If API authentication is disabled, this field will be ignored. All current APIAuthenticators require the email to be
	// lowercase and unique, although custom authenticators may not enforce this.
	Email *string `json:"email,omitempty"`

	// A shorter name for the user than the id. Unlike id it does not identify the user (it
	// might not be unique). Used in some places in the UI.
	FriendlyName *string `json:"friendly_name,omitempty"`

	// A unique identifier for the user. Cannot be edited.
	Id string `json:"id"`
}

// UserCreation defines model for UserCreation.
type UserCreation struct {

	// a unique identifier for the user.
	Id         string `json:"id"`
	InviteUser *bool  `json:"invite_user,omitempty"`
}

// UserList defines model for UserList.
type UserList struct {
	Pagination Pagination `json:"pagination"`
	Results    []User     `json:"results"`
}

// VersionConfig defines model for VersionConfig.
type VersionConfig struct {
	LatestVersion      *string `json:"latest_version,omitempty"`
	UpgradeRecommended *bool   `json:"upgrade_recommended,omitempty"`
	UpgradeUrl         *string `json:"upgrade_url,omitempty"`
	Version            *string `json:"version,omitempty"`
	VersionContext     *string `json:"version_context,omitempty"`
}

// IfMatch defines model for IfMatch.
type IfMatch string

// IfNoneMatch defines model for IfNoneMatch.
type IfNoneMatch string

// NoTombstone defines model for NoTombstone.
type NoTombstone bool

// PaginationAfter defines model for PaginationAfter.
type PaginationAfter string

// PaginationAmount defines model for PaginationAmount.
type PaginationAmount int

// PaginationDelimiter defines model for PaginationDelimiter.
type PaginationDelimiter string

// PaginationPrefix defines model for PaginationPrefix.
type PaginationPrefix string

// SearchString defines model for SearchString.
type SearchString string

// BadRequest defines model for BadRequest.
type BadRequest Error

// Conflict defines model for Conflict.
type Conflict Error

// Forbidden defines model for Forbidden.
type Forbidden Error

// NotFound defines model for NotFound.
type NotFound Error

// NotFoundOrNoACL defines model for NotFoundOrNoACL.
type NotFoundOrNoACL ErrorNoACL

// NotImplemented defines model for NotImplemented.
type NotImplemented Error

// PreconditionFailed defines model for PreconditionFailed.
type PreconditionFailed Error

// ServerError defines model for ServerError.
type ServerError Error

// Unauthorized defines model for Unauthorized.
type Unauthorized Error

// ValidationError defines model for ValidationError.
type ValidationError Error

// ExternalPrincipalLoginJSONBody defines parameters for ExternalPrincipalLogin.
type ExternalPrincipalLoginJSONBody ExternalLoginInformation

// GetExternalPrincipalParams defines parameters for GetExternalPrincipal.
type GetExternalPrincipalParams struct {
	PrincipalId string `json:"principalId"`
}

// ListGroupsParams defines parameters for ListGroups.
type ListGroupsParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// CreateGroupJSONBody defines parameters for CreateGroup.
type CreateGroupJSONBody GroupCreation

// SetGroupACLJSONBody defines parameters for SetGroupACL.
type SetGroupACLJSONBody ACL

// ListGroupMembersParams defines parameters for ListGroupMembers.
type ListGroupMembersParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// ListGroupPoliciesParams defines parameters for ListGroupPolicies.
type ListGroupPoliciesParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// LoginJSONBody defines parameters for Login.
type LoginJSONBody LoginInformation

// ListPoliciesParams defines parameters for ListPolicies.
type ListPoliciesParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// CreatePolicyJSONBody defines parameters for CreatePolicy.
type CreatePolicyJSONBody Policy

// UpdatePolicyJSONBody defines parameters for UpdatePolicy.
type UpdatePolicyJSONBody Policy

// ListUsersParams defines parameters for ListUsers.
type ListUsersParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// CreateUserJSONBody defines parameters for CreateUser.
type CreateUserJSONBody UserCreation

// ListUserCredentialsParams defines parameters for ListUserCredentials.
type ListUserCredentialsParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// DeleteUserExternalPrincipalParams defines parameters for DeleteUserExternalPrincipal.
type DeleteUserExternalPrincipalParams struct {
	PrincipalId string `json:"principalId"`
}

// CreateUserExternalPrincipalJSONBody defines parameters for CreateUserExternalPrincipal.
type CreateUserExternalPrincipalJSONBody ExternalPrincipalCreation

// CreateUserExternalPrincipalParams defines parameters for CreateUserExternalPrincipal.
type CreateUserExternalPrincipalParams struct {
	PrincipalId string `json:"principalId"`
}

// ListUserExternalPrincipalsParams defines parameters for ListUserExternalPrincipals.
type ListUserExternalPrincipalsParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// ListUserGroupsParams defines parameters for ListUserGroups.
type ListUserGroupsParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// ListUserPoliciesParams defines parameters for ListUserPolicies.
type ListUserPoliciesParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`

	// will return all distinct policies attached to the user or any of its groups
	Effective *bool `json:"effective,omitempty"`
}

// PullIcebergTableJSONBody defines parameters for PullIcebergTable.
type PullIcebergTableJSONBody IcebergPullRequest

// PushIcebergTableJSONBody defines parameters for PushIcebergTable.
type PushIcebergTableJSONBody IcebergPushRequest

// ListRepositoriesParams defines parameters for ListRepositories.
type ListRepositoriesParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`

	// string for searching relevant entries
	Search *SearchString `json:"search,omitempty"`
}

// CreateRepositoryJSONBody defines parameters for CreateRepository.
type CreateRepositoryJSONBody RepositoryCreation

// CreateRepositoryParams defines parameters for CreateRepository.
type CreateRepositoryParams struct {

	// If true, create a bare repository with no initial commit and branch
	Bare *bool `json:"bare,omitempty"`
}

// DeleteRepositoryParams defines parameters for DeleteRepository.
type DeleteRepositoryParams struct {

	// Bypass read-only protection and delete the repository
	Force *bool `json:"force,omitempty"`
}

// ListRepositoryRunsParams defines parameters for ListRepositoryRuns.
type ListRepositoryRunsParams struct {

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
	Branch *string           `json:"branch,omitempty"`
	Commit *string           `json:"commit,omitempty"`
}

// ListRunHooksParams defines parameters for ListRunHooks.
type ListRunHooksParams struct {

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// InternalDeleteBranchProtectionRuleJSONBody defines parameters for InternalDeleteBranchProtectionRule.
type InternalDeleteBranchProtectionRuleJSONBody struct {
	Pattern string `json:"pattern"`
}

// InternalCreateBranchProtectionRuleJSONBody defines parameters for InternalCreateBranchProtectionRule.
type InternalCreateBranchProtectionRuleJSONBody BranchProtectionRule

// ListBranchesParams defines parameters for ListBranches.
type ListBranchesParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount     *PaginationAmount `json:"amount,omitempty"`
	ShowHidden *bool             `json:"show_hidden,omitempty"`
}

// CreateBranchJSONBody defines parameters for CreateBranch.
type CreateBranchJSONBody BranchCreation

// DeleteBranchParams defines parameters for DeleteBranch.
type DeleteBranchParams struct {
	Force *bool `json:"force,omitempty"`
}

// ResetBranchJSONBody defines parameters for ResetBranch.
type ResetBranchJSONBody ResetCreation

// CherryPickJSONBody defines parameters for CherryPick.
type CherryPickJSONBody CherryPickCreation

// CommitJSONBody defines parameters for Commit.
type CommitJSONBody CommitCreation

// CommitParams defines parameters for Commit.
type CommitParams struct {

	// The source metarange to commit. Branch must not have uncommitted changes.
	SourceMetarange *string `json:"source_metarange,omitempty"`
}

// CommitAsyncJSONBody defines parameters for CommitAsync.
type CommitAsyncJSONBody CommitCreation

// CommitAsyncParams defines parameters for CommitAsync.
type CommitAsyncParams struct {

	// The source metarange to commit. Branch must not have uncommitted changes.
	SourceMetarange *string `json:"source_metarange,omitempty"`
}

// DiffBranchParams defines parameters for DiffBranch.
type DiffBranchParams struct {

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// delimiter used to group common prefixes by
	Delimiter *PaginationDelimiter `json:"delimiter,omitempty"`
}

// HardResetBranchParams defines parameters for HardResetBranch.
type HardResetBranchParams struct {

	// After reset, branch will point at this reference.
	Ref   string `json:"ref"`
	Force *bool  `json:"force,omitempty"`
}

// ImportCancelParams defines parameters for ImportCancel.
type ImportCancelParams struct {

	// Unique identifier of the import process
	Id string `json:"id"`
}

// ImportStatusParams defines parameters for ImportStatus.
type ImportStatusParams struct {

	// Unique identifier of the import process
	Id string `json:"id"`
}

// ImportStartJSONBody defines parameters for ImportStart.
type ImportStartJSONBody ImportCreation

// DeleteObjectParams defines parameters for DeleteObject.
type DeleteObjectParams struct {

	// relative to the branch
	Path  string `json:"path"`
	Force *bool  `json:"force,omitempty"`

	// delete entry without tombstone when possible *EXPERIMENTAL*
	NoTombstone *NoTombstone `json:"no_tombstone,omitempty"`
}

// UploadObjectParams defines parameters for UploadObject.
type UploadObjectParams struct {

	// relative to the branch
	Path string `json:"path"`

	// Deprecated, this capability will not be supported in future releases.
	StorageClass *string `json:"storageClass,omitempty"`
	Force        *bool   `json:"force,omitempty"`

	// Set to "*" to atomically allow the upload only if the key has no object yet. Other values are not supported.
	IfNoneMatch *IfNoneMatch `json:"If-None-Match,omitempty"`

	// Set to the object's ETag to atomically allow operations only if the object's current ETag matches the provided value.
	IfMatch *IfMatch `json:"If-Match,omitempty"`
}

// StageObjectJSONBody defines parameters for StageObject.
type StageObjectJSONBody ObjectStageCreation

// StageObjectParams defines parameters for StageObject.
type StageObjectParams struct {

	// relative to the branch
	Path string `json:"path"`
}

// CopyObjectJSONBody defines parameters for CopyObject.
type CopyObjectJSONBody ObjectCopyCreation

// CopyObjectParams defines parameters for CopyObject.
type CopyObjectParams struct {

	// destination path relative to the branch
	DestPath string `json:"dest_path"`
}

// DeleteObjectsJSONBody defines parameters for DeleteObjects.
type DeleteObjectsJSONBody PathList

// DeleteObjectsParams defines parameters for DeleteObjects.
type DeleteObjectsParams struct {
	Force *bool `json:"force,omitempty"`

	// delete entry without tombstone when possible *EXPERIMENTAL*
	NoTombstone *NoTombstone `json:"no_tombstone,omitempty"`
}

// UploadObjectPreflightParams defines parameters for UploadObjectPreflight.
type UploadObjectPreflightParams struct {

	// relative to the branch
	Path string `json:"path"`
}

// UpdateObjectUserMetadataJSONBody defines parameters for UpdateObjectUserMetadata.
type UpdateObjectUserMetadataJSONBody UpdateObjectUserMetadata

// UpdateObjectUserMetadataParams defines parameters for UpdateObjectUserMetadata.
type UpdateObjectUserMetadataParams struct {

	// path to object relative to the branch
	Path string `json:"path"`
}

// RevertBranchJSONBody defines parameters for RevertBranch.
type RevertBranchJSONBody RevertCreation

// GetPhysicalAddressParams defines parameters for GetPhysicalAddress.
type GetPhysicalAddressParams struct {

	// relative to the branch
	Path    string `json:"path"`
	Presign *bool  `json:"presign,omitempty"`
}

// LinkPhysicalAddressJSONBody defines parameters for LinkPhysicalAddress.
type LinkPhysicalAddressJSONBody StagingMetadata

// LinkPhysicalAddressParams defines parameters for LinkPhysicalAddress.
type LinkPhysicalAddressParams struct {

	// relative to the branch
	Path string `json:"path"`

	// Set to "*" to atomically allow the upload only if the key has no object yet. Other values are not supported.
	IfNoneMatch *IfNoneMatch `json:"If-None-Match,omitempty"`

	// Set to the object's ETag to atomically allow operations only if the object's current ETag matches the provided value.
	IfMatch *IfMatch `json:"If-Match,omitempty"`
}

// CreatePresignMultipartUploadParams defines parameters for CreatePresignMultipartUpload.
type CreatePresignMultipartUploadParams struct {

	// relative to the branch
	Path string `json:"path"`

	// number of presigned URL parts required to upload
	Parts *int `json:"parts,omitempty"`
}

// AbortPresignMultipartUploadJSONBody defines parameters for AbortPresignMultipartUpload.
type AbortPresignMultipartUploadJSONBody AbortPresignMultipartUpload

// AbortPresignMultipartUploadParams defines parameters for AbortPresignMultipartUpload.
type AbortPresignMultipartUploadParams struct {

	// relative to the branch
	Path string `json:"path"`
}

// CompletePresignMultipartUploadJSONBody defines parameters for CompletePresignMultipartUpload.
type CompletePresignMultipartUploadJSONBody CompletePresignMultipartUpload

// CompletePresignMultipartUploadParams defines parameters for CompletePresignMultipartUpload.
type CompletePresignMultipartUploadParams struct {

	// relative to the branch
	Path string `json:"path"`
}

// UploadPartJSONBody defines parameters for UploadPart.
type UploadPartJSONBody UploadPartFrom

// UploadPartParams defines parameters for UploadPart.
type UploadPartParams struct {
	Path string `json:"path"`
}

// UploadPartCopyJSONBody defines parameters for UploadPartCopy.
type UploadPartCopyJSONBody UploadPartCopyFrom

// UploadPartCopyParams defines parameters for UploadPartCopy.
type UploadPartCopyParams struct {
	Path string `json:"path"`
}

// CreateCommitRecordJSONBody defines parameters for CreateCommitRecord.
type CreateCommitRecordJSONBody CommitRecordCreation

// DumpStatusParams defines parameters for DumpStatus.
type DumpStatusParams struct {
	TaskId string `json:"task_id"`
}

// PrepareGarbageCollectionCommitsStatusParams defines parameters for PrepareGarbageCollectionCommitsStatus.
type PrepareGarbageCollectionCommitsStatusParams struct {

	// Unique identifier of the prepare GC commits task
	Id string `json:"id"`
}

// PrepareGarbageCollectionUncommittedJSONBody defines parameters for PrepareGarbageCollectionUncommitted.
type PrepareGarbageCollectionUncommittedJSONBody PrepareGCUncommittedRequest

// InternalSetGarbageCollectionRulesJSONBody defines parameters for InternalSetGarbageCollectionRules.
type InternalSetGarbageCollectionRulesJSONBody GarbageCollectionRules

// DeleteRepositoryMetadataJSONBody defines parameters for DeleteRepositoryMetadata.
type DeleteRepositoryMetadataJSONBody RepositoryMetadataKeys

// SetRepositoryMetadataJSONBody defines parameters for SetRepositoryMetadata.
type SetRepositoryMetadataJSONBody RepositoryMetadataSet

// GetMetadataObjectParams defines parameters for GetMetadataObject.
type GetMetadataObjectParams struct {
	Presign *bool `json:"presign,omitempty"`
}

// ListPullRequestsParams defines parameters for ListPullRequests.
type ListPullRequestsParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
	Status *string           `json:"status,omitempty"`
}

// CreatePullRequestJSONBody defines parameters for CreatePullRequest.
type CreatePullRequestJSONBody PullRequestCreation

// UpdatePullRequestJSONBody defines parameters for UpdatePullRequest.
type UpdatePullRequestJSONBody PullRequestBasic

// RestoreRefsJSONBody defines parameters for RestoreRefs.
type RestoreRefsJSONBody RefsRestore

// CreateSymlinkFileParams defines parameters for CreateSymlinkFile.
type CreateSymlinkFileParams struct {

	// path to the table data
	Location *string `json:"location,omitempty"`
}

// DiffRefsParams defines parameters for DiffRefs.
type DiffRefsParams struct {

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// delimiter used to group common prefixes by
	Delimiter *PaginationDelimiter `json:"delimiter,omitempty"`
	Type      *string              `json:"type,omitempty"`

	// If set to true, the diff will include right-side object stats. *EXPERIMENTAL*
	IncludeRightStats *bool `json:"include_right_stats,omitempty"`
}

// LogCommitsParams defines parameters for LogCommits.
type LogCommitsParams struct {

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`

	// list of paths, each element is a path of a specific object
	Objects *[]string `json:"objects,omitempty"`

	// list of paths, each element is a path of a prefix
	Prefixes *[]string `json:"prefixes,omitempty"`

	// limit the number of items in return to 'amount'. Without further indication on actual number of items.
	Limit *bool `json:"limit,omitempty"`

	// if set to true, follow only the first parent upon reaching a merge commit
	FirstParent *bool `json:"first_parent,omitempty"`

	// Show commits more recent than a specific date-time. In case used with stop_at parameter, will stop at the first commit that meets any of the conditions.
	Since *time.Time `json:"since,omitempty"`

	// A reference to stop at. In case used with since parameter, will stop at the first commit that meets any of the conditions.
	StopAt *string `json:"stop_at,omitempty"`
}

// GetObjectParams defines parameters for GetObject.
type GetObjectParams struct {

	// relative to the ref
	Path    string `json:"path"`
	Presign *bool  `json:"presign,omitempty"`

	// Byte range to retrieve
	Range *string `json:"Range,omitempty"`

	// Returns response only if the object does not have a matching ETag
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// HeadObjectParams defines parameters for HeadObject.
type HeadObjectParams struct {

	// relative to the ref
	Path string `json:"path"`

	// Byte range to retrieve
	Range *string `json:"Range,omitempty"`
}

// ListObjectsParams defines parameters for ListObjects.
type ListObjectsParams struct {
	UserMetadata *bool `json:"user_metadata,omitempty"`
	Presign      *bool `json:"presign,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`

	// delimiter used to group common prefixes by
	Delimiter *PaginationDelimiter `json:"delimiter,omitempty"`

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`
}

// StatObjectParams defines parameters for StatObject.
type StatObjectParams struct {

	// relative to the branch
	Path         string `json:"path"`
	UserMetadata *bool  `json:"user_metadata,omitempty"`
	Presign      *bool  `json:"presign,omitempty"`
}

// GetUnderlyingPropertiesParams defines parameters for GetUnderlyingProperties.
type GetUnderlyingPropertiesParams struct {

	// relative to the branch
	Path string `json:"path"`
}

// MergeIntoBranchJSONBody defines parameters for MergeIntoBranch.
type MergeIntoBranchJSONBody Merge

// MergeIntoBranchAsyncJSONBody defines parameters for MergeIntoBranchAsync.
type MergeIntoBranchAsyncJSONBody Merge

// RestoreStatusParams defines parameters for RestoreStatus.
type RestoreStatusParams struct {
	TaskId string `json:"task_id"`
}

// RestoreSubmitJSONBody defines parameters for RestoreSubmit.
type RestoreSubmitJSONBody RefsRestore

// SetBranchProtectionRulesJSONBody defines parameters for SetBranchProtectionRules.
type SetBranchProtectionRulesJSONBody []BranchProtectionRule

// SetBranchProtectionRulesParams defines parameters for SetBranchProtectionRules.
type SetBranchProtectionRulesParams struct {

	// if provided, the branch protection rules will be updated only if the current ETag match the provided value
	IfMatch *string `json:"If-Match,omitempty"`
}

// SetGCRulesJSONBody defines parameters for SetGCRules.
type SetGCRulesJSONBody GarbageCollectionRules

// ListTagsParams defines parameters for ListTags.
type ListTagsParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// CreateTagJSONBody defines parameters for CreateTag.
type CreateTagJSONBody TagCreation

// DeleteTagParams defines parameters for DeleteTag.
type DeleteTagParams struct {
	Force *bool `json:"force,omitempty"`
}

// SetupCommPrefsJSONBody defines parameters for SetupCommPrefs.
type SetupCommPrefsJSONBody CommPrefsInput

// SetupJSONBody defines parameters for Setup.
type SetupJSONBody Setup

// PostStatsEventsJSONBody defines parameters for PostStatsEvents.
type PostStatsEventsJSONBody StatsEventsList

// StsLoginJSONBody defines parameters for StsLogin.
type StsLoginJSONBody StsAuthRequest

// ExternalPrincipalLoginJSONRequestBody defines body for ExternalPrincipalLogin for application/json ContentType.
type ExternalPrincipalLoginJSONRequestBody ExternalPrincipalLoginJSONBody

// CreateGroupJSONRequestBody defines body for CreateGroup for application/json ContentType.
type CreateGroupJSONRequestBody CreateGroupJSONBody

// SetGroupACLJSONRequestBody defines body for SetGroupACL for application/json ContentType.
type SetGroupACLJSONRequestBody SetGroupACLJSONBody

// LoginJSONRequestBody defines body for Login for application/json ContentType.
type LoginJSONRequestBody LoginJSONBody

// CreatePolicyJSONRequestBody defines body for CreatePolicy for application/json ContentType.
type CreatePolicyJSONRequestBody CreatePolicyJSONBody

// UpdatePolicyJSONRequestBody defines body for UpdatePolicy for application/json ContentType.
type UpdatePolicyJSONRequestBody UpdatePolicyJSONBody

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody CreateUserJSONBody

// CreateUserExternalPrincipalJSONRequestBody defines body for CreateUserExternalPrincipal for application/json ContentType.
type CreateUserExternalPrincipalJSONRequestBody CreateUserExternalPrincipalJSONBody

// PullIcebergTableJSONRequestBody defines body for PullIcebergTable for application/json ContentType.
type PullIcebergTableJSONRequestBody PullIcebergTableJSONBody

// PushIcebergTableJSONRequestBody defines body for PushIcebergTable for application/json ContentType.
type PushIcebergTableJSONRequestBody PushIcebergTableJSONBody

// CreateRepositoryJSONRequestBody defines body for CreateRepository for application/json ContentType.
type CreateRepositoryJSONRequestBody CreateRepositoryJSONBody

// InternalDeleteBranchProtectionRuleJSONRequestBody defines body for InternalDeleteBranchProtectionRule for application/json ContentType.
type InternalDeleteBranchProtectionRuleJSONRequestBody InternalDeleteBranchProtectionRuleJSONBody

// InternalCreateBranchProtectionRuleJSONRequestBody defines body for InternalCreateBranchProtectionRule for application/json ContentType.
type InternalCreateBranchProtectionRuleJSONRequestBody InternalCreateBranchProtectionRuleJSONBody

// CreateBranchJSONRequestBody defines body for CreateBranch for application/json ContentType.
type CreateBranchJSONRequestBody CreateBranchJSONBody

// ResetBranchJSONRequestBody defines body for ResetBranch for application/json ContentType.
type ResetBranchJSONRequestBody ResetBranchJSONBody

// CherryPickJSONRequestBody defines body for CherryPick for application/json ContentType.
type CherryPickJSONRequestBody CherryPickJSONBody

// CommitJSONRequestBody defines body for Commit for application/json ContentType.
type CommitJSONRequestBody CommitJSONBody

// CommitAsyncJSONRequestBody defines body for CommitAsync for application/json ContentType.
type CommitAsyncJSONRequestBody CommitAsyncJSONBody

// ImportStartJSONRequestBody defines body for ImportStart for application/json ContentType.
type ImportStartJSONRequestBody ImportStartJSONBody

// StageObjectJSONRequestBody defines body for StageObject for application/json ContentType.
type StageObjectJSONRequestBody StageObjectJSONBody

// CopyObjectJSONRequestBody defines body for CopyObject for application/json ContentType.
type CopyObjectJSONRequestBody CopyObjectJSONBody

// DeleteObjectsJSONRequestBody defines body for DeleteObjects for application/json ContentType.
type DeleteObjectsJSONRequestBody DeleteObjectsJSONBody

// UpdateObjectUserMetadataJSONRequestBody defines body for UpdateObjectUserMetadata for application/json ContentType.
type UpdateObjectUserMetadataJSONRequestBody UpdateObjectUserMetadataJSONBody

// RevertBranchJSONRequestBody defines body for RevertBranch for application/json ContentType.
type RevertBranchJSONRequestBody RevertBranchJSONBody

// LinkPhysicalAddressJSONRequestBody defines body for LinkPhysicalAddress for application/json ContentType.
type LinkPhysicalAddressJSONRequestBody LinkPhysicalAddressJSONBody

// AbortPresignMultipartUploadJSONRequestBody defines body for AbortPresignMultipartUpload for application/json ContentType.
type AbortPresignMultipartUploadJSONRequestBody AbortPresignMultipartUploadJSONBody

// CompletePresignMultipartUploadJSONRequestBody defines body for CompletePresignMultipartUpload for application/json ContentType.
type CompletePresignMultipartUploadJSONRequestBody CompletePresignMultipartUploadJSONBody

// UploadPartJSONRequestBody defines body for UploadPart for application/json ContentType.
type UploadPartJSONRequestBody UploadPartJSONBody

// UploadPartCopyJSONRequestBody defines body for UploadPartCopy for application/json ContentType.
type UploadPartCopyJSONRequestBody UploadPartCopyJSONBody

// CreateCommitRecordJSONRequestBody defines body for CreateCommitRecord for application/json ContentType.
type CreateCommitRecordJSONRequestBody CreateCommitRecordJSONBody

// PrepareGarbageCollectionUncommittedJSONRequestBody defines body for PrepareGarbageCollectionUncommitted for application/json ContentType.
type PrepareGarbageCollectionUncommittedJSONRequestBody PrepareGarbageCollectionUncommittedJSONBody

// InternalSetGarbageCollectionRulesJSONRequestBody defines body for InternalSetGarbageCollectionRules for application/json ContentType.
type InternalSetGarbageCollectionRulesJSONRequestBody InternalSetGarbageCollectionRulesJSONBody

// DeleteRepositoryMetadataJSONRequestBody defines body for DeleteRepositoryMetadata for application/json ContentType.
type DeleteRepositoryMetadataJSONRequestBody DeleteRepositoryMetadataJSONBody

// SetRepositoryMetadataJSONRequestBody defines body for SetRepositoryMetadata for application/json ContentType.
type SetRepositoryMetadataJSONRequestBody SetRepositoryMetadataJSONBody

// CreatePullRequestJSONRequestBody defines body for CreatePullRequest for application/json ContentType.
type CreatePullRequestJSONRequestBody CreatePullRequestJSONBody

// UpdatePullRequestJSONRequestBody defines body for UpdatePullRequest for application/json ContentType.
type UpdatePullRequestJSONRequestBody UpdatePullRequestJSONBody

// RestoreRefsJSONRequestBody defines body for RestoreRefs for application/json ContentType.
type RestoreRefsJSONRequestBody RestoreRefsJSONBody

// MergeIntoBranchJSONRequestBody defines body for MergeIntoBranch for application/json ContentType.
type MergeIntoBranchJSONRequestBody MergeIntoBranchJSONBody

// MergeIntoBranchAsyncJSONRequestBody defines body for MergeIntoBranchAsync for application/json ContentType.
type MergeIntoBranchAsyncJSONRequestBody MergeIntoBranchAsyncJSONBody

// RestoreSubmitJSONRequestBody defines body for RestoreSubmit for application/json ContentType.
type RestoreSubmitJSONRequestBody RestoreSubmitJSONBody

// SetBranchProtectionRulesJSONRequestBody defines body for SetBranchProtectionRules for application/json ContentType.
type SetBranchProtectionRulesJSONRequestBody SetBranchProtectionRulesJSONBody

// SetGCRulesJSONRequestBody defines body for SetGCRules for application/json ContentType.
type SetGCRulesJSONRequestBody SetGCRulesJSONBody

// CreateTagJSONRequestBody defines body for CreateTag for application/json ContentType.
type CreateTagJSONRequestBody CreateTagJSONBody

// SetupCommPrefsJSONRequestBody defines body for SetupCommPrefs for application/json ContentType.
type SetupCommPrefsJSONRequestBody SetupCommPrefsJSONBody

// SetupJSONRequestBody defines body for Setup for application/json ContentType.
type SetupJSONRequestBody SetupJSONBody

// PostStatsEventsJSONRequestBody defines body for PostStatsEvents for application/json ContentType.
type PostStatsEventsJSONRequestBody PostStatsEventsJSONBody

// StsLoginJSONRequestBody defines body for StsLogin for application/json ContentType.
type StsLoginJSONRequestBody StsLoginJSONBody

// Getter for additional properties for Commit_Metadata. Returns the specified
// element and whether it was found
func (a Commit_Metadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Commit_Metadata
func (a *Commit_Metadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Commit_Metadata to handle AdditionalProperties
func (a *Commit_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Commit_Metadata to handle AdditionalProperties
func (a Commit_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CommitCreation_Metadata. Returns the specified
// element and whether it was found
func (a CommitCreation_Metadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CommitCreation_Metadata
func (a *CommitCreation_Metadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CommitCreation_Metadata to handle AdditionalProperties
func (a *CommitCreation_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CommitCreation_Metadata to handle AdditionalProperties
func (a CommitCreation_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CommitOverrides_Metadata. Returns the specified
// element and whether it was found
func (a CommitOverrides_Metadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CommitOverrides_Metadata
func (a *CommitOverrides_Metadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CommitOverrides_Metadata to handle AdditionalProperties
func (a *CommitOverrides_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CommitOverrides_Metadata to handle AdditionalProperties
func (a CommitOverrides_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CommitRecordCreation_Metadata. Returns the specified
// element and whether it was found
func (a CommitRecordCreation_Metadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CommitRecordCreation_Metadata
func (a *CommitRecordCreation_Metadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CommitRecordCreation_Metadata to handle AdditionalProperties
func (a *CommitRecordCreation_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CommitRecordCreation_Metadata to handle AdditionalProperties
func (a CommitRecordCreation_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CompletePresignMultipartUpload_UserMetadata. Returns the specified
// element and whether it was found
func (a CompletePresignMultipartUpload_UserMetadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CompletePresignMultipartUpload_UserMetadata
func (a *CompletePresignMultipartUpload_UserMetadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CompletePresignMultipartUpload_UserMetadata to handle AdditionalProperties
func (a *CompletePresignMultipartUpload_UserMetadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CompletePresignMultipartUpload_UserMetadata to handle AdditionalProperties
func (a CompletePresignMultipartUpload_UserMetadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ExternalPrincipalSettings. Returns the specified
// element and whether it was found
func (a ExternalPrincipalSettings) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ExternalPrincipalSettings
func (a *ExternalPrincipalSettings) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ExternalPrincipalSettings to handle AdditionalProperties
func (a *ExternalPrincipalSettings) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ExternalPrincipalSettings to handle AdditionalProperties
func (a ExternalPrincipalSettings) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Merge_Metadata. Returns the specified
// element and whether it was found
func (a Merge_Metadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Merge_Metadata
func (a *Merge_Metadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Merge_Metadata to handle AdditionalProperties
func (a *Merge_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Merge_Metadata to handle AdditionalProperties
func (a Merge_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ObjectUserMetadata. Returns the specified
// element and whether it was found
func (a ObjectUserMetadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ObjectUserMetadata
func (a *ObjectUserMetadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ObjectUserMetadata to handle AdditionalProperties
func (a *ObjectUserMetadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ObjectUserMetadata to handle AdditionalProperties
func (a ObjectUserMetadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PolicyCondition. Returns the specified
// element and whether it was found
func (a PolicyCondition) Get(fieldName string) (value []string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PolicyCondition
func (a *PolicyCondition) Set(fieldName string, value []string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string][]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PolicyCondition to handle AdditionalProperties
func (a *PolicyCondition) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string][]string)
		for fieldName, fieldBuf := range object {
			var fieldVal []string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PolicyCondition to handle AdditionalProperties
func (a PolicyCondition) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RepositoryMetadata. Returns the specified
// element and whether it was found
func (a RepositoryMetadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RepositoryMetadata
func (a *RepositoryMetadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RepositoryMetadata to handle AdditionalProperties
func (a *RepositoryMetadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RepositoryMetadata to handle AdditionalProperties
func (a RepositoryMetadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RepositoryMetadataSet_Metadata. Returns the specified
// element and whether it was found
func (a RepositoryMetadataSet_Metadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RepositoryMetadataSet_Metadata
func (a *RepositoryMetadataSet_Metadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RepositoryMetadataSet_Metadata to handle AdditionalProperties
func (a *RepositoryMetadataSet_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RepositoryMetadataSet_Metadata to handle AdditionalProperties
func (a RepositoryMetadataSet_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for StagingMetadata_UserMetadata. Returns the specified
// element and whether it was found
func (a StagingMetadata_UserMetadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for StagingMetadata_UserMetadata
func (a *StagingMetadata_UserMetadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for StagingMetadata_UserMetadata to handle AdditionalProperties
func (a *StagingMetadata_UserMetadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for StagingMetadata_UserMetadata to handle AdditionalProperties
func (a StagingMetadata_UserMetadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Statement_Condition. Returns the specified
// element and whether it was found
func (a Statement_Condition) Get(fieldName string) (value PolicyCondition, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Statement_Condition
func (a *Statement_Condition) Set(fieldName string, value PolicyCondition) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]PolicyCondition)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Statement_Condition to handle AdditionalProperties
func (a *Statement_Condition) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]PolicyCondition)
		for fieldName, fieldBuf := range object {
			var fieldVal PolicyCondition
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Statement_Condition to handle AdditionalProperties
func (a Statement_Condition) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = http.DefaultClient
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAuthCapabilities request
	GetAuthCapabilities(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExternalPrincipalLogin request  with any body
	ExternalPrincipalLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExternalPrincipalLogin(ctx context.Context, body ExternalPrincipalLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExternalPrincipal request
	GetExternalPrincipal(ctx context.Context, params *GetExternalPrincipalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTokenFromMailbox request
	GetTokenFromMailbox(ctx context.Context, mailbox string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReleaseTokenToMailbox request
	ReleaseTokenToMailbox(ctx context.Context, loginRequestToken string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTokenRedirect request
	GetTokenRedirect(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGroups request
	ListGroups(ctx context.Context, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGroup request  with any body
	CreateGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGroup(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroup request
	DeleteGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroup request
	GetGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupACL request
	GetGroupACL(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetGroupACL request  with any body
	SetGroupACLWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetGroupACL(ctx context.Context, groupId string, body SetGroupACLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGroupMembers request
	ListGroupMembers(ctx context.Context, groupId string, params *ListGroupMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroupMembership request
	DeleteGroupMembership(ctx context.Context, groupId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddGroupMembership request
	AddGroupMembership(ctx context.Context, groupId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGroupPolicies request
	ListGroupPolicies(ctx context.Context, groupId string, params *ListGroupPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DetachPolicyFromGroup request
	DetachPolicyFromGroup(ctx context.Context, groupId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachPolicyToGroup request
	AttachPolicyToGroup(ctx context.Context, groupId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Login request  with any body
	LoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Login(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPolicies request
	ListPolicies(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePolicy request  with any body
	CreatePolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePolicy(ctx context.Context, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePolicy request
	DeletePolicy(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPolicy request
	GetPolicy(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePolicy request  with any body
	UpdatePolicyWithBody(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePolicy(ctx context.Context, policyId string, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsers request
	ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUser request  with any body
	CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserCredentials request
	ListUserCredentials(ctx context.Context, userId string, params *ListUserCredentialsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCredentials request
	CreateCredentials(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCredentials request
	DeleteCredentials(ctx context.Context, userId string, accessKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCredentials request
	GetCredentials(ctx context.Context, userId string, accessKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserExternalPrincipal request
	DeleteUserExternalPrincipal(ctx context.Context, userId string, params *DeleteUserExternalPrincipalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserExternalPrincipal request  with any body
	CreateUserExternalPrincipalWithBody(ctx context.Context, userId string, params *CreateUserExternalPrincipalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUserExternalPrincipal(ctx context.Context, userId string, params *CreateUserExternalPrincipalParams, body CreateUserExternalPrincipalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserExternalPrincipals request
	ListUserExternalPrincipals(ctx context.Context, userId string, params *ListUserExternalPrincipalsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserGroups request
	ListUserGroups(ctx context.Context, userId string, params *ListUserGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserPolicies request
	ListUserPolicies(ctx context.Context, userId string, params *ListUserPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DetachPolicyFromUser request
	DetachPolicyFromUser(ctx context.Context, userId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachPolicyToUser request
	AttachPolicyToUser(ctx context.Context, userId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfig request
	GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGarbageCollectionConfig request
	GetGarbageCollectionConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStorageConfig request
	GetStorageConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLakeFSVersion request
	GetLakeFSVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HealthCheck request
	HealthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PullIcebergTable request  with any body
	PullIcebergTableWithBody(ctx context.Context, catalog string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PullIcebergTable(ctx context.Context, catalog string, body PullIcebergTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PushIcebergTable request  with any body
	PushIcebergTableWithBody(ctx context.Context, catalog string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PushIcebergTable(ctx context.Context, catalog string, body PushIcebergTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLicense request
	GetLicense(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthCallback request
	OauthCallback(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRepositories request
	ListRepositories(ctx context.Context, params *ListRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRepository request  with any body
	CreateRepositoryWithBody(ctx context.Context, params *CreateRepositoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRepository(ctx context.Context, params *CreateRepositoryParams, body CreateRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRepository request
	DeleteRepository(ctx context.Context, repository string, params *DeleteRepositoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRepository request
	GetRepository(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRepositoryRuns request
	ListRepositoryRuns(ctx context.Context, repository string, params *ListRepositoryRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRun request
	GetRun(ctx context.Context, repository string, runId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRunHooks request
	ListRunHooks(ctx context.Context, repository string, runId string, params *ListRunHooksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRunHookOutput request
	GetRunHookOutput(ctx context.Context, repository string, runId string, hookRunId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalDeleteBranchProtectionRule request  with any body
	InternalDeleteBranchProtectionRuleWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InternalDeleteBranchProtectionRule(ctx context.Context, repository string, body InternalDeleteBranchProtectionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalGetBranchProtectionRules request
	InternalGetBranchProtectionRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalCreateBranchProtectionRule request  with any body
	InternalCreateBranchProtectionRuleWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InternalCreateBranchProtectionRule(ctx context.Context, repository string, body InternalCreateBranchProtectionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBranchProtectionRulePreflight request
	CreateBranchProtectionRulePreflight(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBranches request
	ListBranches(ctx context.Context, repository string, params *ListBranchesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBranch request  with any body
	CreateBranchWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBranch(ctx context.Context, repository string, body CreateBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBranch request
	DeleteBranch(ctx context.Context, repository string, branch string, params *DeleteBranchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBranch request
	GetBranch(ctx context.Context, repository string, branch string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetBranch request  with any body
	ResetBranchWithBody(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResetBranch(ctx context.Context, repository string, branch string, body ResetBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CherryPick request  with any body
	CherryPickWithBody(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CherryPick(ctx context.Context, repository string, branch string, body CherryPickJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Commit request  with any body
	CommitWithBody(ctx context.Context, repository string, branch string, params *CommitParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Commit(ctx context.Context, repository string, branch string, params *CommitParams, body CommitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommitAsync request  with any body
	CommitAsyncWithBody(ctx context.Context, repository string, branch string, params *CommitAsyncParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CommitAsync(ctx context.Context, repository string, branch string, params *CommitAsyncParams, body CommitAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommitAsyncStatus request
	CommitAsyncStatus(ctx context.Context, repository string, branch string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DiffBranch request
	DiffBranch(ctx context.Context, repository string, branch string, params *DiffBranchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HardResetBranch request
	HardResetBranch(ctx context.Context, repository string, branch string, params *HardResetBranchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportCancel request
	ImportCancel(ctx context.Context, repository string, branch string, params *ImportCancelParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportStatus request
	ImportStatus(ctx context.Context, repository string, branch string, params *ImportStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportStart request  with any body
	ImportStartWithBody(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ImportStart(ctx context.Context, repository string, branch string, body ImportStartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteObject request
	DeleteObject(ctx context.Context, repository string, branch string, params *DeleteObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadObject request  with any body
	UploadObjectWithBody(ctx context.Context, repository string, branch string, params *UploadObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StageObject request  with any body
	StageObjectWithBody(ctx context.Context, repository string, branch string, params *StageObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StageObject(ctx context.Context, repository string, branch string, params *StageObjectParams, body StageObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CopyObject request  with any body
	CopyObjectWithBody(ctx context.Context, repository string, branch string, params *CopyObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CopyObject(ctx context.Context, repository string, branch string, params *CopyObjectParams, body CopyObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteObjects request  with any body
	DeleteObjectsWithBody(ctx context.Context, repository string, branch string, params *DeleteObjectsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteObjects(ctx context.Context, repository string, branch string, params *DeleteObjectsParams, body DeleteObjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadObjectPreflight request
	UploadObjectPreflight(ctx context.Context, repository string, branch string, params *UploadObjectPreflightParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateObjectUserMetadata request  with any body
	UpdateObjectUserMetadataWithBody(ctx context.Context, repository string, branch string, params *UpdateObjectUserMetadataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateObjectUserMetadata(ctx context.Context, repository string, branch string, params *UpdateObjectUserMetadataParams, body UpdateObjectUserMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevertBranch request  with any body
	RevertBranchWithBody(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevertBranch(ctx context.Context, repository string, branch string, body RevertBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPhysicalAddress request
	GetPhysicalAddress(ctx context.Context, repository string, branch string, params *GetPhysicalAddressParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkPhysicalAddress request  with any body
	LinkPhysicalAddressWithBody(ctx context.Context, repository string, branch string, params *LinkPhysicalAddressParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkPhysicalAddress(ctx context.Context, repository string, branch string, params *LinkPhysicalAddressParams, body LinkPhysicalAddressJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePresignMultipartUpload request
	CreatePresignMultipartUpload(ctx context.Context, repository string, branch string, params *CreatePresignMultipartUploadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AbortPresignMultipartUpload request  with any body
	AbortPresignMultipartUploadWithBody(ctx context.Context, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AbortPresignMultipartUpload(ctx context.Context, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, body AbortPresignMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CompletePresignMultipartUpload request  with any body
	CompletePresignMultipartUploadWithBody(ctx context.Context, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CompletePresignMultipartUpload(ctx context.Context, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, body CompletePresignMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadPart request  with any body
	UploadPartWithBody(ctx context.Context, repository string, branch string, uploadId string, partNumber int, params *UploadPartParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UploadPart(ctx context.Context, repository string, branch string, uploadId string, partNumber int, params *UploadPartParams, body UploadPartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadPartCopy request  with any body
	UploadPartCopyWithBody(ctx context.Context, repository string, branch string, uploadId string, partNumber int, params *UploadPartCopyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UploadPartCopy(ctx context.Context, repository string, branch string, uploadId string, partNumber int, params *UploadPartCopyParams, body UploadPartCopyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCommitRecord request  with any body
	CreateCommitRecordWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCommitRecord(ctx context.Context, repository string, body CreateCommitRecordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCommit request
	GetCommit(ctx context.Context, repository string, commitId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DumpStatus request
	DumpStatus(ctx context.Context, repository string, params *DumpStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DumpSubmit request
	DumpSubmit(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PrepareGarbageCollectionCommits request
	PrepareGarbageCollectionCommits(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PrepareGarbageCollectionCommitsAsync request
	PrepareGarbageCollectionCommitsAsync(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PrepareGarbageCollectionCommitsStatus request
	PrepareGarbageCollectionCommitsStatus(ctx context.Context, repository string, params *PrepareGarbageCollectionCommitsStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PrepareGarbageCollectionUncommitted request  with any body
	PrepareGarbageCollectionUncommittedWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PrepareGarbageCollectionUncommitted(ctx context.Context, repository string, body PrepareGarbageCollectionUncommittedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalDeleteGarbageCollectionRules request
	InternalDeleteGarbageCollectionRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalGetGarbageCollectionRules request
	InternalGetGarbageCollectionRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalSetGarbageCollectionRules request  with any body
	InternalSetGarbageCollectionRulesWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InternalSetGarbageCollectionRules(ctx context.Context, repository string, body InternalSetGarbageCollectionRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetGarbageCollectionRulesPreflight request
	SetGarbageCollectionRulesPreflight(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRepositoryMetadata request  with any body
	DeleteRepositoryMetadataWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteRepositoryMetadata(ctx context.Context, repository string, body DeleteRepositoryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRepositoryMetadata request
	GetRepositoryMetadata(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetRepositoryMetadata request  with any body
	SetRepositoryMetadataWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetRepositoryMetadata(ctx context.Context, repository string, body SetRepositoryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMetaRange request
	GetMetaRange(ctx context.Context, repository string, metaRange string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMetadataObject request
	GetMetadataObject(ctx context.Context, repository string, pType string, objectId string, params *GetMetadataObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRange request
	GetRange(ctx context.Context, repository string, pRange string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPullRequests request
	ListPullRequests(ctx context.Context, repository string, params *ListPullRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePullRequest request  with any body
	CreatePullRequestWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePullRequest(ctx context.Context, repository string, body CreatePullRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPullRequest request
	GetPullRequest(ctx context.Context, repository string, pullRequest string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePullRequest request  with any body
	UpdatePullRequestWithBody(ctx context.Context, repository string, pullRequest string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePullRequest(ctx context.Context, repository string, pullRequest string, body UpdatePullRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MergePullRequest request
	MergePullRequest(ctx context.Context, repository string, pullRequest string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DumpRefs request
	DumpRefs(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestoreRefs request  with any body
	RestoreRefsWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RestoreRefs(ctx context.Context, repository string, body RestoreRefsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSymlinkFile request
	CreateSymlinkFile(ctx context.Context, repository string, branch string, params *CreateSymlinkFileParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DiffRefs request
	DiffRefs(ctx context.Context, repository string, leftRef string, rightRef string, params *DiffRefsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LogCommits request
	LogCommits(ctx context.Context, repository string, ref string, params *LogCommitsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetObject request
	GetObject(ctx context.Context, repository string, ref string, params *GetObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HeadObject request
	HeadObject(ctx context.Context, repository string, ref string, params *HeadObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListObjects request
	ListObjects(ctx context.Context, repository string, ref string, params *ListObjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StatObject request
	StatObject(ctx context.Context, repository string, ref string, params *StatObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUnderlyingProperties request
	GetUnderlyingProperties(ctx context.Context, repository string, ref string, params *GetUnderlyingPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindMergeBase request
	FindMergeBase(ctx context.Context, repository string, sourceRef string, destinationBranch string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MergeIntoBranch request  with any body
	MergeIntoBranchWithBody(ctx context.Context, repository string, sourceRef string, destinationBranch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MergeIntoBranch(ctx context.Context, repository string, sourceRef string, destinationBranch string, body MergeIntoBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MergeIntoBranchAsync request  with any body
	MergeIntoBranchAsyncWithBody(ctx context.Context, repository string, sourceRef string, destinationBranch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MergeIntoBranchAsync(ctx context.Context, repository string, sourceRef string, destinationBranch string, body MergeIntoBranchAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MergeIntoBranchAsyncStatus request
	MergeIntoBranchAsyncStatus(ctx context.Context, repository string, sourceRef string, destinationBranch string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestoreStatus request
	RestoreStatus(ctx context.Context, repository string, params *RestoreStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestoreSubmit request  with any body
	RestoreSubmitWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RestoreSubmit(ctx context.Context, repository string, body RestoreSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBranchProtectionRules request
	GetBranchProtectionRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetBranchProtectionRules request  with any body
	SetBranchProtectionRulesWithBody(ctx context.Context, repository string, params *SetBranchProtectionRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetBranchProtectionRules(ctx context.Context, repository string, params *SetBranchProtectionRulesParams, body SetBranchProtectionRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGCRules request
	DeleteGCRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGCRules request
	GetGCRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetGCRules request  with any body
	SetGCRulesWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetGCRules(ctx context.Context, repository string, body SetGCRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTags request
	ListTags(ctx context.Context, repository string, params *ListTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTag request  with any body
	CreateTagWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTag(ctx context.Context, repository string, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTag request
	DeleteTag(ctx context.Context, repository string, tag string, params *DeleteTagParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTag request
	GetTag(ctx context.Context, repository string, tag string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetupCommPrefs request  with any body
	SetupCommPrefsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetupCommPrefs(ctx context.Context, body SetupCommPrefsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSetupState request
	GetSetupState(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Setup request  with any body
	SetupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Setup(ctx context.Context, body SetupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostStatsEvents request  with any body
	PostStatsEventsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostStatsEvents(ctx context.Context, body PostStatsEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StsLogin request  with any body
	StsLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StsLogin(ctx context.Context, body StsLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsageReportSummary request
	GetUsageReportSummary(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentUser request
	GetCurrentUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAuthCapabilities(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthCapabilitiesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExternalPrincipalLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExternalPrincipalLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExternalPrincipalLogin(ctx context.Context, body ExternalPrincipalLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExternalPrincipalLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExternalPrincipal(ctx context.Context, params *GetExternalPrincipalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExternalPrincipalRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTokenFromMailbox(ctx context.Context, mailbox string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTokenFromMailboxRequest(c.Server, mailbox)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReleaseTokenToMailbox(ctx context.Context, loginRequestToken string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReleaseTokenToMailboxRequest(c.Server, loginRequestToken)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTokenRedirect(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTokenRedirectRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGroups(ctx context.Context, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroup(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupACL(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupACLRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetGroupACLWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetGroupACLRequestWithBody(c.Server, groupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetGroupACL(ctx context.Context, groupId string, body SetGroupACLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetGroupACLRequest(c.Server, groupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGroupMembers(ctx context.Context, groupId string, params *ListGroupMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGroupMembersRequest(c.Server, groupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroupMembership(ctx context.Context, groupId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupMembershipRequest(c.Server, groupId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddGroupMembership(ctx context.Context, groupId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddGroupMembershipRequest(c.Server, groupId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGroupPolicies(ctx context.Context, groupId string, params *ListGroupPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGroupPoliciesRequest(c.Server, groupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DetachPolicyFromGroup(ctx context.Context, groupId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDetachPolicyFromGroupRequest(c.Server, groupId, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachPolicyToGroup(ctx context.Context, groupId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachPolicyToGroupRequest(c.Server, groupId, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Login(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPolicies(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePolicyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePolicy(ctx context.Context, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePolicyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePolicy(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePolicyRequest(c.Server, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPolicy(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPolicyRequest(c.Server, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePolicyWithBody(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePolicyRequestWithBody(c.Server, policyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePolicy(ctx context.Context, policyId string, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePolicyRequest(c.Server, policyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserCredentials(ctx context.Context, userId string, params *ListUserCredentialsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserCredentialsRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCredentials(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCredentialsRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCredentials(ctx context.Context, userId string, accessKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCredentialsRequest(c.Server, userId, accessKeyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCredentials(ctx context.Context, userId string, accessKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCredentialsRequest(c.Server, userId, accessKeyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserExternalPrincipal(ctx context.Context, userId string, params *DeleteUserExternalPrincipalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserExternalPrincipalRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserExternalPrincipalWithBody(ctx context.Context, userId string, params *CreateUserExternalPrincipalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserExternalPrincipalRequestWithBody(c.Server, userId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserExternalPrincipal(ctx context.Context, userId string, params *CreateUserExternalPrincipalParams, body CreateUserExternalPrincipalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserExternalPrincipalRequest(c.Server, userId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserExternalPrincipals(ctx context.Context, userId string, params *ListUserExternalPrincipalsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserExternalPrincipalsRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserGroups(ctx context.Context, userId string, params *ListUserGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserGroupsRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserPolicies(ctx context.Context, userId string, params *ListUserPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserPoliciesRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DetachPolicyFromUser(ctx context.Context, userId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDetachPolicyFromUserRequest(c.Server, userId, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachPolicyToUser(ctx context.Context, userId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachPolicyToUserRequest(c.Server, userId, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGarbageCollectionConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGarbageCollectionConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStorageConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStorageConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLakeFSVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLakeFSVersionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HealthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthCheckRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullIcebergTableWithBody(ctx context.Context, catalog string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullIcebergTableRequestWithBody(c.Server, catalog, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullIcebergTable(ctx context.Context, catalog string, body PullIcebergTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullIcebergTableRequest(c.Server, catalog, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PushIcebergTableWithBody(ctx context.Context, catalog string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPushIcebergTableRequestWithBody(c.Server, catalog, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PushIcebergTable(ctx context.Context, catalog string, body PushIcebergTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPushIcebergTableRequest(c.Server, catalog, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLicense(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLicenseRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthCallback(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthCallbackRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRepositories(ctx context.Context, params *ListRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRepositoriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRepositoryWithBody(ctx context.Context, params *CreateRepositoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRepositoryRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRepository(ctx context.Context, params *CreateRepositoryParams, body CreateRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRepositoryRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRepository(ctx context.Context, repository string, params *DeleteRepositoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRepositoryRequest(c.Server, repository, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRepository(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRepositoryRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRepositoryRuns(ctx context.Context, repository string, params *ListRepositoryRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRepositoryRunsRequest(c.Server, repository, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRun(ctx context.Context, repository string, runId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRunRequest(c.Server, repository, runId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRunHooks(ctx context.Context, repository string, runId string, params *ListRunHooksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRunHooksRequest(c.Server, repository, runId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRunHookOutput(ctx context.Context, repository string, runId string, hookRunId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRunHookOutputRequest(c.Server, repository, runId, hookRunId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalDeleteBranchProtectionRuleWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalDeleteBranchProtectionRuleRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalDeleteBranchProtectionRule(ctx context.Context, repository string, body InternalDeleteBranchProtectionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalDeleteBranchProtectionRuleRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalGetBranchProtectionRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalGetBranchProtectionRulesRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalCreateBranchProtectionRuleWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalCreateBranchProtectionRuleRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalCreateBranchProtectionRule(ctx context.Context, repository string, body InternalCreateBranchProtectionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalCreateBranchProtectionRuleRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBranchProtectionRulePreflight(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBranchProtectionRulePreflightRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBranches(ctx context.Context, repository string, params *ListBranchesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBranchesRequest(c.Server, repository, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBranchWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBranchRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBranch(ctx context.Context, repository string, body CreateBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBranchRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBranch(ctx context.Context, repository string, branch string, params *DeleteBranchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBranchRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBranch(ctx context.Context, repository string, branch string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBranchRequest(c.Server, repository, branch)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetBranchWithBody(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetBranchRequestWithBody(c.Server, repository, branch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetBranch(ctx context.Context, repository string, branch string, body ResetBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetBranchRequest(c.Server, repository, branch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CherryPickWithBody(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCherryPickRequestWithBody(c.Server, repository, branch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CherryPick(ctx context.Context, repository string, branch string, body CherryPickJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCherryPickRequest(c.Server, repository, branch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitWithBody(ctx context.Context, repository string, branch string, params *CommitParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitRequestWithBody(c.Server, repository, branch, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Commit(ctx context.Context, repository string, branch string, params *CommitParams, body CommitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitRequest(c.Server, repository, branch, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitAsyncWithBody(ctx context.Context, repository string, branch string, params *CommitAsyncParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitAsyncRequestWithBody(c.Server, repository, branch, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitAsync(ctx context.Context, repository string, branch string, params *CommitAsyncParams, body CommitAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitAsyncRequest(c.Server, repository, branch, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitAsyncStatus(ctx context.Context, repository string, branch string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitAsyncStatusRequest(c.Server, repository, branch, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DiffBranch(ctx context.Context, repository string, branch string, params *DiffBranchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDiffBranchRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HardResetBranch(ctx context.Context, repository string, branch string, params *HardResetBranchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHardResetBranchRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportCancel(ctx context.Context, repository string, branch string, params *ImportCancelParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportCancelRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportStatus(ctx context.Context, repository string, branch string, params *ImportStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportStatusRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportStartWithBody(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportStartRequestWithBody(c.Server, repository, branch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportStart(ctx context.Context, repository string, branch string, body ImportStartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportStartRequest(c.Server, repository, branch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteObject(ctx context.Context, repository string, branch string, params *DeleteObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteObjectRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadObjectWithBody(ctx context.Context, repository string, branch string, params *UploadObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadObjectRequestWithBody(c.Server, repository, branch, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StageObjectWithBody(ctx context.Context, repository string, branch string, params *StageObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStageObjectRequestWithBody(c.Server, repository, branch, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StageObject(ctx context.Context, repository string, branch string, params *StageObjectParams, body StageObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStageObjectRequest(c.Server, repository, branch, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CopyObjectWithBody(ctx context.Context, repository string, branch string, params *CopyObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCopyObjectRequestWithBody(c.Server, repository, branch, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CopyObject(ctx context.Context, repository string, branch string, params *CopyObjectParams, body CopyObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCopyObjectRequest(c.Server, repository, branch, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteObjectsWithBody(ctx context.Context, repository string, branch string, params *DeleteObjectsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteObjectsRequestWithBody(c.Server, repository, branch, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteObjects(ctx context.Context, repository string, branch string, params *DeleteObjectsParams, body DeleteObjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteObjectsRequest(c.Server, repository, branch, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadObjectPreflight(ctx context.Context, repository string, branch string, params *UploadObjectPreflightParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadObjectPreflightRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateObjectUserMetadataWithBody(ctx context.Context, repository string, branch string, params *UpdateObjectUserMetadataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateObjectUserMetadataRequestWithBody(c.Server, repository, branch, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateObjectUserMetadata(ctx context.Context, repository string, branch string, params *UpdateObjectUserMetadataParams, body UpdateObjectUserMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateObjectUserMetadataRequest(c.Server, repository, branch, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevertBranchWithBody(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevertBranchRequestWithBody(c.Server, repository, branch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevertBranch(ctx context.Context, repository string, branch string, body RevertBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevertBranchRequest(c.Server, repository, branch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPhysicalAddress(ctx context.Context, repository string, branch string, params *GetPhysicalAddressParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPhysicalAddressRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkPhysicalAddressWithBody(ctx context.Context, repository string, branch string, params *LinkPhysicalAddressParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkPhysicalAddressRequestWithBody(c.Server, repository, branch, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkPhysicalAddress(ctx context.Context, repository string, branch string, params *LinkPhysicalAddressParams, body LinkPhysicalAddressJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkPhysicalAddressRequest(c.Server, repository, branch, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePresignMultipartUpload(ctx context.Context, repository string, branch string, params *CreatePresignMultipartUploadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePresignMultipartUploadRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AbortPresignMultipartUploadWithBody(ctx context.Context, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAbortPresignMultipartUploadRequestWithBody(c.Server, repository, branch, uploadId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AbortPresignMultipartUpload(ctx context.Context, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, body AbortPresignMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAbortPresignMultipartUploadRequest(c.Server, repository, branch, uploadId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompletePresignMultipartUploadWithBody(ctx context.Context, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompletePresignMultipartUploadRequestWithBody(c.Server, repository, branch, uploadId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompletePresignMultipartUpload(ctx context.Context, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, body CompletePresignMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompletePresignMultipartUploadRequest(c.Server, repository, branch, uploadId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadPartWithBody(ctx context.Context, repository string, branch string, uploadId string, partNumber int, params *UploadPartParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadPartRequestWithBody(c.Server, repository, branch, uploadId, partNumber, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadPart(ctx context.Context, repository string, branch string, uploadId string, partNumber int, params *UploadPartParams, body UploadPartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadPartRequest(c.Server, repository, branch, uploadId, partNumber, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadPartCopyWithBody(ctx context.Context, repository string, branch string, uploadId string, partNumber int, params *UploadPartCopyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadPartCopyRequestWithBody(c.Server, repository, branch, uploadId, partNumber, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadPartCopy(ctx context.Context, repository string, branch string, uploadId string, partNumber int, params *UploadPartCopyParams, body UploadPartCopyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadPartCopyRequest(c.Server, repository, branch, uploadId, partNumber, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCommitRecordWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCommitRecordRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCommitRecord(ctx context.Context, repository string, body CreateCommitRecordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCommitRecordRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCommit(ctx context.Context, repository string, commitId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCommitRequest(c.Server, repository, commitId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DumpStatus(ctx context.Context, repository string, params *DumpStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDumpStatusRequest(c.Server, repository, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DumpSubmit(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDumpSubmitRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrepareGarbageCollectionCommits(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareGarbageCollectionCommitsRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrepareGarbageCollectionCommitsAsync(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareGarbageCollectionCommitsAsyncRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrepareGarbageCollectionCommitsStatus(ctx context.Context, repository string, params *PrepareGarbageCollectionCommitsStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareGarbageCollectionCommitsStatusRequest(c.Server, repository, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrepareGarbageCollectionUncommittedWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareGarbageCollectionUncommittedRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrepareGarbageCollectionUncommitted(ctx context.Context, repository string, body PrepareGarbageCollectionUncommittedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareGarbageCollectionUncommittedRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalDeleteGarbageCollectionRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalDeleteGarbageCollectionRulesRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalGetGarbageCollectionRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalGetGarbageCollectionRulesRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalSetGarbageCollectionRulesWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalSetGarbageCollectionRulesRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalSetGarbageCollectionRules(ctx context.Context, repository string, body InternalSetGarbageCollectionRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalSetGarbageCollectionRulesRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetGarbageCollectionRulesPreflight(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetGarbageCollectionRulesPreflightRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRepositoryMetadataWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRepositoryMetadataRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRepositoryMetadata(ctx context.Context, repository string, body DeleteRepositoryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRepositoryMetadataRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRepositoryMetadata(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRepositoryMetadataRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRepositoryMetadataWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRepositoryMetadataRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRepositoryMetadata(ctx context.Context, repository string, body SetRepositoryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRepositoryMetadataRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMetaRange(ctx context.Context, repository string, metaRange string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMetaRangeRequest(c.Server, repository, metaRange)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMetadataObject(ctx context.Context, repository string, pType string, objectId string, params *GetMetadataObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMetadataObjectRequest(c.Server, repository, pType, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRange(ctx context.Context, repository string, pRange string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRangeRequest(c.Server, repository, pRange)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPullRequests(ctx context.Context, repository string, params *ListPullRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPullRequestsRequest(c.Server, repository, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePullRequestWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePullRequestRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePullRequest(ctx context.Context, repository string, body CreatePullRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePullRequestRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPullRequest(ctx context.Context, repository string, pullRequest string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPullRequestRequest(c.Server, repository, pullRequest)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePullRequestWithBody(ctx context.Context, repository string, pullRequest string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePullRequestRequestWithBody(c.Server, repository, pullRequest, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePullRequest(ctx context.Context, repository string, pullRequest string, body UpdatePullRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePullRequestRequest(c.Server, repository, pullRequest, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergePullRequest(ctx context.Context, repository string, pullRequest string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergePullRequestRequest(c.Server, repository, pullRequest)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DumpRefs(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDumpRefsRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreRefsWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreRefsRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreRefs(ctx context.Context, repository string, body RestoreRefsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreRefsRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSymlinkFile(ctx context.Context, repository string, branch string, params *CreateSymlinkFileParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSymlinkFileRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DiffRefs(ctx context.Context, repository string, leftRef string, rightRef string, params *DiffRefsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDiffRefsRequest(c.Server, repository, leftRef, rightRef, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogCommits(ctx context.Context, repository string, ref string, params *LogCommitsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogCommitsRequest(c.Server, repository, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetObject(ctx context.Context, repository string, ref string, params *GetObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetObjectRequest(c.Server, repository, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeadObject(ctx context.Context, repository string, ref string, params *HeadObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeadObjectRequest(c.Server, repository, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListObjects(ctx context.Context, repository string, ref string, params *ListObjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListObjectsRequest(c.Server, repository, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StatObject(ctx context.Context, repository string, ref string, params *StatObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatObjectRequest(c.Server, repository, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUnderlyingProperties(ctx context.Context, repository string, ref string, params *GetUnderlyingPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUnderlyingPropertiesRequest(c.Server, repository, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindMergeBase(ctx context.Context, repository string, sourceRef string, destinationBranch string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindMergeBaseRequest(c.Server, repository, sourceRef, destinationBranch)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeIntoBranchWithBody(ctx context.Context, repository string, sourceRef string, destinationBranch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeIntoBranchRequestWithBody(c.Server, repository, sourceRef, destinationBranch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeIntoBranch(ctx context.Context, repository string, sourceRef string, destinationBranch string, body MergeIntoBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeIntoBranchRequest(c.Server, repository, sourceRef, destinationBranch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeIntoBranchAsyncWithBody(ctx context.Context, repository string, sourceRef string, destinationBranch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeIntoBranchAsyncRequestWithBody(c.Server, repository, sourceRef, destinationBranch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeIntoBranchAsync(ctx context.Context, repository string, sourceRef string, destinationBranch string, body MergeIntoBranchAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeIntoBranchAsyncRequest(c.Server, repository, sourceRef, destinationBranch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeIntoBranchAsyncStatus(ctx context.Context, repository string, sourceRef string, destinationBranch string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeIntoBranchAsyncStatusRequest(c.Server, repository, sourceRef, destinationBranch, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreStatus(ctx context.Context, repository string, params *RestoreStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreStatusRequest(c.Server, repository, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreSubmitWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreSubmitRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreSubmit(ctx context.Context, repository string, body RestoreSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreSubmitRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBranchProtectionRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBranchProtectionRulesRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetBranchProtectionRulesWithBody(ctx context.Context, repository string, params *SetBranchProtectionRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetBranchProtectionRulesRequestWithBody(c.Server, repository, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetBranchProtectionRules(ctx context.Context, repository string, params *SetBranchProtectionRulesParams, body SetBranchProtectionRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetBranchProtectionRulesRequest(c.Server, repository, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGCRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGCRulesRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGCRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGCRulesRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetGCRulesWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetGCRulesRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetGCRules(ctx context.Context, repository string, body SetGCRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetGCRulesRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTags(ctx context.Context, repository string, params *ListTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTagsRequest(c.Server, repository, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTagWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTagRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTag(ctx context.Context, repository string, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTagRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTag(ctx context.Context, repository string, tag string, params *DeleteTagParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTagRequest(c.Server, repository, tag, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTag(ctx context.Context, repository string, tag string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTagRequest(c.Server, repository, tag)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetupCommPrefsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetupCommPrefsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetupCommPrefs(ctx context.Context, body SetupCommPrefsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetupCommPrefsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSetupState(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSetupStateRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Setup(ctx context.Context, body SetupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStatsEventsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStatsEventsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStatsEvents(ctx context.Context, body PostStatsEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStatsEventsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StsLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStsLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StsLogin(ctx context.Context, body StsLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStsLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsageReportSummary(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsageReportSummaryRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAuthCapabilitiesRequest generates requests for GetAuthCapabilities
func NewGetAuthCapabilitiesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/capabilities")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExternalPrincipalLoginRequest calls the generic ExternalPrincipalLogin builder with application/json body
func NewExternalPrincipalLoginRequest(server string, body ExternalPrincipalLoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExternalPrincipalLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewExternalPrincipalLoginRequestWithBody generates requests for ExternalPrincipalLogin with any type of body
func NewExternalPrincipalLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/external/principal/login")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetExternalPrincipalRequest generates requests for GetExternalPrincipal
func NewGetExternalPrincipalRequest(server string, params *GetExternalPrincipalParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/external/principals")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "principalId", runtime.ParamLocationQuery, params.PrincipalId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTokenFromMailboxRequest generates requests for GetTokenFromMailbox
func NewGetTokenFromMailboxRequest(server string, mailbox string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mailbox", runtime.ParamLocationPath, mailbox)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/get-token/mailboxes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReleaseTokenToMailboxRequest generates requests for ReleaseTokenToMailbox
func NewReleaseTokenToMailboxRequest(server string, loginRequestToken string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "loginRequestToken", runtime.ParamLocationPath, loginRequestToken)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/get-token/release-token/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTokenRedirectRequest generates requests for GetTokenRedirect
func NewGetTokenRedirectRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/get-token/start")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListGroupsRequest generates requests for ListGroups
func NewListGroupsRequest(server string, params *ListGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateGroupRequest calls the generic CreateGroup builder with application/json body
func NewCreateGroupRequest(server string, body CreateGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGroupRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateGroupRequestWithBody generates requests for CreateGroup with any type of body
func NewCreateGroupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGroupRequest generates requests for DeleteGroup
func NewDeleteGroupRequest(server string, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupRequest generates requests for GetGroup
func NewGetGroupRequest(server string, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupACLRequest generates requests for GetGroupACL
func NewGetGroupACLRequest(server string, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s/acl", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetGroupACLRequest calls the generic SetGroupACL builder with application/json body
func NewSetGroupACLRequest(server string, groupId string, body SetGroupACLJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetGroupACLRequestWithBody(server, groupId, "application/json", bodyReader)
}

// NewSetGroupACLRequestWithBody generates requests for SetGroupACL with any type of body
func NewSetGroupACLRequestWithBody(server string, groupId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s/acl", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListGroupMembersRequest generates requests for ListGroupMembers
func NewListGroupMembersRequest(server string, groupId string, params *ListGroupMembersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteGroupMembershipRequest generates requests for DeleteGroupMembership
func NewDeleteGroupMembershipRequest(server string, groupId string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddGroupMembershipRequest generates requests for AddGroupMembership
func NewAddGroupMembershipRequest(server string, groupId string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListGroupPoliciesRequest generates requests for ListGroupPolicies
func NewListGroupPoliciesRequest(server string, groupId string, params *ListGroupPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s/policies", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDetachPolicyFromGroupRequest generates requests for DetachPolicyFromGroup
func NewDetachPolicyFromGroupRequest(server string, groupId string, policyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s/policies/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachPolicyToGroupRequest generates requests for AttachPolicyToGroup
func NewAttachPolicyToGroupRequest(server string, groupId string, policyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s/policies/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoginRequest calls the generic Login builder with application/json body
func NewLoginRequest(server string, body LoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewLoginRequestWithBody generates requests for Login with any type of body
func NewLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/login")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPoliciesRequest generates requests for ListPolicies
func NewListPoliciesRequest(server string, params *ListPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/policies")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePolicyRequest calls the generic CreatePolicy builder with application/json body
func NewCreatePolicyRequest(server string, body CreatePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePolicyRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePolicyRequestWithBody generates requests for CreatePolicy with any type of body
func NewCreatePolicyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/policies")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePolicyRequest generates requests for DeletePolicy
func NewDeletePolicyRequest(server string, policyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPolicyRequest generates requests for GetPolicy
func NewGetPolicyRequest(server string, policyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePolicyRequest calls the generic UpdatePolicy builder with application/json body
func NewUpdatePolicyRequest(server string, policyId string, body UpdatePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePolicyRequestWithBody(server, policyId, "application/json", bodyReader)
}

// NewUpdatePolicyRequestWithBody generates requests for UpdatePolicy with any type of body
func NewUpdatePolicyRequestWithBody(server string, policyId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListUsersRequest generates requests for ListUsers
func NewListUsersRequest(server string, params *ListUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserRequest calls the generic CreateUser builder with application/json body
func NewCreateUserRequest(server string, body CreateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateUserRequestWithBody generates requests for CreateUser with any type of body
func NewCreateUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUserCredentialsRequest generates requests for ListUserCredentials
func NewListUserCredentialsRequest(server string, userId string, params *ListUserCredentialsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/credentials", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCredentialsRequest generates requests for CreateCredentials
func NewCreateCredentialsRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/credentials", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteCredentialsRequest generates requests for DeleteCredentials
func NewDeleteCredentialsRequest(server string, userId string, accessKeyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "accessKeyId", runtime.ParamLocationPath, accessKeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/credentials/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCredentialsRequest generates requests for GetCredentials
func NewGetCredentialsRequest(server string, userId string, accessKeyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "accessKeyId", runtime.ParamLocationPath, accessKeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/credentials/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteUserExternalPrincipalRequest generates requests for DeleteUserExternalPrincipal
func NewDeleteUserExternalPrincipalRequest(server string, userId string, params *DeleteUserExternalPrincipalParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/external/principals", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "principalId", runtime.ParamLocationQuery, params.PrincipalId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserExternalPrincipalRequest calls the generic CreateUserExternalPrincipal builder with application/json body
func NewCreateUserExternalPrincipalRequest(server string, userId string, params *CreateUserExternalPrincipalParams, body CreateUserExternalPrincipalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserExternalPrincipalRequestWithBody(server, userId, params, "application/json", bodyReader)
}

// NewCreateUserExternalPrincipalRequestWithBody generates requests for CreateUserExternalPrincipal with any type of body
func NewCreateUserExternalPrincipalRequestWithBody(server string, userId string, params *CreateUserExternalPrincipalParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/external/principals", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "principalId", runtime.ParamLocationQuery, params.PrincipalId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListUserExternalPrincipalsRequest generates requests for ListUserExternalPrincipals
func NewListUserExternalPrincipalsRequest(server string, userId string, params *ListUserExternalPrincipalsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/external/principals/ls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUserGroupsRequest generates requests for ListUserGroups
func NewListUserGroupsRequest(server string, userId string, params *ListUserGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUserPoliciesRequest generates requests for ListUserPolicies
func NewListUserPoliciesRequest(server string, userId string, params *ListUserPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/policies", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Effective != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective", runtime.ParamLocationQuery, *params.Effective); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDetachPolicyFromUserRequest generates requests for DetachPolicyFromUser
func NewDetachPolicyFromUserRequest(server string, userId string, policyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/policies/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachPolicyToUserRequest generates requests for AttachPolicyToUser
func NewAttachPolicyToUserRequest(server string, userId string, policyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/policies/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigRequest generates requests for GetConfig
func NewGetConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/config")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGarbageCollectionConfigRequest generates requests for GetGarbageCollectionConfig
func NewGetGarbageCollectionConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/config/garbage-collection")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStorageConfigRequest generates requests for GetStorageConfig
func NewGetStorageConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/config/storage")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLakeFSVersionRequest generates requests for GetLakeFSVersion
func NewGetLakeFSVersionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/config/version")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHealthCheckRequest generates requests for HealthCheck
func NewHealthCheckRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/healthcheck")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPullIcebergTableRequest calls the generic PullIcebergTable builder with application/json body
func NewPullIcebergTableRequest(server string, catalog string, body PullIcebergTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPullIcebergTableRequestWithBody(server, catalog, "application/json", bodyReader)
}

// NewPullIcebergTableRequestWithBody generates requests for PullIcebergTable with any type of body
func NewPullIcebergTableRequestWithBody(server string, catalog string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "catalog", runtime.ParamLocationPath, catalog)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iceberg/remotes/%s/pull", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPushIcebergTableRequest calls the generic PushIcebergTable builder with application/json body
func NewPushIcebergTableRequest(server string, catalog string, body PushIcebergTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPushIcebergTableRequestWithBody(server, catalog, "application/json", bodyReader)
}

// NewPushIcebergTableRequestWithBody generates requests for PushIcebergTable with any type of body
func NewPushIcebergTableRequestWithBody(server string, catalog string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "catalog", runtime.ParamLocationPath, catalog)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iceberg/remotes/%s/push", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLicenseRequest generates requests for GetLicense
func NewGetLicenseRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/license")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthCallbackRequest generates requests for OauthCallback
func NewOauthCallbackRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oidc/callback")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRepositoriesRequest generates requests for ListRepositories
func NewListRepositoriesRequest(server string, params *ListRepositoriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Search != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRepositoryRequest calls the generic CreateRepository builder with application/json body
func NewCreateRepositoryRequest(server string, params *CreateRepositoryParams, body CreateRepositoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRepositoryRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateRepositoryRequestWithBody generates requests for CreateRepository with any type of body
func NewCreateRepositoryRequestWithBody(server string, params *CreateRepositoryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Bare != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bare", runtime.ParamLocationQuery, *params.Bare); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRepositoryRequest generates requests for DeleteRepository
func NewDeleteRepositoryRequest(server string, repository string, params *DeleteRepositoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRepositoryRequest generates requests for GetRepository
func NewGetRepositoryRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRepositoryRunsRequest generates requests for ListRepositoryRuns
func NewListRepositoryRunsRequest(server string, repository string, params *ListRepositoryRunsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/actions/runs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Branch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "branch", runtime.ParamLocationQuery, *params.Branch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Commit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "commit", runtime.ParamLocationQuery, *params.Commit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRunRequest generates requests for GetRun
func NewGetRunRequest(server string, repository string, runId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/actions/runs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRunHooksRequest generates requests for ListRunHooks
func NewListRunHooksRequest(server string, repository string, runId string, params *ListRunHooksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/actions/runs/%s/hooks", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRunHookOutputRequest generates requests for GetRunHookOutput
func NewGetRunHookOutputRequest(server string, repository string, runId string, hookRunId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "hook_run_id", runtime.ParamLocationPath, hookRunId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/actions/runs/%s/hooks/%s/output", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalDeleteBranchProtectionRuleRequest calls the generic InternalDeleteBranchProtectionRule builder with application/json body
func NewInternalDeleteBranchProtectionRuleRequest(server string, repository string, body InternalDeleteBranchProtectionRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInternalDeleteBranchProtectionRuleRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewInternalDeleteBranchProtectionRuleRequestWithBody generates requests for InternalDeleteBranchProtectionRule with any type of body
func NewInternalDeleteBranchProtectionRuleRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branch_protection", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInternalGetBranchProtectionRulesRequest generates requests for InternalGetBranchProtectionRules
func NewInternalGetBranchProtectionRulesRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branch_protection", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalCreateBranchProtectionRuleRequest calls the generic InternalCreateBranchProtectionRule builder with application/json body
func NewInternalCreateBranchProtectionRuleRequest(server string, repository string, body InternalCreateBranchProtectionRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInternalCreateBranchProtectionRuleRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewInternalCreateBranchProtectionRuleRequestWithBody generates requests for InternalCreateBranchProtectionRule with any type of body
func NewInternalCreateBranchProtectionRuleRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branch_protection", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateBranchProtectionRulePreflightRequest generates requests for CreateBranchProtectionRulePreflight
func NewCreateBranchProtectionRulePreflightRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branch_protection/set_allowed", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBranchesRequest generates requests for ListBranches
func NewListBranchesRequest(server string, repository string, params *ListBranchesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ShowHidden != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_hidden", runtime.ParamLocationQuery, *params.ShowHidden); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBranchRequest calls the generic CreateBranch builder with application/json body
func NewCreateBranchRequest(server string, repository string, body CreateBranchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBranchRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewCreateBranchRequestWithBody generates requests for CreateBranch with any type of body
func NewCreateBranchRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBranchRequest generates requests for DeleteBranch
func NewDeleteBranchRequest(server string, repository string, branch string, params *DeleteBranchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBranchRequest generates requests for GetBranch
func NewGetBranchRequest(server string, repository string, branch string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResetBranchRequest calls the generic ResetBranch builder with application/json body
func NewResetBranchRequest(server string, repository string, branch string, body ResetBranchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResetBranchRequestWithBody(server, repository, branch, "application/json", bodyReader)
}

// NewResetBranchRequestWithBody generates requests for ResetBranch with any type of body
func NewResetBranchRequestWithBody(server string, repository string, branch string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCherryPickRequest calls the generic CherryPick builder with application/json body
func NewCherryPickRequest(server string, repository string, branch string, body CherryPickJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCherryPickRequestWithBody(server, repository, branch, "application/json", bodyReader)
}

// NewCherryPickRequestWithBody generates requests for CherryPick with any type of body
func NewCherryPickRequestWithBody(server string, repository string, branch string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/cherry-pick", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCommitRequest calls the generic Commit builder with application/json body
func NewCommitRequest(server string, repository string, branch string, params *CommitParams, body CommitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCommitRequestWithBody(server, repository, branch, params, "application/json", bodyReader)
}

// NewCommitRequestWithBody generates requests for Commit with any type of body
func NewCommitRequestWithBody(server string, repository string, branch string, params *CommitParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/commits", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.SourceMetarange != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "source_metarange", runtime.ParamLocationQuery, *params.SourceMetarange); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCommitAsyncRequest calls the generic CommitAsync builder with application/json body
func NewCommitAsyncRequest(server string, repository string, branch string, params *CommitAsyncParams, body CommitAsyncJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCommitAsyncRequestWithBody(server, repository, branch, params, "application/json", bodyReader)
}

// NewCommitAsyncRequestWithBody generates requests for CommitAsync with any type of body
func NewCommitAsyncRequestWithBody(server string, repository string, branch string, params *CommitAsyncParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/commits/async", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.SourceMetarange != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "source_metarange", runtime.ParamLocationQuery, *params.SourceMetarange); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCommitAsyncStatusRequest generates requests for CommitAsyncStatus
func NewCommitAsyncStatusRequest(server string, repository string, branch string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/commits/async/%s/status", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDiffBranchRequest generates requests for DiffBranch
func NewDiffBranchRequest(server string, repository string, branch string, params *DiffBranchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/diff", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Delimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delimiter", runtime.ParamLocationQuery, *params.Delimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHardResetBranchRequest generates requests for HardResetBranch
func NewHardResetBranchRequest(server string, repository string, branch string, params *HardResetBranchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/hard_reset", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ref", runtime.ParamLocationQuery, params.Ref); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewImportCancelRequest generates requests for ImportCancel
func NewImportCancelRequest(server string, repository string, branch string, params *ImportCancelParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/import", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewImportStatusRequest generates requests for ImportStatus
func NewImportStatusRequest(server string, repository string, branch string, params *ImportStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/import", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewImportStartRequest calls the generic ImportStart builder with application/json body
func NewImportStartRequest(server string, repository string, branch string, body ImportStartJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewImportStartRequestWithBody(server, repository, branch, "application/json", bodyReader)
}

// NewImportStartRequestWithBody generates requests for ImportStart with any type of body
func NewImportStartRequestWithBody(server string, repository string, branch string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/import", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteObjectRequest generates requests for DeleteObject
func NewDeleteObjectRequest(server string, repository string, branch string, params *DeleteObjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/objects", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NoTombstone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "no_tombstone", runtime.ParamLocationQuery, *params.NoTombstone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadObjectRequestWithBody generates requests for UploadObject with any type of body
func NewUploadObjectRequestWithBody(server string, repository string, branch string, params *UploadObjectParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/objects", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.StorageClass != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storageClass", runtime.ParamLocationQuery, *params.StorageClass); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.IfNoneMatch != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, *params.IfNoneMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-None-Match", headerParam0)
	}

	if params.IfMatch != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-Match", headerParam1)
	}

	return req, nil
}

// NewStageObjectRequest calls the generic StageObject builder with application/json body
func NewStageObjectRequest(server string, repository string, branch string, params *StageObjectParams, body StageObjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStageObjectRequestWithBody(server, repository, branch, params, "application/json", bodyReader)
}

// NewStageObjectRequestWithBody generates requests for StageObject with any type of body
func NewStageObjectRequestWithBody(server string, repository string, branch string, params *StageObjectParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/objects", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCopyObjectRequest calls the generic CopyObject builder with application/json body
func NewCopyObjectRequest(server string, repository string, branch string, params *CopyObjectParams, body CopyObjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCopyObjectRequestWithBody(server, repository, branch, params, "application/json", bodyReader)
}

// NewCopyObjectRequestWithBody generates requests for CopyObject with any type of body
func NewCopyObjectRequestWithBody(server string, repository string, branch string, params *CopyObjectParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/objects/copy", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dest_path", runtime.ParamLocationQuery, params.DestPath); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteObjectsRequest calls the generic DeleteObjects builder with application/json body
func NewDeleteObjectsRequest(server string, repository string, branch string, params *DeleteObjectsParams, body DeleteObjectsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteObjectsRequestWithBody(server, repository, branch, params, "application/json", bodyReader)
}

// NewDeleteObjectsRequestWithBody generates requests for DeleteObjects with any type of body
func NewDeleteObjectsRequestWithBody(server string, repository string, branch string, params *DeleteObjectsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/objects/delete", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NoTombstone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "no_tombstone", runtime.ParamLocationQuery, *params.NoTombstone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUploadObjectPreflightRequest generates requests for UploadObjectPreflight
func NewUploadObjectPreflightRequest(server string, repository string, branch string, params *UploadObjectPreflightParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/objects/stage_allowed", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateObjectUserMetadataRequest calls the generic UpdateObjectUserMetadata builder with application/json body
func NewUpdateObjectUserMetadataRequest(server string, repository string, branch string, params *UpdateObjectUserMetadataParams, body UpdateObjectUserMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateObjectUserMetadataRequestWithBody(server, repository, branch, params, "application/json", bodyReader)
}

// NewUpdateObjectUserMetadataRequestWithBody generates requests for UpdateObjectUserMetadata with any type of body
func NewUpdateObjectUserMetadataRequestWithBody(server string, repository string, branch string, params *UpdateObjectUserMetadataParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/objects/stat/user_metadata", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevertBranchRequest calls the generic RevertBranch builder with application/json body
func NewRevertBranchRequest(server string, repository string, branch string, body RevertBranchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevertBranchRequestWithBody(server, repository, branch, "application/json", bodyReader)
}

// NewRevertBranchRequestWithBody generates requests for RevertBranch with any type of body
func NewRevertBranchRequestWithBody(server string, repository string, branch string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/revert", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPhysicalAddressRequest generates requests for GetPhysicalAddress
func NewGetPhysicalAddressRequest(server string, repository string, branch string, params *GetPhysicalAddressParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/staging/backing", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Presign != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "presign", runtime.ParamLocationQuery, *params.Presign); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLinkPhysicalAddressRequest calls the generic LinkPhysicalAddress builder with application/json body
func NewLinkPhysicalAddressRequest(server string, repository string, branch string, params *LinkPhysicalAddressParams, body LinkPhysicalAddressJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkPhysicalAddressRequestWithBody(server, repository, branch, params, "application/json", bodyReader)
}

// NewLinkPhysicalAddressRequestWithBody generates requests for LinkPhysicalAddress with any type of body
func NewLinkPhysicalAddressRequestWithBody(server string, repository string, branch string, params *LinkPhysicalAddressParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/staging/backing", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.IfNoneMatch != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, *params.IfNoneMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-None-Match", headerParam0)
	}

	if params.IfMatch != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-Match", headerParam1)
	}

	return req, nil
}

// NewCreatePresignMultipartUploadRequest generates requests for CreatePresignMultipartUpload
func NewCreatePresignMultipartUploadRequest(server string, repository string, branch string, params *CreatePresignMultipartUploadParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/staging/pmpu", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Parts != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parts", runtime.ParamLocationQuery, *params.Parts); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAbortPresignMultipartUploadRequest calls the generic AbortPresignMultipartUpload builder with application/json body
func NewAbortPresignMultipartUploadRequest(server string, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, body AbortPresignMultipartUploadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAbortPresignMultipartUploadRequestWithBody(server, repository, branch, uploadId, params, "application/json", bodyReader)
}

// NewAbortPresignMultipartUploadRequestWithBody generates requests for AbortPresignMultipartUpload with any type of body
func NewAbortPresignMultipartUploadRequestWithBody(server string, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "uploadId", runtime.ParamLocationPath, uploadId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/staging/pmpu/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCompletePresignMultipartUploadRequest calls the generic CompletePresignMultipartUpload builder with application/json body
func NewCompletePresignMultipartUploadRequest(server string, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, body CompletePresignMultipartUploadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCompletePresignMultipartUploadRequestWithBody(server, repository, branch, uploadId, params, "application/json", bodyReader)
}

// NewCompletePresignMultipartUploadRequestWithBody generates requests for CompletePresignMultipartUpload with any type of body
func NewCompletePresignMultipartUploadRequestWithBody(server string, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "uploadId", runtime.ParamLocationPath, uploadId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/staging/pmpu/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUploadPartRequest calls the generic UploadPart builder with application/json body
func NewUploadPartRequest(server string, repository string, branch string, uploadId string, partNumber int, params *UploadPartParams, body UploadPartJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUploadPartRequestWithBody(server, repository, branch, uploadId, partNumber, params, "application/json", bodyReader)
}

// NewUploadPartRequestWithBody generates requests for UploadPart with any type of body
func NewUploadPartRequestWithBody(server string, repository string, branch string, uploadId string, partNumber int, params *UploadPartParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "uploadId", runtime.ParamLocationPath, uploadId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "partNumber", runtime.ParamLocationPath, partNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/staging/pmpu/%s/parts/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUploadPartCopyRequest calls the generic UploadPartCopy builder with application/json body
func NewUploadPartCopyRequest(server string, repository string, branch string, uploadId string, partNumber int, params *UploadPartCopyParams, body UploadPartCopyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUploadPartCopyRequestWithBody(server, repository, branch, uploadId, partNumber, params, "application/json", bodyReader)
}

// NewUploadPartCopyRequestWithBody generates requests for UploadPartCopy with any type of body
func NewUploadPartCopyRequestWithBody(server string, repository string, branch string, uploadId string, partNumber int, params *UploadPartCopyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "uploadId", runtime.ParamLocationPath, uploadId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "partNumber", runtime.ParamLocationPath, partNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/staging/pmpu/%s/parts/%s/copy", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateCommitRecordRequest calls the generic CreateCommitRecord builder with application/json body
func NewCreateCommitRecordRequest(server string, repository string, body CreateCommitRecordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCommitRecordRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewCreateCommitRecordRequestWithBody generates requests for CreateCommitRecord with any type of body
func NewCreateCommitRecordRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/commits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCommitRequest generates requests for GetCommit
func NewGetCommitRequest(server string, repository string, commitId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/commits/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDumpStatusRequest generates requests for DumpStatus
func NewDumpStatusRequest(server string, repository string, params *DumpStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/dump", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "task_id", runtime.ParamLocationQuery, params.TaskId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDumpSubmitRequest generates requests for DumpSubmit
func NewDumpSubmitRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/dump", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPrepareGarbageCollectionCommitsRequest generates requests for PrepareGarbageCollectionCommits
func NewPrepareGarbageCollectionCommitsRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/gc/prepare_commits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPrepareGarbageCollectionCommitsAsyncRequest generates requests for PrepareGarbageCollectionCommitsAsync
func NewPrepareGarbageCollectionCommitsAsyncRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/gc/prepare_commits/async", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPrepareGarbageCollectionCommitsStatusRequest generates requests for PrepareGarbageCollectionCommitsStatus
func NewPrepareGarbageCollectionCommitsStatusRequest(server string, repository string, params *PrepareGarbageCollectionCommitsStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/gc/prepare_commits/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPrepareGarbageCollectionUncommittedRequest calls the generic PrepareGarbageCollectionUncommitted builder with application/json body
func NewPrepareGarbageCollectionUncommittedRequest(server string, repository string, body PrepareGarbageCollectionUncommittedJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPrepareGarbageCollectionUncommittedRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewPrepareGarbageCollectionUncommittedRequestWithBody generates requests for PrepareGarbageCollectionUncommitted with any type of body
func NewPrepareGarbageCollectionUncommittedRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/gc/prepare_uncommited", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInternalDeleteGarbageCollectionRulesRequest generates requests for InternalDeleteGarbageCollectionRules
func NewInternalDeleteGarbageCollectionRulesRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/gc/rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalGetGarbageCollectionRulesRequest generates requests for InternalGetGarbageCollectionRules
func NewInternalGetGarbageCollectionRulesRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/gc/rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalSetGarbageCollectionRulesRequest calls the generic InternalSetGarbageCollectionRules builder with application/json body
func NewInternalSetGarbageCollectionRulesRequest(server string, repository string, body InternalSetGarbageCollectionRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInternalSetGarbageCollectionRulesRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewInternalSetGarbageCollectionRulesRequestWithBody generates requests for InternalSetGarbageCollectionRules with any type of body
func NewInternalSetGarbageCollectionRulesRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/gc/rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSetGarbageCollectionRulesPreflightRequest generates requests for SetGarbageCollectionRulesPreflight
func NewSetGarbageCollectionRulesPreflightRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/gc/rules/set_allowed", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteRepositoryMetadataRequest calls the generic DeleteRepositoryMetadata builder with application/json body
func NewDeleteRepositoryMetadataRequest(server string, repository string, body DeleteRepositoryMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteRepositoryMetadataRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewDeleteRepositoryMetadataRequestWithBody generates requests for DeleteRepositoryMetadata with any type of body
func NewDeleteRepositoryMetadataRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/metadata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRepositoryMetadataRequest generates requests for GetRepositoryMetadata
func NewGetRepositoryMetadataRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/metadata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetRepositoryMetadataRequest calls the generic SetRepositoryMetadata builder with application/json body
func NewSetRepositoryMetadataRequest(server string, repository string, body SetRepositoryMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetRepositoryMetadataRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewSetRepositoryMetadataRequestWithBody generates requests for SetRepositoryMetadata with any type of body
func NewSetRepositoryMetadataRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/metadata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMetaRangeRequest generates requests for GetMetaRange
func NewGetMetaRangeRequest(server string, repository string, metaRange string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "meta_range", runtime.ParamLocationPath, metaRange)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/metadata/meta_range/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMetadataObjectRequest generates requests for GetMetadataObject
func NewGetMetadataObjectRequest(server string, repository string, pType string, objectId string, params *GetMetadataObjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/metadata/object/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Presign != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "presign", runtime.ParamLocationQuery, *params.Presign); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRangeRequest generates requests for GetRange
func NewGetRangeRequest(server string, repository string, pRange string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "range", runtime.ParamLocationPath, pRange)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/metadata/range/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPullRequestsRequest generates requests for ListPullRequests
func NewListPullRequestsRequest(server string, repository string, params *ListPullRequestsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/pulls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Status != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePullRequestRequest calls the generic CreatePullRequest builder with application/json body
func NewCreatePullRequestRequest(server string, repository string, body CreatePullRequestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePullRequestRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewCreatePullRequestRequestWithBody generates requests for CreatePullRequest with any type of body
func NewCreatePullRequestRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/pulls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPullRequestRequest generates requests for GetPullRequest
func NewGetPullRequestRequest(server string, repository string, pullRequest string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pull_request", runtime.ParamLocationPath, pullRequest)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/pulls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePullRequestRequest calls the generic UpdatePullRequest builder with application/json body
func NewUpdatePullRequestRequest(server string, repository string, pullRequest string, body UpdatePullRequestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePullRequestRequestWithBody(server, repository, pullRequest, "application/json", bodyReader)
}

// NewUpdatePullRequestRequestWithBody generates requests for UpdatePullRequest with any type of body
func NewUpdatePullRequestRequestWithBody(server string, repository string, pullRequest string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pull_request", runtime.ParamLocationPath, pullRequest)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/pulls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergePullRequestRequest generates requests for MergePullRequest
func NewMergePullRequestRequest(server string, repository string, pullRequest string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pull_request", runtime.ParamLocationPath, pullRequest)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/pulls/%s/merge", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDumpRefsRequest generates requests for DumpRefs
func NewDumpRefsRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/dump", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreRefsRequest calls the generic RestoreRefs builder with application/json body
func NewRestoreRefsRequest(server string, repository string, body RestoreRefsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRestoreRefsRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewRestoreRefsRequestWithBody generates requests for RestoreRefs with any type of body
func NewRestoreRefsRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/restore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateSymlinkFileRequest generates requests for CreateSymlinkFile
func NewCreateSymlinkFileRequest(server string, repository string, branch string, params *CreateSymlinkFileParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/symlink", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Location != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "location", runtime.ParamLocationQuery, *params.Location); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDiffRefsRequest generates requests for DiffRefs
func NewDiffRefsRequest(server string, repository string, leftRef string, rightRef string, params *DiffRefsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "leftRef", runtime.ParamLocationPath, leftRef)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "rightRef", runtime.ParamLocationPath, rightRef)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/diff/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Delimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delimiter", runtime.ParamLocationQuery, *params.Delimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeRightStats != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_right_stats", runtime.ParamLocationQuery, *params.IncludeRightStats); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLogCommitsRequest generates requests for LogCommits
func NewLogCommitsRequest(server string, repository string, ref string, params *LogCommitsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/commits", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Objects != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "objects", runtime.ParamLocationQuery, *params.Objects); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Prefixes != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefixes", runtime.ParamLocationQuery, *params.Prefixes); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FirstParent != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first_parent", runtime.ParamLocationQuery, *params.FirstParent); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Since != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StopAt != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stop_at", runtime.ParamLocationQuery, *params.StopAt); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetObjectRequest generates requests for GetObject
func NewGetObjectRequest(server string, repository string, ref string, params *GetObjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/objects", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Presign != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "presign", runtime.ParamLocationQuery, *params.Presign); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.Range != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Range", runtime.ParamLocationHeader, *params.Range)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Range", headerParam0)
	}

	if params.IfNoneMatch != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, *params.IfNoneMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-None-Match", headerParam1)
	}

	return req, nil
}

// NewHeadObjectRequest generates requests for HeadObject
func NewHeadObjectRequest(server string, repository string, ref string, params *HeadObjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/objects", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.Range != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Range", runtime.ParamLocationHeader, *params.Range)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Range", headerParam0)
	}

	return req, nil
}

// NewListObjectsRequest generates requests for ListObjects
func NewListObjectsRequest(server string, repository string, ref string, params *ListObjectsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/objects/ls", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.UserMetadata != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_metadata", runtime.ParamLocationQuery, *params.UserMetadata); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Presign != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "presign", runtime.ParamLocationQuery, *params.Presign); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Delimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delimiter", runtime.ParamLocationQuery, *params.Delimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStatObjectRequest generates requests for StatObject
func NewStatObjectRequest(server string, repository string, ref string, params *StatObjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/objects/stat", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.UserMetadata != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_metadata", runtime.ParamLocationQuery, *params.UserMetadata); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Presign != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "presign", runtime.ParamLocationQuery, *params.Presign); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUnderlyingPropertiesRequest generates requests for GetUnderlyingProperties
func NewGetUnderlyingPropertiesRequest(server string, repository string, ref string, params *GetUnderlyingPropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/objects/underlyingProperties", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindMergeBaseRequest generates requests for FindMergeBase
func NewFindMergeBaseRequest(server string, repository string, sourceRef string, destinationBranch string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sourceRef", runtime.ParamLocationPath, sourceRef)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "destinationBranch", runtime.ParamLocationPath, destinationBranch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/merge/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMergeIntoBranchRequest calls the generic MergeIntoBranch builder with application/json body
func NewMergeIntoBranchRequest(server string, repository string, sourceRef string, destinationBranch string, body MergeIntoBranchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeIntoBranchRequestWithBody(server, repository, sourceRef, destinationBranch, "application/json", bodyReader)
}

// NewMergeIntoBranchRequestWithBody generates requests for MergeIntoBranch with any type of body
func NewMergeIntoBranchRequestWithBody(server string, repository string, sourceRef string, destinationBranch string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sourceRef", runtime.ParamLocationPath, sourceRef)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "destinationBranch", runtime.ParamLocationPath, destinationBranch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/merge/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergeIntoBranchAsyncRequest calls the generic MergeIntoBranchAsync builder with application/json body
func NewMergeIntoBranchAsyncRequest(server string, repository string, sourceRef string, destinationBranch string, body MergeIntoBranchAsyncJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeIntoBranchAsyncRequestWithBody(server, repository, sourceRef, destinationBranch, "application/json", bodyReader)
}

// NewMergeIntoBranchAsyncRequestWithBody generates requests for MergeIntoBranchAsync with any type of body
func NewMergeIntoBranchAsyncRequestWithBody(server string, repository string, sourceRef string, destinationBranch string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sourceRef", runtime.ParamLocationPath, sourceRef)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "destinationBranch", runtime.ParamLocationPath, destinationBranch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/merge/%s/async", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergeIntoBranchAsyncStatusRequest generates requests for MergeIntoBranchAsyncStatus
func NewMergeIntoBranchAsyncStatusRequest(server string, repository string, sourceRef string, destinationBranch string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sourceRef", runtime.ParamLocationPath, sourceRef)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "destinationBranch", runtime.ParamLocationPath, destinationBranch)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/merge/%s/async/%s/status", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreStatusRequest generates requests for RestoreStatus
func NewRestoreStatusRequest(server string, repository string, params *RestoreStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/restore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "task_id", runtime.ParamLocationQuery, params.TaskId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreSubmitRequest calls the generic RestoreSubmit builder with application/json body
func NewRestoreSubmitRequest(server string, repository string, body RestoreSubmitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRestoreSubmitRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewRestoreSubmitRequestWithBody generates requests for RestoreSubmit with any type of body
func NewRestoreSubmitRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/restore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBranchProtectionRulesRequest generates requests for GetBranchProtectionRules
func NewGetBranchProtectionRulesRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/settings/branch_protection", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetBranchProtectionRulesRequest calls the generic SetBranchProtectionRules builder with application/json body
func NewSetBranchProtectionRulesRequest(server string, repository string, params *SetBranchProtectionRulesParams, body SetBranchProtectionRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetBranchProtectionRulesRequestWithBody(server, repository, params, "application/json", bodyReader)
}

// NewSetBranchProtectionRulesRequestWithBody generates requests for SetBranchProtectionRules with any type of body
func NewSetBranchProtectionRulesRequestWithBody(server string, repository string, params *SetBranchProtectionRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/settings/branch_protection", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.IfMatch != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-Match", headerParam0)
	}

	return req, nil
}

// NewDeleteGCRulesRequest generates requests for DeleteGCRules
func NewDeleteGCRulesRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/settings/gc_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGCRulesRequest generates requests for GetGCRules
func NewGetGCRulesRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/settings/gc_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetGCRulesRequest calls the generic SetGCRules builder with application/json body
func NewSetGCRulesRequest(server string, repository string, body SetGCRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetGCRulesRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewSetGCRulesRequestWithBody generates requests for SetGCRules with any type of body
func NewSetGCRulesRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/settings/gc_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListTagsRequest generates requests for ListTags
func NewListTagsRequest(server string, repository string, params *ListTagsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTagRequest calls the generic CreateTag builder with application/json body
func NewCreateTagRequest(server string, repository string, body CreateTagJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTagRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewCreateTagRequestWithBody generates requests for CreateTag with any type of body
func NewCreateTagRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTagRequest generates requests for DeleteTag
func NewDeleteTagRequest(server string, repository string, tag string, params *DeleteTagParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tag", runtime.ParamLocationPath, tag)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/tags/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTagRequest generates requests for GetTag
func NewGetTagRequest(server string, repository string, tag string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tag", runtime.ParamLocationPath, tag)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/tags/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetupCommPrefsRequest calls the generic SetupCommPrefs builder with application/json body
func NewSetupCommPrefsRequest(server string, body SetupCommPrefsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetupCommPrefsRequestWithBody(server, "application/json", bodyReader)
}

// NewSetupCommPrefsRequestWithBody generates requests for SetupCommPrefs with any type of body
func NewSetupCommPrefsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setup_comm_prefs")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSetupStateRequest generates requests for GetSetupState
func NewGetSetupStateRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setup_lakefs")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetupRequest calls the generic Setup builder with application/json body
func NewSetupRequest(server string, body SetupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetupRequestWithBody(server, "application/json", bodyReader)
}

// NewSetupRequestWithBody generates requests for Setup with any type of body
func NewSetupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setup_lakefs")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostStatsEventsRequest calls the generic PostStatsEvents builder with application/json body
func NewPostStatsEventsRequest(server string, body PostStatsEventsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostStatsEventsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostStatsEventsRequestWithBody generates requests for PostStatsEvents with any type of body
func NewPostStatsEventsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/statistics")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStsLoginRequest calls the generic StsLogin builder with application/json body
func NewStsLoginRequest(server string, body StsLoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStsLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewStsLoginRequestWithBody generates requests for StsLogin with any type of body
func NewStsLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sts/login")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUsageReportSummaryRequest generates requests for GetUsageReportSummary
func NewGetUsageReportSummaryRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/usage-report/summary")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrentUserRequest generates requests for GetCurrentUser
func NewGetCurrentUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAuthCapabilities request
	GetAuthCapabilitiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAuthCapabilitiesResponse, error)

	// ExternalPrincipalLogin request  with any body
	ExternalPrincipalLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExternalPrincipalLoginResponse, error)

	ExternalPrincipalLoginWithResponse(ctx context.Context, body ExternalPrincipalLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*ExternalPrincipalLoginResponse, error)

	// GetExternalPrincipal request
	GetExternalPrincipalWithResponse(ctx context.Context, params *GetExternalPrincipalParams, reqEditors ...RequestEditorFn) (*GetExternalPrincipalResponse, error)

	// GetTokenFromMailbox request
	GetTokenFromMailboxWithResponse(ctx context.Context, mailbox string, reqEditors ...RequestEditorFn) (*GetTokenFromMailboxResponse, error)

	// ReleaseTokenToMailbox request
	ReleaseTokenToMailboxWithResponse(ctx context.Context, loginRequestToken string, reqEditors ...RequestEditorFn) (*ReleaseTokenToMailboxResponse, error)

	// GetTokenRedirect request
	GetTokenRedirectWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTokenRedirectResponse, error)

	// ListGroups request
	ListGroupsWithResponse(ctx context.Context, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*ListGroupsResponse, error)

	// CreateGroup request  with any body
	CreateGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	CreateGroupWithResponse(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	// DeleteGroup request
	DeleteGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error)

	// GetGroup request
	GetGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*GetGroupResponse, error)

	// GetGroupACL request
	GetGroupACLWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*GetGroupACLResponse, error)

	// SetGroupACL request  with any body
	SetGroupACLWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetGroupACLResponse, error)

	SetGroupACLWithResponse(ctx context.Context, groupId string, body SetGroupACLJSONRequestBody, reqEditors ...RequestEditorFn) (*SetGroupACLResponse, error)

	// ListGroupMembers request
	ListGroupMembersWithResponse(ctx context.Context, groupId string, params *ListGroupMembersParams, reqEditors ...RequestEditorFn) (*ListGroupMembersResponse, error)

	// DeleteGroupMembership request
	DeleteGroupMembershipWithResponse(ctx context.Context, groupId string, userId string, reqEditors ...RequestEditorFn) (*DeleteGroupMembershipResponse, error)

	// AddGroupMembership request
	AddGroupMembershipWithResponse(ctx context.Context, groupId string, userId string, reqEditors ...RequestEditorFn) (*AddGroupMembershipResponse, error)

	// ListGroupPolicies request
	ListGroupPoliciesWithResponse(ctx context.Context, groupId string, params *ListGroupPoliciesParams, reqEditors ...RequestEditorFn) (*ListGroupPoliciesResponse, error)

	// DetachPolicyFromGroup request
	DetachPolicyFromGroupWithResponse(ctx context.Context, groupId string, policyId string, reqEditors ...RequestEditorFn) (*DetachPolicyFromGroupResponse, error)

	// AttachPolicyToGroup request
	AttachPolicyToGroupWithResponse(ctx context.Context, groupId string, policyId string, reqEditors ...RequestEditorFn) (*AttachPolicyToGroupResponse, error)

	// Login request  with any body
	LoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	LoginWithResponse(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	// ListPolicies request
	ListPoliciesWithResponse(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*ListPoliciesResponse, error)

	// CreatePolicy request  with any body
	CreatePolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error)

	CreatePolicyWithResponse(ctx context.Context, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error)

	// DeletePolicy request
	DeletePolicyWithResponse(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*DeletePolicyResponse, error)

	// GetPolicy request
	GetPolicyWithResponse(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*GetPolicyResponse, error)

	// UpdatePolicy request  with any body
	UpdatePolicyWithBodyWithResponse(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error)

	UpdatePolicyWithResponse(ctx context.Context, policyId string, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error)

	// ListUsers request
	ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error)

	// CreateUser request  with any body
	CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	// DeleteUser request
	DeleteUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// GetUser request
	GetUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// ListUserCredentials request
	ListUserCredentialsWithResponse(ctx context.Context, userId string, params *ListUserCredentialsParams, reqEditors ...RequestEditorFn) (*ListUserCredentialsResponse, error)

	// CreateCredentials request
	CreateCredentialsWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*CreateCredentialsResponse, error)

	// DeleteCredentials request
	DeleteCredentialsWithResponse(ctx context.Context, userId string, accessKeyId string, reqEditors ...RequestEditorFn) (*DeleteCredentialsResponse, error)

	// GetCredentials request
	GetCredentialsWithResponse(ctx context.Context, userId string, accessKeyId string, reqEditors ...RequestEditorFn) (*GetCredentialsResponse, error)

	// DeleteUserExternalPrincipal request
	DeleteUserExternalPrincipalWithResponse(ctx context.Context, userId string, params *DeleteUserExternalPrincipalParams, reqEditors ...RequestEditorFn) (*DeleteUserExternalPrincipalResponse, error)

	// CreateUserExternalPrincipal request  with any body
	CreateUserExternalPrincipalWithBodyWithResponse(ctx context.Context, userId string, params *CreateUserExternalPrincipalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserExternalPrincipalResponse, error)

	CreateUserExternalPrincipalWithResponse(ctx context.Context, userId string, params *CreateUserExternalPrincipalParams, body CreateUserExternalPrincipalJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserExternalPrincipalResponse, error)

	// ListUserExternalPrincipals request
	ListUserExternalPrincipalsWithResponse(ctx context.Context, userId string, params *ListUserExternalPrincipalsParams, reqEditors ...RequestEditorFn) (*ListUserExternalPrincipalsResponse, error)

	// ListUserGroups request
	ListUserGroupsWithResponse(ctx context.Context, userId string, params *ListUserGroupsParams, reqEditors ...RequestEditorFn) (*ListUserGroupsResponse, error)

	// ListUserPolicies request
	ListUserPoliciesWithResponse(ctx context.Context, userId string, params *ListUserPoliciesParams, reqEditors ...RequestEditorFn) (*ListUserPoliciesResponse, error)

	// DetachPolicyFromUser request
	DetachPolicyFromUserWithResponse(ctx context.Context, userId string, policyId string, reqEditors ...RequestEditorFn) (*DetachPolicyFromUserResponse, error)

	// AttachPolicyToUser request
	AttachPolicyToUserWithResponse(ctx context.Context, userId string, policyId string, reqEditors ...RequestEditorFn) (*AttachPolicyToUserResponse, error)

	// GetConfig request
	GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigResponse, error)

	// GetGarbageCollectionConfig request
	GetGarbageCollectionConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGarbageCollectionConfigResponse, error)

	// GetStorageConfig request
	GetStorageConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStorageConfigResponse, error)

	// GetLakeFSVersion request
	GetLakeFSVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLakeFSVersionResponse, error)

	// HealthCheck request
	HealthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error)

	// PullIcebergTable request  with any body
	PullIcebergTableWithBodyWithResponse(ctx context.Context, catalog string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PullIcebergTableResponse, error)

	PullIcebergTableWithResponse(ctx context.Context, catalog string, body PullIcebergTableJSONRequestBody, reqEditors ...RequestEditorFn) (*PullIcebergTableResponse, error)

	// PushIcebergTable request  with any body
	PushIcebergTableWithBodyWithResponse(ctx context.Context, catalog string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PushIcebergTableResponse, error)

	PushIcebergTableWithResponse(ctx context.Context, catalog string, body PushIcebergTableJSONRequestBody, reqEditors ...RequestEditorFn) (*PushIcebergTableResponse, error)

	// GetLicense request
	GetLicenseWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLicenseResponse, error)

	// OauthCallback request
	OauthCallbackWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*OauthCallbackResponse, error)

	// ListRepositories request
	ListRepositoriesWithResponse(ctx context.Context, params *ListRepositoriesParams, reqEditors ...RequestEditorFn) (*ListRepositoriesResponse, error)

	// CreateRepository request  with any body
	CreateRepositoryWithBodyWithResponse(ctx context.Context, params *CreateRepositoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRepositoryResponse, error)

	CreateRepositoryWithResponse(ctx context.Context, params *CreateRepositoryParams, body CreateRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRepositoryResponse, error)

	// DeleteRepository request
	DeleteRepositoryWithResponse(ctx context.Context, repository string, params *DeleteRepositoryParams, reqEditors ...RequestEditorFn) (*DeleteRepositoryResponse, error)

	// GetRepository request
	GetRepositoryWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*GetRepositoryResponse, error)

	// ListRepositoryRuns request
	ListRepositoryRunsWithResponse(ctx context.Context, repository string, params *ListRepositoryRunsParams, reqEditors ...RequestEditorFn) (*ListRepositoryRunsResponse, error)

	// GetRun request
	GetRunWithResponse(ctx context.Context, repository string, runId string, reqEditors ...RequestEditorFn) (*GetRunResponse, error)

	// ListRunHooks request
	ListRunHooksWithResponse(ctx context.Context, repository string, runId string, params *ListRunHooksParams, reqEditors ...RequestEditorFn) (*ListRunHooksResponse, error)

	// GetRunHookOutput request
	GetRunHookOutputWithResponse(ctx context.Context, repository string, runId string, hookRunId string, reqEditors ...RequestEditorFn) (*GetRunHookOutputResponse, error)

	// InternalDeleteBranchProtectionRule request  with any body
	InternalDeleteBranchProtectionRuleWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalDeleteBranchProtectionRuleResponse, error)

	InternalDeleteBranchProtectionRuleWithResponse(ctx context.Context, repository string, body InternalDeleteBranchProtectionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalDeleteBranchProtectionRuleResponse, error)

	// InternalGetBranchProtectionRules request
	InternalGetBranchProtectionRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*InternalGetBranchProtectionRulesResponse, error)

	// InternalCreateBranchProtectionRule request  with any body
	InternalCreateBranchProtectionRuleWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalCreateBranchProtectionRuleResponse, error)

	InternalCreateBranchProtectionRuleWithResponse(ctx context.Context, repository string, body InternalCreateBranchProtectionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalCreateBranchProtectionRuleResponse, error)

	// CreateBranchProtectionRulePreflight request
	CreateBranchProtectionRulePreflightWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*CreateBranchProtectionRulePreflightResponse, error)

	// ListBranches request
	ListBranchesWithResponse(ctx context.Context, repository string, params *ListBranchesParams, reqEditors ...RequestEditorFn) (*ListBranchesResponse, error)

	// CreateBranch request  with any body
	CreateBranchWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBranchResponse, error)

	CreateBranchWithResponse(ctx context.Context, repository string, body CreateBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBranchResponse, error)

	// DeleteBranch request
	DeleteBranchWithResponse(ctx context.Context, repository string, branch string, params *DeleteBranchParams, reqEditors ...RequestEditorFn) (*DeleteBranchResponse, error)

	// GetBranch request
	GetBranchWithResponse(ctx context.Context, repository string, branch string, reqEditors ...RequestEditorFn) (*GetBranchResponse, error)

	// ResetBranch request  with any body
	ResetBranchWithBodyWithResponse(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetBranchResponse, error)

	ResetBranchWithResponse(ctx context.Context, repository string, branch string, body ResetBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetBranchResponse, error)

	// CherryPick request  with any body
	CherryPickWithBodyWithResponse(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CherryPickResponse, error)

	CherryPickWithResponse(ctx context.Context, repository string, branch string, body CherryPickJSONRequestBody, reqEditors ...RequestEditorFn) (*CherryPickResponse, error)

	// Commit request  with any body
	CommitWithBodyWithResponse(ctx context.Context, repository string, branch string, params *CommitParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommitResponse, error)

	CommitWithResponse(ctx context.Context, repository string, branch string, params *CommitParams, body CommitJSONRequestBody, reqEditors ...RequestEditorFn) (*CommitResponse, error)

	// CommitAsync request  with any body
	CommitAsyncWithBodyWithResponse(ctx context.Context, repository string, branch string, params *CommitAsyncParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommitAsyncResponse, error)

	CommitAsyncWithResponse(ctx context.Context, repository string, branch string, params *CommitAsyncParams, body CommitAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*CommitAsyncResponse, error)

	// CommitAsyncStatus request
	CommitAsyncStatusWithResponse(ctx context.Context, repository string, branch string, id string, reqEditors ...RequestEditorFn) (*CommitAsyncStatusResponse, error)

	// DiffBranch request
	DiffBranchWithResponse(ctx context.Context, repository string, branch string, params *DiffBranchParams, reqEditors ...RequestEditorFn) (*DiffBranchResponse, error)

	// HardResetBranch request
	HardResetBranchWithResponse(ctx context.Context, repository string, branch string, params *HardResetBranchParams, reqEditors ...RequestEditorFn) (*HardResetBranchResponse, error)

	// ImportCancel request
	ImportCancelWithResponse(ctx context.Context, repository string, branch string, params *ImportCancelParams, reqEditors ...RequestEditorFn) (*ImportCancelResponse, error)

	// ImportStatus request
	ImportStatusWithResponse(ctx context.Context, repository string, branch string, params *ImportStatusParams, reqEditors ...RequestEditorFn) (*ImportStatusResponse, error)

	// ImportStart request  with any body
	ImportStartWithBodyWithResponse(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportStartResponse, error)

	ImportStartWithResponse(ctx context.Context, repository string, branch string, body ImportStartJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportStartResponse, error)

	// DeleteObject request
	DeleteObjectWithResponse(ctx context.Context, repository string, branch string, params *DeleteObjectParams, reqEditors ...RequestEditorFn) (*DeleteObjectResponse, error)

	// UploadObject request  with any body
	UploadObjectWithBodyWithResponse(ctx context.Context, repository string, branch string, params *UploadObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadObjectResponse, error)

	// StageObject request  with any body
	StageObjectWithBodyWithResponse(ctx context.Context, repository string, branch string, params *StageObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StageObjectResponse, error)

	StageObjectWithResponse(ctx context.Context, repository string, branch string, params *StageObjectParams, body StageObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*StageObjectResponse, error)

	// CopyObject request  with any body
	CopyObjectWithBodyWithResponse(ctx context.Context, repository string, branch string, params *CopyObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CopyObjectResponse, error)

	CopyObjectWithResponse(ctx context.Context, repository string, branch string, params *CopyObjectParams, body CopyObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CopyObjectResponse, error)

	// DeleteObjects request  with any body
	DeleteObjectsWithBodyWithResponse(ctx context.Context, repository string, branch string, params *DeleteObjectsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteObjectsResponse, error)

	DeleteObjectsWithResponse(ctx context.Context, repository string, branch string, params *DeleteObjectsParams, body DeleteObjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteObjectsResponse, error)

	// UploadObjectPreflight request
	UploadObjectPreflightWithResponse(ctx context.Context, repository string, branch string, params *UploadObjectPreflightParams, reqEditors ...RequestEditorFn) (*UploadObjectPreflightResponse, error)

	// UpdateObjectUserMetadata request  with any body
	UpdateObjectUserMetadataWithBodyWithResponse(ctx context.Context, repository string, branch string, params *UpdateObjectUserMetadataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateObjectUserMetadataResponse, error)

	UpdateObjectUserMetadataWithResponse(ctx context.Context, repository string, branch string, params *UpdateObjectUserMetadataParams, body UpdateObjectUserMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateObjectUserMetadataResponse, error)

	// RevertBranch request  with any body
	RevertBranchWithBodyWithResponse(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevertBranchResponse, error)

	RevertBranchWithResponse(ctx context.Context, repository string, branch string, body RevertBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*RevertBranchResponse, error)

	// GetPhysicalAddress request
	GetPhysicalAddressWithResponse(ctx context.Context, repository string, branch string, params *GetPhysicalAddressParams, reqEditors ...RequestEditorFn) (*GetPhysicalAddressResponse, error)

	// LinkPhysicalAddress request  with any body
	LinkPhysicalAddressWithBodyWithResponse(ctx context.Context, repository string, branch string, params *LinkPhysicalAddressParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkPhysicalAddressResponse, error)

	LinkPhysicalAddressWithResponse(ctx context.Context, repository string, branch string, params *LinkPhysicalAddressParams, body LinkPhysicalAddressJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkPhysicalAddressResponse, error)

	// CreatePresignMultipartUpload request
	CreatePresignMultipartUploadWithResponse(ctx context.Context, repository string, branch string, params *CreatePresignMultipartUploadParams, reqEditors ...RequestEditorFn) (*CreatePresignMultipartUploadResponse, error)

	// AbortPresignMultipartUpload request  with any body
	AbortPresignMultipartUploadWithBodyWithResponse(ctx context.Context, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AbortPresignMultipartUploadResponse, error)

	AbortPresignMultipartUploadWithResponse(ctx context.Context, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, body AbortPresignMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*AbortPresignMultipartUploadResponse, error)

	// CompletePresignMultipartUpload request  with any body
	CompletePresignMultipartUploadWithBodyWithResponse(ctx context.Context, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompletePresignMultipartUploadResponse, error)

	CompletePresignMultipartUploadWithResponse(ctx context.Context, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, body CompletePresignMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*CompletePresignMultipartUploadResponse, error)

	// UploadPart request  with any body
	UploadPartWithBodyWithResponse(ctx context.Context, repository string, branch string, uploadId string, partNumber int, params *UploadPartParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadPartResponse, error)

	UploadPartWithResponse(ctx context.Context, repository string, branch string, uploadId string, partNumber int, params *UploadPartParams, body UploadPartJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadPartResponse, error)

	// UploadPartCopy request  with any body
	UploadPartCopyWithBodyWithResponse(ctx context.Context, repository string, branch string, uploadId string, partNumber int, params *UploadPartCopyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadPartCopyResponse, error)

	UploadPartCopyWithResponse(ctx context.Context, repository string, branch string, uploadId string, partNumber int, params *UploadPartCopyParams, body UploadPartCopyJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadPartCopyResponse, error)

	// CreateCommitRecord request  with any body
	CreateCommitRecordWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCommitRecordResponse, error)

	CreateCommitRecordWithResponse(ctx context.Context, repository string, body CreateCommitRecordJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCommitRecordResponse, error)

	// GetCommit request
	GetCommitWithResponse(ctx context.Context, repository string, commitId string, reqEditors ...RequestEditorFn) (*GetCommitResponse, error)

	// DumpStatus request
	DumpStatusWithResponse(ctx context.Context, repository string, params *DumpStatusParams, reqEditors ...RequestEditorFn) (*DumpStatusResponse, error)

	// DumpSubmit request
	DumpSubmitWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*DumpSubmitResponse, error)

	// PrepareGarbageCollectionCommits request
	PrepareGarbageCollectionCommitsWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*PrepareGarbageCollectionCommitsResponse, error)

	// PrepareGarbageCollectionCommitsAsync request
	PrepareGarbageCollectionCommitsAsyncWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*PrepareGarbageCollectionCommitsAsyncResponse, error)

	// PrepareGarbageCollectionCommitsStatus request
	PrepareGarbageCollectionCommitsStatusWithResponse(ctx context.Context, repository string, params *PrepareGarbageCollectionCommitsStatusParams, reqEditors ...RequestEditorFn) (*PrepareGarbageCollectionCommitsStatusResponse, error)

	// PrepareGarbageCollectionUncommitted request  with any body
	PrepareGarbageCollectionUncommittedWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrepareGarbageCollectionUncommittedResponse, error)

	PrepareGarbageCollectionUncommittedWithResponse(ctx context.Context, repository string, body PrepareGarbageCollectionUncommittedJSONRequestBody, reqEditors ...RequestEditorFn) (*PrepareGarbageCollectionUncommittedResponse, error)

	// InternalDeleteGarbageCollectionRules request
	InternalDeleteGarbageCollectionRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*InternalDeleteGarbageCollectionRulesResponse, error)

	// InternalGetGarbageCollectionRules request
	InternalGetGarbageCollectionRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*InternalGetGarbageCollectionRulesResponse, error)

	// InternalSetGarbageCollectionRules request  with any body
	InternalSetGarbageCollectionRulesWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalSetGarbageCollectionRulesResponse, error)

	InternalSetGarbageCollectionRulesWithResponse(ctx context.Context, repository string, body InternalSetGarbageCollectionRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalSetGarbageCollectionRulesResponse, error)

	// SetGarbageCollectionRulesPreflight request
	SetGarbageCollectionRulesPreflightWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*SetGarbageCollectionRulesPreflightResponse, error)

	// DeleteRepositoryMetadata request  with any body
	DeleteRepositoryMetadataWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteRepositoryMetadataResponse, error)

	DeleteRepositoryMetadataWithResponse(ctx context.Context, repository string, body DeleteRepositoryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteRepositoryMetadataResponse, error)

	// GetRepositoryMetadata request
	GetRepositoryMetadataWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*GetRepositoryMetadataResponse, error)

	// SetRepositoryMetadata request  with any body
	SetRepositoryMetadataWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetRepositoryMetadataResponse, error)

	SetRepositoryMetadataWithResponse(ctx context.Context, repository string, body SetRepositoryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*SetRepositoryMetadataResponse, error)

	// GetMetaRange request
	GetMetaRangeWithResponse(ctx context.Context, repository string, metaRange string, reqEditors ...RequestEditorFn) (*GetMetaRangeResponse, error)

	// GetMetadataObject request
	GetMetadataObjectWithResponse(ctx context.Context, repository string, pType string, objectId string, params *GetMetadataObjectParams, reqEditors ...RequestEditorFn) (*GetMetadataObjectResponse, error)

	// GetRange request
	GetRangeWithResponse(ctx context.Context, repository string, pRange string, reqEditors ...RequestEditorFn) (*GetRangeResponse, error)

	// ListPullRequests request
	ListPullRequestsWithResponse(ctx context.Context, repository string, params *ListPullRequestsParams, reqEditors ...RequestEditorFn) (*ListPullRequestsResponse, error)

	// CreatePullRequest request  with any body
	CreatePullRequestWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePullRequestResponse, error)

	CreatePullRequestWithResponse(ctx context.Context, repository string, body CreatePullRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePullRequestResponse, error)

	// GetPullRequest request
	GetPullRequestWithResponse(ctx context.Context, repository string, pullRequest string, reqEditors ...RequestEditorFn) (*GetPullRequestResponse, error)

	// UpdatePullRequest request  with any body
	UpdatePullRequestWithBodyWithResponse(ctx context.Context, repository string, pullRequest string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePullRequestResponse, error)

	UpdatePullRequestWithResponse(ctx context.Context, repository string, pullRequest string, body UpdatePullRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePullRequestResponse, error)

	// MergePullRequest request
	MergePullRequestWithResponse(ctx context.Context, repository string, pullRequest string, reqEditors ...RequestEditorFn) (*MergePullRequestResponse, error)

	// DumpRefs request
	DumpRefsWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*DumpRefsResponse, error)

	// RestoreRefs request  with any body
	RestoreRefsWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestoreRefsResponse, error)

	RestoreRefsWithResponse(ctx context.Context, repository string, body RestoreRefsJSONRequestBody, reqEditors ...RequestEditorFn) (*RestoreRefsResponse, error)

	// CreateSymlinkFile request
	CreateSymlinkFileWithResponse(ctx context.Context, repository string, branch string, params *CreateSymlinkFileParams, reqEditors ...RequestEditorFn) (*CreateSymlinkFileResponse, error)

	// DiffRefs request
	DiffRefsWithResponse(ctx context.Context, repository string, leftRef string, rightRef string, params *DiffRefsParams, reqEditors ...RequestEditorFn) (*DiffRefsResponse, error)

	// LogCommits request
	LogCommitsWithResponse(ctx context.Context, repository string, ref string, params *LogCommitsParams, reqEditors ...RequestEditorFn) (*LogCommitsResponse, error)

	// GetObject request
	GetObjectWithResponse(ctx context.Context, repository string, ref string, params *GetObjectParams, reqEditors ...RequestEditorFn) (*GetObjectResponse, error)

	// HeadObject request
	HeadObjectWithResponse(ctx context.Context, repository string, ref string, params *HeadObjectParams, reqEditors ...RequestEditorFn) (*HeadObjectResponse, error)

	// ListObjects request
	ListObjectsWithResponse(ctx context.Context, repository string, ref string, params *ListObjectsParams, reqEditors ...RequestEditorFn) (*ListObjectsResponse, error)

	// StatObject request
	StatObjectWithResponse(ctx context.Context, repository string, ref string, params *StatObjectParams, reqEditors ...RequestEditorFn) (*StatObjectResponse, error)

	// GetUnderlyingProperties request
	GetUnderlyingPropertiesWithResponse(ctx context.Context, repository string, ref string, params *GetUnderlyingPropertiesParams, reqEditors ...RequestEditorFn) (*GetUnderlyingPropertiesResponse, error)

	// FindMergeBase request
	FindMergeBaseWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, reqEditors ...RequestEditorFn) (*FindMergeBaseResponse, error)

	// MergeIntoBranch request  with any body
	MergeIntoBranchWithBodyWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeIntoBranchResponse, error)

	MergeIntoBranchWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, body MergeIntoBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeIntoBranchResponse, error)

	// MergeIntoBranchAsync request  with any body
	MergeIntoBranchAsyncWithBodyWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeIntoBranchAsyncResponse, error)

	MergeIntoBranchAsyncWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, body MergeIntoBranchAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeIntoBranchAsyncResponse, error)

	// MergeIntoBranchAsyncStatus request
	MergeIntoBranchAsyncStatusWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, id string, reqEditors ...RequestEditorFn) (*MergeIntoBranchAsyncStatusResponse, error)

	// RestoreStatus request
	RestoreStatusWithResponse(ctx context.Context, repository string, params *RestoreStatusParams, reqEditors ...RequestEditorFn) (*RestoreStatusResponse, error)

	// RestoreSubmit request  with any body
	RestoreSubmitWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestoreSubmitResponse, error)

	RestoreSubmitWithResponse(ctx context.Context, repository string, body RestoreSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*RestoreSubmitResponse, error)

	// GetBranchProtectionRules request
	GetBranchProtectionRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*GetBranchProtectionRulesResponse, error)

	// SetBranchProtectionRules request  with any body
	SetBranchProtectionRulesWithBodyWithResponse(ctx context.Context, repository string, params *SetBranchProtectionRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetBranchProtectionRulesResponse, error)

	SetBranchProtectionRulesWithResponse(ctx context.Context, repository string, params *SetBranchProtectionRulesParams, body SetBranchProtectionRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetBranchProtectionRulesResponse, error)

	// DeleteGCRules request
	DeleteGCRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*DeleteGCRulesResponse, error)

	// GetGCRules request
	GetGCRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*GetGCRulesResponse, error)

	// SetGCRules request  with any body
	SetGCRulesWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetGCRulesResponse, error)

	SetGCRulesWithResponse(ctx context.Context, repository string, body SetGCRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetGCRulesResponse, error)

	// ListTags request
	ListTagsWithResponse(ctx context.Context, repository string, params *ListTagsParams, reqEditors ...RequestEditorFn) (*ListTagsResponse, error)

	// CreateTag request  with any body
	CreateTagWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTagResponse, error)

	CreateTagWithResponse(ctx context.Context, repository string, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTagResponse, error)

	// DeleteTag request
	DeleteTagWithResponse(ctx context.Context, repository string, tag string, params *DeleteTagParams, reqEditors ...RequestEditorFn) (*DeleteTagResponse, error)

	// GetTag request
	GetTagWithResponse(ctx context.Context, repository string, tag string, reqEditors ...RequestEditorFn) (*GetTagResponse, error)

	// SetupCommPrefs request  with any body
	SetupCommPrefsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetupCommPrefsResponse, error)

	SetupCommPrefsWithResponse(ctx context.Context, body SetupCommPrefsJSONRequestBody, reqEditors ...RequestEditorFn) (*SetupCommPrefsResponse, error)

	// GetSetupState request
	GetSetupStateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSetupStateResponse, error)

	// Setup request  with any body
	SetupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetupResponse, error)

	SetupWithResponse(ctx context.Context, body SetupJSONRequestBody, reqEditors ...RequestEditorFn) (*SetupResponse, error)

	// PostStatsEvents request  with any body
	PostStatsEventsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStatsEventsResponse, error)

	PostStatsEventsWithResponse(ctx context.Context, body PostStatsEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStatsEventsResponse, error)

	// StsLogin request  with any body
	StsLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StsLoginResponse, error)

	StsLoginWithResponse(ctx context.Context, body StsLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*StsLoginResponse, error)

	// GetUsageReportSummary request
	GetUsageReportSummaryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUsageReportSummaryResponse, error)

	// GetCurrentUser request
	GetCurrentUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentUserResponse, error)
}

type GetAuthCapabilitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthCapabilities
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetAuthCapabilitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthCapabilitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExternalPrincipalLoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthenticationToken
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ExternalPrincipalLoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExternalPrincipalLoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExternalPrincipalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExternalPrincipal
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetExternalPrincipalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExternalPrincipalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTokenFromMailboxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthenticationToken
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON501      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetTokenFromMailboxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTokenFromMailboxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReleaseTokenToMailboxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON501      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ReleaseTokenToMailboxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReleaseTokenToMailboxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTokenRedirectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON501      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetTokenRedirectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTokenRedirectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupList
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Group
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Group
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupACLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ACL
	JSON400      *Error
	JSON401      *Error
	JSON404      *ErrorNoACL
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetGroupACLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupACLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetGroupACLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SetGroupACLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetGroupACLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGroupMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserList
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListGroupMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGroupMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupMembershipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteGroupMembershipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupMembershipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddGroupMembershipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AddGroupMembershipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddGroupMembershipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGroupPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyList
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListGroupPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGroupPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DetachPolicyFromGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DetachPolicyFromGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DetachPolicyFromGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachPolicyToGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AttachPolicyToGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachPolicyToGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthenticationToken
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r LoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyList
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Policy
	JSON400      *Error
	JSON401      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreatePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeletePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Policy
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Policy
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdatePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserList
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *User
	JSON400      *Error
	JSON401      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CredentialsList
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListUserCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CredentialsWithSecret
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Credentials
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserExternalPrincipalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteUserExternalPrincipalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserExternalPrincipalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserExternalPrincipalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateUserExternalPrincipalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserExternalPrincipalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserExternalPrincipalsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExternalPrincipalList
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListUserExternalPrincipalsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserExternalPrincipalsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupList
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListUserGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyList
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListUserPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DetachPolicyFromUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DetachPolicyFromUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DetachPolicyFromUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachPolicyToUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AttachPolicyToUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachPolicyToUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Config
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r GetConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGarbageCollectionConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GarbageCollectionConfig
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r GetGarbageCollectionConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGarbageCollectionConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStorageConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StorageConfig
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r GetStorageConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStorageConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLakeFSVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VersionConfig
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r GetLakeFSVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLakeFSVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HealthCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HealthCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PullIcebergTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PullIcebergTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PullIcebergTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PushIcebergTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PushIcebergTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PushIcebergTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLicenseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *License
	JSON401      *Error
	JSON501      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetLicenseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLicenseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r OauthCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRepositoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RepositoryList
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListRepositoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRepositoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Repository
	JSON400      *Error
	JSON401      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Repository
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRepositoryRunsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionRunList
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListRepositoryRunsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRepositoryRunsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionRun
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRunHooksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HookRunList
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListRunHooksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRunHooksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRunHookOutputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRunHookOutputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRunHookOutputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalDeleteBranchProtectionRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r InternalDeleteBranchProtectionRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalDeleteBranchProtectionRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalGetBranchProtectionRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]BranchProtectionRule
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r InternalGetBranchProtectionRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalGetBranchProtectionRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalCreateBranchProtectionRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r InternalCreateBranchProtectionRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalCreateBranchProtectionRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBranchProtectionRulePreflightResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateBranchProtectionRulePreflightResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBranchProtectionRulePreflightResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBranchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RefList
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListBranchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBranchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Ref
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ResetBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CherryPickResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Commit
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CherryPickResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CherryPickResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Commit
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	JSON412      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CommitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommitAsyncResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *TaskCreation
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON501      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CommitAsyncResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommitAsyncResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommitAsyncStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommitAsyncStatus
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	JSON412      *Error
	JSON501      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CommitAsyncStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommitAsyncStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DiffBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DiffList
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DiffBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DiffBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HardResetBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r HardResetBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HardResetBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ImportCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ImportStatus
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ImportStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportStartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *ImportCreationResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ImportStartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportStartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ObjectStats
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON412      *Error
	JSON501      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UploadObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StageObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ObjectStats
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r StageObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StageObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CopyObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ObjectStats
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CopyObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CopyObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteObjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectErrorList
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteObjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteObjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadObjectPreflightResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UploadObjectPreflightResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadObjectPreflightResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateObjectUserMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdateObjectUserMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateObjectUserMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevertBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r RevertBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevertBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPhysicalAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StagingLocation
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetPhysicalAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPhysicalAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkPhysicalAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStats
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *StagingLocation
	JSON412      *Error
	JSON501      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r LinkPhysicalAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkPhysicalAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePresignMultipartUploadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PresignMultipartUpload
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreatePresignMultipartUploadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePresignMultipartUploadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AbortPresignMultipartUploadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AbortPresignMultipartUploadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AbortPresignMultipartUploadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompletePresignMultipartUploadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStats
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON409      *StagingLocation
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CompletePresignMultipartUploadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompletePresignMultipartUploadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadPartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UploadTo
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UploadPartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadPartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadPartCopyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UploadPartCopyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadPartCopyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCommitRecordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateCommitRecordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCommitRecordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCommitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Commit
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetCommitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCommitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DumpStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RepositoryDumpStatus
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DumpStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DumpStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DumpSubmitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *TaskInfo
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DumpSubmitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DumpSubmitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PrepareGarbageCollectionCommitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *GarbageCollectionPrepareResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PrepareGarbageCollectionCommitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PrepareGarbageCollectionCommitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PrepareGarbageCollectionCommitsAsyncResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *TaskCreation
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PrepareGarbageCollectionCommitsAsyncResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PrepareGarbageCollectionCommitsAsyncResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PrepareGarbageCollectionCommitsStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PrepareGarbageCollectionCommitsStatus
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PrepareGarbageCollectionCommitsStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PrepareGarbageCollectionCommitsStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PrepareGarbageCollectionUncommittedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PrepareGCUncommittedResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PrepareGarbageCollectionUncommittedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PrepareGarbageCollectionUncommittedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalDeleteGarbageCollectionRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r InternalDeleteGarbageCollectionRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalDeleteGarbageCollectionRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalGetGarbageCollectionRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GarbageCollectionRules
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r InternalGetGarbageCollectionRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalGetGarbageCollectionRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalSetGarbageCollectionRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r InternalSetGarbageCollectionRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalSetGarbageCollectionRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetGarbageCollectionRulesPreflightResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SetGarbageCollectionRulesPreflightResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetGarbageCollectionRulesPreflightResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRepositoryMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteRepositoryMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRepositoryMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRepositoryMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RepositoryMetadata
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRepositoryMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRepositoryMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetRepositoryMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SetRepositoryMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetRepositoryMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMetaRangeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StorageURI
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetMetaRangeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetaRangeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMetadataObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetMetadataObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetadataObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRangeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StorageURI
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRangeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRangeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPullRequestsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PullRequestsList
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListPullRequestsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPullRequestsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePullRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PullRequestCreationResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreatePullRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePullRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPullRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PullRequest
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetPullRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPullRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePullRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdatePullRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePullRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergePullRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MergeResult
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *MergeResult
	JSON412      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r MergePullRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergePullRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DumpRefsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RefsDump
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DumpRefsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DumpRefsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreRefsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r RestoreRefsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreRefsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSymlinkFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *StorageURI
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateSymlinkFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSymlinkFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DiffRefsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DiffList
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DiffRefsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DiffRefsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogCommitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommitList
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r LogCommitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogCommitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON410      *Error
	JSON416      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HeadObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HeadObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HeadObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListObjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStatsList
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListObjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListObjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StatObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStats
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r StatObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StatObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUnderlyingPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UnderlyingObjectProperties
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetUnderlyingPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUnderlyingPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindMergeBaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FindMergeBaseResult
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r FindMergeBaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindMergeBaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeIntoBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MergeResult
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *MergeResult
	JSON412      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r MergeIntoBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeIntoBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeIntoBranchAsyncResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *TaskCreation
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON501      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r MergeIntoBranchAsyncResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeIntoBranchAsyncResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeIntoBranchAsyncStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MergeAsyncStatus
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	JSON412      *Error
	JSON501      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r MergeIntoBranchAsyncStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeIntoBranchAsyncStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RepositoryRestoreStatus
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r RestoreStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreSubmitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *TaskInfo
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r RestoreSubmitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreSubmitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBranchProtectionRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]BranchProtectionRule
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetBranchProtectionRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBranchProtectionRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetBranchProtectionRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON412      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SetBranchProtectionRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetBranchProtectionRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGCRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteGCRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGCRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGCRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GarbageCollectionRules
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetGCRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGCRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetGCRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SetGCRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetGCRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RefList
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Ref
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Ref
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetupCommPrefsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON409      *Error
	JSON412      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SetupCommPrefsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetupCommPrefsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSetupStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SetupState
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSetupStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSetupStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CredentialsWithSecret
	JSON400      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SetupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostStatsEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostStatsEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostStatsEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StsLoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthenticationToken
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r StsLoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StsLoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsageReportSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InstallationUsageReport
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetUsageReportSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsageReportSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CurrentUser
}

// Status returns HTTPResponse.Status
func (r GetCurrentUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAuthCapabilitiesWithResponse request returning *GetAuthCapabilitiesResponse
func (c *ClientWithResponses) GetAuthCapabilitiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAuthCapabilitiesResponse, error) {
	rsp, err := c.GetAuthCapabilities(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthCapabilitiesResponse(rsp)
}

// ExternalPrincipalLoginWithBodyWithResponse request with arbitrary body returning *ExternalPrincipalLoginResponse
func (c *ClientWithResponses) ExternalPrincipalLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExternalPrincipalLoginResponse, error) {
	rsp, err := c.ExternalPrincipalLoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExternalPrincipalLoginResponse(rsp)
}

func (c *ClientWithResponses) ExternalPrincipalLoginWithResponse(ctx context.Context, body ExternalPrincipalLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*ExternalPrincipalLoginResponse, error) {
	rsp, err := c.ExternalPrincipalLogin(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExternalPrincipalLoginResponse(rsp)
}

// GetExternalPrincipalWithResponse request returning *GetExternalPrincipalResponse
func (c *ClientWithResponses) GetExternalPrincipalWithResponse(ctx context.Context, params *GetExternalPrincipalParams, reqEditors ...RequestEditorFn) (*GetExternalPrincipalResponse, error) {
	rsp, err := c.GetExternalPrincipal(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExternalPrincipalResponse(rsp)
}

// GetTokenFromMailboxWithResponse request returning *GetTokenFromMailboxResponse
func (c *ClientWithResponses) GetTokenFromMailboxWithResponse(ctx context.Context, mailbox string, reqEditors ...RequestEditorFn) (*GetTokenFromMailboxResponse, error) {
	rsp, err := c.GetTokenFromMailbox(ctx, mailbox, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTokenFromMailboxResponse(rsp)
}

// ReleaseTokenToMailboxWithResponse request returning *ReleaseTokenToMailboxResponse
func (c *ClientWithResponses) ReleaseTokenToMailboxWithResponse(ctx context.Context, loginRequestToken string, reqEditors ...RequestEditorFn) (*ReleaseTokenToMailboxResponse, error) {
	rsp, err := c.ReleaseTokenToMailbox(ctx, loginRequestToken, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReleaseTokenToMailboxResponse(rsp)
}

// GetTokenRedirectWithResponse request returning *GetTokenRedirectResponse
func (c *ClientWithResponses) GetTokenRedirectWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTokenRedirectResponse, error) {
	rsp, err := c.GetTokenRedirect(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTokenRedirectResponse(rsp)
}

// ListGroupsWithResponse request returning *ListGroupsResponse
func (c *ClientWithResponses) ListGroupsWithResponse(ctx context.Context, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*ListGroupsResponse, error) {
	rsp, err := c.ListGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGroupsResponse(rsp)
}

// CreateGroupWithBodyWithResponse request with arbitrary body returning *CreateGroupResponse
func (c *ClientWithResponses) CreateGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateGroupWithResponse(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

// DeleteGroupWithResponse request returning *DeleteGroupResponse
func (c *ClientWithResponses) DeleteGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error) {
	rsp, err := c.DeleteGroup(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupResponse(rsp)
}

// GetGroupWithResponse request returning *GetGroupResponse
func (c *ClientWithResponses) GetGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*GetGroupResponse, error) {
	rsp, err := c.GetGroup(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupResponse(rsp)
}

// GetGroupACLWithResponse request returning *GetGroupACLResponse
func (c *ClientWithResponses) GetGroupACLWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*GetGroupACLResponse, error) {
	rsp, err := c.GetGroupACL(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupACLResponse(rsp)
}

// SetGroupACLWithBodyWithResponse request with arbitrary body returning *SetGroupACLResponse
func (c *ClientWithResponses) SetGroupACLWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetGroupACLResponse, error) {
	rsp, err := c.SetGroupACLWithBody(ctx, groupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetGroupACLResponse(rsp)
}

func (c *ClientWithResponses) SetGroupACLWithResponse(ctx context.Context, groupId string, body SetGroupACLJSONRequestBody, reqEditors ...RequestEditorFn) (*SetGroupACLResponse, error) {
	rsp, err := c.SetGroupACL(ctx, groupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetGroupACLResponse(rsp)
}

// ListGroupMembersWithResponse request returning *ListGroupMembersResponse
func (c *ClientWithResponses) ListGroupMembersWithResponse(ctx context.Context, groupId string, params *ListGroupMembersParams, reqEditors ...RequestEditorFn) (*ListGroupMembersResponse, error) {
	rsp, err := c.ListGroupMembers(ctx, groupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGroupMembersResponse(rsp)
}

// DeleteGroupMembershipWithResponse request returning *DeleteGroupMembershipResponse
func (c *ClientWithResponses) DeleteGroupMembershipWithResponse(ctx context.Context, groupId string, userId string, reqEditors ...RequestEditorFn) (*DeleteGroupMembershipResponse, error) {
	rsp, err := c.DeleteGroupMembership(ctx, groupId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupMembershipResponse(rsp)
}

// AddGroupMembershipWithResponse request returning *AddGroupMembershipResponse
func (c *ClientWithResponses) AddGroupMembershipWithResponse(ctx context.Context, groupId string, userId string, reqEditors ...RequestEditorFn) (*AddGroupMembershipResponse, error) {
	rsp, err := c.AddGroupMembership(ctx, groupId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddGroupMembershipResponse(rsp)
}

// ListGroupPoliciesWithResponse request returning *ListGroupPoliciesResponse
func (c *ClientWithResponses) ListGroupPoliciesWithResponse(ctx context.Context, groupId string, params *ListGroupPoliciesParams, reqEditors ...RequestEditorFn) (*ListGroupPoliciesResponse, error) {
	rsp, err := c.ListGroupPolicies(ctx, groupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGroupPoliciesResponse(rsp)
}

// DetachPolicyFromGroupWithResponse request returning *DetachPolicyFromGroupResponse
func (c *ClientWithResponses) DetachPolicyFromGroupWithResponse(ctx context.Context, groupId string, policyId string, reqEditors ...RequestEditorFn) (*DetachPolicyFromGroupResponse, error) {
	rsp, err := c.DetachPolicyFromGroup(ctx, groupId, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDetachPolicyFromGroupResponse(rsp)
}

// AttachPolicyToGroupWithResponse request returning *AttachPolicyToGroupResponse
func (c *ClientWithResponses) AttachPolicyToGroupWithResponse(ctx context.Context, groupId string, policyId string, reqEditors ...RequestEditorFn) (*AttachPolicyToGroupResponse, error) {
	rsp, err := c.AttachPolicyToGroup(ctx, groupId, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachPolicyToGroupResponse(rsp)
}

// LoginWithBodyWithResponse request with arbitrary body returning *LoginResponse
func (c *ClientWithResponses) LoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.LoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

func (c *ClientWithResponses) LoginWithResponse(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.Login(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

// ListPoliciesWithResponse request returning *ListPoliciesResponse
func (c *ClientWithResponses) ListPoliciesWithResponse(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*ListPoliciesResponse, error) {
	rsp, err := c.ListPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPoliciesResponse(rsp)
}

// CreatePolicyWithBodyWithResponse request with arbitrary body returning *CreatePolicyResponse
func (c *ClientWithResponses) CreatePolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error) {
	rsp, err := c.CreatePolicyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePolicyResponse(rsp)
}

func (c *ClientWithResponses) CreatePolicyWithResponse(ctx context.Context, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error) {
	rsp, err := c.CreatePolicy(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePolicyResponse(rsp)
}

// DeletePolicyWithResponse request returning *DeletePolicyResponse
func (c *ClientWithResponses) DeletePolicyWithResponse(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*DeletePolicyResponse, error) {
	rsp, err := c.DeletePolicy(ctx, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePolicyResponse(rsp)
}

// GetPolicyWithResponse request returning *GetPolicyResponse
func (c *ClientWithResponses) GetPolicyWithResponse(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*GetPolicyResponse, error) {
	rsp, err := c.GetPolicy(ctx, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPolicyResponse(rsp)
}

// UpdatePolicyWithBodyWithResponse request with arbitrary body returning *UpdatePolicyResponse
func (c *ClientWithResponses) UpdatePolicyWithBodyWithResponse(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error) {
	rsp, err := c.UpdatePolicyWithBody(ctx, policyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePolicyResponse(rsp)
}

func (c *ClientWithResponses) UpdatePolicyWithResponse(ctx context.Context, policyId string, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error) {
	rsp, err := c.UpdatePolicy(ctx, policyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePolicyResponse(rsp)
}

// ListUsersWithResponse request returning *ListUsersResponse
func (c *ClientWithResponses) ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error) {
	rsp, err := c.ListUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersResponse(rsp)
}

// CreateUserWithBodyWithResponse request with arbitrary body returning *CreateUserResponse
func (c *ClientWithResponses) CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

func (c *ClientWithResponses) CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// ListUserCredentialsWithResponse request returning *ListUserCredentialsResponse
func (c *ClientWithResponses) ListUserCredentialsWithResponse(ctx context.Context, userId string, params *ListUserCredentialsParams, reqEditors ...RequestEditorFn) (*ListUserCredentialsResponse, error) {
	rsp, err := c.ListUserCredentials(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserCredentialsResponse(rsp)
}

// CreateCredentialsWithResponse request returning *CreateCredentialsResponse
func (c *ClientWithResponses) CreateCredentialsWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*CreateCredentialsResponse, error) {
	rsp, err := c.CreateCredentials(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCredentialsResponse(rsp)
}

// DeleteCredentialsWithResponse request returning *DeleteCredentialsResponse
func (c *ClientWithResponses) DeleteCredentialsWithResponse(ctx context.Context, userId string, accessKeyId string, reqEditors ...RequestEditorFn) (*DeleteCredentialsResponse, error) {
	rsp, err := c.DeleteCredentials(ctx, userId, accessKeyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCredentialsResponse(rsp)
}

// GetCredentialsWithResponse request returning *GetCredentialsResponse
func (c *ClientWithResponses) GetCredentialsWithResponse(ctx context.Context, userId string, accessKeyId string, reqEditors ...RequestEditorFn) (*GetCredentialsResponse, error) {
	rsp, err := c.GetCredentials(ctx, userId, accessKeyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCredentialsResponse(rsp)
}

// DeleteUserExternalPrincipalWithResponse request returning *DeleteUserExternalPrincipalResponse
func (c *ClientWithResponses) DeleteUserExternalPrincipalWithResponse(ctx context.Context, userId string, params *DeleteUserExternalPrincipalParams, reqEditors ...RequestEditorFn) (*DeleteUserExternalPrincipalResponse, error) {
	rsp, err := c.DeleteUserExternalPrincipal(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserExternalPrincipalResponse(rsp)
}

// CreateUserExternalPrincipalWithBodyWithResponse request with arbitrary body returning *CreateUserExternalPrincipalResponse
func (c *ClientWithResponses) CreateUserExternalPrincipalWithBodyWithResponse(ctx context.Context, userId string, params *CreateUserExternalPrincipalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserExternalPrincipalResponse, error) {
	rsp, err := c.CreateUserExternalPrincipalWithBody(ctx, userId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserExternalPrincipalResponse(rsp)
}

func (c *ClientWithResponses) CreateUserExternalPrincipalWithResponse(ctx context.Context, userId string, params *CreateUserExternalPrincipalParams, body CreateUserExternalPrincipalJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserExternalPrincipalResponse, error) {
	rsp, err := c.CreateUserExternalPrincipal(ctx, userId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserExternalPrincipalResponse(rsp)
}

// ListUserExternalPrincipalsWithResponse request returning *ListUserExternalPrincipalsResponse
func (c *ClientWithResponses) ListUserExternalPrincipalsWithResponse(ctx context.Context, userId string, params *ListUserExternalPrincipalsParams, reqEditors ...RequestEditorFn) (*ListUserExternalPrincipalsResponse, error) {
	rsp, err := c.ListUserExternalPrincipals(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserExternalPrincipalsResponse(rsp)
}

// ListUserGroupsWithResponse request returning *ListUserGroupsResponse
func (c *ClientWithResponses) ListUserGroupsWithResponse(ctx context.Context, userId string, params *ListUserGroupsParams, reqEditors ...RequestEditorFn) (*ListUserGroupsResponse, error) {
	rsp, err := c.ListUserGroups(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserGroupsResponse(rsp)
}

// ListUserPoliciesWithResponse request returning *ListUserPoliciesResponse
func (c *ClientWithResponses) ListUserPoliciesWithResponse(ctx context.Context, userId string, params *ListUserPoliciesParams, reqEditors ...RequestEditorFn) (*ListUserPoliciesResponse, error) {
	rsp, err := c.ListUserPolicies(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserPoliciesResponse(rsp)
}

// DetachPolicyFromUserWithResponse request returning *DetachPolicyFromUserResponse
func (c *ClientWithResponses) DetachPolicyFromUserWithResponse(ctx context.Context, userId string, policyId string, reqEditors ...RequestEditorFn) (*DetachPolicyFromUserResponse, error) {
	rsp, err := c.DetachPolicyFromUser(ctx, userId, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDetachPolicyFromUserResponse(rsp)
}

// AttachPolicyToUserWithResponse request returning *AttachPolicyToUserResponse
func (c *ClientWithResponses) AttachPolicyToUserWithResponse(ctx context.Context, userId string, policyId string, reqEditors ...RequestEditorFn) (*AttachPolicyToUserResponse, error) {
	rsp, err := c.AttachPolicyToUser(ctx, userId, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachPolicyToUserResponse(rsp)
}

// GetConfigWithResponse request returning *GetConfigResponse
func (c *ClientWithResponses) GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigResponse, error) {
	rsp, err := c.GetConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigResponse(rsp)
}

// GetGarbageCollectionConfigWithResponse request returning *GetGarbageCollectionConfigResponse
func (c *ClientWithResponses) GetGarbageCollectionConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGarbageCollectionConfigResponse, error) {
	rsp, err := c.GetGarbageCollectionConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGarbageCollectionConfigResponse(rsp)
}

// GetStorageConfigWithResponse request returning *GetStorageConfigResponse
func (c *ClientWithResponses) GetStorageConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStorageConfigResponse, error) {
	rsp, err := c.GetStorageConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStorageConfigResponse(rsp)
}

// GetLakeFSVersionWithResponse request returning *GetLakeFSVersionResponse
func (c *ClientWithResponses) GetLakeFSVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLakeFSVersionResponse, error) {
	rsp, err := c.GetLakeFSVersion(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLakeFSVersionResponse(rsp)
}

// HealthCheckWithResponse request returning *HealthCheckResponse
func (c *ClientWithResponses) HealthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error) {
	rsp, err := c.HealthCheck(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthCheckResponse(rsp)
}

// PullIcebergTableWithBodyWithResponse request with arbitrary body returning *PullIcebergTableResponse
func (c *ClientWithResponses) PullIcebergTableWithBodyWithResponse(ctx context.Context, catalog string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PullIcebergTableResponse, error) {
	rsp, err := c.PullIcebergTableWithBody(ctx, catalog, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullIcebergTableResponse(rsp)
}

func (c *ClientWithResponses) PullIcebergTableWithResponse(ctx context.Context, catalog string, body PullIcebergTableJSONRequestBody, reqEditors ...RequestEditorFn) (*PullIcebergTableResponse, error) {
	rsp, err := c.PullIcebergTable(ctx, catalog, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullIcebergTableResponse(rsp)
}

// PushIcebergTableWithBodyWithResponse request with arbitrary body returning *PushIcebergTableResponse
func (c *ClientWithResponses) PushIcebergTableWithBodyWithResponse(ctx context.Context, catalog string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PushIcebergTableResponse, error) {
	rsp, err := c.PushIcebergTableWithBody(ctx, catalog, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePushIcebergTableResponse(rsp)
}

func (c *ClientWithResponses) PushIcebergTableWithResponse(ctx context.Context, catalog string, body PushIcebergTableJSONRequestBody, reqEditors ...RequestEditorFn) (*PushIcebergTableResponse, error) {
	rsp, err := c.PushIcebergTable(ctx, catalog, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePushIcebergTableResponse(rsp)
}

// GetLicenseWithResponse request returning *GetLicenseResponse
func (c *ClientWithResponses) GetLicenseWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLicenseResponse, error) {
	rsp, err := c.GetLicense(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLicenseResponse(rsp)
}

// OauthCallbackWithResponse request returning *OauthCallbackResponse
func (c *ClientWithResponses) OauthCallbackWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*OauthCallbackResponse, error) {
	rsp, err := c.OauthCallback(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthCallbackResponse(rsp)
}

// ListRepositoriesWithResponse request returning *ListRepositoriesResponse
func (c *ClientWithResponses) ListRepositoriesWithResponse(ctx context.Context, params *ListRepositoriesParams, reqEditors ...RequestEditorFn) (*ListRepositoriesResponse, error) {
	rsp, err := c.ListRepositories(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRepositoriesResponse(rsp)
}

// CreateRepositoryWithBodyWithResponse request with arbitrary body returning *CreateRepositoryResponse
func (c *ClientWithResponses) CreateRepositoryWithBodyWithResponse(ctx context.Context, params *CreateRepositoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRepositoryResponse, error) {
	rsp, err := c.CreateRepositoryWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRepositoryResponse(rsp)
}

func (c *ClientWithResponses) CreateRepositoryWithResponse(ctx context.Context, params *CreateRepositoryParams, body CreateRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRepositoryResponse, error) {
	rsp, err := c.CreateRepository(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRepositoryResponse(rsp)
}

// DeleteRepositoryWithResponse request returning *DeleteRepositoryResponse
func (c *ClientWithResponses) DeleteRepositoryWithResponse(ctx context.Context, repository string, params *DeleteRepositoryParams, reqEditors ...RequestEditorFn) (*DeleteRepositoryResponse, error) {
	rsp, err := c.DeleteRepository(ctx, repository, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRepositoryResponse(rsp)
}

// GetRepositoryWithResponse request returning *GetRepositoryResponse
func (c *ClientWithResponses) GetRepositoryWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*GetRepositoryResponse, error) {
	rsp, err := c.GetRepository(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRepositoryResponse(rsp)
}

// ListRepositoryRunsWithResponse request returning *ListRepositoryRunsResponse
func (c *ClientWithResponses) ListRepositoryRunsWithResponse(ctx context.Context, repository string, params *ListRepositoryRunsParams, reqEditors ...RequestEditorFn) (*ListRepositoryRunsResponse, error) {
	rsp, err := c.ListRepositoryRuns(ctx, repository, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRepositoryRunsResponse(rsp)
}

// GetRunWithResponse request returning *GetRunResponse
func (c *ClientWithResponses) GetRunWithResponse(ctx context.Context, repository string, runId string, reqEditors ...RequestEditorFn) (*GetRunResponse, error) {
	rsp, err := c.GetRun(ctx, repository, runId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRunResponse(rsp)
}

// ListRunHooksWithResponse request returning *ListRunHooksResponse
func (c *ClientWithResponses) ListRunHooksWithResponse(ctx context.Context, repository string, runId string, params *ListRunHooksParams, reqEditors ...RequestEditorFn) (*ListRunHooksResponse, error) {
	rsp, err := c.ListRunHooks(ctx, repository, runId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRunHooksResponse(rsp)
}

// GetRunHookOutputWithResponse request returning *GetRunHookOutputResponse
func (c *ClientWithResponses) GetRunHookOutputWithResponse(ctx context.Context, repository string, runId string, hookRunId string, reqEditors ...RequestEditorFn) (*GetRunHookOutputResponse, error) {
	rsp, err := c.GetRunHookOutput(ctx, repository, runId, hookRunId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRunHookOutputResponse(rsp)
}

// InternalDeleteBranchProtectionRuleWithBodyWithResponse request with arbitrary body returning *InternalDeleteBranchProtectionRuleResponse
func (c *ClientWithResponses) InternalDeleteBranchProtectionRuleWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalDeleteBranchProtectionRuleResponse, error) {
	rsp, err := c.InternalDeleteBranchProtectionRuleWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalDeleteBranchProtectionRuleResponse(rsp)
}

func (c *ClientWithResponses) InternalDeleteBranchProtectionRuleWithResponse(ctx context.Context, repository string, body InternalDeleteBranchProtectionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalDeleteBranchProtectionRuleResponse, error) {
	rsp, err := c.InternalDeleteBranchProtectionRule(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalDeleteBranchProtectionRuleResponse(rsp)
}

// InternalGetBranchProtectionRulesWithResponse request returning *InternalGetBranchProtectionRulesResponse
func (c *ClientWithResponses) InternalGetBranchProtectionRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*InternalGetBranchProtectionRulesResponse, error) {
	rsp, err := c.InternalGetBranchProtectionRules(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalGetBranchProtectionRulesResponse(rsp)
}

// InternalCreateBranchProtectionRuleWithBodyWithResponse request with arbitrary body returning *InternalCreateBranchProtectionRuleResponse
func (c *ClientWithResponses) InternalCreateBranchProtectionRuleWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalCreateBranchProtectionRuleResponse, error) {
	rsp, err := c.InternalCreateBranchProtectionRuleWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalCreateBranchProtectionRuleResponse(rsp)
}

func (c *ClientWithResponses) InternalCreateBranchProtectionRuleWithResponse(ctx context.Context, repository string, body InternalCreateBranchProtectionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalCreateBranchProtectionRuleResponse, error) {
	rsp, err := c.InternalCreateBranchProtectionRule(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalCreateBranchProtectionRuleResponse(rsp)
}

// CreateBranchProtectionRulePreflightWithResponse request returning *CreateBranchProtectionRulePreflightResponse
func (c *ClientWithResponses) CreateBranchProtectionRulePreflightWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*CreateBranchProtectionRulePreflightResponse, error) {
	rsp, err := c.CreateBranchProtectionRulePreflight(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBranchProtectionRulePreflightResponse(rsp)
}

// ListBranchesWithResponse request returning *ListBranchesResponse
func (c *ClientWithResponses) ListBranchesWithResponse(ctx context.Context, repository string, params *ListBranchesParams, reqEditors ...RequestEditorFn) (*ListBranchesResponse, error) {
	rsp, err := c.ListBranches(ctx, repository, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBranchesResponse(rsp)
}

// CreateBranchWithBodyWithResponse request with arbitrary body returning *CreateBranchResponse
func (c *ClientWithResponses) CreateBranchWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBranchResponse, error) {
	rsp, err := c.CreateBranchWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBranchResponse(rsp)
}

func (c *ClientWithResponses) CreateBranchWithResponse(ctx context.Context, repository string, body CreateBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBranchResponse, error) {
	rsp, err := c.CreateBranch(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBranchResponse(rsp)
}

// DeleteBranchWithResponse request returning *DeleteBranchResponse
func (c *ClientWithResponses) DeleteBranchWithResponse(ctx context.Context, repository string, branch string, params *DeleteBranchParams, reqEditors ...RequestEditorFn) (*DeleteBranchResponse, error) {
	rsp, err := c.DeleteBranch(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBranchResponse(rsp)
}

// GetBranchWithResponse request returning *GetBranchResponse
func (c *ClientWithResponses) GetBranchWithResponse(ctx context.Context, repository string, branch string, reqEditors ...RequestEditorFn) (*GetBranchResponse, error) {
	rsp, err := c.GetBranch(ctx, repository, branch, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBranchResponse(rsp)
}

// ResetBranchWithBodyWithResponse request with arbitrary body returning *ResetBranchResponse
func (c *ClientWithResponses) ResetBranchWithBodyWithResponse(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetBranchResponse, error) {
	rsp, err := c.ResetBranchWithBody(ctx, repository, branch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetBranchResponse(rsp)
}

func (c *ClientWithResponses) ResetBranchWithResponse(ctx context.Context, repository string, branch string, body ResetBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetBranchResponse, error) {
	rsp, err := c.ResetBranch(ctx, repository, branch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetBranchResponse(rsp)
}

// CherryPickWithBodyWithResponse request with arbitrary body returning *CherryPickResponse
func (c *ClientWithResponses) CherryPickWithBodyWithResponse(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CherryPickResponse, error) {
	rsp, err := c.CherryPickWithBody(ctx, repository, branch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCherryPickResponse(rsp)
}

func (c *ClientWithResponses) CherryPickWithResponse(ctx context.Context, repository string, branch string, body CherryPickJSONRequestBody, reqEditors ...RequestEditorFn) (*CherryPickResponse, error) {
	rsp, err := c.CherryPick(ctx, repository, branch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCherryPickResponse(rsp)
}

// CommitWithBodyWithResponse request with arbitrary body returning *CommitResponse
func (c *ClientWithResponses) CommitWithBodyWithResponse(ctx context.Context, repository string, branch string, params *CommitParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommitResponse, error) {
	rsp, err := c.CommitWithBody(ctx, repository, branch, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitResponse(rsp)
}

func (c *ClientWithResponses) CommitWithResponse(ctx context.Context, repository string, branch string, params *CommitParams, body CommitJSONRequestBody, reqEditors ...RequestEditorFn) (*CommitResponse, error) {
	rsp, err := c.Commit(ctx, repository, branch, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitResponse(rsp)
}

// CommitAsyncWithBodyWithResponse request with arbitrary body returning *CommitAsyncResponse
func (c *ClientWithResponses) CommitAsyncWithBodyWithResponse(ctx context.Context, repository string, branch string, params *CommitAsyncParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommitAsyncResponse, error) {
	rsp, err := c.CommitAsyncWithBody(ctx, repository, branch, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitAsyncResponse(rsp)
}

func (c *ClientWithResponses) CommitAsyncWithResponse(ctx context.Context, repository string, branch string, params *CommitAsyncParams, body CommitAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*CommitAsyncResponse, error) {
	rsp, err := c.CommitAsync(ctx, repository, branch, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitAsyncResponse(rsp)
}

// CommitAsyncStatusWithResponse request returning *CommitAsyncStatusResponse
func (c *ClientWithResponses) CommitAsyncStatusWithResponse(ctx context.Context, repository string, branch string, id string, reqEditors ...RequestEditorFn) (*CommitAsyncStatusResponse, error) {
	rsp, err := c.CommitAsyncStatus(ctx, repository, branch, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitAsyncStatusResponse(rsp)
}

// DiffBranchWithResponse request returning *DiffBranchResponse
func (c *ClientWithResponses) DiffBranchWithResponse(ctx context.Context, repository string, branch string, params *DiffBranchParams, reqEditors ...RequestEditorFn) (*DiffBranchResponse, error) {
	rsp, err := c.DiffBranch(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDiffBranchResponse(rsp)
}

// HardResetBranchWithResponse request returning *HardResetBranchResponse
func (c *ClientWithResponses) HardResetBranchWithResponse(ctx context.Context, repository string, branch string, params *HardResetBranchParams, reqEditors ...RequestEditorFn) (*HardResetBranchResponse, error) {
	rsp, err := c.HardResetBranch(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHardResetBranchResponse(rsp)
}

// ImportCancelWithResponse request returning *ImportCancelResponse
func (c *ClientWithResponses) ImportCancelWithResponse(ctx context.Context, repository string, branch string, params *ImportCancelParams, reqEditors ...RequestEditorFn) (*ImportCancelResponse, error) {
	rsp, err := c.ImportCancel(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportCancelResponse(rsp)
}

// ImportStatusWithResponse request returning *ImportStatusResponse
func (c *ClientWithResponses) ImportStatusWithResponse(ctx context.Context, repository string, branch string, params *ImportStatusParams, reqEditors ...RequestEditorFn) (*ImportStatusResponse, error) {
	rsp, err := c.ImportStatus(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportStatusResponse(rsp)
}

// ImportStartWithBodyWithResponse request with arbitrary body returning *ImportStartResponse
func (c *ClientWithResponses) ImportStartWithBodyWithResponse(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportStartResponse, error) {
	rsp, err := c.ImportStartWithBody(ctx, repository, branch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportStartResponse(rsp)
}

func (c *ClientWithResponses) ImportStartWithResponse(ctx context.Context, repository string, branch string, body ImportStartJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportStartResponse, error) {
	rsp, err := c.ImportStart(ctx, repository, branch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportStartResponse(rsp)
}

// DeleteObjectWithResponse request returning *DeleteObjectResponse
func (c *ClientWithResponses) DeleteObjectWithResponse(ctx context.Context, repository string, branch string, params *DeleteObjectParams, reqEditors ...RequestEditorFn) (*DeleteObjectResponse, error) {
	rsp, err := c.DeleteObject(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteObjectResponse(rsp)
}

// UploadObjectWithBodyWithResponse request with arbitrary body returning *UploadObjectResponse
func (c *ClientWithResponses) UploadObjectWithBodyWithResponse(ctx context.Context, repository string, branch string, params *UploadObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadObjectResponse, error) {
	rsp, err := c.UploadObjectWithBody(ctx, repository, branch, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadObjectResponse(rsp)
}

// StageObjectWithBodyWithResponse request with arbitrary body returning *StageObjectResponse
func (c *ClientWithResponses) StageObjectWithBodyWithResponse(ctx context.Context, repository string, branch string, params *StageObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StageObjectResponse, error) {
	rsp, err := c.StageObjectWithBody(ctx, repository, branch, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStageObjectResponse(rsp)
}

func (c *ClientWithResponses) StageObjectWithResponse(ctx context.Context, repository string, branch string, params *StageObjectParams, body StageObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*StageObjectResponse, error) {
	rsp, err := c.StageObject(ctx, repository, branch, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStageObjectResponse(rsp)
}

// CopyObjectWithBodyWithResponse request with arbitrary body returning *CopyObjectResponse
func (c *ClientWithResponses) CopyObjectWithBodyWithResponse(ctx context.Context, repository string, branch string, params *CopyObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CopyObjectResponse, error) {
	rsp, err := c.CopyObjectWithBody(ctx, repository, branch, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCopyObjectResponse(rsp)
}

func (c *ClientWithResponses) CopyObjectWithResponse(ctx context.Context, repository string, branch string, params *CopyObjectParams, body CopyObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CopyObjectResponse, error) {
	rsp, err := c.CopyObject(ctx, repository, branch, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCopyObjectResponse(rsp)
}

// DeleteObjectsWithBodyWithResponse request with arbitrary body returning *DeleteObjectsResponse
func (c *ClientWithResponses) DeleteObjectsWithBodyWithResponse(ctx context.Context, repository string, branch string, params *DeleteObjectsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteObjectsResponse, error) {
	rsp, err := c.DeleteObjectsWithBody(ctx, repository, branch, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteObjectsResponse(rsp)
}

func (c *ClientWithResponses) DeleteObjectsWithResponse(ctx context.Context, repository string, branch string, params *DeleteObjectsParams, body DeleteObjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteObjectsResponse, error) {
	rsp, err := c.DeleteObjects(ctx, repository, branch, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteObjectsResponse(rsp)
}

// UploadObjectPreflightWithResponse request returning *UploadObjectPreflightResponse
func (c *ClientWithResponses) UploadObjectPreflightWithResponse(ctx context.Context, repository string, branch string, params *UploadObjectPreflightParams, reqEditors ...RequestEditorFn) (*UploadObjectPreflightResponse, error) {
	rsp, err := c.UploadObjectPreflight(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadObjectPreflightResponse(rsp)
}

// UpdateObjectUserMetadataWithBodyWithResponse request with arbitrary body returning *UpdateObjectUserMetadataResponse
func (c *ClientWithResponses) UpdateObjectUserMetadataWithBodyWithResponse(ctx context.Context, repository string, branch string, params *UpdateObjectUserMetadataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateObjectUserMetadataResponse, error) {
	rsp, err := c.UpdateObjectUserMetadataWithBody(ctx, repository, branch, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateObjectUserMetadataResponse(rsp)
}

func (c *ClientWithResponses) UpdateObjectUserMetadataWithResponse(ctx context.Context, repository string, branch string, params *UpdateObjectUserMetadataParams, body UpdateObjectUserMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateObjectUserMetadataResponse, error) {
	rsp, err := c.UpdateObjectUserMetadata(ctx, repository, branch, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateObjectUserMetadataResponse(rsp)
}

// RevertBranchWithBodyWithResponse request with arbitrary body returning *RevertBranchResponse
func (c *ClientWithResponses) RevertBranchWithBodyWithResponse(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevertBranchResponse, error) {
	rsp, err := c.RevertBranchWithBody(ctx, repository, branch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevertBranchResponse(rsp)
}

func (c *ClientWithResponses) RevertBranchWithResponse(ctx context.Context, repository string, branch string, body RevertBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*RevertBranchResponse, error) {
	rsp, err := c.RevertBranch(ctx, repository, branch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevertBranchResponse(rsp)
}

// GetPhysicalAddressWithResponse request returning *GetPhysicalAddressResponse
func (c *ClientWithResponses) GetPhysicalAddressWithResponse(ctx context.Context, repository string, branch string, params *GetPhysicalAddressParams, reqEditors ...RequestEditorFn) (*GetPhysicalAddressResponse, error) {
	rsp, err := c.GetPhysicalAddress(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPhysicalAddressResponse(rsp)
}

// LinkPhysicalAddressWithBodyWithResponse request with arbitrary body returning *LinkPhysicalAddressResponse
func (c *ClientWithResponses) LinkPhysicalAddressWithBodyWithResponse(ctx context.Context, repository string, branch string, params *LinkPhysicalAddressParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkPhysicalAddressResponse, error) {
	rsp, err := c.LinkPhysicalAddressWithBody(ctx, repository, branch, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkPhysicalAddressResponse(rsp)
}

func (c *ClientWithResponses) LinkPhysicalAddressWithResponse(ctx context.Context, repository string, branch string, params *LinkPhysicalAddressParams, body LinkPhysicalAddressJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkPhysicalAddressResponse, error) {
	rsp, err := c.LinkPhysicalAddress(ctx, repository, branch, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkPhysicalAddressResponse(rsp)
}

// CreatePresignMultipartUploadWithResponse request returning *CreatePresignMultipartUploadResponse
func (c *ClientWithResponses) CreatePresignMultipartUploadWithResponse(ctx context.Context, repository string, branch string, params *CreatePresignMultipartUploadParams, reqEditors ...RequestEditorFn) (*CreatePresignMultipartUploadResponse, error) {
	rsp, err := c.CreatePresignMultipartUpload(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePresignMultipartUploadResponse(rsp)
}

// AbortPresignMultipartUploadWithBodyWithResponse request with arbitrary body returning *AbortPresignMultipartUploadResponse
func (c *ClientWithResponses) AbortPresignMultipartUploadWithBodyWithResponse(ctx context.Context, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AbortPresignMultipartUploadResponse, error) {
	rsp, err := c.AbortPresignMultipartUploadWithBody(ctx, repository, branch, uploadId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAbortPresignMultipartUploadResponse(rsp)
}

func (c *ClientWithResponses) AbortPresignMultipartUploadWithResponse(ctx context.Context, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, body AbortPresignMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*AbortPresignMultipartUploadResponse, error) {
	rsp, err := c.AbortPresignMultipartUpload(ctx, repository, branch, uploadId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAbortPresignMultipartUploadResponse(rsp)
}

// CompletePresignMultipartUploadWithBodyWithResponse request with arbitrary body returning *CompletePresignMultipartUploadResponse
func (c *ClientWithResponses) CompletePresignMultipartUploadWithBodyWithResponse(ctx context.Context, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompletePresignMultipartUploadResponse, error) {
	rsp, err := c.CompletePresignMultipartUploadWithBody(ctx, repository, branch, uploadId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompletePresignMultipartUploadResponse(rsp)
}

func (c *ClientWithResponses) CompletePresignMultipartUploadWithResponse(ctx context.Context, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, body CompletePresignMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*CompletePresignMultipartUploadResponse, error) {
	rsp, err := c.CompletePresignMultipartUpload(ctx, repository, branch, uploadId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompletePresignMultipartUploadResponse(rsp)
}

// UploadPartWithBodyWithResponse request with arbitrary body returning *UploadPartResponse
func (c *ClientWithResponses) UploadPartWithBodyWithResponse(ctx context.Context, repository string, branch string, uploadId string, partNumber int, params *UploadPartParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadPartResponse, error) {
	rsp, err := c.UploadPartWithBody(ctx, repository, branch, uploadId, partNumber, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadPartResponse(rsp)
}

func (c *ClientWithResponses) UploadPartWithResponse(ctx context.Context, repository string, branch string, uploadId string, partNumber int, params *UploadPartParams, body UploadPartJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadPartResponse, error) {
	rsp, err := c.UploadPart(ctx, repository, branch, uploadId, partNumber, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadPartResponse(rsp)
}

// UploadPartCopyWithBodyWithResponse request with arbitrary body returning *UploadPartCopyResponse
func (c *ClientWithResponses) UploadPartCopyWithBodyWithResponse(ctx context.Context, repository string, branch string, uploadId string, partNumber int, params *UploadPartCopyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadPartCopyResponse, error) {
	rsp, err := c.UploadPartCopyWithBody(ctx, repository, branch, uploadId, partNumber, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadPartCopyResponse(rsp)
}

func (c *ClientWithResponses) UploadPartCopyWithResponse(ctx context.Context, repository string, branch string, uploadId string, partNumber int, params *UploadPartCopyParams, body UploadPartCopyJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadPartCopyResponse, error) {
	rsp, err := c.UploadPartCopy(ctx, repository, branch, uploadId, partNumber, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadPartCopyResponse(rsp)
}

// CreateCommitRecordWithBodyWithResponse request with arbitrary body returning *CreateCommitRecordResponse
func (c *ClientWithResponses) CreateCommitRecordWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCommitRecordResponse, error) {
	rsp, err := c.CreateCommitRecordWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCommitRecordResponse(rsp)
}

func (c *ClientWithResponses) CreateCommitRecordWithResponse(ctx context.Context, repository string, body CreateCommitRecordJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCommitRecordResponse, error) {
	rsp, err := c.CreateCommitRecord(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCommitRecordResponse(rsp)
}

// GetCommitWithResponse request returning *GetCommitResponse
func (c *ClientWithResponses) GetCommitWithResponse(ctx context.Context, repository string, commitId string, reqEditors ...RequestEditorFn) (*GetCommitResponse, error) {
	rsp, err := c.GetCommit(ctx, repository, commitId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCommitResponse(rsp)
}

// DumpStatusWithResponse request returning *DumpStatusResponse
func (c *ClientWithResponses) DumpStatusWithResponse(ctx context.Context, repository string, params *DumpStatusParams, reqEditors ...RequestEditorFn) (*DumpStatusResponse, error) {
	rsp, err := c.DumpStatus(ctx, repository, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDumpStatusResponse(rsp)
}

// DumpSubmitWithResponse request returning *DumpSubmitResponse
func (c *ClientWithResponses) DumpSubmitWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*DumpSubmitResponse, error) {
	rsp, err := c.DumpSubmit(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDumpSubmitResponse(rsp)
}

// PrepareGarbageCollectionCommitsWithResponse request returning *PrepareGarbageCollectionCommitsResponse
func (c *ClientWithResponses) PrepareGarbageCollectionCommitsWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*PrepareGarbageCollectionCommitsResponse, error) {
	rsp, err := c.PrepareGarbageCollectionCommits(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareGarbageCollectionCommitsResponse(rsp)
}

// PrepareGarbageCollectionCommitsAsyncWithResponse request returning *PrepareGarbageCollectionCommitsAsyncResponse
func (c *ClientWithResponses) PrepareGarbageCollectionCommitsAsyncWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*PrepareGarbageCollectionCommitsAsyncResponse, error) {
	rsp, err := c.PrepareGarbageCollectionCommitsAsync(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareGarbageCollectionCommitsAsyncResponse(rsp)
}

// PrepareGarbageCollectionCommitsStatusWithResponse request returning *PrepareGarbageCollectionCommitsStatusResponse
func (c *ClientWithResponses) PrepareGarbageCollectionCommitsStatusWithResponse(ctx context.Context, repository string, params *PrepareGarbageCollectionCommitsStatusParams, reqEditors ...RequestEditorFn) (*PrepareGarbageCollectionCommitsStatusResponse, error) {
	rsp, err := c.PrepareGarbageCollectionCommitsStatus(ctx, repository, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareGarbageCollectionCommitsStatusResponse(rsp)
}

// PrepareGarbageCollectionUncommittedWithBodyWithResponse request with arbitrary body returning *PrepareGarbageCollectionUncommittedResponse
func (c *ClientWithResponses) PrepareGarbageCollectionUncommittedWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrepareGarbageCollectionUncommittedResponse, error) {
	rsp, err := c.PrepareGarbageCollectionUncommittedWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareGarbageCollectionUncommittedResponse(rsp)
}

func (c *ClientWithResponses) PrepareGarbageCollectionUncommittedWithResponse(ctx context.Context, repository string, body PrepareGarbageCollectionUncommittedJSONRequestBody, reqEditors ...RequestEditorFn) (*PrepareGarbageCollectionUncommittedResponse, error) {
	rsp, err := c.PrepareGarbageCollectionUncommitted(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareGarbageCollectionUncommittedResponse(rsp)
}

// InternalDeleteGarbageCollectionRulesWithResponse request returning *InternalDeleteGarbageCollectionRulesResponse
func (c *ClientWithResponses) InternalDeleteGarbageCollectionRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*InternalDeleteGarbageCollectionRulesResponse, error) {
	rsp, err := c.InternalDeleteGarbageCollectionRules(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalDeleteGarbageCollectionRulesResponse(rsp)
}

// InternalGetGarbageCollectionRulesWithResponse request returning *InternalGetGarbageCollectionRulesResponse
func (c *ClientWithResponses) InternalGetGarbageCollectionRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*InternalGetGarbageCollectionRulesResponse, error) {
	rsp, err := c.InternalGetGarbageCollectionRules(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalGetGarbageCollectionRulesResponse(rsp)
}

// InternalSetGarbageCollectionRulesWithBodyWithResponse request with arbitrary body returning *InternalSetGarbageCollectionRulesResponse
func (c *ClientWithResponses) InternalSetGarbageCollectionRulesWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalSetGarbageCollectionRulesResponse, error) {
	rsp, err := c.InternalSetGarbageCollectionRulesWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalSetGarbageCollectionRulesResponse(rsp)
}

func (c *ClientWithResponses) InternalSetGarbageCollectionRulesWithResponse(ctx context.Context, repository string, body InternalSetGarbageCollectionRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalSetGarbageCollectionRulesResponse, error) {
	rsp, err := c.InternalSetGarbageCollectionRules(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalSetGarbageCollectionRulesResponse(rsp)
}

// SetGarbageCollectionRulesPreflightWithResponse request returning *SetGarbageCollectionRulesPreflightResponse
func (c *ClientWithResponses) SetGarbageCollectionRulesPreflightWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*SetGarbageCollectionRulesPreflightResponse, error) {
	rsp, err := c.SetGarbageCollectionRulesPreflight(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetGarbageCollectionRulesPreflightResponse(rsp)
}

// DeleteRepositoryMetadataWithBodyWithResponse request with arbitrary body returning *DeleteRepositoryMetadataResponse
func (c *ClientWithResponses) DeleteRepositoryMetadataWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteRepositoryMetadataResponse, error) {
	rsp, err := c.DeleteRepositoryMetadataWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRepositoryMetadataResponse(rsp)
}

func (c *ClientWithResponses) DeleteRepositoryMetadataWithResponse(ctx context.Context, repository string, body DeleteRepositoryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteRepositoryMetadataResponse, error) {
	rsp, err := c.DeleteRepositoryMetadata(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRepositoryMetadataResponse(rsp)
}

// GetRepositoryMetadataWithResponse request returning *GetRepositoryMetadataResponse
func (c *ClientWithResponses) GetRepositoryMetadataWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*GetRepositoryMetadataResponse, error) {
	rsp, err := c.GetRepositoryMetadata(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRepositoryMetadataResponse(rsp)
}

// SetRepositoryMetadataWithBodyWithResponse request with arbitrary body returning *SetRepositoryMetadataResponse
func (c *ClientWithResponses) SetRepositoryMetadataWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetRepositoryMetadataResponse, error) {
	rsp, err := c.SetRepositoryMetadataWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRepositoryMetadataResponse(rsp)
}

func (c *ClientWithResponses) SetRepositoryMetadataWithResponse(ctx context.Context, repository string, body SetRepositoryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*SetRepositoryMetadataResponse, error) {
	rsp, err := c.SetRepositoryMetadata(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRepositoryMetadataResponse(rsp)
}

// GetMetaRangeWithResponse request returning *GetMetaRangeResponse
func (c *ClientWithResponses) GetMetaRangeWithResponse(ctx context.Context, repository string, metaRange string, reqEditors ...RequestEditorFn) (*GetMetaRangeResponse, error) {
	rsp, err := c.GetMetaRange(ctx, repository, metaRange, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMetaRangeResponse(rsp)
}

// GetMetadataObjectWithResponse request returning *GetMetadataObjectResponse
func (c *ClientWithResponses) GetMetadataObjectWithResponse(ctx context.Context, repository string, pType string, objectId string, params *GetMetadataObjectParams, reqEditors ...RequestEditorFn) (*GetMetadataObjectResponse, error) {
	rsp, err := c.GetMetadataObject(ctx, repository, pType, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMetadataObjectResponse(rsp)
}

// GetRangeWithResponse request returning *GetRangeResponse
func (c *ClientWithResponses) GetRangeWithResponse(ctx context.Context, repository string, pRange string, reqEditors ...RequestEditorFn) (*GetRangeResponse, error) {
	rsp, err := c.GetRange(ctx, repository, pRange, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRangeResponse(rsp)
}

// ListPullRequestsWithResponse request returning *ListPullRequestsResponse
func (c *ClientWithResponses) ListPullRequestsWithResponse(ctx context.Context, repository string, params *ListPullRequestsParams, reqEditors ...RequestEditorFn) (*ListPullRequestsResponse, error) {
	rsp, err := c.ListPullRequests(ctx, repository, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPullRequestsResponse(rsp)
}

// CreatePullRequestWithBodyWithResponse request with arbitrary body returning *CreatePullRequestResponse
func (c *ClientWithResponses) CreatePullRequestWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePullRequestResponse, error) {
	rsp, err := c.CreatePullRequestWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePullRequestResponse(rsp)
}

func (c *ClientWithResponses) CreatePullRequestWithResponse(ctx context.Context, repository string, body CreatePullRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePullRequestResponse, error) {
	rsp, err := c.CreatePullRequest(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePullRequestResponse(rsp)
}

// GetPullRequestWithResponse request returning *GetPullRequestResponse
func (c *ClientWithResponses) GetPullRequestWithResponse(ctx context.Context, repository string, pullRequest string, reqEditors ...RequestEditorFn) (*GetPullRequestResponse, error) {
	rsp, err := c.GetPullRequest(ctx, repository, pullRequest, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPullRequestResponse(rsp)
}

// UpdatePullRequestWithBodyWithResponse request with arbitrary body returning *UpdatePullRequestResponse
func (c *ClientWithResponses) UpdatePullRequestWithBodyWithResponse(ctx context.Context, repository string, pullRequest string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePullRequestResponse, error) {
	rsp, err := c.UpdatePullRequestWithBody(ctx, repository, pullRequest, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePullRequestResponse(rsp)
}

func (c *ClientWithResponses) UpdatePullRequestWithResponse(ctx context.Context, repository string, pullRequest string, body UpdatePullRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePullRequestResponse, error) {
	rsp, err := c.UpdatePullRequest(ctx, repository, pullRequest, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePullRequestResponse(rsp)
}

// MergePullRequestWithResponse request returning *MergePullRequestResponse
func (c *ClientWithResponses) MergePullRequestWithResponse(ctx context.Context, repository string, pullRequest string, reqEditors ...RequestEditorFn) (*MergePullRequestResponse, error) {
	rsp, err := c.MergePullRequest(ctx, repository, pullRequest, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergePullRequestResponse(rsp)
}

// DumpRefsWithResponse request returning *DumpRefsResponse
func (c *ClientWithResponses) DumpRefsWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*DumpRefsResponse, error) {
	rsp, err := c.DumpRefs(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDumpRefsResponse(rsp)
}

// RestoreRefsWithBodyWithResponse request with arbitrary body returning *RestoreRefsResponse
func (c *ClientWithResponses) RestoreRefsWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestoreRefsResponse, error) {
	rsp, err := c.RestoreRefsWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreRefsResponse(rsp)
}

func (c *ClientWithResponses) RestoreRefsWithResponse(ctx context.Context, repository string, body RestoreRefsJSONRequestBody, reqEditors ...RequestEditorFn) (*RestoreRefsResponse, error) {
	rsp, err := c.RestoreRefs(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreRefsResponse(rsp)
}

// CreateSymlinkFileWithResponse request returning *CreateSymlinkFileResponse
func (c *ClientWithResponses) CreateSymlinkFileWithResponse(ctx context.Context, repository string, branch string, params *CreateSymlinkFileParams, reqEditors ...RequestEditorFn) (*CreateSymlinkFileResponse, error) {
	rsp, err := c.CreateSymlinkFile(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSymlinkFileResponse(rsp)
}

// DiffRefsWithResponse request returning *DiffRefsResponse
func (c *ClientWithResponses) DiffRefsWithResponse(ctx context.Context, repository string, leftRef string, rightRef string, params *DiffRefsParams, reqEditors ...RequestEditorFn) (*DiffRefsResponse, error) {
	rsp, err := c.DiffRefs(ctx, repository, leftRef, rightRef, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDiffRefsResponse(rsp)
}

// LogCommitsWithResponse request returning *LogCommitsResponse
func (c *ClientWithResponses) LogCommitsWithResponse(ctx context.Context, repository string, ref string, params *LogCommitsParams, reqEditors ...RequestEditorFn) (*LogCommitsResponse, error) {
	rsp, err := c.LogCommits(ctx, repository, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogCommitsResponse(rsp)
}

// GetObjectWithResponse request returning *GetObjectResponse
func (c *ClientWithResponses) GetObjectWithResponse(ctx context.Context, repository string, ref string, params *GetObjectParams, reqEditors ...RequestEditorFn) (*GetObjectResponse, error) {
	rsp, err := c.GetObject(ctx, repository, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetObjectResponse(rsp)
}

// HeadObjectWithResponse request returning *HeadObjectResponse
func (c *ClientWithResponses) HeadObjectWithResponse(ctx context.Context, repository string, ref string, params *HeadObjectParams, reqEditors ...RequestEditorFn) (*HeadObjectResponse, error) {
	rsp, err := c.HeadObject(ctx, repository, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeadObjectResponse(rsp)
}

// ListObjectsWithResponse request returning *ListObjectsResponse
func (c *ClientWithResponses) ListObjectsWithResponse(ctx context.Context, repository string, ref string, params *ListObjectsParams, reqEditors ...RequestEditorFn) (*ListObjectsResponse, error) {
	rsp, err := c.ListObjects(ctx, repository, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListObjectsResponse(rsp)
}

// StatObjectWithResponse request returning *StatObjectResponse
func (c *ClientWithResponses) StatObjectWithResponse(ctx context.Context, repository string, ref string, params *StatObjectParams, reqEditors ...RequestEditorFn) (*StatObjectResponse, error) {
	rsp, err := c.StatObject(ctx, repository, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatObjectResponse(rsp)
}

// GetUnderlyingPropertiesWithResponse request returning *GetUnderlyingPropertiesResponse
func (c *ClientWithResponses) GetUnderlyingPropertiesWithResponse(ctx context.Context, repository string, ref string, params *GetUnderlyingPropertiesParams, reqEditors ...RequestEditorFn) (*GetUnderlyingPropertiesResponse, error) {
	rsp, err := c.GetUnderlyingProperties(ctx, repository, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUnderlyingPropertiesResponse(rsp)
}

// FindMergeBaseWithResponse request returning *FindMergeBaseResponse
func (c *ClientWithResponses) FindMergeBaseWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, reqEditors ...RequestEditorFn) (*FindMergeBaseResponse, error) {
	rsp, err := c.FindMergeBase(ctx, repository, sourceRef, destinationBranch, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindMergeBaseResponse(rsp)
}

// MergeIntoBranchWithBodyWithResponse request with arbitrary body returning *MergeIntoBranchResponse
func (c *ClientWithResponses) MergeIntoBranchWithBodyWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeIntoBranchResponse, error) {
	rsp, err := c.MergeIntoBranchWithBody(ctx, repository, sourceRef, destinationBranch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeIntoBranchResponse(rsp)
}

func (c *ClientWithResponses) MergeIntoBranchWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, body MergeIntoBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeIntoBranchResponse, error) {
	rsp, err := c.MergeIntoBranch(ctx, repository, sourceRef, destinationBranch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeIntoBranchResponse(rsp)
}

// MergeIntoBranchAsyncWithBodyWithResponse request with arbitrary body returning *MergeIntoBranchAsyncResponse
func (c *ClientWithResponses) MergeIntoBranchAsyncWithBodyWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeIntoBranchAsyncResponse, error) {
	rsp, err := c.MergeIntoBranchAsyncWithBody(ctx, repository, sourceRef, destinationBranch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeIntoBranchAsyncResponse(rsp)
}

func (c *ClientWithResponses) MergeIntoBranchAsyncWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, body MergeIntoBranchAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeIntoBranchAsyncResponse, error) {
	rsp, err := c.MergeIntoBranchAsync(ctx, repository, sourceRef, destinationBranch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeIntoBranchAsyncResponse(rsp)
}

// MergeIntoBranchAsyncStatusWithResponse request returning *MergeIntoBranchAsyncStatusResponse
func (c *ClientWithResponses) MergeIntoBranchAsyncStatusWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, id string, reqEditors ...RequestEditorFn) (*MergeIntoBranchAsyncStatusResponse, error) {
	rsp, err := c.MergeIntoBranchAsyncStatus(ctx, repository, sourceRef, destinationBranch, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeIntoBranchAsyncStatusResponse(rsp)
}

// RestoreStatusWithResponse request returning *RestoreStatusResponse
func (c *ClientWithResponses) RestoreStatusWithResponse(ctx context.Context, repository string, params *RestoreStatusParams, reqEditors ...RequestEditorFn) (*RestoreStatusResponse, error) {
	rsp, err := c.RestoreStatus(ctx, repository, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreStatusResponse(rsp)
}

// RestoreSubmitWithBodyWithResponse request with arbitrary body returning *RestoreSubmitResponse
func (c *ClientWithResponses) RestoreSubmitWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestoreSubmitResponse, error) {
	rsp, err := c.RestoreSubmitWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreSubmitResponse(rsp)
}

func (c *ClientWithResponses) RestoreSubmitWithResponse(ctx context.Context, repository string, body RestoreSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*RestoreSubmitResponse, error) {
	rsp, err := c.RestoreSubmit(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreSubmitResponse(rsp)
}

// GetBranchProtectionRulesWithResponse request returning *GetBranchProtectionRulesResponse
func (c *ClientWithResponses) GetBranchProtectionRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*GetBranchProtectionRulesResponse, error) {
	rsp, err := c.GetBranchProtectionRules(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBranchProtectionRulesResponse(rsp)
}

// SetBranchProtectionRulesWithBodyWithResponse request with arbitrary body returning *SetBranchProtectionRulesResponse
func (c *ClientWithResponses) SetBranchProtectionRulesWithBodyWithResponse(ctx context.Context, repository string, params *SetBranchProtectionRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetBranchProtectionRulesResponse, error) {
	rsp, err := c.SetBranchProtectionRulesWithBody(ctx, repository, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetBranchProtectionRulesResponse(rsp)
}

func (c *ClientWithResponses) SetBranchProtectionRulesWithResponse(ctx context.Context, repository string, params *SetBranchProtectionRulesParams, body SetBranchProtectionRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetBranchProtectionRulesResponse, error) {
	rsp, err := c.SetBranchProtectionRules(ctx, repository, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetBranchProtectionRulesResponse(rsp)
}

// DeleteGCRulesWithResponse request returning *DeleteGCRulesResponse
func (c *ClientWithResponses) DeleteGCRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*DeleteGCRulesResponse, error) {
	rsp, err := c.DeleteGCRules(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGCRulesResponse(rsp)
}

// GetGCRulesWithResponse request returning *GetGCRulesResponse
func (c *ClientWithResponses) GetGCRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*GetGCRulesResponse, error) {
	rsp, err := c.GetGCRules(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGCRulesResponse(rsp)
}

// SetGCRulesWithBodyWithResponse request with arbitrary body returning *SetGCRulesResponse
func (c *ClientWithResponses) SetGCRulesWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetGCRulesResponse, error) {
	rsp, err := c.SetGCRulesWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetGCRulesResponse(rsp)
}

func (c *ClientWithResponses) SetGCRulesWithResponse(ctx context.Context, repository string, body SetGCRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetGCRulesResponse, error) {
	rsp, err := c.SetGCRules(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetGCRulesResponse(rsp)
}

// ListTagsWithResponse request returning *ListTagsResponse
func (c *ClientWithResponses) ListTagsWithResponse(ctx context.Context, repository string, params *ListTagsParams, reqEditors ...RequestEditorFn) (*ListTagsResponse, error) {
	rsp, err := c.ListTags(ctx, repository, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTagsResponse(rsp)
}

// CreateTagWithBodyWithResponse request with arbitrary body returning *CreateTagResponse
func (c *ClientWithResponses) CreateTagWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTagResponse, error) {
	rsp, err := c.CreateTagWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTagResponse(rsp)
}

func (c *ClientWithResponses) CreateTagWithResponse(ctx context.Context, repository string, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTagResponse, error) {
	rsp, err := c.CreateTag(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTagResponse(rsp)
}

// DeleteTagWithResponse request returning *DeleteTagResponse
func (c *ClientWithResponses) DeleteTagWithResponse(ctx context.Context, repository string, tag string, params *DeleteTagParams, reqEditors ...RequestEditorFn) (*DeleteTagResponse, error) {
	rsp, err := c.DeleteTag(ctx, repository, tag, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTagResponse(rsp)
}

// GetTagWithResponse request returning *GetTagResponse
func (c *ClientWithResponses) GetTagWithResponse(ctx context.Context, repository string, tag string, reqEditors ...RequestEditorFn) (*GetTagResponse, error) {
	rsp, err := c.GetTag(ctx, repository, tag, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTagResponse(rsp)
}

// SetupCommPrefsWithBodyWithResponse request with arbitrary body returning *SetupCommPrefsResponse
func (c *ClientWithResponses) SetupCommPrefsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetupCommPrefsResponse, error) {
	rsp, err := c.SetupCommPrefsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetupCommPrefsResponse(rsp)
}

func (c *ClientWithResponses) SetupCommPrefsWithResponse(ctx context.Context, body SetupCommPrefsJSONRequestBody, reqEditors ...RequestEditorFn) (*SetupCommPrefsResponse, error) {
	rsp, err := c.SetupCommPrefs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetupCommPrefsResponse(rsp)
}

// GetSetupStateWithResponse request returning *GetSetupStateResponse
func (c *ClientWithResponses) GetSetupStateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSetupStateResponse, error) {
	rsp, err := c.GetSetupState(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSetupStateResponse(rsp)
}

// SetupWithBodyWithResponse request with arbitrary body returning *SetupResponse
func (c *ClientWithResponses) SetupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetupResponse, error) {
	rsp, err := c.SetupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetupResponse(rsp)
}

func (c *ClientWithResponses) SetupWithResponse(ctx context.Context, body SetupJSONRequestBody, reqEditors ...RequestEditorFn) (*SetupResponse, error) {
	rsp, err := c.Setup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetupResponse(rsp)
}

// PostStatsEventsWithBodyWithResponse request with arbitrary body returning *PostStatsEventsResponse
func (c *ClientWithResponses) PostStatsEventsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStatsEventsResponse, error) {
	rsp, err := c.PostStatsEventsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStatsEventsResponse(rsp)
}

func (c *ClientWithResponses) PostStatsEventsWithResponse(ctx context.Context, body PostStatsEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStatsEventsResponse, error) {
	rsp, err := c.PostStatsEvents(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStatsEventsResponse(rsp)
}

// StsLoginWithBodyWithResponse request with arbitrary body returning *StsLoginResponse
func (c *ClientWithResponses) StsLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StsLoginResponse, error) {
	rsp, err := c.StsLoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStsLoginResponse(rsp)
}

func (c *ClientWithResponses) StsLoginWithResponse(ctx context.Context, body StsLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*StsLoginResponse, error) {
	rsp, err := c.StsLogin(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStsLoginResponse(rsp)
}

// GetUsageReportSummaryWithResponse request returning *GetUsageReportSummaryResponse
func (c *ClientWithResponses) GetUsageReportSummaryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUsageReportSummaryResponse, error) {
	rsp, err := c.GetUsageReportSummary(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsageReportSummaryResponse(rsp)
}

// GetCurrentUserWithResponse request returning *GetCurrentUserResponse
func (c *ClientWithResponses) GetCurrentUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentUserResponse, error) {
	rsp, err := c.GetCurrentUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentUserResponse(rsp)
}

// ParseGetAuthCapabilitiesResponse parses an HTTP response from a GetAuthCapabilitiesWithResponse call
func ParseGetAuthCapabilitiesResponse(rsp *http.Response) (*GetAuthCapabilitiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetAuthCapabilitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthCapabilities
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseExternalPrincipalLoginResponse parses an HTTP response from a ExternalPrincipalLoginWithResponse call
func ParseExternalPrincipalLoginResponse(rsp *http.Response) (*ExternalPrincipalLoginResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ExternalPrincipalLoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthenticationToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetExternalPrincipalResponse parses an HTTP response from a GetExternalPrincipalWithResponse call
func ParseGetExternalPrincipalResponse(rsp *http.Response) (*GetExternalPrincipalResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetExternalPrincipalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExternalPrincipal
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTokenFromMailboxResponse parses an HTTP response from a GetTokenFromMailboxWithResponse call
func ParseGetTokenFromMailboxResponse(rsp *http.Response) (*GetTokenFromMailboxResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetTokenFromMailboxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthenticationToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReleaseTokenToMailboxResponse parses an HTTP response from a ReleaseTokenToMailboxWithResponse call
func ParseReleaseTokenToMailboxResponse(rsp *http.Response) (*ReleaseTokenToMailboxResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ReleaseTokenToMailboxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTokenRedirectResponse parses an HTTP response from a GetTokenRedirectWithResponse call
func ParseGetTokenRedirectResponse(rsp *http.Response) (*GetTokenRedirectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetTokenRedirectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListGroupsResponse parses an HTTP response from a ListGroupsWithResponse call
func ParseListGroupsResponse(rsp *http.Response) (*ListGroupsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateGroupResponse parses an HTTP response from a CreateGroupWithResponse call
func ParseCreateGroupResponse(rsp *http.Response) (*CreateGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteGroupResponse parses an HTTP response from a DeleteGroupWithResponse call
func ParseDeleteGroupResponse(rsp *http.Response) (*DeleteGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetGroupResponse parses an HTTP response from a GetGroupWithResponse call
func ParseGetGroupResponse(rsp *http.Response) (*GetGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetGroupACLResponse parses an HTTP response from a GetGroupACLWithResponse call
func ParseGetGroupACLResponse(rsp *http.Response) (*GetGroupACLResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetGroupACLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ACL
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNoACL
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetGroupACLResponse parses an HTTP response from a SetGroupACLWithResponse call
func ParseSetGroupACLResponse(rsp *http.Response) (*SetGroupACLResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SetGroupACLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListGroupMembersResponse parses an HTTP response from a ListGroupMembersWithResponse call
func ParseListGroupMembersResponse(rsp *http.Response) (*ListGroupMembersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListGroupMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteGroupMembershipResponse parses an HTTP response from a DeleteGroupMembershipWithResponse call
func ParseDeleteGroupMembershipResponse(rsp *http.Response) (*DeleteGroupMembershipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupMembershipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddGroupMembershipResponse parses an HTTP response from a AddGroupMembershipWithResponse call
func ParseAddGroupMembershipResponse(rsp *http.Response) (*AddGroupMembershipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AddGroupMembershipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListGroupPoliciesResponse parses an HTTP response from a ListGroupPoliciesWithResponse call
func ParseListGroupPoliciesResponse(rsp *http.Response) (*ListGroupPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListGroupPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDetachPolicyFromGroupResponse parses an HTTP response from a DetachPolicyFromGroupWithResponse call
func ParseDetachPolicyFromGroupResponse(rsp *http.Response) (*DetachPolicyFromGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DetachPolicyFromGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAttachPolicyToGroupResponse parses an HTTP response from a AttachPolicyToGroupWithResponse call
func ParseAttachPolicyToGroupResponse(rsp *http.Response) (*AttachPolicyToGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AttachPolicyToGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseLoginResponse parses an HTTP response from a LoginWithResponse call
func ParseLoginResponse(rsp *http.Response) (*LoginResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &LoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthenticationToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListPoliciesResponse parses an HTTP response from a ListPoliciesWithResponse call
func ParseListPoliciesResponse(rsp *http.Response) (*ListPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreatePolicyResponse parses an HTTP response from a CreatePolicyWithResponse call
func ParseCreatePolicyResponse(rsp *http.Response) (*CreatePolicyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreatePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeletePolicyResponse parses an HTTP response from a DeletePolicyWithResponse call
func ParseDeletePolicyResponse(rsp *http.Response) (*DeletePolicyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeletePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPolicyResponse parses an HTTP response from a GetPolicyWithResponse call
func ParseGetPolicyResponse(rsp *http.Response) (*GetPolicyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdatePolicyResponse parses an HTTP response from a UpdatePolicyWithResponse call
func ParseUpdatePolicyResponse(rsp *http.Response) (*UpdatePolicyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdatePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListUsersResponse parses an HTTP response from a ListUsersWithResponse call
func ParseListUsersResponse(rsp *http.Response) (*ListUsersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateUserResponse parses an HTTP response from a CreateUserWithResponse call
func ParseCreateUserResponse(rsp *http.Response) (*CreateUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListUserCredentialsResponse parses an HTTP response from a ListUserCredentialsWithResponse call
func ParseListUserCredentialsResponse(rsp *http.Response) (*ListUserCredentialsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListUserCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CredentialsList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateCredentialsResponse parses an HTTP response from a CreateCredentialsWithResponse call
func ParseCreateCredentialsResponse(rsp *http.Response) (*CreateCredentialsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CredentialsWithSecret
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteCredentialsResponse parses an HTTP response from a DeleteCredentialsWithResponse call
func ParseDeleteCredentialsResponse(rsp *http.Response) (*DeleteCredentialsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCredentialsResponse parses an HTTP response from a GetCredentialsWithResponse call
func ParseGetCredentialsResponse(rsp *http.Response) (*GetCredentialsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Credentials
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteUserExternalPrincipalResponse parses an HTTP response from a DeleteUserExternalPrincipalWithResponse call
func ParseDeleteUserExternalPrincipalResponse(rsp *http.Response) (*DeleteUserExternalPrincipalResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserExternalPrincipalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateUserExternalPrincipalResponse parses an HTTP response from a CreateUserExternalPrincipalWithResponse call
func ParseCreateUserExternalPrincipalResponse(rsp *http.Response) (*CreateUserExternalPrincipalResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateUserExternalPrincipalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListUserExternalPrincipalsResponse parses an HTTP response from a ListUserExternalPrincipalsWithResponse call
func ParseListUserExternalPrincipalsResponse(rsp *http.Response) (*ListUserExternalPrincipalsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListUserExternalPrincipalsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExternalPrincipalList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListUserGroupsResponse parses an HTTP response from a ListUserGroupsWithResponse call
func ParseListUserGroupsResponse(rsp *http.Response) (*ListUserGroupsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListUserGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListUserPoliciesResponse parses an HTTP response from a ListUserPoliciesWithResponse call
func ParseListUserPoliciesResponse(rsp *http.Response) (*ListUserPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListUserPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDetachPolicyFromUserResponse parses an HTTP response from a DetachPolicyFromUserWithResponse call
func ParseDetachPolicyFromUserResponse(rsp *http.Response) (*DetachPolicyFromUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DetachPolicyFromUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAttachPolicyToUserResponse parses an HTTP response from a AttachPolicyToUserWithResponse call
func ParseAttachPolicyToUserResponse(rsp *http.Response) (*AttachPolicyToUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AttachPolicyToUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetConfigResponse parses an HTTP response from a GetConfigWithResponse call
func ParseGetConfigResponse(rsp *http.Response) (*GetConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Config
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetGarbageCollectionConfigResponse parses an HTTP response from a GetGarbageCollectionConfigWithResponse call
func ParseGetGarbageCollectionConfigResponse(rsp *http.Response) (*GetGarbageCollectionConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetGarbageCollectionConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GarbageCollectionConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetStorageConfigResponse parses an HTTP response from a GetStorageConfigWithResponse call
func ParseGetStorageConfigResponse(rsp *http.Response) (*GetStorageConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetStorageConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StorageConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetLakeFSVersionResponse parses an HTTP response from a GetLakeFSVersionWithResponse call
func ParseGetLakeFSVersionResponse(rsp *http.Response) (*GetLakeFSVersionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetLakeFSVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VersionConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseHealthCheckResponse parses an HTTP response from a HealthCheckWithResponse call
func ParseHealthCheckResponse(rsp *http.Response) (*HealthCheckResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &HealthCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParsePullIcebergTableResponse parses an HTTP response from a PullIcebergTableWithResponse call
func ParsePullIcebergTableResponse(rsp *http.Response) (*PullIcebergTableResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PullIcebergTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePushIcebergTableResponse parses an HTTP response from a PushIcebergTableWithResponse call
func ParsePushIcebergTableResponse(rsp *http.Response) (*PushIcebergTableResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PushIcebergTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLicenseResponse parses an HTTP response from a GetLicenseWithResponse call
func ParseGetLicenseResponse(rsp *http.Response) (*GetLicenseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetLicenseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest License
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOauthCallbackResponse parses an HTTP response from a OauthCallbackWithResponse call
func ParseOauthCallbackResponse(rsp *http.Response) (*OauthCallbackResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &OauthCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListRepositoriesResponse parses an HTTP response from a ListRepositoriesWithResponse call
func ParseListRepositoriesResponse(rsp *http.Response) (*ListRepositoriesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListRepositoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RepositoryList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateRepositoryResponse parses an HTTP response from a CreateRepositoryWithResponse call
func ParseCreateRepositoryResponse(rsp *http.Response) (*CreateRepositoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Repository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteRepositoryResponse parses an HTTP response from a DeleteRepositoryWithResponse call
func ParseDeleteRepositoryResponse(rsp *http.Response) (*DeleteRepositoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRepositoryResponse parses an HTTP response from a GetRepositoryWithResponse call
func ParseGetRepositoryResponse(rsp *http.Response) (*GetRepositoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Repository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListRepositoryRunsResponse parses an HTTP response from a ListRepositoryRunsWithResponse call
func ParseListRepositoryRunsResponse(rsp *http.Response) (*ListRepositoryRunsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListRepositoryRunsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionRunList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRunResponse parses an HTTP response from a GetRunWithResponse call
func ParseGetRunResponse(rsp *http.Response) (*GetRunResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListRunHooksResponse parses an HTTP response from a ListRunHooksWithResponse call
func ParseListRunHooksResponse(rsp *http.Response) (*ListRunHooksResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListRunHooksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HookRunList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRunHookOutputResponse parses an HTTP response from a GetRunHookOutputWithResponse call
func ParseGetRunHookOutputResponse(rsp *http.Response) (*GetRunHookOutputResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetRunHookOutputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInternalDeleteBranchProtectionRuleResponse parses an HTTP response from a InternalDeleteBranchProtectionRuleWithResponse call
func ParseInternalDeleteBranchProtectionRuleResponse(rsp *http.Response) (*InternalDeleteBranchProtectionRuleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &InternalDeleteBranchProtectionRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInternalGetBranchProtectionRulesResponse parses an HTTP response from a InternalGetBranchProtectionRulesWithResponse call
func ParseInternalGetBranchProtectionRulesResponse(rsp *http.Response) (*InternalGetBranchProtectionRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &InternalGetBranchProtectionRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []BranchProtectionRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInternalCreateBranchProtectionRuleResponse parses an HTTP response from a InternalCreateBranchProtectionRuleWithResponse call
func ParseInternalCreateBranchProtectionRuleResponse(rsp *http.Response) (*InternalCreateBranchProtectionRuleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &InternalCreateBranchProtectionRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBranchProtectionRulePreflightResponse parses an HTTP response from a CreateBranchProtectionRulePreflightWithResponse call
func ParseCreateBranchProtectionRulePreflightResponse(rsp *http.Response) (*CreateBranchProtectionRulePreflightResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateBranchProtectionRulePreflightResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListBranchesResponse parses an HTTP response from a ListBranchesWithResponse call
func ParseListBranchesResponse(rsp *http.Response) (*ListBranchesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListBranchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RefList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBranchResponse parses an HTTP response from a CreateBranchWithResponse call
func ParseCreateBranchResponse(rsp *http.Response) (*CreateBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteBranchResponse parses an HTTP response from a DeleteBranchWithResponse call
func ParseDeleteBranchResponse(rsp *http.Response) (*DeleteBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBranchResponse parses an HTTP response from a GetBranchWithResponse call
func ParseGetBranchResponse(rsp *http.Response) (*GetBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Ref
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseResetBranchResponse parses an HTTP response from a ResetBranchWithResponse call
func ParseResetBranchResponse(rsp *http.Response) (*ResetBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ResetBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCherryPickResponse parses an HTTP response from a CherryPickWithResponse call
func ParseCherryPickResponse(rsp *http.Response) (*CherryPickResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CherryPickResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Commit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCommitResponse parses an HTTP response from a CommitWithResponse call
func ParseCommitResponse(rsp *http.Response) (*CommitResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CommitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Commit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCommitAsyncResponse parses an HTTP response from a CommitAsyncWithResponse call
func ParseCommitAsyncResponse(rsp *http.Response) (*CommitAsyncResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CommitAsyncResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TaskCreation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCommitAsyncStatusResponse parses an HTTP response from a CommitAsyncStatusWithResponse call
func ParseCommitAsyncStatusResponse(rsp *http.Response) (*CommitAsyncStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CommitAsyncStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommitAsyncStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDiffBranchResponse parses an HTTP response from a DiffBranchWithResponse call
func ParseDiffBranchResponse(rsp *http.Response) (*DiffBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DiffBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DiffList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseHardResetBranchResponse parses an HTTP response from a HardResetBranchWithResponse call
func ParseHardResetBranchResponse(rsp *http.Response) (*HardResetBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &HardResetBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseImportCancelResponse parses an HTTP response from a ImportCancelWithResponse call
func ParseImportCancelResponse(rsp *http.Response) (*ImportCancelResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ImportCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseImportStatusResponse parses an HTTP response from a ImportStatusWithResponse call
func ParseImportStatusResponse(rsp *http.Response) (*ImportStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ImportStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ImportStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseImportStartResponse parses an HTTP response from a ImportStartWithResponse call
func ParseImportStartResponse(rsp *http.Response) (*ImportStartResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ImportStartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ImportCreationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteObjectResponse parses an HTTP response from a DeleteObjectWithResponse call
func ParseDeleteObjectResponse(rsp *http.Response) (*DeleteObjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUploadObjectResponse parses an HTTP response from a UploadObjectWithResponse call
func ParseUploadObjectResponse(rsp *http.Response) (*UploadObjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UploadObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ObjectStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStageObjectResponse parses an HTTP response from a StageObjectWithResponse call
func ParseStageObjectResponse(rsp *http.Response) (*StageObjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &StageObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ObjectStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCopyObjectResponse parses an HTTP response from a CopyObjectWithResponse call
func ParseCopyObjectResponse(rsp *http.Response) (*CopyObjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CopyObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ObjectStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteObjectsResponse parses an HTTP response from a DeleteObjectsWithResponse call
func ParseDeleteObjectsResponse(rsp *http.Response) (*DeleteObjectsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteObjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUploadObjectPreflightResponse parses an HTTP response from a UploadObjectPreflightWithResponse call
func ParseUploadObjectPreflightResponse(rsp *http.Response) (*UploadObjectPreflightResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UploadObjectPreflightResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateObjectUserMetadataResponse parses an HTTP response from a UpdateObjectUserMetadataWithResponse call
func ParseUpdateObjectUserMetadataResponse(rsp *http.Response) (*UpdateObjectUserMetadataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdateObjectUserMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRevertBranchResponse parses an HTTP response from a RevertBranchWithResponse call
func ParseRevertBranchResponse(rsp *http.Response) (*RevertBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &RevertBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPhysicalAddressResponse parses an HTTP response from a GetPhysicalAddressWithResponse call
func ParseGetPhysicalAddressResponse(rsp *http.Response) (*GetPhysicalAddressResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetPhysicalAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StagingLocation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseLinkPhysicalAddressResponse parses an HTTP response from a LinkPhysicalAddressWithResponse call
func ParseLinkPhysicalAddressResponse(rsp *http.Response) (*LinkPhysicalAddressResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &LinkPhysicalAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest StagingLocation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreatePresignMultipartUploadResponse parses an HTTP response from a CreatePresignMultipartUploadWithResponse call
func ParseCreatePresignMultipartUploadResponse(rsp *http.Response) (*CreatePresignMultipartUploadResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreatePresignMultipartUploadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PresignMultipartUpload
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAbortPresignMultipartUploadResponse parses an HTTP response from a AbortPresignMultipartUploadWithResponse call
func ParseAbortPresignMultipartUploadResponse(rsp *http.Response) (*AbortPresignMultipartUploadResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AbortPresignMultipartUploadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCompletePresignMultipartUploadResponse parses an HTTP response from a CompletePresignMultipartUploadWithResponse call
func ParseCompletePresignMultipartUploadResponse(rsp *http.Response) (*CompletePresignMultipartUploadResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CompletePresignMultipartUploadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest StagingLocation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUploadPartResponse parses an HTTP response from a UploadPartWithResponse call
func ParseUploadPartResponse(rsp *http.Response) (*UploadPartResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UploadPartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UploadTo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUploadPartCopyResponse parses an HTTP response from a UploadPartCopyWithResponse call
func ParseUploadPartCopyResponse(rsp *http.Response) (*UploadPartCopyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UploadPartCopyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateCommitRecordResponse parses an HTTP response from a CreateCommitRecordWithResponse call
func ParseCreateCommitRecordResponse(rsp *http.Response) (*CreateCommitRecordResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateCommitRecordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCommitResponse parses an HTTP response from a GetCommitWithResponse call
func ParseGetCommitResponse(rsp *http.Response) (*GetCommitResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetCommitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Commit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDumpStatusResponse parses an HTTP response from a DumpStatusWithResponse call
func ParseDumpStatusResponse(rsp *http.Response) (*DumpStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DumpStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RepositoryDumpStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDumpSubmitResponse parses an HTTP response from a DumpSubmitWithResponse call
func ParseDumpSubmitResponse(rsp *http.Response) (*DumpSubmitResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DumpSubmitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TaskInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePrepareGarbageCollectionCommitsResponse parses an HTTP response from a PrepareGarbageCollectionCommitsWithResponse call
func ParsePrepareGarbageCollectionCommitsResponse(rsp *http.Response) (*PrepareGarbageCollectionCommitsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PrepareGarbageCollectionCommitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest GarbageCollectionPrepareResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePrepareGarbageCollectionCommitsAsyncResponse parses an HTTP response from a PrepareGarbageCollectionCommitsAsyncWithResponse call
func ParsePrepareGarbageCollectionCommitsAsyncResponse(rsp *http.Response) (*PrepareGarbageCollectionCommitsAsyncResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PrepareGarbageCollectionCommitsAsyncResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TaskCreation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePrepareGarbageCollectionCommitsStatusResponse parses an HTTP response from a PrepareGarbageCollectionCommitsStatusWithResponse call
func ParsePrepareGarbageCollectionCommitsStatusResponse(rsp *http.Response) (*PrepareGarbageCollectionCommitsStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PrepareGarbageCollectionCommitsStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PrepareGarbageCollectionCommitsStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePrepareGarbageCollectionUncommittedResponse parses an HTTP response from a PrepareGarbageCollectionUncommittedWithResponse call
func ParsePrepareGarbageCollectionUncommittedResponse(rsp *http.Response) (*PrepareGarbageCollectionUncommittedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PrepareGarbageCollectionUncommittedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PrepareGCUncommittedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInternalDeleteGarbageCollectionRulesResponse parses an HTTP response from a InternalDeleteGarbageCollectionRulesWithResponse call
func ParseInternalDeleteGarbageCollectionRulesResponse(rsp *http.Response) (*InternalDeleteGarbageCollectionRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &InternalDeleteGarbageCollectionRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInternalGetGarbageCollectionRulesResponse parses an HTTP response from a InternalGetGarbageCollectionRulesWithResponse call
func ParseInternalGetGarbageCollectionRulesResponse(rsp *http.Response) (*InternalGetGarbageCollectionRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &InternalGetGarbageCollectionRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GarbageCollectionRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInternalSetGarbageCollectionRulesResponse parses an HTTP response from a InternalSetGarbageCollectionRulesWithResponse call
func ParseInternalSetGarbageCollectionRulesResponse(rsp *http.Response) (*InternalSetGarbageCollectionRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &InternalSetGarbageCollectionRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetGarbageCollectionRulesPreflightResponse parses an HTTP response from a SetGarbageCollectionRulesPreflightWithResponse call
func ParseSetGarbageCollectionRulesPreflightResponse(rsp *http.Response) (*SetGarbageCollectionRulesPreflightResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SetGarbageCollectionRulesPreflightResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteRepositoryMetadataResponse parses an HTTP response from a DeleteRepositoryMetadataWithResponse call
func ParseDeleteRepositoryMetadataResponse(rsp *http.Response) (*DeleteRepositoryMetadataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteRepositoryMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRepositoryMetadataResponse parses an HTTP response from a GetRepositoryMetadataWithResponse call
func ParseGetRepositoryMetadataResponse(rsp *http.Response) (*GetRepositoryMetadataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetRepositoryMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RepositoryMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetRepositoryMetadataResponse parses an HTTP response from a SetRepositoryMetadataWithResponse call
func ParseSetRepositoryMetadataResponse(rsp *http.Response) (*SetRepositoryMetadataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SetRepositoryMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMetaRangeResponse parses an HTTP response from a GetMetaRangeWithResponse call
func ParseGetMetaRangeResponse(rsp *http.Response) (*GetMetaRangeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetMetaRangeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StorageURI
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMetadataObjectResponse parses an HTTP response from a GetMetadataObjectWithResponse call
func ParseGetMetadataObjectResponse(rsp *http.Response) (*GetMetadataObjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetMetadataObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRangeResponse parses an HTTP response from a GetRangeWithResponse call
func ParseGetRangeResponse(rsp *http.Response) (*GetRangeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetRangeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StorageURI
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListPullRequestsResponse parses an HTTP response from a ListPullRequestsWithResponse call
func ParseListPullRequestsResponse(rsp *http.Response) (*ListPullRequestsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListPullRequestsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PullRequestsList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreatePullRequestResponse parses an HTTP response from a CreatePullRequestWithResponse call
func ParseCreatePullRequestResponse(rsp *http.Response) (*CreatePullRequestResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreatePullRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PullRequestCreationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPullRequestResponse parses an HTTP response from a GetPullRequestWithResponse call
func ParseGetPullRequestResponse(rsp *http.Response) (*GetPullRequestResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetPullRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PullRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdatePullRequestResponse parses an HTTP response from a UpdatePullRequestWithResponse call
func ParseUpdatePullRequestResponse(rsp *http.Response) (*UpdatePullRequestResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdatePullRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMergePullRequestResponse parses an HTTP response from a MergePullRequestWithResponse call
func ParseMergePullRequestResponse(rsp *http.Response) (*MergePullRequestResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &MergePullRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MergeResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest MergeResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDumpRefsResponse parses an HTTP response from a DumpRefsWithResponse call
func ParseDumpRefsResponse(rsp *http.Response) (*DumpRefsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DumpRefsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RefsDump
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRestoreRefsResponse parses an HTTP response from a RestoreRefsWithResponse call
func ParseRestoreRefsResponse(rsp *http.Response) (*RestoreRefsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &RestoreRefsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSymlinkFileResponse parses an HTTP response from a CreateSymlinkFileWithResponse call
func ParseCreateSymlinkFileResponse(rsp *http.Response) (*CreateSymlinkFileResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateSymlinkFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest StorageURI
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDiffRefsResponse parses an HTTP response from a DiffRefsWithResponse call
func ParseDiffRefsResponse(rsp *http.Response) (*DiffRefsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DiffRefsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DiffList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseLogCommitsResponse parses an HTTP response from a LogCommitsWithResponse call
func ParseLogCommitsResponse(rsp *http.Response) (*LogCommitsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &LogCommitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommitList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetObjectResponse parses an HTTP response from a GetObjectWithResponse call
func ParseGetObjectResponse(rsp *http.Response) (*GetObjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 416:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON416 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseHeadObjectResponse parses an HTTP response from a HeadObjectWithResponse call
func ParseHeadObjectResponse(rsp *http.Response) (*HeadObjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &HeadObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseListObjectsResponse parses an HTTP response from a ListObjectsWithResponse call
func ParseListObjectsResponse(rsp *http.Response) (*ListObjectsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListObjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStatsList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStatObjectResponse parses an HTTP response from a StatObjectWithResponse call
func ParseStatObjectResponse(rsp *http.Response) (*StatObjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &StatObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUnderlyingPropertiesResponse parses an HTTP response from a GetUnderlyingPropertiesWithResponse call
func ParseGetUnderlyingPropertiesResponse(rsp *http.Response) (*GetUnderlyingPropertiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetUnderlyingPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UnderlyingObjectProperties
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseFindMergeBaseResponse parses an HTTP response from a FindMergeBaseWithResponse call
func ParseFindMergeBaseResponse(rsp *http.Response) (*FindMergeBaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &FindMergeBaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FindMergeBaseResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMergeIntoBranchResponse parses an HTTP response from a MergeIntoBranchWithResponse call
func ParseMergeIntoBranchResponse(rsp *http.Response) (*MergeIntoBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &MergeIntoBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MergeResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest MergeResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMergeIntoBranchAsyncResponse parses an HTTP response from a MergeIntoBranchAsyncWithResponse call
func ParseMergeIntoBranchAsyncResponse(rsp *http.Response) (*MergeIntoBranchAsyncResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &MergeIntoBranchAsyncResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TaskCreation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMergeIntoBranchAsyncStatusResponse parses an HTTP response from a MergeIntoBranchAsyncStatusWithResponse call
func ParseMergeIntoBranchAsyncStatusResponse(rsp *http.Response) (*MergeIntoBranchAsyncStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &MergeIntoBranchAsyncStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MergeAsyncStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRestoreStatusResponse parses an HTTP response from a RestoreStatusWithResponse call
func ParseRestoreStatusResponse(rsp *http.Response) (*RestoreStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &RestoreStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RepositoryRestoreStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRestoreSubmitResponse parses an HTTP response from a RestoreSubmitWithResponse call
func ParseRestoreSubmitResponse(rsp *http.Response) (*RestoreSubmitResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &RestoreSubmitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TaskInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBranchProtectionRulesResponse parses an HTTP response from a GetBranchProtectionRulesWithResponse call
func ParseGetBranchProtectionRulesResponse(rsp *http.Response) (*GetBranchProtectionRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetBranchProtectionRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []BranchProtectionRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetBranchProtectionRulesResponse parses an HTTP response from a SetBranchProtectionRulesWithResponse call
func ParseSetBranchProtectionRulesResponse(rsp *http.Response) (*SetBranchProtectionRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SetBranchProtectionRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteGCRulesResponse parses an HTTP response from a DeleteGCRulesWithResponse call
func ParseDeleteGCRulesResponse(rsp *http.Response) (*DeleteGCRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteGCRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetGCRulesResponse parses an HTTP response from a GetGCRulesWithResponse call
func ParseGetGCRulesResponse(rsp *http.Response) (*GetGCRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetGCRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GarbageCollectionRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetGCRulesResponse parses an HTTP response from a SetGCRulesWithResponse call
func ParseSetGCRulesResponse(rsp *http.Response) (*SetGCRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SetGCRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListTagsResponse parses an HTTP response from a ListTagsWithResponse call
func ParseListTagsResponse(rsp *http.Response) (*ListTagsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RefList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTagResponse parses an HTTP response from a CreateTagWithResponse call
func ParseCreateTagResponse(rsp *http.Response) (*CreateTagResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Ref
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTagResponse parses an HTTP response from a DeleteTagWithResponse call
func ParseDeleteTagResponse(rsp *http.Response) (*DeleteTagResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTagResponse parses an HTTP response from a GetTagWithResponse call
func ParseGetTagResponse(rsp *http.Response) (*GetTagResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Ref
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetupCommPrefsResponse parses an HTTP response from a SetupCommPrefsWithResponse call
func ParseSetupCommPrefsResponse(rsp *http.Response) (*SetupCommPrefsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SetupCommPrefsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSetupStateResponse parses an HTTP response from a GetSetupStateWithResponse call
func ParseGetSetupStateResponse(rsp *http.Response) (*GetSetupStateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetSetupStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SetupState
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetupResponse parses an HTTP response from a SetupWithResponse call
func ParseSetupResponse(rsp *http.Response) (*SetupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SetupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CredentialsWithSecret
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostStatsEventsResponse parses an HTTP response from a PostStatsEventsWithResponse call
func ParsePostStatsEventsResponse(rsp *http.Response) (*PostStatsEventsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostStatsEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStsLoginResponse parses an HTTP response from a StsLoginWithResponse call
func ParseStsLoginResponse(rsp *http.Response) (*StsLoginResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &StsLoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthenticationToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUsageReportSummaryResponse parses an HTTP response from a GetUsageReportSummaryWithResponse call
func ParseGetUsageReportSummaryResponse(rsp *http.Response) (*GetUsageReportSummaryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetUsageReportSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InstallationUsageReport
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/text) unsupported

	}

	return response, nil
}

// ParseGetCurrentUserResponse parses an HTTP response from a GetCurrentUserWithResponse call
func ParseGetCurrentUserResponse(rsp *http.Response) (*GetCurrentUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CurrentUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// chi-interface.tmpl based on https://github.com/deepmap/oapi-codegen/tree/master/pkg/codegen/templates

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// list authentication capabilities supported
	// (GET /auth/capabilities)
	GetAuthCapabilities(w http.ResponseWriter, r *http.Request)
	// perform a login using an external authenticator
	// (POST /auth/external/principal/login)
	ExternalPrincipalLogin(w http.ResponseWriter, r *http.Request, body ExternalPrincipalLoginJSONRequestBody)
	// describe external principal by id
	// (GET /auth/external/principals)
	GetExternalPrincipal(w http.ResponseWriter, r *http.Request, params GetExternalPrincipalParams)
	// receive the token after user has authenticated on redirect URL.
	// (GET /auth/get-token/mailboxes/{mailbox})
	GetTokenFromMailbox(w http.ResponseWriter, r *http.Request, mailbox string)
	// release a token for the current (authenticated) user to the mailbox of this login request.
	// (GET /auth/get-token/release-token/{loginRequestToken})
	ReleaseTokenToMailbox(w http.ResponseWriter, r *http.Request, loginRequestToken string)
	// start acquiring a token by logging in on a browser
	// (GET /auth/get-token/start)
	GetTokenRedirect(w http.ResponseWriter, r *http.Request)
	// list groups
	// (GET /auth/groups)
	ListGroups(w http.ResponseWriter, r *http.Request, params ListGroupsParams)
	// create group
	// (POST /auth/groups)
	CreateGroup(w http.ResponseWriter, r *http.Request, body CreateGroupJSONRequestBody)
	// delete group
	// (DELETE /auth/groups/{groupId})
	DeleteGroup(w http.ResponseWriter, r *http.Request, groupId string)
	// get group
	// (GET /auth/groups/{groupId})
	GetGroup(w http.ResponseWriter, r *http.Request, groupId string)
	// get ACL of group
	// (GET /auth/groups/{groupId}/acl)
	GetGroupACL(w http.ResponseWriter, r *http.Request, groupId string)
	// set ACL of group
	// (POST /auth/groups/{groupId}/acl)
	SetGroupACL(w http.ResponseWriter, r *http.Request, body SetGroupACLJSONRequestBody, groupId string)
	// list group members
	// (GET /auth/groups/{groupId}/members)
	ListGroupMembers(w http.ResponseWriter, r *http.Request, groupId string, params ListGroupMembersParams)
	// delete group membership
	// (DELETE /auth/groups/{groupId}/members/{userId})
	DeleteGroupMembership(w http.ResponseWriter, r *http.Request, groupId string, userId string)
	// add group membership
	// (PUT /auth/groups/{groupId}/members/{userId})
	AddGroupMembership(w http.ResponseWriter, r *http.Request, groupId string, userId string)
	// list group policies
	// (GET /auth/groups/{groupId}/policies)
	ListGroupPolicies(w http.ResponseWriter, r *http.Request, groupId string, params ListGroupPoliciesParams)
	// detach policy from group
	// (DELETE /auth/groups/{groupId}/policies/{policyId})
	DetachPolicyFromGroup(w http.ResponseWriter, r *http.Request, groupId string, policyId string)
	// attach policy to group
	// (PUT /auth/groups/{groupId}/policies/{policyId})
	AttachPolicyToGroup(w http.ResponseWriter, r *http.Request, groupId string, policyId string)
	// perform a login
	// (POST /auth/login)
	Login(w http.ResponseWriter, r *http.Request, body LoginJSONRequestBody)
	// list policies
	// (GET /auth/policies)
	ListPolicies(w http.ResponseWriter, r *http.Request, params ListPoliciesParams)
	// create policy
	// (POST /auth/policies)
	CreatePolicy(w http.ResponseWriter, r *http.Request, body CreatePolicyJSONRequestBody)
	// delete policy
	// (DELETE /auth/policies/{policyId})
	DeletePolicy(w http.ResponseWriter, r *http.Request, policyId string)
	// get policy
	// (GET /auth/policies/{policyId})
	GetPolicy(w http.ResponseWriter, r *http.Request, policyId string)
	// update policy
	// (PUT /auth/policies/{policyId})
	UpdatePolicy(w http.ResponseWriter, r *http.Request, body UpdatePolicyJSONRequestBody, policyId string)
	// list users
	// (GET /auth/users)
	ListUsers(w http.ResponseWriter, r *http.Request, params ListUsersParams)
	// create user
	// (POST /auth/users)
	CreateUser(w http.ResponseWriter, r *http.Request, body CreateUserJSONRequestBody)
	// delete user
	// (DELETE /auth/users/{userId})
	DeleteUser(w http.ResponseWriter, r *http.Request, userId string)
	// get user
	// (GET /auth/users/{userId})
	GetUser(w http.ResponseWriter, r *http.Request, userId string)
	// list user credentials
	// (GET /auth/users/{userId}/credentials)
	ListUserCredentials(w http.ResponseWriter, r *http.Request, userId string, params ListUserCredentialsParams)
	// create credentials
	// (POST /auth/users/{userId}/credentials)
	CreateCredentials(w http.ResponseWriter, r *http.Request, userId string)
	// delete credentials
	// (DELETE /auth/users/{userId}/credentials/{accessKeyId})
	DeleteCredentials(w http.ResponseWriter, r *http.Request, userId string, accessKeyId string)
	// get credentials
	// (GET /auth/users/{userId}/credentials/{accessKeyId})
	GetCredentials(w http.ResponseWriter, r *http.Request, userId string, accessKeyId string)
	// delete external principal from user
	// (DELETE /auth/users/{userId}/external/principals)
	DeleteUserExternalPrincipal(w http.ResponseWriter, r *http.Request, userId string, params DeleteUserExternalPrincipalParams)
	// attach external principal to user
	// (POST /auth/users/{userId}/external/principals)
	CreateUserExternalPrincipal(w http.ResponseWriter, r *http.Request, body CreateUserExternalPrincipalJSONRequestBody, userId string, params CreateUserExternalPrincipalParams)
	// list user external policies attached to a user
	// (GET /auth/users/{userId}/external/principals/ls)
	ListUserExternalPrincipals(w http.ResponseWriter, r *http.Request, userId string, params ListUserExternalPrincipalsParams)
	// list user groups
	// (GET /auth/users/{userId}/groups)
	ListUserGroups(w http.ResponseWriter, r *http.Request, userId string, params ListUserGroupsParams)
	// list user policies
	// (GET /auth/users/{userId}/policies)
	ListUserPolicies(w http.ResponseWriter, r *http.Request, userId string, params ListUserPoliciesParams)
	// detach policy from user
	// (DELETE /auth/users/{userId}/policies/{policyId})
	DetachPolicyFromUser(w http.ResponseWriter, r *http.Request, userId string, policyId string)
	// attach policy to user
	// (PUT /auth/users/{userId}/policies/{policyId})
	AttachPolicyToUser(w http.ResponseWriter, r *http.Request, userId string, policyId string)

	// (GET /config)
	GetConfig(w http.ResponseWriter, r *http.Request)

	// (GET /config/garbage-collection)
	GetGarbageCollectionConfig(w http.ResponseWriter, r *http.Request)

	// (GET /config/storage)
	GetStorageConfig(w http.ResponseWriter, r *http.Request)

	// (GET /config/version)
	GetLakeFSVersion(w http.ResponseWriter, r *http.Request)

	// (GET /healthcheck)
	HealthCheck(w http.ResponseWriter, r *http.Request)
	// take a table previously pushed from lakeFS into a remote catalog, and pull its state back into the originating lakeFS repository
	// (POST /iceberg/remotes/{catalog}/pull)
	PullIcebergTable(w http.ResponseWriter, r *http.Request, body PullIcebergTableJSONRequestBody, catalog string)
	// register existing lakeFS table in remote catalog
	// (POST /iceberg/remotes/{catalog}/push)
	PushIcebergTable(w http.ResponseWriter, r *http.Request, body PushIcebergTableJSONRequestBody, catalog string)

	// (GET /license)
	GetLicense(w http.ResponseWriter, r *http.Request)

	// (GET /oidc/callback)
	OauthCallback(w http.ResponseWriter, r *http.Request)
	// list repositories
	// (GET /repositories)
	ListRepositories(w http.ResponseWriter, r *http.Request, params ListRepositoriesParams)
	// create repository
	// (POST /repositories)
	CreateRepository(w http.ResponseWriter, r *http.Request, body CreateRepositoryJSONRequestBody, params CreateRepositoryParams)
	// delete repository
	// (DELETE /repositories/{repository})
	DeleteRepository(w http.ResponseWriter, r *http.Request, repository string, params DeleteRepositoryParams)
	// get repository
	// (GET /repositories/{repository})
	GetRepository(w http.ResponseWriter, r *http.Request, repository string)
	// list runs
	// (GET /repositories/{repository}/actions/runs)
	ListRepositoryRuns(w http.ResponseWriter, r *http.Request, repository string, params ListRepositoryRunsParams)
	// get a run
	// (GET /repositories/{repository}/actions/runs/{run_id})
	GetRun(w http.ResponseWriter, r *http.Request, repository string, runId string)
	// list run hooks
	// (GET /repositories/{repository}/actions/runs/{run_id}/hooks)
	ListRunHooks(w http.ResponseWriter, r *http.Request, repository string, runId string, params ListRunHooksParams)
	// get run hook output
	// (GET /repositories/{repository}/actions/runs/{run_id}/hooks/{hook_run_id}/output)
	GetRunHookOutput(w http.ResponseWriter, r *http.Request, repository string, runId string, hookRunId string)

	// (DELETE /repositories/{repository}/branch_protection)
	InternalDeleteBranchProtectionRule(w http.ResponseWriter, r *http.Request, body InternalDeleteBranchProtectionRuleJSONRequestBody, repository string)
	// get branch protection rules
	// (GET /repositories/{repository}/branch_protection)
	InternalGetBranchProtectionRules(w http.ResponseWriter, r *http.Request, repository string)

	// (POST /repositories/{repository}/branch_protection)
	InternalCreateBranchProtectionRule(w http.ResponseWriter, r *http.Request, body InternalCreateBranchProtectionRuleJSONRequestBody, repository string)

	// (GET /repositories/{repository}/branch_protection/set_allowed)
	CreateBranchProtectionRulePreflight(w http.ResponseWriter, r *http.Request, repository string)
	// list branches
	// (GET /repositories/{repository}/branches)
	ListBranches(w http.ResponseWriter, r *http.Request, repository string, params ListBranchesParams)
	// create branch
	// (POST /repositories/{repository}/branches)
	CreateBranch(w http.ResponseWriter, r *http.Request, body CreateBranchJSONRequestBody, repository string)
	// delete branch
	// (DELETE /repositories/{repository}/branches/{branch})
	DeleteBranch(w http.ResponseWriter, r *http.Request, repository string, branch string, params DeleteBranchParams)
	// get branch
	// (GET /repositories/{repository}/branches/{branch})
	GetBranch(w http.ResponseWriter, r *http.Request, repository string, branch string)
	// reset branch
	// (PUT /repositories/{repository}/branches/{branch})
	ResetBranch(w http.ResponseWriter, r *http.Request, body ResetBranchJSONRequestBody, repository string, branch string)
	// Replay the changes from the given commit on the branch
	// (POST /repositories/{repository}/branches/{branch}/cherry-pick)
	CherryPick(w http.ResponseWriter, r *http.Request, body CherryPickJSONRequestBody, repository string, branch string)
	// create commit
	// (POST /repositories/{repository}/branches/{branch}/commits)
	Commit(w http.ResponseWriter, r *http.Request, body CommitJSONRequestBody, repository string, branch string, params CommitParams)
	// create commit asynchronously
	// (POST /repositories/{repository}/branches/{branch}/commits/async)
	CommitAsync(w http.ResponseWriter, r *http.Request, body CommitAsyncJSONRequestBody, repository string, branch string, params CommitAsyncParams)
	// get status of async commit operation
	// (GET /repositories/{repository}/branches/{branch}/commits/async/{id}/status)
	CommitAsyncStatus(w http.ResponseWriter, r *http.Request, repository string, branch string, id string)
	// diff branch
	// (GET /repositories/{repository}/branches/{branch}/diff)
	DiffBranch(w http.ResponseWriter, r *http.Request, repository string, branch string, params DiffBranchParams)
	// hard reset branch
	// (PUT /repositories/{repository}/branches/{branch}/hard_reset)
	HardResetBranch(w http.ResponseWriter, r *http.Request, repository string, branch string, params HardResetBranchParams)
	// cancel ongoing import
	// (DELETE /repositories/{repository}/branches/{branch}/import)
	ImportCancel(w http.ResponseWriter, r *http.Request, repository string, branch string, params ImportCancelParams)
	// get import status
	// (GET /repositories/{repository}/branches/{branch}/import)
	ImportStatus(w http.ResponseWriter, r *http.Request, repository string, branch string, params ImportStatusParams)
	// import data from object store
	// (POST /repositories/{repository}/branches/{branch}/import)
	ImportStart(w http.ResponseWriter, r *http.Request, body ImportStartJSONRequestBody, repository string, branch string)
	// delete object. Missing objects will not return a NotFound error.
	// (DELETE /repositories/{repository}/branches/{branch}/objects)
	DeleteObject(w http.ResponseWriter, r *http.Request, repository string, branch string, params DeleteObjectParams)

	// (POST /repositories/{repository}/branches/{branch}/objects)
	UploadObject(w http.ResponseWriter, r *http.Request, repository string, branch string, params UploadObjectParams)
	// stage an object's metadata for the given branch
	// (PUT /repositories/{repository}/branches/{branch}/objects)
	StageObject(w http.ResponseWriter, r *http.Request, body StageObjectJSONRequestBody, repository string, branch string, params StageObjectParams)
	// create a copy of an object
	// (POST /repositories/{repository}/branches/{branch}/objects/copy)
	CopyObject(w http.ResponseWriter, r *http.Request, body CopyObjectJSONRequestBody, repository string, branch string, params CopyObjectParams)
	// delete objects. Missing objects will not return a NotFound error.
	// (POST /repositories/{repository}/branches/{branch}/objects/delete)
	DeleteObjects(w http.ResponseWriter, r *http.Request, body DeleteObjectsJSONRequestBody, repository string, branch string, params DeleteObjectsParams)

	// (GET /repositories/{repository}/branches/{branch}/objects/stage_allowed)
	UploadObjectPreflight(w http.ResponseWriter, r *http.Request, repository string, branch string, params UploadObjectPreflightParams)
	// rewrite (all) object metadata
	// (PUT /repositories/{repository}/branches/{branch}/objects/stat/user_metadata)
	UpdateObjectUserMetadata(w http.ResponseWriter, r *http.Request, body UpdateObjectUserMetadataJSONRequestBody, repository string, branch string, params UpdateObjectUserMetadataParams)
	// revert
	// (POST /repositories/{repository}/branches/{branch}/revert)
	RevertBranch(w http.ResponseWriter, r *http.Request, body RevertBranchJSONRequestBody, repository string, branch string)
	// generate an address to which the client can upload an object
	// (GET /repositories/{repository}/branches/{branch}/staging/backing)
	GetPhysicalAddress(w http.ResponseWriter, r *http.Request, repository string, branch string, params GetPhysicalAddressParams)
	// associate staging on this physical address with a path
	// (PUT /repositories/{repository}/branches/{branch}/staging/backing)
	LinkPhysicalAddress(w http.ResponseWriter, r *http.Request, body LinkPhysicalAddressJSONRequestBody, repository string, branch string, params LinkPhysicalAddressParams)
	// Initiate a multipart upload
	// (POST /repositories/{repository}/branches/{branch}/staging/pmpu)
	CreatePresignMultipartUpload(w http.ResponseWriter, r *http.Request, repository string, branch string, params CreatePresignMultipartUploadParams)
	// Abort a presign multipart upload
	// (DELETE /repositories/{repository}/branches/{branch}/staging/pmpu/{uploadId})
	AbortPresignMultipartUpload(w http.ResponseWriter, r *http.Request, body AbortPresignMultipartUploadJSONRequestBody, repository string, branch string, uploadId string, params AbortPresignMultipartUploadParams)
	// Complete a presign multipart upload request
	// (PUT /repositories/{repository}/branches/{branch}/staging/pmpu/{uploadId})
	CompletePresignMultipartUpload(w http.ResponseWriter, r *http.Request, body CompletePresignMultipartUploadJSONRequestBody, repository string, branch string, uploadId string, params CompletePresignMultipartUploadParams)

	// (PUT /repositories/{repository}/branches/{branch}/staging/pmpu/{uploadId}/parts/{partNumber})
	UploadPart(w http.ResponseWriter, r *http.Request, body UploadPartJSONRequestBody, repository string, branch string, uploadId string, partNumber int, params UploadPartParams)

	// (PUT /repositories/{repository}/branches/{branch}/staging/pmpu/{uploadId}/parts/{partNumber}/copy)
	UploadPartCopy(w http.ResponseWriter, r *http.Request, body UploadPartCopyJSONRequestBody, repository string, branch string, uploadId string, partNumber int, params UploadPartCopyParams)
	// create commit record
	// (POST /repositories/{repository}/commits)
	CreateCommitRecord(w http.ResponseWriter, r *http.Request, body CreateCommitRecordJSONRequestBody, repository string)
	// get commit
	// (GET /repositories/{repository}/commits/{commitId})
	GetCommit(w http.ResponseWriter, r *http.Request, repository string, commitId string)
	// Status of a repository dump task
	// (GET /repositories/{repository}/dump)
	DumpStatus(w http.ResponseWriter, r *http.Request, repository string, params DumpStatusParams)
	// Backup the repository metadata (tags, commits, branches) and save the backup to the object store.
	// (POST /repositories/{repository}/dump)
	DumpSubmit(w http.ResponseWriter, r *http.Request, repository string)
	// save lists of active commits for garbage collection
	// (POST /repositories/{repository}/gc/prepare_commits)
	PrepareGarbageCollectionCommits(w http.ResponseWriter, r *http.Request, repository string)
	// prepare gc commits
	// (POST /repositories/{repository}/gc/prepare_commits/async)
	PrepareGarbageCollectionCommitsAsync(w http.ResponseWriter, r *http.Request, repository string)
	// get status of prepare gc commits operation
	// (GET /repositories/{repository}/gc/prepare_commits/status)
	PrepareGarbageCollectionCommitsStatus(w http.ResponseWriter, r *http.Request, repository string, params PrepareGarbageCollectionCommitsStatusParams)
	// save repository uncommitted metadata for garbage collection
	// (POST /repositories/{repository}/gc/prepare_uncommited)
	PrepareGarbageCollectionUncommitted(w http.ResponseWriter, r *http.Request, body PrepareGarbageCollectionUncommittedJSONRequestBody, repository string)

	// (DELETE /repositories/{repository}/gc/rules)
	InternalDeleteGarbageCollectionRules(w http.ResponseWriter, r *http.Request, repository string)

	// (GET /repositories/{repository}/gc/rules)
	InternalGetGarbageCollectionRules(w http.ResponseWriter, r *http.Request, repository string)

	// (POST /repositories/{repository}/gc/rules)
	InternalSetGarbageCollectionRules(w http.ResponseWriter, r *http.Request, body InternalSetGarbageCollectionRulesJSONRequestBody, repository string)

	// (GET /repositories/{repository}/gc/rules/set_allowed)
	SetGarbageCollectionRulesPreflight(w http.ResponseWriter, r *http.Request, repository string)
	// delete repository metadata
	// (DELETE /repositories/{repository}/metadata)
	DeleteRepositoryMetadata(w http.ResponseWriter, r *http.Request, body DeleteRepositoryMetadataJSONRequestBody, repository string)
	// get repository metadata
	// (GET /repositories/{repository}/metadata)
	GetRepositoryMetadata(w http.ResponseWriter, r *http.Request, repository string)
	// set repository metadata
	// (POST /repositories/{repository}/metadata)
	SetRepositoryMetadata(w http.ResponseWriter, r *http.Request, body SetRepositoryMetadataJSONRequestBody, repository string)
	// return URI to a meta-range file
	// (GET /repositories/{repository}/metadata/meta_range/{meta_range})
	GetMetaRange(w http.ResponseWriter, r *http.Request, repository string, metaRange string)
	// return a lakeFS metadata object by ID
	// (GET /repositories/{repository}/metadata/object/{type}/{object_id})
	GetMetadataObject(w http.ResponseWriter, r *http.Request, repository string, pType string, objectId string, params GetMetadataObjectParams)
	// return URI to a range file
	// (GET /repositories/{repository}/metadata/range/{range})
	GetRange(w http.ResponseWriter, r *http.Request, repository string, pRange string)
	// list pull requests
	// (GET /repositories/{repository}/pulls)
	ListPullRequests(w http.ResponseWriter, r *http.Request, repository string, params ListPullRequestsParams)
	// create pull request
	// (POST /repositories/{repository}/pulls)
	CreatePullRequest(w http.ResponseWriter, r *http.Request, body CreatePullRequestJSONRequestBody, repository string)
	// get pull request
	// (GET /repositories/{repository}/pulls/{pull_request})
	GetPullRequest(w http.ResponseWriter, r *http.Request, repository string, pullRequest string)
	// update pull request
	// (PATCH /repositories/{repository}/pulls/{pull_request})
	UpdatePullRequest(w http.ResponseWriter, r *http.Request, body UpdatePullRequestJSONRequestBody, repository string, pullRequest string)
	// merge pull request
	// (PUT /repositories/{repository}/pulls/{pull_request}/merge)
	MergePullRequest(w http.ResponseWriter, r *http.Request, repository string, pullRequest string)
	// Dump repository refs (tags, commits, branches) to object store
	// Deprecated: a new API will introduce long running operations
	// (PUT /repositories/{repository}/refs/dump)
	DumpRefs(w http.ResponseWriter, r *http.Request, repository string)
	// Restore repository refs (tags, commits, branches) from object store.
	// Deprecated: a new API will introduce long running operations
	// (PUT /repositories/{repository}/refs/restore)
	RestoreRefs(w http.ResponseWriter, r *http.Request, body RestoreRefsJSONRequestBody, repository string)
	// creates symlink files corresponding to the given directory
	// (POST /repositories/{repository}/refs/{branch}/symlink)
	CreateSymlinkFile(w http.ResponseWriter, r *http.Request, repository string, branch string, params CreateSymlinkFileParams)
	// diff references
	// (GET /repositories/{repository}/refs/{leftRef}/diff/{rightRef})
	DiffRefs(w http.ResponseWriter, r *http.Request, repository string, leftRef string, rightRef string, params DiffRefsParams)
	// get commit log from ref. If both objects and prefixes are empty, return all commits.
	// (GET /repositories/{repository}/refs/{ref}/commits)
	LogCommits(w http.ResponseWriter, r *http.Request, repository string, ref string, params LogCommitsParams)
	// get object content
	// (GET /repositories/{repository}/refs/{ref}/objects)
	GetObject(w http.ResponseWriter, r *http.Request, repository string, ref string, params GetObjectParams)
	// check if object exists
	// (HEAD /repositories/{repository}/refs/{ref}/objects)
	HeadObject(w http.ResponseWriter, r *http.Request, repository string, ref string, params HeadObjectParams)
	// list objects under a given prefix
	// (GET /repositories/{repository}/refs/{ref}/objects/ls)
	ListObjects(w http.ResponseWriter, r *http.Request, repository string, ref string, params ListObjectsParams)
	// get object metadata
	// (GET /repositories/{repository}/refs/{ref}/objects/stat)
	StatObject(w http.ResponseWriter, r *http.Request, repository string, ref string, params StatObjectParams)
	// get object properties on underlying storage
	// (GET /repositories/{repository}/refs/{ref}/objects/underlyingProperties)
	GetUnderlyingProperties(w http.ResponseWriter, r *http.Request, repository string, ref string, params GetUnderlyingPropertiesParams)
	// find the merge base for 2 references
	// (GET /repositories/{repository}/refs/{sourceRef}/merge/{destinationBranch})
	FindMergeBase(w http.ResponseWriter, r *http.Request, repository string, sourceRef string, destinationBranch string)
	// merge references
	// (POST /repositories/{repository}/refs/{sourceRef}/merge/{destinationBranch})
	MergeIntoBranch(w http.ResponseWriter, r *http.Request, body MergeIntoBranchJSONRequestBody, repository string, sourceRef string, destinationBranch string)
	// merge references asynchronously
	// (POST /repositories/{repository}/refs/{sourceRef}/merge/{destinationBranch}/async)
	MergeIntoBranchAsync(w http.ResponseWriter, r *http.Request, body MergeIntoBranchAsyncJSONRequestBody, repository string, sourceRef string, destinationBranch string)
	// get status of async merge operation
	// (GET /repositories/{repository}/refs/{sourceRef}/merge/{destinationBranch}/async/{id}/status)
	MergeIntoBranchAsyncStatus(w http.ResponseWriter, r *http.Request, repository string, sourceRef string, destinationBranch string, id string)
	// Status of a restore request
	// (GET /repositories/{repository}/restore)
	RestoreStatus(w http.ResponseWriter, r *http.Request, repository string, params RestoreStatusParams)
	// Restore repository from a dump in the object store
	// (POST /repositories/{repository}/restore)
	RestoreSubmit(w http.ResponseWriter, r *http.Request, body RestoreSubmitJSONRequestBody, repository string)
	// get branch protection rules
	// (GET /repositories/{repository}/settings/branch_protection)
	GetBranchProtectionRules(w http.ResponseWriter, r *http.Request, repository string)

	// (PUT /repositories/{repository}/settings/branch_protection)
	SetBranchProtectionRules(w http.ResponseWriter, r *http.Request, body SetBranchProtectionRulesJSONRequestBody, repository string, params SetBranchProtectionRulesParams)

	// (DELETE /repositories/{repository}/settings/gc_rules)
	DeleteGCRules(w http.ResponseWriter, r *http.Request, repository string)
	// get repository GC rules
	// (GET /repositories/{repository}/settings/gc_rules)
	GetGCRules(w http.ResponseWriter, r *http.Request, repository string)

	// (PUT /repositories/{repository}/settings/gc_rules)
	SetGCRules(w http.ResponseWriter, r *http.Request, body SetGCRulesJSONRequestBody, repository string)
	// list tags
	// (GET /repositories/{repository}/tags)
	ListTags(w http.ResponseWriter, r *http.Request, repository string, params ListTagsParams)
	// create tag
	// (POST /repositories/{repository}/tags)
	CreateTag(w http.ResponseWriter, r *http.Request, body CreateTagJSONRequestBody, repository string)
	// delete tag
	// (DELETE /repositories/{repository}/tags/{tag})
	DeleteTag(w http.ResponseWriter, r *http.Request, repository string, tag string, params DeleteTagParams)
	// get tag
	// (GET /repositories/{repository}/tags/{tag})
	GetTag(w http.ResponseWriter, r *http.Request, repository string, tag string)
	// setup communications preferences
	// (POST /setup_comm_prefs)
	SetupCommPrefs(w http.ResponseWriter, r *http.Request, body SetupCommPrefsJSONRequestBody)
	// check if the lakeFS installation is already set up
	// (GET /setup_lakefs)
	GetSetupState(w http.ResponseWriter, r *http.Request)
	// setup lakeFS and create a first user
	// (POST /setup_lakefs)
	Setup(w http.ResponseWriter, r *http.Request, body SetupJSONRequestBody)
	// post stats events, this endpoint is meant for internal use only
	// (POST /statistics)
	PostStatsEvents(w http.ResponseWriter, r *http.Request, body PostStatsEventsJSONRequestBody)
	// perform a login with STS
	// (POST /sts/login)
	StsLogin(w http.ResponseWriter, r *http.Request, body StsLoginJSONRequestBody)
	// get usage report summary
	// (GET /usage-report/summary)
	GetUsageReportSummary(w http.ResponseWriter, r *http.Request)
	// get current user
	// (GET /user)
	GetCurrentUser(w http.ResponseWriter, r *http.Request)
}

// chi-middleware.tmpl based on https://github.com/deepmap/oapi-codegen/tree/master/pkg/codegen/templates

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// GetAuthCapabilities operation middleware
func (siw *ServerInterfaceWrapper) GetAuthCapabilities(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetAuthCapabilities")
	defer task.End()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAuthCapabilities(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ExternalPrincipalLogin operation middleware
func (siw *ServerInterfaceWrapper) ExternalPrincipalLogin(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ExternalPrincipalLogin")
	defer task.End()

	// ------------- Body parse -------------
	var body ExternalPrincipalLoginJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'ExternalPrincipalLogin' as JSON", http.StatusBadRequest)
			return
		}
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ExternalPrincipalLogin(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetExternalPrincipal operation middleware
func (siw *ServerInterfaceWrapper) GetExternalPrincipal(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetExternalPrincipal")
	defer task.End()

	var err error

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetExternalPrincipalParams

	// ------------- Required query parameter "principalId" -------------
	if paramValue := r.URL.Query().Get("principalId"); paramValue != "" {

	} else {
		http.Error(w, "Query argument principalId is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "principalId", r.URL.Query(), &params.PrincipalId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter principalId: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetExternalPrincipal(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetTokenFromMailbox operation middleware
func (siw *ServerInterfaceWrapper) GetTokenFromMailbox(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetTokenFromMailbox")
	defer task.End()

	var err error

	// ------------- Path parameter "mailbox" -------------
	var mailbox string

	err = runtime.BindStyledParameter("simple", false, "mailbox", chi.URLParam(r, "mailbox"), &mailbox)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter mailbox: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTokenFromMailbox(w, r, mailbox)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ReleaseTokenToMailbox operation middleware
func (siw *ServerInterfaceWrapper) ReleaseTokenToMailbox(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ReleaseTokenToMailbox")
	defer task.End()

	var err error

	// ------------- Path parameter "loginRequestToken" -------------
	var loginRequestToken string

	err = runtime.BindStyledParameter("simple", false, "loginRequestToken", chi.URLParam(r, "loginRequestToken"), &loginRequestToken)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter loginRequestToken: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ReleaseTokenToMailbox(w, r, loginRequestToken)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetTokenRedirect operation middleware
func (siw *ServerInterfaceWrapper) GetTokenRedirect(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetTokenRedirect")
	defer task.End()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTokenRedirect(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListGroups operation middleware
func (siw *ServerInterfaceWrapper) ListGroups(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListGroups")
	defer task.End()

	var err error

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListGroupsParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListGroups(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateGroup operation middleware
func (siw *ServerInterfaceWrapper) CreateGroup(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CreateGroup")
	defer task.End()

	// ------------- Body parse -------------
	var body CreateGroupJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreateGroup' as JSON", http.StatusBadRequest)
			return
		}
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateGroup(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteGroup operation middleware
func (siw *ServerInterfaceWrapper) DeleteGroup(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DeleteGroup")
	defer task.End()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGroup(w, r, groupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetGroup operation middleware
func (siw *ServerInterfaceWrapper) GetGroup(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetGroup")
	defer task.End()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGroup(w, r, groupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetGroupACL operation middleware
func (siw *ServerInterfaceWrapper) GetGroupACL(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetGroupACL")
	defer task.End()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGroupACL(w, r, groupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SetGroupACL operation middleware
func (siw *ServerInterfaceWrapper) SetGroupACL(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:SetGroupACL")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body SetGroupACLJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'SetGroupACL' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetGroupACL(w, r, body, groupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListGroupMembers operation middleware
func (siw *ServerInterfaceWrapper) ListGroupMembers(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListGroupMembers")
	defer task.End()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListGroupMembersParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListGroupMembers(w, r, groupId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteGroupMembership operation middleware
func (siw *ServerInterfaceWrapper) DeleteGroupMembership(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DeleteGroupMembership")
	defer task.End()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGroupMembership(w, r, groupId, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddGroupMembership operation middleware
func (siw *ServerInterfaceWrapper) AddGroupMembership(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:AddGroupMembership")
	defer task.End()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddGroupMembership(w, r, groupId, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListGroupPolicies operation middleware
func (siw *ServerInterfaceWrapper) ListGroupPolicies(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListGroupPolicies")
	defer task.End()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListGroupPoliciesParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListGroupPolicies(w, r, groupId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DetachPolicyFromGroup operation middleware
func (siw *ServerInterfaceWrapper) DetachPolicyFromGroup(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DetachPolicyFromGroup")
	defer task.End()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DetachPolicyFromGroup(w, r, groupId, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AttachPolicyToGroup operation middleware
func (siw *ServerInterfaceWrapper) AttachPolicyToGroup(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:AttachPolicyToGroup")
	defer task.End()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachPolicyToGroup(w, r, groupId, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Login operation middleware
func (siw *ServerInterfaceWrapper) Login(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:Login")
	defer task.End()

	// ------------- Body parse -------------
	var body LoginJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'Login' as JSON", http.StatusBadRequest)
			return
		}
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Login(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListPolicies operation middleware
func (siw *ServerInterfaceWrapper) ListPolicies(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListPolicies")
	defer task.End()

	var err error

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPoliciesParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListPolicies(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreatePolicy operation middleware
func (siw *ServerInterfaceWrapper) CreatePolicy(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CreatePolicy")
	defer task.End()

	// ------------- Body parse -------------
	var body CreatePolicyJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreatePolicy' as JSON", http.StatusBadRequest)
			return
		}
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreatePolicy(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeletePolicy operation middleware
func (siw *ServerInterfaceWrapper) DeletePolicy(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DeletePolicy")
	defer task.End()

	var err error

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeletePolicy(w, r, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetPolicy operation middleware
func (siw *ServerInterfaceWrapper) GetPolicy(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetPolicy")
	defer task.End()

	var err error

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPolicy(w, r, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdatePolicy operation middleware
func (siw *ServerInterfaceWrapper) UpdatePolicy(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:UpdatePolicy")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body UpdatePolicyJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'UpdatePolicy' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdatePolicy(w, r, body, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListUsers operation middleware
func (siw *ServerInterfaceWrapper) ListUsers(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListUsers")
	defer task.End()

	var err error

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUsersParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUsers(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateUser operation middleware
func (siw *ServerInterfaceWrapper) CreateUser(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CreateUser")
	defer task.End()

	// ------------- Body parse -------------
	var body CreateUserJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreateUser' as JSON", http.StatusBadRequest)
			return
		}
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateUser(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteUser operation middleware
func (siw *ServerInterfaceWrapper) DeleteUser(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DeleteUser")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUser(w, r, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetUser operation middleware
func (siw *ServerInterfaceWrapper) GetUser(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetUser")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUser(w, r, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListUserCredentials operation middleware
func (siw *ServerInterfaceWrapper) ListUserCredentials(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListUserCredentials")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUserCredentialsParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUserCredentials(w, r, userId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateCredentials operation middleware
func (siw *ServerInterfaceWrapper) CreateCredentials(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CreateCredentials")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateCredentials(w, r, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteCredentials operation middleware
func (siw *ServerInterfaceWrapper) DeleteCredentials(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DeleteCredentials")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "accessKeyId" -------------
	var accessKeyId string

	err = runtime.BindStyledParameter("simple", false, "accessKeyId", chi.URLParam(r, "accessKeyId"), &accessKeyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter accessKeyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteCredentials(w, r, userId, accessKeyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetCredentials operation middleware
func (siw *ServerInterfaceWrapper) GetCredentials(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetCredentials")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "accessKeyId" -------------
	var accessKeyId string

	err = runtime.BindStyledParameter("simple", false, "accessKeyId", chi.URLParam(r, "accessKeyId"), &accessKeyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter accessKeyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCredentials(w, r, userId, accessKeyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteUserExternalPrincipal operation middleware
func (siw *ServerInterfaceWrapper) DeleteUserExternalPrincipal(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DeleteUserExternalPrincipal")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteUserExternalPrincipalParams

	// ------------- Required query parameter "principalId" -------------
	if paramValue := r.URL.Query().Get("principalId"); paramValue != "" {

	} else {
		http.Error(w, "Query argument principalId is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "principalId", r.URL.Query(), &params.PrincipalId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter principalId: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUserExternalPrincipal(w, r, userId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateUserExternalPrincipal operation middleware
func (siw *ServerInterfaceWrapper) CreateUserExternalPrincipal(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CreateUserExternalPrincipal")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body CreateUserExternalPrincipalJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreateUserExternalPrincipal' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateUserExternalPrincipalParams

	// ------------- Required query parameter "principalId" -------------
	if paramValue := r.URL.Query().Get("principalId"); paramValue != "" {

	} else {
		http.Error(w, "Query argument principalId is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "principalId", r.URL.Query(), &params.PrincipalId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter principalId: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateUserExternalPrincipal(w, r, body, userId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListUserExternalPrincipals operation middleware
func (siw *ServerInterfaceWrapper) ListUserExternalPrincipals(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListUserExternalPrincipals")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUserExternalPrincipalsParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUserExternalPrincipals(w, r, userId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListUserGroups operation middleware
func (siw *ServerInterfaceWrapper) ListUserGroups(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListUserGroups")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUserGroupsParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUserGroups(w, r, userId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListUserPolicies operation middleware
func (siw *ServerInterfaceWrapper) ListUserPolicies(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListUserPolicies")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUserPoliciesParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "effective" -------------
	if paramValue := r.URL.Query().Get("effective"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "effective", r.URL.Query(), &params.Effective)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter effective: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUserPolicies(w, r, userId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DetachPolicyFromUser operation middleware
func (siw *ServerInterfaceWrapper) DetachPolicyFromUser(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DetachPolicyFromUser")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DetachPolicyFromUser(w, r, userId, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AttachPolicyToUser operation middleware
func (siw *ServerInterfaceWrapper) AttachPolicyToUser(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:AttachPolicyToUser")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachPolicyToUser(w, r, userId, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetConfig operation middleware
func (siw *ServerInterfaceWrapper) GetConfig(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetConfig")
	defer task.End()

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetConfig(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetGarbageCollectionConfig operation middleware
func (siw *ServerInterfaceWrapper) GetGarbageCollectionConfig(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetGarbageCollectionConfig")
	defer task.End()

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGarbageCollectionConfig(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetStorageConfig operation middleware
func (siw *ServerInterfaceWrapper) GetStorageConfig(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetStorageConfig")
	defer task.End()

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetStorageConfig(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetLakeFSVersion operation middleware
func (siw *ServerInterfaceWrapper) GetLakeFSVersion(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetLakeFSVersion")
	defer task.End()

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLakeFSVersion(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// HealthCheck operation middleware
func (siw *ServerInterfaceWrapper) HealthCheck(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:HealthCheck")
	defer task.End()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HealthCheck(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PullIcebergTable operation middleware
func (siw *ServerInterfaceWrapper) PullIcebergTable(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:PullIcebergTable")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body PullIcebergTableJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'PullIcebergTable' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "catalog" -------------
	var catalog string

	err = runtime.BindStyledParameter("simple", false, "catalog", chi.URLParam(r, "catalog"), &catalog)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter catalog: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PullIcebergTable(w, r, body, catalog)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PushIcebergTable operation middleware
func (siw *ServerInterfaceWrapper) PushIcebergTable(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:PushIcebergTable")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body PushIcebergTableJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'PushIcebergTable' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "catalog" -------------
	var catalog string

	err = runtime.BindStyledParameter("simple", false, "catalog", chi.URLParam(r, "catalog"), &catalog)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter catalog: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PushIcebergTable(w, r, body, catalog)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetLicense operation middleware
func (siw *ServerInterfaceWrapper) GetLicense(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetLicense")
	defer task.End()

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLicense(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// OauthCallback operation middleware
func (siw *ServerInterfaceWrapper) OauthCallback(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:OauthCallback")
	defer task.End()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.OauthCallback(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListRepositories operation middleware
func (siw *ServerInterfaceWrapper) ListRepositories(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListRepositories")
	defer task.End()

	var err error

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRepositoriesParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "search" -------------
	if paramValue := r.URL.Query().Get("search"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter search: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListRepositories(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateRepository operation middleware
func (siw *ServerInterfaceWrapper) CreateRepository(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CreateRepository")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body CreateRepositoryJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreateRepository' as JSON", http.StatusBadRequest)
			return
		}
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateRepositoryParams

	// ------------- Optional query parameter "bare" -------------
	if paramValue := r.URL.Query().Get("bare"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "bare", r.URL.Query(), &params.Bare)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter bare: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateRepository(w, r, body, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteRepository operation middleware
func (siw *ServerInterfaceWrapper) DeleteRepository(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DeleteRepository")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteRepositoryParams

	// ------------- Optional query parameter "force" -------------
	if paramValue := r.URL.Query().Get("force"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "force", r.URL.Query(), &params.Force)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter force: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteRepository(w, r, repository, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetRepository operation middleware
func (siw *ServerInterfaceWrapper) GetRepository(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetRepository")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRepository(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListRepositoryRuns operation middleware
func (siw *ServerInterfaceWrapper) ListRepositoryRuns(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListRepositoryRuns")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRepositoryRunsParams

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "branch" -------------
	if paramValue := r.URL.Query().Get("branch"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "branch", r.URL.Query(), &params.Branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "commit" -------------
	if paramValue := r.URL.Query().Get("commit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "commit", r.URL.Query(), &params.Commit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter commit: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListRepositoryRuns(w, r, repository, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetRun operation middleware
func (siw *ServerInterfaceWrapper) GetRun(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetRun")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "run_id" -------------
	var runId string

	err = runtime.BindStyledParameter("simple", false, "run_id", chi.URLParam(r, "run_id"), &runId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter run_id: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRun(w, r, repository, runId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListRunHooks operation middleware
func (siw *ServerInterfaceWrapper) ListRunHooks(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListRunHooks")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "run_id" -------------
	var runId string

	err = runtime.BindStyledParameter("simple", false, "run_id", chi.URLParam(r, "run_id"), &runId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter run_id: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRunHooksParams

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListRunHooks(w, r, repository, runId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetRunHookOutput operation middleware
func (siw *ServerInterfaceWrapper) GetRunHookOutput(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetRunHookOutput")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "run_id" -------------
	var runId string

	err = runtime.BindStyledParameter("simple", false, "run_id", chi.URLParam(r, "run_id"), &runId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter run_id: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "hook_run_id" -------------
	var hookRunId string

	err = runtime.BindStyledParameter("simple", false, "hook_run_id", chi.URLParam(r, "hook_run_id"), &hookRunId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter hook_run_id: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRunHookOutput(w, r, repository, runId, hookRunId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// InternalDeleteBranchProtectionRule operation middleware
func (siw *ServerInterfaceWrapper) InternalDeleteBranchProtectionRule(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:InternalDeleteBranchProtectionRule")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body InternalDeleteBranchProtectionRuleJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'InternalDeleteBranchProtectionRule' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.InternalDeleteBranchProtectionRule(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// InternalGetBranchProtectionRules operation middleware
func (siw *ServerInterfaceWrapper) InternalGetBranchProtectionRules(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:InternalGetBranchProtectionRules")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.InternalGetBranchProtectionRules(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// InternalCreateBranchProtectionRule operation middleware
func (siw *ServerInterfaceWrapper) InternalCreateBranchProtectionRule(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:InternalCreateBranchProtectionRule")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body InternalCreateBranchProtectionRuleJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'InternalCreateBranchProtectionRule' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.InternalCreateBranchProtectionRule(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateBranchProtectionRulePreflight operation middleware
func (siw *ServerInterfaceWrapper) CreateBranchProtectionRulePreflight(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CreateBranchProtectionRulePreflight")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateBranchProtectionRulePreflight(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListBranches operation middleware
func (siw *ServerInterfaceWrapper) ListBranches(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListBranches")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListBranchesParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "show_hidden" -------------
	if paramValue := r.URL.Query().Get("show_hidden"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "show_hidden", r.URL.Query(), &params.ShowHidden)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter show_hidden: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListBranches(w, r, repository, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateBranch operation middleware
func (siw *ServerInterfaceWrapper) CreateBranch(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CreateBranch")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body CreateBranchJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreateBranch' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateBranch(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteBranch operation middleware
func (siw *ServerInterfaceWrapper) DeleteBranch(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DeleteBranch")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteBranchParams

	// ------------- Optional query parameter "force" -------------
	if paramValue := r.URL.Query().Get("force"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "force", r.URL.Query(), &params.Force)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter force: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteBranch(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetBranch operation middleware
func (siw *ServerInterfaceWrapper) GetBranch(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetBranch")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetBranch(w, r, repository, branch)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ResetBranch operation middleware
func (siw *ServerInterfaceWrapper) ResetBranch(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ResetBranch")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body ResetBranchJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'ResetBranch' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ResetBranch(w, r, body, repository, branch)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CherryPick operation middleware
func (siw *ServerInterfaceWrapper) CherryPick(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CherryPick")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body CherryPickJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CherryPick' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CherryPick(w, r, body, repository, branch)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Commit operation middleware
func (siw *ServerInterfaceWrapper) Commit(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:Commit")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body CommitJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'Commit' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CommitParams

	// ------------- Optional query parameter "source_metarange" -------------
	if paramValue := r.URL.Query().Get("source_metarange"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "source_metarange", r.URL.Query(), &params.SourceMetarange)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter source_metarange: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Commit(w, r, body, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CommitAsync operation middleware
func (siw *ServerInterfaceWrapper) CommitAsync(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CommitAsync")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body CommitAsyncJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CommitAsync' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CommitAsyncParams

	// ------------- Optional query parameter "source_metarange" -------------
	if paramValue := r.URL.Query().Get("source_metarange"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "source_metarange", r.URL.Query(), &params.SourceMetarange)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter source_metarange: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CommitAsync(w, r, body, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CommitAsyncStatus operation middleware
func (siw *ServerInterfaceWrapper) CommitAsyncStatus(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CommitAsyncStatus")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", chi.URLParam(r, "id"), &id)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter id: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CommitAsyncStatus(w, r, repository, branch, id)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DiffBranch operation middleware
func (siw *ServerInterfaceWrapper) DiffBranch(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DiffBranch")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DiffBranchParams

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "delimiter" -------------
	if paramValue := r.URL.Query().Get("delimiter"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "delimiter", r.URL.Query(), &params.Delimiter)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter delimiter: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DiffBranch(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// HardResetBranch operation middleware
func (siw *ServerInterfaceWrapper) HardResetBranch(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:HardResetBranch")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params HardResetBranchParams

	// ------------- Required query parameter "ref" -------------
	if paramValue := r.URL.Query().Get("ref"); paramValue != "" {

	} else {
		http.Error(w, "Query argument ref is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "ref", r.URL.Query(), &params.Ref)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ref: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "force" -------------
	if paramValue := r.URL.Query().Get("force"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "force", r.URL.Query(), &params.Force)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter force: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HardResetBranch(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ImportCancel operation middleware
func (siw *ServerInterfaceWrapper) ImportCancel(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ImportCancel")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ImportCancelParams

	// ------------- Required query parameter "id" -------------
	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		http.Error(w, "Query argument id is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter id: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ImportCancel(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ImportStatus operation middleware
func (siw *ServerInterfaceWrapper) ImportStatus(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ImportStatus")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ImportStatusParams

	// ------------- Required query parameter "id" -------------
	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		http.Error(w, "Query argument id is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter id: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ImportStatus(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ImportStart operation middleware
func (siw *ServerInterfaceWrapper) ImportStart(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ImportStart")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body ImportStartJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'ImportStart' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ImportStart(w, r, body, repository, branch)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteObject operation middleware
func (siw *ServerInterfaceWrapper) DeleteObject(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DeleteObject")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteObjectParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "force" -------------
	if paramValue := r.URL.Query().Get("force"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "force", r.URL.Query(), &params.Force)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter force: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "no_tombstone" -------------
	if paramValue := r.URL.Query().Get("no_tombstone"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "no_tombstone", r.URL.Query(), &params.NoTombstone)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter no_tombstone: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteObject(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UploadObject operation middleware
func (siw *ServerInterfaceWrapper) UploadObject(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:UploadObject")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UploadObjectParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "storageClass" -------------
	if paramValue := r.URL.Query().Get("storageClass"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "storageClass", r.URL.Query(), &params.StorageClass)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter storageClass: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "force" -------------
	if paramValue := r.URL.Query().Get("force"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "force", r.URL.Query(), &params.Force)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter force: %s", err), http.StatusBadRequest)
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch IfNoneMatch
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for If-None-Match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "If-None-Match", valueList[0], &IfNoneMatch)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter If-None-Match: %s", err), http.StatusBadRequest)
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch IfMatch
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for If-Match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "If-Match", valueList[0], &IfMatch)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter If-Match: %s", err), http.StatusBadRequest)
			return
		}

		params.IfMatch = &IfMatch

	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UploadObject(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// StageObject operation middleware
func (siw *ServerInterfaceWrapper) StageObject(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:StageObject")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body StageObjectJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'StageObject' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params StageObjectParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.StageObject(w, r, body, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CopyObject operation middleware
func (siw *ServerInterfaceWrapper) CopyObject(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CopyObject")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body CopyObjectJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CopyObject' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CopyObjectParams

	// ------------- Required query parameter "dest_path" -------------
	if paramValue := r.URL.Query().Get("dest_path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument dest_path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "dest_path", r.URL.Query(), &params.DestPath)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter dest_path: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CopyObject(w, r, body, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteObjects operation middleware
func (siw *ServerInterfaceWrapper) DeleteObjects(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DeleteObjects")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body DeleteObjectsJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'DeleteObjects' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteObjectsParams

	// ------------- Optional query parameter "force" -------------
	if paramValue := r.URL.Query().Get("force"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "force", r.URL.Query(), &params.Force)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter force: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "no_tombstone" -------------
	if paramValue := r.URL.Query().Get("no_tombstone"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "no_tombstone", r.URL.Query(), &params.NoTombstone)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter no_tombstone: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteObjects(w, r, body, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UploadObjectPreflight operation middleware
func (siw *ServerInterfaceWrapper) UploadObjectPreflight(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:UploadObjectPreflight")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UploadObjectPreflightParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UploadObjectPreflight(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateObjectUserMetadata operation middleware
func (siw *ServerInterfaceWrapper) UpdateObjectUserMetadata(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:UpdateObjectUserMetadata")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body UpdateObjectUserMetadataJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'UpdateObjectUserMetadata' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateObjectUserMetadataParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateObjectUserMetadata(w, r, body, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RevertBranch operation middleware
func (siw *ServerInterfaceWrapper) RevertBranch(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:RevertBranch")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body RevertBranchJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'RevertBranch' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RevertBranch(w, r, body, repository, branch)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetPhysicalAddress operation middleware
func (siw *ServerInterfaceWrapper) GetPhysicalAddress(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetPhysicalAddress")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPhysicalAddressParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "presign" -------------
	if paramValue := r.URL.Query().Get("presign"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "presign", r.URL.Query(), &params.Presign)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter presign: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPhysicalAddress(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// LinkPhysicalAddress operation middleware
func (siw *ServerInterfaceWrapper) LinkPhysicalAddress(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:LinkPhysicalAddress")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body LinkPhysicalAddressJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'LinkPhysicalAddress' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params LinkPhysicalAddressParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch IfNoneMatch
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for If-None-Match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "If-None-Match", valueList[0], &IfNoneMatch)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter If-None-Match: %s", err), http.StatusBadRequest)
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch IfMatch
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for If-Match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "If-Match", valueList[0], &IfMatch)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter If-Match: %s", err), http.StatusBadRequest)
			return
		}

		params.IfMatch = &IfMatch

	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LinkPhysicalAddress(w, r, body, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreatePresignMultipartUpload operation middleware
func (siw *ServerInterfaceWrapper) CreatePresignMultipartUpload(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CreatePresignMultipartUpload")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreatePresignMultipartUploadParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "parts" -------------
	if paramValue := r.URL.Query().Get("parts"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "parts", r.URL.Query(), &params.Parts)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter parts: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreatePresignMultipartUpload(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AbortPresignMultipartUpload operation middleware
func (siw *ServerInterfaceWrapper) AbortPresignMultipartUpload(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:AbortPresignMultipartUpload")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body AbortPresignMultipartUploadJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'AbortPresignMultipartUpload' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "uploadId" -------------
	var uploadId string

	err = runtime.BindStyledParameter("simple", false, "uploadId", chi.URLParam(r, "uploadId"), &uploadId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uploadId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AbortPresignMultipartUploadParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AbortPresignMultipartUpload(w, r, body, repository, branch, uploadId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CompletePresignMultipartUpload operation middleware
func (siw *ServerInterfaceWrapper) CompletePresignMultipartUpload(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CompletePresignMultipartUpload")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body CompletePresignMultipartUploadJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CompletePresignMultipartUpload' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "uploadId" -------------
	var uploadId string

	err = runtime.BindStyledParameter("simple", false, "uploadId", chi.URLParam(r, "uploadId"), &uploadId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uploadId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CompletePresignMultipartUploadParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CompletePresignMultipartUpload(w, r, body, repository, branch, uploadId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UploadPart operation middleware
func (siw *ServerInterfaceWrapper) UploadPart(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:UploadPart")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body UploadPartJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'UploadPart' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "uploadId" -------------
	var uploadId string

	err = runtime.BindStyledParameter("simple", false, "uploadId", chi.URLParam(r, "uploadId"), &uploadId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uploadId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "partNumber" -------------
	var partNumber int

	err = runtime.BindStyledParameter("simple", false, "partNumber", chi.URLParam(r, "partNumber"), &partNumber)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter partNumber: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UploadPartParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UploadPart(w, r, body, repository, branch, uploadId, partNumber, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UploadPartCopy operation middleware
func (siw *ServerInterfaceWrapper) UploadPartCopy(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:UploadPartCopy")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body UploadPartCopyJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'UploadPartCopy' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "uploadId" -------------
	var uploadId string

	err = runtime.BindStyledParameter("simple", false, "uploadId", chi.URLParam(r, "uploadId"), &uploadId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uploadId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "partNumber" -------------
	var partNumber int

	err = runtime.BindStyledParameter("simple", false, "partNumber", chi.URLParam(r, "partNumber"), &partNumber)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter partNumber: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UploadPartCopyParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UploadPartCopy(w, r, body, repository, branch, uploadId, partNumber, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateCommitRecord operation middleware
func (siw *ServerInterfaceWrapper) CreateCommitRecord(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CreateCommitRecord")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body CreateCommitRecordJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreateCommitRecord' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateCommitRecord(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetCommit operation middleware
func (siw *ServerInterfaceWrapper) GetCommit(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetCommit")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "commitId" -------------
	var commitId string

	err = runtime.BindStyledParameter("simple", false, "commitId", chi.URLParam(r, "commitId"), &commitId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter commitId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCommit(w, r, repository, commitId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DumpStatus operation middleware
func (siw *ServerInterfaceWrapper) DumpStatus(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DumpStatus")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DumpStatusParams

	// ------------- Required query parameter "task_id" -------------
	if paramValue := r.URL.Query().Get("task_id"); paramValue != "" {

	} else {
		http.Error(w, "Query argument task_id is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "task_id", r.URL.Query(), &params.TaskId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter task_id: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DumpStatus(w, r, repository, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DumpSubmit operation middleware
func (siw *ServerInterfaceWrapper) DumpSubmit(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DumpSubmit")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DumpSubmit(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PrepareGarbageCollectionCommits operation middleware
func (siw *ServerInterfaceWrapper) PrepareGarbageCollectionCommits(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:PrepareGarbageCollectionCommits")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PrepareGarbageCollectionCommits(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PrepareGarbageCollectionCommitsAsync operation middleware
func (siw *ServerInterfaceWrapper) PrepareGarbageCollectionCommitsAsync(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:PrepareGarbageCollectionCommitsAsync")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PrepareGarbageCollectionCommitsAsync(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PrepareGarbageCollectionCommitsStatus operation middleware
func (siw *ServerInterfaceWrapper) PrepareGarbageCollectionCommitsStatus(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:PrepareGarbageCollectionCommitsStatus")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PrepareGarbageCollectionCommitsStatusParams

	// ------------- Required query parameter "id" -------------
	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		http.Error(w, "Query argument id is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter id: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PrepareGarbageCollectionCommitsStatus(w, r, repository, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PrepareGarbageCollectionUncommitted operation middleware
func (siw *ServerInterfaceWrapper) PrepareGarbageCollectionUncommitted(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:PrepareGarbageCollectionUncommitted")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body PrepareGarbageCollectionUncommittedJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'PrepareGarbageCollectionUncommitted' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PrepareGarbageCollectionUncommitted(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// InternalDeleteGarbageCollectionRules operation middleware
func (siw *ServerInterfaceWrapper) InternalDeleteGarbageCollectionRules(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:InternalDeleteGarbageCollectionRules")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.InternalDeleteGarbageCollectionRules(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// InternalGetGarbageCollectionRules operation middleware
func (siw *ServerInterfaceWrapper) InternalGetGarbageCollectionRules(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:InternalGetGarbageCollectionRules")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.InternalGetGarbageCollectionRules(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// InternalSetGarbageCollectionRules operation middleware
func (siw *ServerInterfaceWrapper) InternalSetGarbageCollectionRules(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:InternalSetGarbageCollectionRules")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body InternalSetGarbageCollectionRulesJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'InternalSetGarbageCollectionRules' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.InternalSetGarbageCollectionRules(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SetGarbageCollectionRulesPreflight operation middleware
func (siw *ServerInterfaceWrapper) SetGarbageCollectionRulesPreflight(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:SetGarbageCollectionRulesPreflight")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetGarbageCollectionRulesPreflight(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteRepositoryMetadata operation middleware
func (siw *ServerInterfaceWrapper) DeleteRepositoryMetadata(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DeleteRepositoryMetadata")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body DeleteRepositoryMetadataJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'DeleteRepositoryMetadata' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteRepositoryMetadata(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetRepositoryMetadata operation middleware
func (siw *ServerInterfaceWrapper) GetRepositoryMetadata(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetRepositoryMetadata")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRepositoryMetadata(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SetRepositoryMetadata operation middleware
func (siw *ServerInterfaceWrapper) SetRepositoryMetadata(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:SetRepositoryMetadata")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body SetRepositoryMetadataJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'SetRepositoryMetadata' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetRepositoryMetadata(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetMetaRange operation middleware
func (siw *ServerInterfaceWrapper) GetMetaRange(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetMetaRange")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "meta_range" -------------
	var metaRange string

	err = runtime.BindStyledParameter("simple", false, "meta_range", chi.URLParam(r, "meta_range"), &metaRange)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter meta_range: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMetaRange(w, r, repository, metaRange)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetMetadataObject operation middleware
func (siw *ServerInterfaceWrapper) GetMetadataObject(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetMetadataObject")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "type" -------------
	var pType string

	err = runtime.BindStyledParameter("simple", false, "type", chi.URLParam(r, "type"), &pType)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter type: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "object_id" -------------
	var objectId string

	err = runtime.BindStyledParameter("simple", false, "object_id", chi.URLParam(r, "object_id"), &objectId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter object_id: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetMetadataObjectParams

	// ------------- Optional query parameter "presign" -------------
	if paramValue := r.URL.Query().Get("presign"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "presign", r.URL.Query(), &params.Presign)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter presign: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMetadataObject(w, r, repository, pType, objectId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetRange operation middleware
func (siw *ServerInterfaceWrapper) GetRange(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetRange")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "range" -------------
	var pRange string

	err = runtime.BindStyledParameter("simple", false, "range", chi.URLParam(r, "range"), &pRange)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter range: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRange(w, r, repository, pRange)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListPullRequests operation middleware
func (siw *ServerInterfaceWrapper) ListPullRequests(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListPullRequests")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPullRequestsParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "status" -------------
	if paramValue := r.URL.Query().Get("status"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter status: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListPullRequests(w, r, repository, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreatePullRequest operation middleware
func (siw *ServerInterfaceWrapper) CreatePullRequest(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CreatePullRequest")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body CreatePullRequestJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreatePullRequest' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreatePullRequest(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetPullRequest operation middleware
func (siw *ServerInterfaceWrapper) GetPullRequest(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetPullRequest")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "pull_request" -------------
	var pullRequest string

	err = runtime.BindStyledParameter("simple", false, "pull_request", chi.URLParam(r, "pull_request"), &pullRequest)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter pull_request: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPullRequest(w, r, repository, pullRequest)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdatePullRequest operation middleware
func (siw *ServerInterfaceWrapper) UpdatePullRequest(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:UpdatePullRequest")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body UpdatePullRequestJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'UpdatePullRequest' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "pull_request" -------------
	var pullRequest string

	err = runtime.BindStyledParameter("simple", false, "pull_request", chi.URLParam(r, "pull_request"), &pullRequest)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter pull_request: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdatePullRequest(w, r, body, repository, pullRequest)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// MergePullRequest operation middleware
func (siw *ServerInterfaceWrapper) MergePullRequest(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:MergePullRequest")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "pull_request" -------------
	var pullRequest string

	err = runtime.BindStyledParameter("simple", false, "pull_request", chi.URLParam(r, "pull_request"), &pullRequest)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter pull_request: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.MergePullRequest(w, r, repository, pullRequest)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DumpRefs operation middleware
func (siw *ServerInterfaceWrapper) DumpRefs(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DumpRefs")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DumpRefs(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RestoreRefs operation middleware
func (siw *ServerInterfaceWrapper) RestoreRefs(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:RestoreRefs")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body RestoreRefsJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'RestoreRefs' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RestoreRefs(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateSymlinkFile operation middleware
func (siw *ServerInterfaceWrapper) CreateSymlinkFile(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CreateSymlinkFile")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateSymlinkFileParams

	// ------------- Optional query parameter "location" -------------
	if paramValue := r.URL.Query().Get("location"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "location", r.URL.Query(), &params.Location)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter location: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateSymlinkFile(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DiffRefs operation middleware
func (siw *ServerInterfaceWrapper) DiffRefs(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DiffRefs")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "leftRef" -------------
	var leftRef string

	err = runtime.BindStyledParameter("simple", false, "leftRef", chi.URLParam(r, "leftRef"), &leftRef)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter leftRef: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "rightRef" -------------
	var rightRef string

	err = runtime.BindStyledParameter("simple", false, "rightRef", chi.URLParam(r, "rightRef"), &rightRef)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter rightRef: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DiffRefsParams

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "delimiter" -------------
	if paramValue := r.URL.Query().Get("delimiter"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "delimiter", r.URL.Query(), &params.Delimiter)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter delimiter: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "type" -------------
	if paramValue := r.URL.Query().Get("type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "type", r.URL.Query(), &params.Type)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter type: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "include_right_stats" -------------
	if paramValue := r.URL.Query().Get("include_right_stats"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include_right_stats", r.URL.Query(), &params.IncludeRightStats)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter include_right_stats: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DiffRefs(w, r, repository, leftRef, rightRef, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// LogCommits operation middleware
func (siw *ServerInterfaceWrapper) LogCommits(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:LogCommits")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameter("simple", false, "ref", chi.URLParam(r, "ref"), &ref)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ref: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params LogCommitsParams

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "objects" -------------
	if paramValue := r.URL.Query().Get("objects"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "objects", r.URL.Query(), &params.Objects)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter objects: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "prefixes" -------------
	if paramValue := r.URL.Query().Get("prefixes"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefixes", r.URL.Query(), &params.Prefixes)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefixes: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "first_parent" -------------
	if paramValue := r.URL.Query().Get("first_parent"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "first_parent", r.URL.Query(), &params.FirstParent)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter first_parent: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "since" -------------
	if paramValue := r.URL.Query().Get("since"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "since", r.URL.Query(), &params.Since)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter since: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "stop_at" -------------
	if paramValue := r.URL.Query().Get("stop_at"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "stop_at", r.URL.Query(), &params.StopAt)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter stop_at: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LogCommits(w, r, repository, ref, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetObject operation middleware
func (siw *ServerInterfaceWrapper) GetObject(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetObject")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameter("simple", false, "ref", chi.URLParam(r, "ref"), &ref)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ref: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetObjectParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "presign" -------------
	if paramValue := r.URL.Query().Get("presign"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "presign", r.URL.Query(), &params.Presign)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter presign: %s", err), http.StatusBadRequest)
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "Range" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Range")]; found {
		var Range string
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for Range, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "Range", valueList[0], &Range)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter Range: %s", err), http.StatusBadRequest)
			return
		}

		params.Range = &Range

	}

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for If-None-Match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "If-None-Match", valueList[0], &IfNoneMatch)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter If-None-Match: %s", err), http.StatusBadRequest)
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetObject(w, r, repository, ref, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// HeadObject operation middleware
func (siw *ServerInterfaceWrapper) HeadObject(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:HeadObject")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameter("simple", false, "ref", chi.URLParam(r, "ref"), &ref)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ref: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params HeadObjectParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "Range" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Range")]; found {
		var Range string
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for Range, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "Range", valueList[0], &Range)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter Range: %s", err), http.StatusBadRequest)
			return
		}

		params.Range = &Range

	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HeadObject(w, r, repository, ref, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListObjects operation middleware
func (siw *ServerInterfaceWrapper) ListObjects(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListObjects")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameter("simple", false, "ref", chi.URLParam(r, "ref"), &ref)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ref: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListObjectsParams

	// ------------- Optional query parameter "user_metadata" -------------
	if paramValue := r.URL.Query().Get("user_metadata"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "user_metadata", r.URL.Query(), &params.UserMetadata)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter user_metadata: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "presign" -------------
	if paramValue := r.URL.Query().Get("presign"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "presign", r.URL.Query(), &params.Presign)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter presign: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "delimiter" -------------
	if paramValue := r.URL.Query().Get("delimiter"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "delimiter", r.URL.Query(), &params.Delimiter)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter delimiter: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListObjects(w, r, repository, ref, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// StatObject operation middleware
func (siw *ServerInterfaceWrapper) StatObject(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:StatObject")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameter("simple", false, "ref", chi.URLParam(r, "ref"), &ref)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ref: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params StatObjectParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "user_metadata" -------------
	if paramValue := r.URL.Query().Get("user_metadata"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "user_metadata", r.URL.Query(), &params.UserMetadata)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter user_metadata: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "presign" -------------
	if paramValue := r.URL.Query().Get("presign"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "presign", r.URL.Query(), &params.Presign)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter presign: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.StatObject(w, r, repository, ref, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetUnderlyingProperties operation middleware
func (siw *ServerInterfaceWrapper) GetUnderlyingProperties(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetUnderlyingProperties")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameter("simple", false, "ref", chi.URLParam(r, "ref"), &ref)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ref: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUnderlyingPropertiesParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUnderlyingProperties(w, r, repository, ref, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindMergeBase operation middleware
func (siw *ServerInterfaceWrapper) FindMergeBase(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:FindMergeBase")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "sourceRef" -------------
	var sourceRef string

	err = runtime.BindStyledParameter("simple", false, "sourceRef", chi.URLParam(r, "sourceRef"), &sourceRef)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter sourceRef: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "destinationBranch" -------------
	var destinationBranch string

	err = runtime.BindStyledParameter("simple", false, "destinationBranch", chi.URLParam(r, "destinationBranch"), &destinationBranch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter destinationBranch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindMergeBase(w, r, repository, sourceRef, destinationBranch)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// MergeIntoBranch operation middleware
func (siw *ServerInterfaceWrapper) MergeIntoBranch(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:MergeIntoBranch")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body MergeIntoBranchJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'MergeIntoBranch' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "sourceRef" -------------
	var sourceRef string

	err = runtime.BindStyledParameter("simple", false, "sourceRef", chi.URLParam(r, "sourceRef"), &sourceRef)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter sourceRef: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "destinationBranch" -------------
	var destinationBranch string

	err = runtime.BindStyledParameter("simple", false, "destinationBranch", chi.URLParam(r, "destinationBranch"), &destinationBranch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter destinationBranch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.MergeIntoBranch(w, r, body, repository, sourceRef, destinationBranch)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// MergeIntoBranchAsync operation middleware
func (siw *ServerInterfaceWrapper) MergeIntoBranchAsync(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:MergeIntoBranchAsync")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body MergeIntoBranchAsyncJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'MergeIntoBranchAsync' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "sourceRef" -------------
	var sourceRef string

	err = runtime.BindStyledParameter("simple", false, "sourceRef", chi.URLParam(r, "sourceRef"), &sourceRef)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter sourceRef: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "destinationBranch" -------------
	var destinationBranch string

	err = runtime.BindStyledParameter("simple", false, "destinationBranch", chi.URLParam(r, "destinationBranch"), &destinationBranch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter destinationBranch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.MergeIntoBranchAsync(w, r, body, repository, sourceRef, destinationBranch)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// MergeIntoBranchAsyncStatus operation middleware
func (siw *ServerInterfaceWrapper) MergeIntoBranchAsyncStatus(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:MergeIntoBranchAsyncStatus")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "sourceRef" -------------
	var sourceRef string

	err = runtime.BindStyledParameter("simple", false, "sourceRef", chi.URLParam(r, "sourceRef"), &sourceRef)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter sourceRef: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "destinationBranch" -------------
	var destinationBranch string

	err = runtime.BindStyledParameter("simple", false, "destinationBranch", chi.URLParam(r, "destinationBranch"), &destinationBranch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter destinationBranch: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", chi.URLParam(r, "id"), &id)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter id: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.MergeIntoBranchAsyncStatus(w, r, repository, sourceRef, destinationBranch, id)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RestoreStatus operation middleware
func (siw *ServerInterfaceWrapper) RestoreStatus(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:RestoreStatus")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RestoreStatusParams

	// ------------- Required query parameter "task_id" -------------
	if paramValue := r.URL.Query().Get("task_id"); paramValue != "" {

	} else {
		http.Error(w, "Query argument task_id is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "task_id", r.URL.Query(), &params.TaskId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter task_id: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RestoreStatus(w, r, repository, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RestoreSubmit operation middleware
func (siw *ServerInterfaceWrapper) RestoreSubmit(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:RestoreSubmit")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body RestoreSubmitJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'RestoreSubmit' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RestoreSubmit(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetBranchProtectionRules operation middleware
func (siw *ServerInterfaceWrapper) GetBranchProtectionRules(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetBranchProtectionRules")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetBranchProtectionRules(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SetBranchProtectionRules operation middleware
func (siw *ServerInterfaceWrapper) SetBranchProtectionRules(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:SetBranchProtectionRules")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body SetBranchProtectionRulesJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'SetBranchProtectionRules' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SetBranchProtectionRulesParams

	headers := r.Header

	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch string
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for If-Match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "If-Match", valueList[0], &IfMatch)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter If-Match: %s", err), http.StatusBadRequest)
			return
		}

		params.IfMatch = &IfMatch

	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetBranchProtectionRules(w, r, body, repository, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteGCRules operation middleware
func (siw *ServerInterfaceWrapper) DeleteGCRules(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DeleteGCRules")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGCRules(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetGCRules operation middleware
func (siw *ServerInterfaceWrapper) GetGCRules(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetGCRules")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGCRules(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SetGCRules operation middleware
func (siw *ServerInterfaceWrapper) SetGCRules(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:SetGCRules")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body SetGCRulesJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'SetGCRules' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetGCRules(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListTags operation middleware
func (siw *ServerInterfaceWrapper) ListTags(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListTags")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListTagsParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListTags(w, r, repository, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateTag operation middleware
func (siw *ServerInterfaceWrapper) CreateTag(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CreateTag")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body CreateTagJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreateTag' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateTag(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteTag operation middleware
func (siw *ServerInterfaceWrapper) DeleteTag(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DeleteTag")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "tag" -------------
	var tag string

	err = runtime.BindStyledParameter("simple", false, "tag", chi.URLParam(r, "tag"), &tag)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter tag: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteTagParams

	// ------------- Optional query parameter "force" -------------
	if paramValue := r.URL.Query().Get("force"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "force", r.URL.Query(), &params.Force)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter force: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteTag(w, r, repository, tag, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetTag operation middleware
func (siw *ServerInterfaceWrapper) GetTag(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetTag")
	defer task.End()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "tag" -------------
	var tag string

	err = runtime.BindStyledParameter("simple", false, "tag", chi.URLParam(r, "tag"), &tag)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter tag: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTag(w, r, repository, tag)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SetupCommPrefs operation middleware
func (siw *ServerInterfaceWrapper) SetupCommPrefs(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:SetupCommPrefs")
	defer task.End()

	// ------------- Body parse -------------
	var body SetupCommPrefsJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'SetupCommPrefs' as JSON", http.StatusBadRequest)
			return
		}
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetupCommPrefs(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetSetupState operation middleware
func (siw *ServerInterfaceWrapper) GetSetupState(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetSetupState")
	defer task.End()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSetupState(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Setup operation middleware
func (siw *ServerInterfaceWrapper) Setup(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:Setup")
	defer task.End()

	// ------------- Body parse -------------
	var body SetupJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'Setup' as JSON", http.StatusBadRequest)
			return
		}
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Setup(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostStatsEvents operation middleware
func (siw *ServerInterfaceWrapper) PostStatsEvents(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:PostStatsEvents")
	defer task.End()

	// ------------- Body parse -------------
	var body PostStatsEventsJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'PostStatsEvents' as JSON", http.StatusBadRequest)
			return
		}
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostStatsEvents(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// StsLogin operation middleware
func (siw *ServerInterfaceWrapper) StsLogin(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:StsLogin")
	defer task.End()

	// ------------- Body parse -------------
	var body StsLoginJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'StsLogin' as JSON", http.StatusBadRequest)
			return
		}
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.StsLogin(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetUsageReportSummary operation middleware
func (siw *ServerInterfaceWrapper) GetUsageReportSummary(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetUsageReportSummary")
	defer task.End()

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUsageReportSummary(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetCurrentUser operation middleware
func (siw *ServerInterfaceWrapper) GetCurrentUser(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetCurrentUser")
	defer task.End()

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCurrentUser(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL     string
	BaseRouter  chi.Router
	Middlewares []MiddlewareFunc
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/capabilities", wrapper.GetAuthCapabilities)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/external/principal/login", wrapper.ExternalPrincipalLogin)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/external/principals", wrapper.GetExternalPrincipal)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/get-token/mailboxes/{mailbox}", wrapper.GetTokenFromMailbox)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/get-token/release-token/{loginRequestToken}", wrapper.ReleaseTokenToMailbox)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/get-token/start", wrapper.GetTokenRedirect)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/groups", wrapper.ListGroups)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/groups", wrapper.CreateGroup)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/groups/{groupId}", wrapper.DeleteGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/groups/{groupId}", wrapper.GetGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/groups/{groupId}/acl", wrapper.GetGroupACL)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/groups/{groupId}/acl", wrapper.SetGroupACL)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/groups/{groupId}/members", wrapper.ListGroupMembers)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/groups/{groupId}/members/{userId}", wrapper.DeleteGroupMembership)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/auth/groups/{groupId}/members/{userId}", wrapper.AddGroupMembership)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/groups/{groupId}/policies", wrapper.ListGroupPolicies)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/groups/{groupId}/policies/{policyId}", wrapper.DetachPolicyFromGroup)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/auth/groups/{groupId}/policies/{policyId}", wrapper.AttachPolicyToGroup)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/login", wrapper.Login)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/policies", wrapper.ListPolicies)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/policies", wrapper.CreatePolicy)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/policies/{policyId}", wrapper.DeletePolicy)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/policies/{policyId}", wrapper.GetPolicy)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/auth/policies/{policyId}", wrapper.UpdatePolicy)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/users", wrapper.ListUsers)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/users", wrapper.CreateUser)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/users/{userId}", wrapper.DeleteUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/users/{userId}", wrapper.GetUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/users/{userId}/credentials", wrapper.ListUserCredentials)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/users/{userId}/credentials", wrapper.CreateCredentials)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/users/{userId}/credentials/{accessKeyId}", wrapper.DeleteCredentials)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/users/{userId}/credentials/{accessKeyId}", wrapper.GetCredentials)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/users/{userId}/external/principals", wrapper.DeleteUserExternalPrincipal)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/users/{userId}/external/principals", wrapper.CreateUserExternalPrincipal)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/users/{userId}/external/principals/ls", wrapper.ListUserExternalPrincipals)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/users/{userId}/groups", wrapper.ListUserGroups)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/users/{userId}/policies", wrapper.ListUserPolicies)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/users/{userId}/policies/{policyId}", wrapper.DetachPolicyFromUser)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/auth/users/{userId}/policies/{policyId}", wrapper.AttachPolicyToUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/config", wrapper.GetConfig)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/config/garbage-collection", wrapper.GetGarbageCollectionConfig)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/config/storage", wrapper.GetStorageConfig)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/config/version", wrapper.GetLakeFSVersion)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/healthcheck", wrapper.HealthCheck)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/iceberg/remotes/{catalog}/pull", wrapper.PullIcebergTable)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/iceberg/remotes/{catalog}/push", wrapper.PushIcebergTable)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/license", wrapper.GetLicense)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/oidc/callback", wrapper.OauthCallback)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories", wrapper.ListRepositories)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories", wrapper.CreateRepository)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}", wrapper.DeleteRepository)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}", wrapper.GetRepository)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/actions/runs", wrapper.ListRepositoryRuns)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/actions/runs/{run_id}", wrapper.GetRun)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/actions/runs/{run_id}/hooks", wrapper.ListRunHooks)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/actions/runs/{run_id}/hooks/{hook_run_id}/output", wrapper.GetRunHookOutput)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/branch_protection", wrapper.InternalDeleteBranchProtectionRule)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/branch_protection", wrapper.InternalGetBranchProtectionRules)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branch_protection", wrapper.InternalCreateBranchProtectionRule)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/branch_protection/set_allowed", wrapper.CreateBranchProtectionRulePreflight)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/branches", wrapper.ListBranches)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches", wrapper.CreateBranch)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/branches/{branch}", wrapper.DeleteBranch)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/branches/{branch}", wrapper.GetBranch)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/branches/{branch}", wrapper.ResetBranch)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches/{branch}/cherry-pick", wrapper.CherryPick)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches/{branch}/commits", wrapper.Commit)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches/{branch}/commits/async", wrapper.CommitAsync)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/branches/{branch}/commits/async/{id}/status", wrapper.CommitAsyncStatus)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/branches/{branch}/diff", wrapper.DiffBranch)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/branches/{branch}/hard_reset", wrapper.HardResetBranch)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/branches/{branch}/import", wrapper.ImportCancel)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/branches/{branch}/import", wrapper.ImportStatus)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches/{branch}/import", wrapper.ImportStart)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/branches/{branch}/objects", wrapper.DeleteObject)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches/{branch}/objects", wrapper.UploadObject)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/branches/{branch}/objects", wrapper.StageObject)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches/{branch}/objects/copy", wrapper.CopyObject)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches/{branch}/objects/delete", wrapper.DeleteObjects)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/branches/{branch}/objects/stage_allowed", wrapper.UploadObjectPreflight)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/branches/{branch}/objects/stat/user_metadata", wrapper.UpdateObjectUserMetadata)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches/{branch}/revert", wrapper.RevertBranch)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/branches/{branch}/staging/backing", wrapper.GetPhysicalAddress)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/branches/{branch}/staging/backing", wrapper.LinkPhysicalAddress)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches/{branch}/staging/pmpu", wrapper.CreatePresignMultipartUpload)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/branches/{branch}/staging/pmpu/{uploadId}", wrapper.AbortPresignMultipartUpload)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/branches/{branch}/staging/pmpu/{uploadId}", wrapper.CompletePresignMultipartUpload)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/branches/{branch}/staging/pmpu/{uploadId}/parts/{partNumber}", wrapper.UploadPart)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/branches/{branch}/staging/pmpu/{uploadId}/parts/{partNumber}/copy", wrapper.UploadPartCopy)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/commits", wrapper.CreateCommitRecord)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/commits/{commitId}", wrapper.GetCommit)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/dump", wrapper.DumpStatus)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/dump", wrapper.DumpSubmit)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/gc/prepare_commits", wrapper.PrepareGarbageCollectionCommits)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/gc/prepare_commits/async", wrapper.PrepareGarbageCollectionCommitsAsync)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/gc/prepare_commits/status", wrapper.PrepareGarbageCollectionCommitsStatus)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/gc/prepare_uncommited", wrapper.PrepareGarbageCollectionUncommitted)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/gc/rules", wrapper.InternalDeleteGarbageCollectionRules)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/gc/rules", wrapper.InternalGetGarbageCollectionRules)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/gc/rules", wrapper.InternalSetGarbageCollectionRules)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/gc/rules/set_allowed", wrapper.SetGarbageCollectionRulesPreflight)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/metadata", wrapper.DeleteRepositoryMetadata)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/metadata", wrapper.GetRepositoryMetadata)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/metadata", wrapper.SetRepositoryMetadata)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/metadata/meta_range/{meta_range}", wrapper.GetMetaRange)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/metadata/object/{type}/{object_id}", wrapper.GetMetadataObject)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/metadata/range/{range}", wrapper.GetRange)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/pulls", wrapper.ListPullRequests)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/pulls", wrapper.CreatePullRequest)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/pulls/{pull_request}", wrapper.GetPullRequest)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/repositories/{repository}/pulls/{pull_request}", wrapper.UpdatePullRequest)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/pulls/{pull_request}/merge", wrapper.MergePullRequest)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/refs/dump", wrapper.DumpRefs)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/refs/restore", wrapper.RestoreRefs)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/refs/{branch}/symlink", wrapper.CreateSymlinkFile)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/refs/{leftRef}/diff/{rightRef}", wrapper.DiffRefs)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/refs/{ref}/commits", wrapper.LogCommits)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/refs/{ref}/objects", wrapper.GetObject)
	})
	r.Group(func(r chi.Router) {
		r.Head(options.BaseURL+"/repositories/{repository}/refs/{ref}/objects", wrapper.HeadObject)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/refs/{ref}/objects/ls", wrapper.ListObjects)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/refs/{ref}/objects/stat", wrapper.StatObject)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/refs/{ref}/objects/underlyingProperties", wrapper.GetUnderlyingProperties)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/refs/{sourceRef}/merge/{destinationBranch}", wrapper.FindMergeBase)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/refs/{sourceRef}/merge/{destinationBranch}", wrapper.MergeIntoBranch)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/refs/{sourceRef}/merge/{destinationBranch}/async", wrapper.MergeIntoBranchAsync)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/refs/{sourceRef}/merge/{destinationBranch}/async/{id}/status", wrapper.MergeIntoBranchAsyncStatus)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/restore", wrapper.RestoreStatus)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/restore", wrapper.RestoreSubmit)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/settings/branch_protection", wrapper.GetBranchProtectionRules)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/settings/branch_protection", wrapper.SetBranchProtectionRules)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/settings/gc_rules", wrapper.DeleteGCRules)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/settings/gc_rules", wrapper.GetGCRules)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/settings/gc_rules", wrapper.SetGCRules)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/tags", wrapper.ListTags)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/tags", wrapper.CreateTag)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/tags/{tag}", wrapper.DeleteTag)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/tags/{tag}", wrapper.GetTag)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/setup_comm_prefs", wrapper.SetupCommPrefs)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/setup_lakefs", wrapper.GetSetupState)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/setup_lakefs", wrapper.Setup)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/statistics", wrapper.PostStatsEvents)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/sts/login", wrapper.StsLogin)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/usage-report/summary", wrapper.GetUsageReportSummary)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/user", wrapper.GetCurrentUser)
	})

	return r
}

// inline.tmpl based on https://github.com/deepmap/oapi-codegen/tree/master/pkg/codegen/templates

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9aXMbudUo/Ffw8k3V2HMpUrI9k4xTqZQtL9ETLypJzuTWyA8L7D4kETUbHQAtmXH0",
	"32/hAOiFjV4ocZE9/DJjsbuxHJwdZ/naC/g84THESvaef+0lVNA5KBD418nkPVXBTP8zBBkIlijG497z",
	"3jkoojhRMyB8/C8I1A+SvL6gU/0jVXzOAhpFC0KjiN8QnoCg+kNJeBwtCJuUPwxSISBWZoC5nhAkvpEI",
	"fs1CCMk1jVIY9Po9+ELnSQS9570n8AsET4/+CEe//BEOn8CzJz8/C4+e/Cl4An+En/901Ov3mF7pDGgI",
	"otfvxXSuvzuZHJg99XsymMGc6s2pRaKfSSVYPO3d3vZ7J5MPPIbm3V/2frzseXesF58mEadhacdXsCAz",
	"KknM7ebJAtSAfFQzEGaPklABJOaKyDRJuFAQlrf9Y8O+9Io7be4Dv+DzsVQ8hurmQohAAYFYiQW5YWrG",
	"U71b+z65mUFMEi4lG0dAfnz9z9PXZyfvX3+4ePEuW9u/UxCLfGkxH2Xfl1YWwoSmkeo9n9BIQt+tdMx5",
	"BDTGpZ7SKYsReV5MFAj9FYL49TxRi39okPWeK5FCf2kXAlQqYsIUzCWh+lOiZkwaKNesE19rAV1hPXOe",
	"xqoKvxm/IXMaL+zcihOzlrpJzTBesBwdHvZ7c/qFzdM5/qX/ZLH58+AoAxiLFUxBLC3wFURszlYBWui+",
	"IKmEUC99KniakIDP5zwmiYAJ+wKSjBc1m8kG6AzFUxzzbsdq1xMilrYfr3m9ZWXnQEUwOzc/dF2V+Z5M",
	"uCASv9d/CYjgmsYKKYmBrFmV+aBxVbf9ngCZ8FgCcuWXNDyDf6cgEfsCHiswiEiTJGIBwnX4L6mX9rUw",
	"7B8ETHrPe///MOf4Q/NUDl8LwYWZqry1lzQkbrLbfu+Yx5OIBVuY+AwkT0UAxE0pya/6mC+omAKu5Q0X",
	"YxaGEG9+MflUyD3VG57G4RZh8IErYuYszP9RfOAvjt+tdxlmSM9a3iIn0JJpoifvEy4sd8C/yThVTrbh",
	"CLjOEy215hAr2AK0NJCKE2o+IyDgccj0G28oi7axjOKcxE6KjEVcgzBfbXwNJ7ECEdOImFmJfbHf+xTT",
	"VM24YP/ZBihKs932e/+gEQtxhi3BIZ/QgeDWMVrkpJZ8EqFVVMUMe01AzJmUzKxg6XCzZySCa4hQRrJr",
	"MNLnxfG7ASGXvTOg4WWvTy57vwqmwPzzPE1AXPYIjcPL+LL3IpyzWP8pQCuNBX3vUqsKVckk4N8pE/rY",
	"fisu8XP2rlEpNZxfjLlQpwIkm8bv00ixhAr1CfVRz3ZnC6mV1xENQwFS+uViafblL7xrCAKQ8u+wOBYQ",
	"QqwYjWR1copvja5gMWJhFdzmMerNJ680rCUoFLOpBOH+QVhMUAMyRgZRIBWLp2W9+cXfT16cfDx/8/HV",
	"hw9/fP3PF+9P373uoTb1DuKpmvWeH1WA3u9JCASoUb7K6hLNK6Sw0vss8+Z/aCT++UnFb16/Pxn+/Y/v",
	"X73+8HY4Pv1yNmHH/9eu+++v/2/b0pdOrAxm3778R6gXepbG1XMbCxoby6gCM60sMmWPs/IU4nCk2Bzt",
	"jgkXc6q02kgVHOCvnjOAa4jVyPzsGVCkcd1cUlGhVpxNKqpS3CLEWsv+rTcxLBw3lmjTKCwAqwbedlF9",
	"B6fSWoogKm0vm73xMN4xo/ctUXGmUbcxy1z37hnFMo2M6Y9KddvXOU7cZoukQtBFlUvk8+TTeHcmF3Fw",
	"QeXVeQb78t5ywFeoT2vjzrpWVF6hCpK9Tx4BQ9tapojpk1Sb6FwYg4HGBLRQeNyrWp79HjgJ1UHwuIMb",
	"BTz0WNQ0JjOlEmJeIvolomZUkYALARFVIJ0JAySNQxDRQlsQuAS9O/jCpNIGRIbDLFZPn/SqBmC/p6Hg",
	"5aV6cBYSboBFNdARZD4qSBNNJBnplAeKqFREP8qhbnd2QyUxn4bFxTYQ3BLOuMUXia28Gi8CpWp2TBM6",
	"ZhHL6KGEQRMuplyNEirlDRdFblE4cRZfMwUjzbN9L9zWzKxlm9FaLvgVeHilcj8vYQX5n18vCD502JBG",
	"IRlDZnzTfHQgwhhh0ndcOMgIviRMZCxgWRNjX8jrhAczLYYkaqjLCPXzs57Xo1A6INyL7xBeIqc7FpCt",
	"oHIEAXRx+vR7s8yqW363vKlfZ6D3ovrEsFlyw6LIOM9m/IakiXFWRQwFrX0J3RfEDjyoOrCqyzGGuk++",
	"oHHWri/hANnr9cA7FVyB5a8R+Hi80mp99XQnMXpNiX0BNQ5NmxYsev6+UzA1JH7USij5q4ZXGFCBmJDr",
	"IFLRcQSjH1fUMdzqfPsrUqe259nUowpqjjTiifSQinAMq+BKhlgvMzT4rK2cDofpo+HjGQixOGXBVT3y",
	"WoHNr0EIFkKrlDzG9z9mr9/2V8H/hAqtE8TpfGxYkQftA1z1QcKCK32ilMxBTIGYhfaN9xyHIWYY8gg1",
	"EHRTCT4nR4+NyLmZsWCmmU0CQjMD/DJkk8ngMr7Q/zSrdajEpBv2qGSnFAQQgsUnfMza9FyFxffRfIo1",
	"TVKiP21VrWDiRzE+n58KmMiTOEk9ChLMKYv8C8uuGcw7HgY7AapSAZ9QEHkQFPX8RMAEBMQBGKdvANow",
	"tJ9auSi9HEZCkAqmFncZ333bMMESBJc2U52+DrxM1VGGKonMgi1gKWqkB16jVOr3phBDLuw6fFBjI8xB",
	"SjqFmmeKjgSNpzCq/VrRkCp0UNDQ+HxodFoW/xVpvQxbQ1FlHbzuK6tr93vXIJyLIr8hKFwPHLbKctSz",
	"3Nz9wknmUFk+wWWY1GMKKvW5Qk+j6OOk9/y3FuNiyRK47S+jm7EjurFfH7v/nC2wntmjy38E80Qt2nUQ",
	"CUpqNQPNDOp4XEBjEvBYURaTWPM7DTA/7fspQ4Ii+ommdCd1iDsL84TFpMBVH3lp6XE3YlpBNrXRy32p",
	"YQlH3XT1iLZbc9hh2rps4WXFobKxAvyXb8aSiAZQxImcitdzVPUTuuGcdWkW0POdbs2WzyDgImzVwHyG",
	"bW7U2n0LHMu37ZK0Ko+SPeo+2MaE2wr0WJaD5RXkz+r21GEttQhnH3QG1xpQzo9mlTlz3NIfFAV4dTj3",
	"tPM2CsK6PJp9UDfQnSR7eQb7oG6GO6oBRWekm7pOGyjBs6oc5MpEAS1r2Bx6d7reUdhboswLXIbLRxNL",
	"M4eQUWI9qb5z852aFh8aoCZaB0KC7/WJnDlvDBchCAjRQpEBxKG2ofRb1rIqnm2TqDB7O6VC+Q69wy1M",
	"H82A0QakbGVyBy7/2fnt96Bg44+C7KVG6Vl1C6AvlQs6hY5jnJu36z4fRVY/6DwGKhQa2KzjCj6d5JNb",
	"Aur45T/M2+5zv3RMFhpnzjNfU8Un5L+GQTKt4vuZ/lkj/HihAKOTAp4s8MCtc6n3v/joL48eXV6GPx7o",
	"//T/Sv76+P88/oOPrqy57/k94ZIpLhbtDrLCu2bAvtmXF/1Wuk7cmtBeZqpLnLG8sJZ97VilLQB4fXpt",
	"PuivTM3O8f7xIZ1fzV3vateqy6fe7Zr12IS/frL3DmWIuNuIRgYkPRiIH/qnk4rP/8HgxjdfUdKu6JGA",
	"Lwpizc9W/K7Wv56KqLNzXb/r2+0rNpmswDX1g0zLcDfAJvxxlMUP2tE/+7ghm85axY1ek9FZzhXFVUr2",
	"Hxgh2/UadgIkqpZa69OvZpd4YQjh0HgXwqEJ3A1N5G43nF/eKQ6IpDzn1+bS2wyOGqEN/evbSMqRe9Z6",
	"HW51MoR6EcZ1B7ZbBogoszbOt3TYVYKbQXAlNfi9sRT31nuL6mLTrs1gmpW8d1/or/1XwGsTk27zbqal",
	"LfsAmoWOdXSMyBkXmS+EwJckoizWOrymIHPL34a/TV6oQtTkZtfU78V8RIOoOQjChGSagIHlmMzWm4HG",
	"fX4xIYXv+JTFJ7E5aa+rhqGkV4tCjHJltOUb61GY5l6MVr91efym1Z4KFgcsoZFvmVVIviBpzP6toYlz",
	"TJgN38JjsUOSxI1J2AAIvZHPpZLPnx89efqcSpnOITwQPIKh/s+BFU+eyDKlWDztzpUqOzp3I/jMBrQU",
	"fTuM6BW8OTeBaSakjkrJA0YV5FExlZ12iUl0U+JVS6czqff2bRQ6t13WtlsRVEXftcmjekjd3S/3IvuM",
	"uJPTmDUGEvAYKYKMF0hEWrFQUIxsKbK6fJVvWBy+BzGFl1TCWXbpsxSESKU282sdwxe5k+zkldOZzD25",
	"/tRHliEGZRqWdLeRCyN46R7t+DuObSNI2iixMkfdvvrLIPQhzFsqxugciSITnFLnAJoKGsAoAcG4Z1uv",
	"LIMvKAwDYpQOaW62TCyHwZIAYkWKA+axPYhVuBaTG+eRFu17OBWQUKExC9NqPJsJnDMM5CjiQY2L3T3R",
	"6J5KQGGBUg1Ckn1PEir+nYIiGFhDHiVUKKQXQxcmWPRxOQbn6fPhcL44sM4sFCMyoQEMR5qDT+RQgFaT",
	"GI+H2Tw+fJsG9ng77cJim+EfWh+x35JAXm9o9XaGlrUnxlEM4cgahcuxdNkLJBUYlR/ymxgTMHNXOW7D",
	"68PKYoiXh62qA9azDaFVDJgkb4/Jv/i4BIGfnwGlR4dPD8I/Pvn54Bl9+vRgHIz/dPDH4HD8jI4ncPhL",
	"Ox1nUcS+Q+zXoGgnEvbHl5kYnzrPS3Zko5AuZAc9LR+u8nHnRcq6VUJ3YerfvccRYW/bRivvtObDfr5W",
	"74a1qu4xCDfm4SoN5DnhmoOv8c+0eDzrpInedL3id6clVuNaamferVpnTrxNlXOj9ovr8u3ob5xfebMz",
	"aFALwNXzL2acX9XxBHz2IDMwiivrO4Dkm1lKyGjIu7BA3i3iuJNemxVwEsAYxPQdD2h0oeV6dW+Z0G5b",
	"nB3rg3v/DCb2YshEKzbZoXlI48kr8sgGmXJhBfZj/4WTuyxqHti9RU5eeWPm3a6XU27RQDG6jt949zig",
	"DZzcoMtrXIJFw3mUYOhZWyH+k8egATXnAkwqIkYeUFJcTqaP4FUFT2Ot0+Eyv+hVdHfR2+WdplFU8Op4",
	"5BaMSmjTHDuHYgBkvmQt0bQiE5GAKhrxKWET1PnRn+UPnyuYW93wtIDzLtRmZGJn21fsArP0glA/Nqs1",
	"2FJM1PHE+GYXuB3WaLDQLtJr3ZVtuiacOk3lbNOHZs36DZ5aCSL3PjZ7YNnC13h0RfS658kV97x29rxB",
	"/ufd0jzhohR0mzEnF9xX8pjbD4wN6hR3aXIXzp+6qzqJIcUlbOoVXh+6S6fcJB2nwRWoYSJ4mAbWAC29",
	"b1devvO77TfNMmERHK06lfvIE6Dsi3zsFoiawXfVhBMEZUdlxJzMO2dwtuskenAXUdYBOeqdMnXusjx8",
	"j+FIJBE8MHFMdzIVlnbos1KK7GvJ0ZU/zO4OzLIgtGWfJOFxIUFrQN6nEh1blGA+KLsGosHmSmzZ1y7j",
	"E5vpukiAMEloTH6wVbRMyk9hYfq5ubaggXLlpjStmgzT5nHJDyX8rx/dPPcNWXKH+GmsfO3uu42x5U+K",
	"XrbK2rQWhL9LFk8jV1bMwtTkxemFWb2QxVLRKDLDjSMeXEmlVSi9pIHXidWVYyxrT5XSEXigiwT6mB5g",
	"M5PH4NuPO1W9oFWDEBrv3lslDyJqQyJ2Z1Zkw63zxO37plizeApSQTiyNFSF8AeT6cYnGZlZPgAhkZxM",
	"qOga8lyOGm5Lj75DonNxBL9dWziTAsp+0tLxDPQhedhj4cV6L57+tjuzL07YxumX589n823rHQvAy+Vr",
	"8qU1o4/MN3nmdHtGeW3CMl5k191lnL18cexRjl6+ODYXEQLmlMVZDiqPydtPJ1qNvOy529PL3oCQixlV",
	"pgTgDRdX8jKu3LHSVM0wgZUFYNmmpfjYlstj8yRiE4YeEGYL+/T62TzeOKQJjaIxDa5Gkd7lKKJj8LjN",
	"3+mfMfkTMzm0wCp/l4po0Gsf3uuTP0fXJBUL8unsHVqsk4mpLCdk8boEh/DOYgYPOL9i1kSpznKMT401",
	"kiXOG5b+P79erBR3b6YzzqZRbejGexu0oTgJmUwiurCbEZLczDSXYQhSHO3PhJJJGkVEQqyM5a4Rgkki",
	"IMaw8suYxeRvF+/fYUr2nC6yvDFKIhZfWdGWwRKHJXNQMx5exvVQ8x7JqWDzwoF0PYFURCMzo0/bmbAY",
	"pF3XGGb0mnFhE+/d13rDEtTgMj4gGqufkzdckI/nJg5B4u8CQiYgUM/Ji1TxA/dnBkrERf2ihAhfO5/x",
	"G0JJYg8jmHEugYxB3YCZe6qNBxaTa0YLS3HVP6w+EOSBqVoPmsZcQKgJubR4bc2akO5UuApNS2TqFoxh",
	"n1FdfGDEpzxV/tOpngrugKdq4NeZTDGLUcpGSL8zHoW+zKbT/CFR8EUVUddeuLqxyIRBlCnT5ky1dBv4",
	"UU2fnqa8dSzBjbXSEpaYfY76XuZRAn+tSGiMbWoPUF5DGHG3sGEMj7hn9uoLrFZrgguQZHMVHiSZ0WuT",
	"3if1ubhKbT4DstbWrJ+OxcjZBNDwAAVk7vy1j7KiHrYyTusqNp2b2u/Jf6dUzkZzB/rm7Z5MTHUSCVYH",
	"WDai7A6pRD4mIFZ9W5Dh0k4F8rJXCABR/DKmSQJUmI+syWPDRaxRWZ0BFREXPuLeRrZGIh5PQVzG1KQ0",
	"lcJNzIt/xiAepklXA07z1Kz28w8OrMZqsQfww2WMRCxxXiaNWNBCgl1pG/ctU39Lx/qLt0y9o+Nst2be",
	"y17fYIF+TBSIuSQ/TJm6jM2yDg7M238mU6bcbgaDwQ8lFlH03ylBFUw9xdtOYhJQCcZz7jZtwpz75m6f",
	"46tG6UMsL8DHWhe2VA/XPMMUgZ7Qay5c1rfxWbmDcWf+6Af918ENi+UPj/V2s7fsKZn3Hv1g/rQvDohb",
	"ccytILTG+JyG0PeszSxc6ySsuNdCMHeVN/lZzU4z+nEFNg6sJq2/+Mrz6iz26qRLMpJ71cd1TcTSMU8W",
	"ayl1JEUw8js/0P+TZXomLHMe5S4iS4TeqilmaG8tFprfuvXR861lhZa/S0XXc+7UpS5LtpN6qK0tcrtY",
	"ba2zN4lOJhgzRqwrpObiuaaG298uLk5LBdyysFkTCJQVJtJcuDxDXdRIeRdNsdcF8PnvodGT0t2oLx5H",
	"m1Fvh65f1rmiU2hI3N9wfsNKtSseUipEx5zfcmrQqgkWnszeQs5FYezG81Xy95630t9cypgPCzyer6UQ",
	"TSsLrMpXKBppH6ALZHAZv8GdaS6FCmNsJMens5Ncry5+Ya4AqCQIXiCPLo0ffDAYmCrGU5n/BSoYPL6M",
	"P4p+VozGKhg2GvMvWCzf6CBjIDQmyEatoVsMD9c2uoBpGlFh3nn7+sJvcy6DyySR+HQ7swyIFbpWYh7/",
	"BwTvk+UBzIVHIuDABpDq5WGRZly3ieYlVBl9sIBBGsWchuu2iCILr0JofBnbG5LiwBGbANbOZBMND1oq",
	"IGmrQeoFjXmqLrUdZOYfXMaXMc5kzGMmyY9GNaXRj0bv7ZLi2pBmqJEszhzoJjvcnqq7UXE+Exrd0IUk",
	"CU9SU7xUQ8bq/MaMNG0aNDoWeIiDVbYDtwEymnBhoBVETPMNdOKlSRIt+ihd0bMcGxelqdTQcc/1+Wbe",
	"mgdL+YmOj7Qwx93GhhW59Nriwzxc9V6G82kJGGVAzagczbnwsOsP8EUZB58miWvKIhtf5ZHt9MsoATFK",
	"/E5b+oXNaVRAcNuUgyQgcIZec82Ufi+GL2rEJxMJnp4vWPk1cz8L0GNb30ns9uCPZcvOuu4qy7YFMk0W",
	"svwIFyG6Qp2XDMxLwOoXAk6Lm/zsPUY1q8P25RACr8yv0707RBB418MjFiy2GUNdH+iqsO9EZ7I9z764",
	"xWM8MR8dtd2x2dhV+209UI5dD4omwu1+ObJ86+IaXBi7hwvyCAbTQZ+cJC8MPy1lhHztZb/rTRz98mRw",
	"9POfBoeDoyGWsc5/eKJ/+Hxbu63d8lqLb2tjszYN6e3xp9gVXArrY/V4rFicGsTOLkk7uG/8s9QF2XSa",
	"BrNP0ny4jslFhS8Iy/3sBAVMf4Xi/g2ZMt5VNQG/mt+GqTbfcDX6bj611qS47tXkcbMJfu6y2N8ek4bU",
	"rm+rwPwaW6lg8Yw8lW1FLmx0304kkb/a79awZSm4u5t/t/DRSypZgA7eqpNLnwtTkY19zY76c9UdbBoG",
	"+Z0KEZcQZiK9WzZJRRPo9lkxX7ah10ltWWAxhbApybdQv89QkfmEnJ7Jhqzh2pX4lIRKCSoD2eXBvHv9",
	"7PWwVw575fStam4PTzCIx5xtz4HO6ygxGNRR5OVLvXuyWUckaDucxpWXmJMlkTsdkHfPq4XS5unmSYox",
	"ToYZ3DGItrCcHVvIRc62NtXNZug0VKm9a/JisT9Qzcy7hafLIFgXHOWrdJ7UJ/qO2uuwu+zo9jcVnba/",
	"5k1krizEO1jdWuq2fgbod93S7le4LHlYgCrWktxeurTJ6l5d/gug4YjH0cLbvANtAOPGyXIU0Qedx8Lk",
	"Tw4w9izrJTvhgoypKHzL6npK2DKoPkb/qVLVwPL9wj0C1lk2twi1fVWKgt3MtpRIVuqhyiKQC6lgjtcP",
	"WZimb14WG38CuVwOw5d8DsOEqtnwsve4VTR5ktIr5+pbfDMSNmkUyyiT5xPMKfNeaLj0+kIB1t/owX8O",
	"D375bP9/8Pnrk/7PT25r6q+WcK1M1tnspmuxB0vw+cg5eFf//veBZUtZIfZP93a5eu4j+fS/U/nfmVKJ",
	"/Ot/5zD/LyaJ/lcJGksGsXr8fDgc/PiHTol1d8BOLUzrfBeh7fje4GCo4XF1mmJdBzkBky56hBH9a0mp",
	"MLRtgnHbDPocWrvWpDLBtkaFyo25nqub6nh/h4UHt67srzUXAFnt/itYrHwDgGN32+y5r67wRjqT2CGb",
	"l2X1u90T5LYJTIJaS4RcbdyFP7bk1xlV5g5Omq68XGDMquJ49zQoBO7b1fYrwRr4bcfMOv/mr0Gsq8EQ",
	"vmxj9FyvH4EToN+Yp8oFmvo9xw+qdZ0NDtCrv2vXumL0o7d5nRl+cNfedObzldvSlTfer21Tdw7KV/TJ",
	"5gk0d971NNQuJGF4+8566phi6U+j9/yLxjAIOTzuVNwTJ6ndE95n+j0iSFlyhB3L42nztYl+H7OKJXZG",
	"t98MvKjtUjy6tFooZvu5+9qiH5LFTEMUO9X3ezFXo+IvnzuFSZ8rLaOn79qvwvRZJBENkAhiF4GF1CHN",
	"IISZQtv3u17wNEsqB2eZho6YIZvFFqCjzIa/25geFkWFvLSlkCabs4SrN7cOpspMnEYmXqNsPdQsdR/H",
	"9WP3mKY61CtqfEvnXrhtxUXlHW8yOVgf4LnUjdJn2FkctpGfhMdkTE1vUmOAPVKLxKZHvL6g08f+9lxb",
	"DQdeIUZ0QMh7utCYwWyK4Hjh2s7eJfauywfmSDvEkZSYzgbbBLkVrRJDfF4MjKmrUld/AdoQGIPo0h7i",
	"0h7OkUfKVOJcProIxWwqibzb5soxSbJQHEKTJGIgB75yxoC5B6VOC1qtQ2dUvPB3koCu7aXt4IVPsoJ3",
	"dSciX197jySIqC8AWW9SEtDfEHyl4DcZTamCG7ow4cE8gZgmbGSliPkRviQgmAYSjQ5s91nzJGUHOKrX",
	"l6cPOI090XaFKL7rUss1XBoKiVLhomIUn1dRKu4Pc1Dd9pJU2XITZr22XFbunjU/X6aHh08D3zax9C0+",
	"hk7+SoR/37l+zP6bD7Hmbs1AZqVoNIsUrQkhZmT/qoq9uKpXGlm5lVHb1Wvh1Rofe+GNzDM2+geNWIit",
	"AabwpftnhTi1pg+cWPJcFBu3bz6itSW95juWWBnZdux+49++c223MxK1+0kEjLRaMpq74JRRmkWneOwz",
	"93rj9MtvjVLme3H59mcJUi3A7nSEnhX7l1eBax0QW/HW0VNHulnqPrcso+wLn85OfAn/J6a8A+b6oWpt",
	"nb0uCU+UHdTG33xkPNOKDx1relxR3orheG058w0hcudKvkhVQ/lAmyvnkV6mGsIoFaw+YNavg6ho5O7p",
	"vFkKWm07UPwgwvbq1qrNy3Jb3buouhUa2V/GGFCtFe+nPx8eupfIoyMy46l4TGwXTRN/hlIaUE0/eoIv",
	"yDsmHpgkP7PrJfD4AH9Bp0X/0XI0+xUQRafk5BVJONO6h7Vqzl6/GVRwYQWVuMG1SNGHZgRgQx/AJteK",
	"otNuTsY658kFlVf1brX26nAx3NT4R7uFtOj5T+IJXzWc5j5zZt0lq8SHjdxG19jJbYX+fsX+bz5hX11C",
	"dm9mTLCygr3UucV133SaZIsXwDsfOpf9KSiVPjF3yQ9ctmtqsh0KHVur+pVGZn86oCj6P9vyMwtv982g",
	"zSs55snijeDz7iGa+bf4XTXkMuDJYtStxulSN9Iql8tH8ocQLi2mUwRtlaLdW67FBnlkCQ1ixQTWFoE4",
	"d208tvloEKIX+TI2XMwf1dulzkyneFoz3IWHWVRcdC2zlV73TtVUFS4zorpUvuNx6bal8GgBtAtC42tu",
	"oCYLxt/ucnPRPDCnLPKjEz7KcMkFKUgQA3IyIS9OT5bde0y6ym8lNymW4YhDihE92gx13kQWXzOjmtha",
	"W1hx0z9wyGR15Gwg43wakBdRRALTN1SP86LYT0kSeyCGJOa2INkYyGWs1RmBWbp6fcaR1yc0UjOeTmfE",
	"iJRyeyaJVcmwnnPsKqAwWVMRaiIYxGG0GPkN7ReZY9WUeipeSagZNR5oFg7IpxhrxbCQMEVCDqYEl/U4",
	"Lgr3GFgWhk1nyvUGMnt6PCCfrFNb8jmYAndZQuunk5rlr9oTziDJMY3t5BCyclei7gHadTSymr5D2xbr",
	"3TWi58i1mm0x8+r0FAlit8EUpg3uusIoyr25K5vCxGc1KvTq99y4TwUNYSRAq8AokPzmtnvRLw3yrvwN",
	"z0boOv+iOoXHmyplqWBqcY5p/q6bGgtGmvRRs8IHep0Y6Z+NMVMqMa45LKzmXmemJrb+zbmvnmfFKvGt",
	"kQQpS03RaML+Dmgk/+tG5ZlmY6ACxBvH0U0Vx3w5+LS6Hs7CoHk12RtNK5F0HjUPk71RP8wt0pQxE7zN",
	"KbDCwYvTk16/F+VVUO0ELxIazIA8GRzatsZmk/L5cHhzczOg+HjAxXRov5XDdyfHrz+cvz54MjgczNQ8",
	"KuQcuCnNbBkm9Y4Gh4NDBJzx2Pae957iT4Vq4EO9zWGxrz92RjM6d1bw5iTsPe+9BaVlULGhv6EvTD/A",
	"754cHhYaTKP+miSRlXzDf0mD4IaYW+/Cl+dCmC+xwlTNSGnxt/3esye/eKxUzrXgXri7T1nw6dWtJNva",
	"8BxvgWzuXYG0es9/+9zvyXQ+p2KhD4JJtSzvi8sj1nMFLmDaXEu7Iq96aHMgrvDrMGvPOUStApkUl57T",
	"qXa3xPcNZwSpXvJwsbazqW0Ue3trmPEGcSIHLWbk+9AiT77Ma/Aa8Gn0MOtpPvCXNCxkkzw7PGr/5FNs",
	"sq8wmAA/etr+0RsuxiwMwa7sWfsXH7h6w9M43DGmu2gcW3aVpNLGOZSKHpf6f1p0z2oa90uXRjZ7rZkI",
	"GplTtaHqBjHR0721iofVJrvbRcAHiE4ZAplZxt6ey+MFYUUOiYjRr8Wcz8YlQ+eg0En2mxXr/04Bm+Rb",
	"oZuNfxL2igqj8Vnlx76sW33OEHIK6gB1mKE2uMb8C8jhV/vP2ybURE71RvD5e/Nyb/c8Ek2rUpZ6xKdT",
	"NKe+EyT9qct6PnB1Mk8ivN43K1o7qxQQALOVYszFBZ0oWyUdqwcUOKWpM58Vxv509m7go4Nm5F8KyjYo",
	"l/vHxgsytSh5lhe0Zq4gZU4w8wKy3odYBERAJdi/vqLAsHiDq6gnnTPzJb51wWuJ55kPI64wDBW/D++O",
	"ng8X2wr4hZsk1GKX8wU439GjEn49tp4YU1fUIQc6xJgr8W73dW/UK41G3JHUo+HAj4cVhGnEyDn98g7i",
	"qTbvjg6fPOt3QlEMQW7l4AVyKWHgU6Pq+TbPbQxRQqfQJ/SGMuVKO7nCfu4MPp296/V7M6ChveqpDzLV",
	"Bp2NcTx7lzca4jcS7eZ68uz3/nnwDq3FA0dNlcHfvr4o8Cpbsxj9nvjBgJC/AySlpZ+/Pj57ffH/NU59",
	"+x3SYA3HR2wiNNAoamLgDSzHi2LPAh5jAXR3aM2UluOs4GlSrwe/Y1K9Na9UiNO3ufyVgmfuNO+I1vmb",
	"F1qmrfjJHG8Obj9vUBvKOwJ7dCCEJYmY01+2pPJsU81Gj8TUIUQJx5B9e30Jpv+j6WS8GQdCuUW012tw",
	"tN7Jas9/b5I5XDFXpgZbqsiyxIGGX/H/J+GtWWAE5jKvjEmv8Pcck9rUNkORZrSwZJ7sjym3nDV06o6p",
	"X6vC1JzC4Z7OtnyAU1D1p+dzZJTVYUt3dzXLlqh3SIOoSfHFQ31x/G6jLovjdz60eXH8ThsmDxt7PooP",
	"HNe/AyQqAWh7uFSnNpwvYcv61YYMUcqrrVEeqthU8neZlNpwz5cys6UVpeq5yBzmY2u2Ntsl7+2Le+vE",
	"hjM0GycGrr8XG4XMM+zYvWC0axl+TSWI7nquRfAZ66bxzrPX92pvZ7WXzItA3hKq9L0jGeRYWYCmHh75",
	"IgxbMeioEYNoGO7xpwZ/aBh2QJ56dpDwiAVN8TGZiDt1b+5lXJaAWyflEKqL7cu3B42qBYGY5Li0e4no",
	"FjP8ao6tVSgqGszM+b8RfN7dDWSxIsQB9hytViJq8BALLLyo2bIp6BeJDjnWIxRVjkQXvAaFjmpRiKo9",
	"CjUJRVVEIcVbDb+WKMRNBh0+/GDDyO6+cId7DurA9K8vT5xXm7QtoPGG8C90HIRw9OTpTz//mZxSNfvL",
	"8M/kb0olH+PIU1HP3ql+PyZht2DDBvTspKTt9bOHr59tXd1qVLQabkltu6DNsDzXi6izy3Pts/qwoTMi",
	"YJ0HXEHWtuaOMvSX9o+OXbvrHV2bJg4R2nhTZ+1Z/15Ar85K896L1OpFqjus+tvTuoM4fHhk97u4QK0/",
	"wXZTZ60Giqlk8GDEwOH3LAYeMlKacsntYiCVbfdkn+T+gqzDBRnGMX//imkq6y7EGrTST9JWKF4/Myol",
	"rG84cs+ke/uPvnDq68nosgdQmew6Y1+me+P3rcamnmjkZe61wpVohoht2itS81537aC7+k+oXnP1H8Hh",
	"tol0r7PWnly7xnqXW+Yamh0GhdrybWpIsQ79XiGhclgASJ1eksN3f63pV2dIUEKrLdFDs8ZUxvSNaTSF",
	"aX5lanYOgYAWLJJ7DFrSURrRpwPbG36lrtFGJyWmETc8ukxhqr1K00WlaeEHdZpN47lshOfvKXUFdWcX",
	"XN4fkVAg9/XoUDWlSdptoQ5FSjwMxVMjYx8b04WxeACHcTJpTc7tagVG1oat66pU0u4U8uPf5ipEZfN0",
	"cBm14vw3GMzzoF0+NvrHA2nT72klElmBVQ47WJ4VBNoboH7CqjNDq6cq9/ZojT2aw8re0eesBps3PBBx",
	"UauOdCgKoWlqXxjiYReG+EaopaGcxFaxvlOwn8b7by/gr1/pqsqiyNZOIjSKSMikYnGg/Bwrq53NBdGo",
	"wCeEKZkfnE/pNC3G2DWUqvi09RPZp448VCq9X+bIJuj0jmkjna8Q91kjd8wa2eq91NZzRvz4s08ZWVfK",
	"SH3EQN622Yrn8goFKMHgGoitX25eT4Ur3V/195rxNunqtU3eqtLGu8a7nfBtDiwLoSK4hlMqxnQKBwGP",
	"Isj6p3ohOAVFil1/+YRMAyJBKRZPpQ+Eb83gx9nYm4dp3ZT1QLYQIDkELNzvD/ClYusW5LajVQnOiQAs",
	"mOnYUDPuuqZ+rThc7ia4QbAvtS2sBbZ/5RsCdKHNRUdAaxS3X2n0dotG9uSDr6luaTt7bBK+5eYh9fB1",
	"W143RGdAIzXDLs21/AGfEjXD3oGA3YgM5AiTJE2wQZBI49h0fC7D8m84/jGO30X7+sCPLVirqVxuC7PC",
	"mGYXLIAxiOlQwJwrrSIGVNGIT2+HSRpFprVMmxJiP1mPq/w0jaITs6gL7Gm3Gf+4nULPlqkLPse4B9Cl",
	"IkYaStrm00s1ypyB5IPWV9aghSh6hRWPcd+JgGvGU4nwkDPbA87xChajD8/AhVhk6SPua+ihZYxNO7Gb",
	"vXldUwsXzJjl8dQNlTeFLig8FnU7ILSc7QSh5WybCC1n90RoPEBzsIr/TtBZwJRJhZ5odOxkGGfggFW0",
	"i+hbi36FXkOddG77flGL9EpVO+wG5ambYrO69/aLRLtzijIQei7OOAuDYUCjSLOgWn/mR4o9kexblSLk",
	"T1pIa8ptEfYC7MqvTyiLjAcRvpjyeMQBzzYz4qFt6efGWVOyt8d6zJhtm4v3rPjit+TibfnmHKgIZueW",
	"w2/S0ZpBsNbZmku+30HKjSgjVM5pCz+3ZeCcFVWFxi4JJxOCwt023iaUjKmAgq5BbpiakZgTFjMMK7bt",
	"trUGMxY0DmY1Ln09zh28+etXDnJgFMNAtpnTXjiORuze57b7Am5r9N4SOSyz7OHX/KsOMbbd6eXlIqFS",
	"EgE0POCxVhkFV9ZNpEnChn5pFb60bh+FmL7597zweuZTszLi3QcAd4jT64Jg9XHAJdzZgpB8cCzkoUcC",
	"dzvedsNYlA96pZvJWt40pMg75FCkcUdFc3GmX93gireng9Io4jev54la/INGKbiledUJp2s0rnuFAY0e",
	"02txa2yuwBee+1ka1ym9pp2rkSyIHHu2XVKTDRFkppshozZVoERuw68ijUcsbOyeeJbGG6Y132C4rlVd",
	"cJvHVW8b5AxFbW+xPaIWpQ/VkFkXog5nnF+1iIk0/hu+9C0g7XcQyqmB3cbFZQIBm7AAicQc4Z5Glpi5",
	"hctaCWX4Vf9v5H7jqbIROw3MXp/nR/PiN0JBnoEK296gEOGBAnUglQA6LxOMcedrrY3FVHiLh1ZMGIsC",
	"xJ7SnkCKJswScFanEqM+j3JvRdkpUg2EKNPGib3+N+6SlzjYaTbWWXqvm71E6MmU9bQnVOm5/A1Ec1T+",
	"LXvxc4ZdfPwvCFQ3757Hb2JgVPToiDSCvQ+l4V6pEBbSrw+q8ePSW1A+RLp3NjVTMJdtYtuLwrcZJlEh",
	"qNfT4seRvTwvsas6INXgzeZcL/ktSVekNPcna2ZwqyPiejmYcaTvOVgLB1tRgg4lqBE6nPQZ1SiV9fh0",
	"KmASselMdQpw++T69Scg5kxKLfSJ4oVrO//RM9uq+w4e4n3KcoOs25W72BxzS0zCS/fStxSP4PPRyhm/",
	"Gc1YGGLb/fp7svLx/zqDmEhQ5IAYJ2oUEQc3wuIgSkMWT4kZN3syID++/ufp67OT968/XLx492Nvy/lm",
	"ZzCpcyJY2t4nm1UcB+Mc0x2ZZj9tS7WoZ/gbVRnuF8yg4IsaztQ8Kk/bbqbDBATEAezgovFp+0dvuBgb",
	"dvH9Fcywoj67CPMgfDfZMfxq/tUhMCLDYx8hbSmcwXK/3Zvhm8e/HQQ/NKFTfdBDgb9tThzWi8K9FKya",
	"21sXgX7X87go+e6XSXsGsoRpmwgNlFjIbwVB6o230spmzpf2XOk+uQiyBaNXlHHDYAZCLA4SZmLbvw1y",
	"8KuWuJNTZsPv108O+QS7ipQ9NkE5HsavZkAKR2nDkL9jLXSzfQWcFkt2Q+ZnkER0Qcyh0ngK0mTN6R+m",
	"7BpiF2bOY/xtrQwBR5bfOjNw4WuN4coXMyCSpyIAMgdFBWbVKG6hOyBGupJ5KhWJuSIzeg0kjc1jrW3b",
	"0xnUhDCbsUfZ2O3hdBvgWrjYh8exvnsOtYKdfPSk/YNTAQGPQ6ZB8AZzwXZW4tvRVl4pw7CMOzObIZWL",
	"OPguWM4L3Mme79yJ7zxZ2+wXVC5paT7uQxSVV0QqKpTjDt8ZK+rMHradelvDVQhygpngMdYMKDAZT2bu",
	"nTnN8CsLb4dSUZXWXxUV6PncvLnR4kbLk7UjLb61F5/bEZ+7o48pKHvahE8MfWTqv0PYejr5FjxclYqa",
	"n2L27xQIwxYFEwZC7xytoQKTQDpwArC8BhZu4lI5ZyYhm0xq+cYrNpls3gGsZ6m7ENXL0xCzVwMexWHv",
	"Ic78/BpWK7mIH0YBgvvFIryCiM2ZW95D1LJXJckZFeEI3aPfjhmReorAnEHEg/wi05TZmYCw/xiQinGg",
	"2QllcYnMQ6rooFo2jIqwfGvQaKUg/hKEad8tB2sdJ5zFimDhMoydsnfeddaIRso1dN7YXD74/n5iXdxU",
	"UyGpuaS4pwLP5gkXqulO/gTfOKZxAFEbbtdqGGYakgiu0aEGo++dN+JBQztxgMv/zi/yH3YgCZ4A4fGU",
	"s3hqEaIYnG1+qL3/N2iYmYwPGQ3Xp46WNu1RSe1+VrRafxfxCWXQePHsG/aKZogh1KaqGxq2vyNHY3n2",
	"MzuNjwROsnPeexvXQDqWbLSmay5HTXob1kwGHxmtqnCY8Tr0Dvxo8uo2FQXYbtd94Bd8PpaKx9DrpmxY",
	"WO2DBjcSNGigOyDvmZRahbCYZIwnbbK5ZjHErZSAHm1QQFuHfd+oB09ARBW7BtfxprEWnp1+DdLmUxJx",
	"GtYRZAsZnUw+8BjeU4URlB1ez19tq5T+KnveN0ZzQBM6ZhFTixwrxkBkmmhuBSFhMZmkKsVigxFQ2XDZ",
	"Z4vJRxQVxa3Z1V0k+X1y4Pu9eRopllChhvrtA83qm1KjC2soQ/9jHC0IJZoWIyATFgFJQJAUkYXczJhz",
	"p4yBaKCE5NINdtnTYO+y2EqS9SbDKgyGa3Xbq21b9j4HRRFo36Ou8T1e+lSYf7/35eA6O5QD+BJEaQgH",
	"Y6Q6q9pmbsTmFN5zRae5qrIJRTxDyinsKtxoTxdb1XekPmtCY6vh/CAz0JpC1Fm4YsUZuGJesUcvHwY8",
	"WWza1790rwZS2QsU5w9328TF9DelTRUn1qOTldQr/fVofTrWMU8WW+AjepoHykb00py5KTKLf89L1hEG",
	"RJGUMNLBsRWvVXRXrpGb8t+EVbUzH4Kf9osOD7kh8j+lapZHNrQR/eGaiR5Rsy6w4lXRvper0/7eZdLs",
	"MpHr8pnclTugQtNataToZVhPnRJriqJrwHmPLvQfIQeJ25+mVNBYAeQtw5z9qiGEvgPnxCNcENBqV8Kl",
	"ZOMIBuREERaHmjBAEqzMrkfIV0HsmIrNQTPfgEaRPgZcEcQhXvnv8fxhF0f5Zt159yBXhR2NR5lJt1WD",
	"II/RSZOQKticBYBav+K51rlp92rq5Xt6k4bvaU723gF9M4pA7XTdrQEP980sVHNk4f4yOk8uvhFMAXlE",
	"o+gxWfaVVMVs/74hPQKuQahvPO3nDDex4Tx8PcUaEvH1MHeJdNunBz+o9GBLN2tJ99UaL4unwzENrjSm",
	"N5R/Pp0tJAto9CIMhQlK6nDhnQiQbBr7Lqa2Uzjs3GzwHQ9qk8ESuzFCzc7Qq2cBQ6gAupcRecBSrLEC",
	"nb4OWorbOzR0hEYMYgxjdPaJz49jgbtXh1cJDX/H4itjti3jKzahwydaTWSx7SBq29YhFseeNJDBZXyR",
	"uejdWPrkxkB4DMQddkjGCzKtMIC+tjMLeMBTJVm43N3rB5m1MdcAkQkN9MSV4HS9u1YOs6Eb/A2lwFrW",
	"s5reeri/DLuXMlDiXevVBzqIksBpBkiS1Cas9YkSCzIDAb+DfEUqJQ+YlhFOhHJbZdfPtyixHLIqHO6q",
	"zCTzJP1mXPzbFC2V6eJ0PjZR51ZRg5B8OntHEirQwW0Gzl2UtQsRyht8xGIFUxDL1cZLcbHYOVWBJJRk",
	"ET+58hBaz68kuUpx8sqgTmnNRm0DGsxw9eQRxxlo9HhwGZ/qX8xmpQnBtdh3NCCvs0/gSwCJcYRGVCoU",
	"gjMqyZzFbJ7OiWT/ARJCAnEoXe2dNA5BRAuN5+OIB1cYf0qYIyvkFIPL+I1e2xeqfyY3XGhd2yzg/Gnh",
	"u355KibJT+9fkkcm7sP4Y+3S9Hof++SoqbB6aiDz3sHzkzu9jd2Z1szo4ZH2zephM4sJe59MxkwdcXho",
	"Y32pVUW2OfxqRj8Jb5d7oJRyA8dckxB1JFhZXTX7ED9pwMv1619NM3oD9DxOk1pkpWMu9qhaQFWEdgNG",
	"fPM1CjwDOVr5Fs3JY66FkZG7dWemDT8qJczHkZM+5gGERkWokrkbdquU3jKpl9i3ZmjVspDArjr8FppO",
	"PCgLapt8zeFWE5nYKTcukodIdMOv+n8fUJu9/bZCmdbDPtdlC3mWlEO2cbA5/aLV9N7zo8PDw37Pau29",
	"50d9v+XjL/VgI1rKplceDsJixUuP25Usw/BON5dtmU/wRvD5tl1aZvYL7vXiV6AoAU1Cq37sOzptlzFt",
	"JUB7z502xZ0+WTPHeEbGC4zL1Uog/o3xuVzNQLh4tQZWdGyC4zfLjvQk3VmSx9LDfQU8YaBPfAY0RIz9",
	"2nt9QaflFZU/1M9d3YaSdtwnCZWSsNhperZS23IXmT1nWp0zbaNMdUsXI1Oz8QwCLjZo12RT3Dv+wxbP",
	"Ezia63q4z1tYa/lS4bBh5UQnV6D0q/mH9b/VxWJk9c03XJF0DZW7fxdFXBpqYm/du+UQaJ0xuGE6T+or",
	"XqbzpK7ekU8ZUlRejR5Q8aKzbKOFnfjqaqbzZMfVdx8yHZznRWoL8R8kg1qBOoqItqNOhHjU6djLRddb",
	"h/wknvBmdGKxqTCA0v2h49QaMOUlDa7SZClQKI/MfqTRpG95quxnbSwf43WwpNcmxmhsRzFO82L5n0E9",
	"qjWzuWkwTAQkVMBopwrmqVnEWyrGdArHPIpM1+Jju6gN3uNW5rRraSptpYEh8wYGWJRJwj5f6D6p9RrL",
	"IyaVYagB3g9ZnESv1tScEwmyg7qL1llF+C304rgr2rveGjvrGvH2mFho7TtHrBPZHVCnrrK9XBMut7R4",
	"aMG3e9bwdLt6e5wRbrFk/cMt5tkNLH4XvG/HOyn7+X1RSLkJRJVevK0gHkRL/gJVugh0k1r9cMTLpzwy",
	"flM1DezMx4WpMhTfbKkw/9Sb0+X2Mq5BoStYO8V0jFLVpLUpdiKNQC4H8XWtU/hnvD41X749PtNDVa94",
	"TuxqTF2MCl3hV53qIrhCpNW9E9zFDiuUfiNFBax+s+oBT0G1nu5bUF2P9nBzZqiZ0cOwpgHiCBpLe9TY",
	"quQvhvSvhneyA96dN+Ld+oV0E8rd4bpNgtrzszsibTfZNpSgWov11GLReir3NJ6yS3wq0Nf+rB+OaVIs",
	"GlOX6GBLfskEAm3ch+QKFoVu3KU8VzeeLy3HjJPfNG24dkp1or/DQt6jdETVS4+A2HkF+R3UKvMAo9es",
	"lVWu72vwYOP3m+VU5NYz3t/xF/0vzee+kyvN8ubP/Yu0peSwThyWfqNhSDAuNqQKrKuSX7PQcrc+XrMV",
	"Cu/N+TUQDVT4wiSWE9Cv+bjceS1qb4PFnYNaK4cr94XbK2oFZ0YrOXRW5ty3+I8Rtisffs3/3RgFpQ/+",
	"zDY432ABGaxe8ensxMc19UoPTAN3/UYpcDRLc/FgW8gEBEprkOdPG7s23O6RLit7hPkSn85OCOZFFEA/",
	"YVGx50+GjzuIvspRdxOqqi19OPyqv78dfjV/jljYSif661U6FW2gcNN9uoHUlS9xU5UI79j8ePAO4qma",
	"1UzFYvXzs54nIl7P9dTcKi8n7ORUi2k5B4WEE1cJPqt1VMMI9pTemdKprWOUS2R76OMFOXnVexjlVTMK",
	"XMNY+FbTMBCnc1Q2LX8pMJvP/TvzFCt02+XtjmXtXszuQsw+OAm7duGapFFUHyTyjkl1mkbRmQPz3TvC",
	"36VV+/26yPsbhtmwFk8DgR6Not4y3U1YpEAQDaYM2TQPzgZybIknoBWGIOISr9L1YD6+tMnYlcJJ1ZXx",
	"j5jEDLbShvbGnWMACJ4ybHLCN7TS32IJj5YsrMKBbyp4I59hVw1pPEtojOEoHN53nej1sBuJm8yw4mG0",
	"E1IHSTX8qv83skM2KmzLxLF5ptuGjvucmYpfeTUE6W+xv0GJj7DQ396giIwrM3asv1rTaGCrnP0llSxY",
	"oZxFA6BsY4G7uY734XN+QrGXFZtmpsM5iClst4vI5qnM18zjvd7oluQDznUGUuOA14cuMHpi1WpYv9O2",
	"BC3QdPrOZZwHXT13flJiBjG3e9bSR+AR4xfFq7+Y6/8TmCdqQQqzXcaF8sWb7bCQFMofk8kd6h+vgeUY",
	"tFwnxxEwkVkq9UYNprQm4/UMJhvNHtTj63n8AQYTidnAex2whGcaXsXbVIRTfQ5s3gUKc13LZE5JDDfk",
	"xemJoXAWK8HDNAAS8XhKRBrHWJDb4YW8vFNwOeKxAJx/J6h8ZubOsHkT0QUTaWe5s1aIB1nUAokpDrTH",
	"/xL+WzCvQAIYfldK+N4ZFeSF0RbziMVX32jZeddfDntA0nEExMZz+BzIkbtwuYfb7tyA6425VtiYPGq+",
	"UHIbWdlH9t37gA1AJLFYjdc/kgRcmI9NLXpe6PBuLtoMQt+RkiKYqDOY3A5DNpkMvwo2neHf9XVn2GTi",
	"V2jWZ7roOeruEfQ6yRjUDUCMLGuPP1morAaNgAkIiAOQpTjJidyyG4vmKyGPAp5GIRkDAYblC6lr5c9F",
	"Vm2YnLx67DfDLY7uYD02JRPzfumUshjNER/ULN2susYt3Uhu9LL0FURsztzyvLWnTIiF7+pTzQTAKOSq",
	"cKOpbrj9JX/qudGsHPHJBKNHNYvUkEdGiTRhFZIgSkMgeFQH2DQr02aokgPy4+t/nr4+O3n/+sPFi3c/",
	"1lUMMKOMcJQRfrlaV/jPXbiy0By5UAzHf0fOp3lpmrvejt8Pr2queKmayb7pCgOmIwth0vYcMqWqbGpH",
	"kEdu+YCdNz3NAcwUzKWHmjJQUyHowoceKywvMWTQrwvSm7AvsL5laWajcTXvC4SjERY7b5Hi5AeKYP9h",
	"QH5lasZTRSapQOZle4xrlYrHhAYqpdHyWIM6rZKZWlwN4YaVBbMlMpvwKOI3eYPzCROmV44GbJpwvQsa",
	"zLAjHsncjmZe35rw+5H5vnVpmIn2ep6oxT9olII/EfJ8xm+yog1zY/YEenVqRuMiNoZUwYFicxiQk5gE",
	"VAJJJYSmLL5UPBlR3Jkhir5hLPp318rd7N0KEGwaPwdQEgP5bYWSzMVWeyiSxUGZX2bxk9kCe15+2Aka",
	"LwqSUHG3fO+O9UK2sF8D2N6uSq8YLlqncNrNRXy61zSr1Tc1XIxrQMBkQE4mZMw1FzWcGz3bjl8SrUWh",
	"f7vv+BqNIkeXg22rq97BJusMcSvIcifJGsIG6uLEyyf6cqHARgcqrsEoGFwD+sSxz5nmjwsF8i+HB0eH",
	"T546ijORm/lOXVBpvreEKm049p73/tcM8OjR5WX444H+T/+v5K+P/8/jP/Q6KGFntnGcQyMjF9ikWC8w",
	"5CDxwmNGr7HLFlVGPmDV7+Jenj6lPz8LJz/9dPTsyU+TIPjpJ3gWPntCj5796Y+//BT+Mnny0+RPv4TP",
	"6vZ5Mjn4wGM4MD1H71JD/ncbkd/31GCvAK33jkp18J6HmKfbHmr/5PDnbUEmoUIxGpFNQsh9b8ip9Pld",
	"6WkTUN9VYsVTX9KfhRnS/9xt4UFL1qPDzd+9WiyFLwmKHpz2581Pa4EJIUEUJh+4IudUMTlhdBzBThSL",
	"CsE6tcAJUS12NT5WxejfgIbfphz93OVuK0MSZuKDvwle34UrYzHm3yVrfuY755c0JFU2t1wB08vWvAij",
	"We1kiZ11ZD/bYRdLDgZ7hUEk8gkCvruSGQRXWq1cpgkfs/gmvd7ivh7v5Q6XZsD1tLdc1fAZtuT6fMw8",
	"fdtoGFln6ltcikzBhb25X0pOcSY99t4m1F5BZp7S3zPd+WgqlSBGhRoNnisCM7LPq3lnS/QBXimVr4dW",
	"volandVIRVV9ZTJFc0/LrprTWj7zbVT8aVAXpjwG8micms74Wq3LksbndKEpkF5TFmnV4PEuTQlPqZS9",
	"erDZBtgPiiuuzkNQyEULFk9PhWYgikGj8/aT7/1N9mTN5jOspjBrO78hPCb5BjGYj05hr+54OEeSwbUG",
	"aHuOsrWW+l2IWPJUBIABbXjTPPwaglbmkcZemqjRWjp+w+IQMy9eUrnRihulieqTShD7EZLm1nysl7UP",
	"Yy6S6oRVIIS+6ycPJg7OYGTR+C7Pk2Hs/aYpoLkjepzAO2eFJtZTGwBR+iRWvDToupMEcBZ/A4d98tw+",
	"ee4BJc+RRzCYDuzlmkGZGedXdhcQEoovpmIH1pFZThOTXJe43UJvsz3TzZhu3q5tq5x3e+3gDOLuO8E5",
	"XvBTlx184OpEy6o5xBZgG2AhBAl9JnjMUxkVc1JWz9ddgbMMv7Lwtq3pnI9Ksk5zm9UiinO14vNuGhw/",
	"wJpBRmQ3f3BaELlv7pCuvjvSKXeWQzS2FoyvpdwOi9F8f4K037mVpDkQczjFHpLl1bBwvV6MLL/by8ds",
	"2u730fi9vBlv8QKTpLxv/96t/btL6V6um/EAOr+7s86bvz+A8gHbaTlfwuLvuDDgZqoSYG4BxRImhMWV",
	"rvN3bTovQSkWT+XQiJtRIriyjR8brnmMvDnN3l1LR74sdawJwXwze7LLKshnpWm+PdMlqxxrV41rKw+i",
	"nzupWD/gvrpzk7rXALedcOnU37atDsOX1tIp0YxNsh43/SbcMb69MWRF/IopI0EqMJEQcRATRcrNc65x",
	"/vr0j/bMj893l0ZrJt07tNDxg9SJmR120tm8TbkNE/HePffuJpSmwcjTSNjX3M429PzWG/5+D3Uza/l4",
	"nTZRe3a76OhbULneHlvZtBfg/k50GYAemPAuItS+Ve+eE60kfMxHDTH6F/qFb6YPx2ZdWLXlqRSd7pui",
	"V5MHlMEdh5j4/102sDB55pvgkhd0uquGFWcwqUHJ/Z3SjvpQKMSzJbRv58PDr4pOb9u1f4PGHS4BJlws",
	"lZTpUMTAI7Q1e9t5++nvrMq+7XDtRZV648FxsM2JuPvykt+FVVBzalsuXKMycbbCLaQElSajgM/nowRj",
	"vp5/rZGZ5/rNYz6fn4rNFX/Oxj+JtX1z1/rPej9p7AqiJYXwFEmv18W1ftl8PCGeDrmhktBIAA0XS+Gm",
	"24hpvBE8nhKzEqm0PDN1QZgsxClsieogSAVTi97z3z4vNcVOE1I6dFk89frKuAb9I3plUb+O0SLyn+vd",
	"b7QJZz6Lr2ayaclaOIkdgz1Lv1czcA1jWSwVjSJDeCzHW23op0lt59h6jrMhRmPG7s5f1sPdBGCACY3k",
	"r0zNziEQ4DUgUwlive773TArGm2xfUgjc7DoSePQwpVQW7dQw7qBQSiqmFQsaJCMp1yaNN/X13qNm8LY",
	"fIbc73AHl5vWOcROVfdtqmf6xExtXwIIu74RXRCHCWem6OscaKxQqmVFR1Jbs64JMeQw4lMWN2hMSr7D",
	"NzaFEPJFqmal9n/b42V6as3LzMcX/Aq8kdo5kpHzi3NiIPadIVsN40lATLiYE2p2baqpnl+cN8dEp5JO",
	"4cAQ6TAbrCHpWL9/hq+f27c3eOonBfFemBnhUBxVwRfVUvdoGVNwOCLseN+trZgWtklkdmI1XAaFU8Pp",
	"H5vAiE9Ghm1OcSlMU6Ou+IrD2qiNJQmrT0xvr0w6X3v/ulEjhXzk+W+ftY07ppIFI3zd/hJwfsWg9BNn",
	"YfkdSedR/oOmSDwPX/23TKM2FaasSOj1e6mIes97Q5qw4fVR7/bz7f8LAAD//ztPJ+EuTAIA",
}

// GetSwaggerSpecReader returns a reader to the Swagger specification corresponding to the generated code in this file.
func GetSwaggerSpecReader() (io.Reader, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	return zr, err
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.T, error) {
	zr, err := GetSwaggerSpecReader()
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	swagger, err := openapi3.NewLoader().LoadFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
