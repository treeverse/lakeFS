// Package apigen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package apigen

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/pkg/errors"
)

const (
	Basic_authScopes  = "basic_auth.Scopes"
	Cookie_authScopes = "cookie_auth.Scopes"
	Jwt_tokenScopes   = "jwt_token.Scopes"
	Oidc_authScopes   = "oidc_auth.Scopes"
	Saml_authScopes   = "saml_auth.Scopes"
)

// ACL defines model for ACL.
type ACL struct {

	// Permission level to give this ACL.  "Read", "Write", "Super" and
	// "Admin" are all supported.
	Permission string `json:"permission"`
}

// AbortPresignMultipartUpload defines model for AbortPresignMultipartUpload.
type AbortPresignMultipartUpload struct {
	PhysicalAddress string `json:"physical_address"`
}

// AccessKeyCredentials defines model for AccessKeyCredentials.
type AccessKeyCredentials struct {

	// access key ID to set for user for use in integration testing.
	AccessKeyId string `json:"access_key_id"`

	// secret access key to set for user for use in integration testing.
	SecretAccessKey string `json:"secret_access_key"`
}

// ActionRun defines model for ActionRun.
type ActionRun struct {
	Branch    string     `json:"branch"`
	CommitId  string     `json:"commit_id"`
	EndTime   *time.Time `json:"end_time,omitempty"`
	EventType string     `json:"event_type"`
	RunId     string     `json:"run_id"`
	StartTime time.Time  `json:"start_time"`
	Status    string     `json:"status"`
}

// ActionRunList defines model for ActionRunList.
type ActionRunList struct {
	Pagination Pagination  `json:"pagination"`
	Results    []ActionRun `json:"results"`
}

// AuthCapabilities defines model for AuthCapabilities.
type AuthCapabilities struct {
	ForgotPassword *bool `json:"forgot_password,omitempty"`
	InviteUser     *bool `json:"invite_user,omitempty"`
}

// AuthenticationToken defines model for AuthenticationToken.
type AuthenticationToken struct {

	// a JWT token that could be used to authenticate requests
	Token string `json:"token"`

	// Unix Epoch in seconds
	TokenExpiration *int64 `json:"token_expiration,omitempty"`
}

// BranchCreation defines model for BranchCreation.
type BranchCreation struct {
	Force  *bool  `json:"force,omitempty"`
	Name   string `json:"name"`
	Source string `json:"source"`
}

// BranchProtectionRule defines model for BranchProtectionRule.
type BranchProtectionRule struct {

	// fnmatch pattern for the branch name, supporting * and ? wildcards
	Pattern string `json:"pattern"`
}

// CherryPickCreation defines model for CherryPickCreation.
type CherryPickCreation struct {
	Force *bool `json:"force,omitempty"`

	// When cherry-picking a merge commit, the parent number (starting from 1) with which to perform the diff.
	// The default branch is parent 1.
	ParentNumber *int `json:"parent_number,omitempty"`

	// the commit to cherry-pick, given by a ref
	Ref string `json:"ref"`
}

// CommPrefsInput defines model for CommPrefsInput.
type CommPrefsInput struct {

	// the provided email
	Email *string `json:"email,omitempty"`

	// user preference to receive feature updates
	FeatureUpdates bool `json:"featureUpdates"`

	// user preference to receive security updates
	SecurityUpdates bool `json:"securityUpdates"`
}

// Commit defines model for Commit.
type Commit struct {
	Committer string `json:"committer"`

	// Unix Epoch in seconds
	CreationDate int64            `json:"creation_date"`
	Generation   *int64           `json:"generation,omitempty"`
	Id           string           `json:"id"`
	Message      string           `json:"message"`
	MetaRangeId  string           `json:"meta_range_id"`
	Metadata     *Commit_Metadata `json:"metadata,omitempty"`
	Parents      []string         `json:"parents"`
	Version      *int             `json:"version,omitempty"`
}

// Commit_Metadata defines model for Commit.Metadata.
type Commit_Metadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// CommitCreation defines model for CommitCreation.
type CommitCreation struct {

	// sets whether a commit can contain no changes
	AllowEmpty *bool `json:"allow_empty,omitempty"`

	// set date to override creation date in the commit (Unix Epoch in seconds)
	Date     *int64                   `json:"date,omitempty"`
	Force    *bool                    `json:"force,omitempty"`
	Message  string                   `json:"message"`
	Metadata *CommitCreation_Metadata `json:"metadata,omitempty"`
}

// CommitCreation_Metadata defines model for CommitCreation.Metadata.
type CommitCreation_Metadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// CommitList defines model for CommitList.
type CommitList struct {
	Pagination Pagination `json:"pagination"`
	Results    []Commit   `json:"results"`
}

// CommitRecordCreation defines model for CommitRecordCreation.
type CommitRecordCreation struct {

	// id of the commit record
	CommitId string `json:"commit_id"`

	// committer of the commit record
	Committer string `json:"committer"`

	// Unix Epoch in seconds
	CreationDate int64 `json:"creation_date"`
	Force        *bool `json:"force,omitempty"`

	// generation of the commit record
	Generation int64 `json:"generation"`

	// message of the commit record
	Message string `json:"message"`

	// metadata of the commit record
	Metadata *CommitRecordCreation_Metadata `json:"metadata,omitempty"`

	// metarange_id of the commit record
	MetarangeId string `json:"metarange_id"`

	// parents of the commit record
	Parents []string `json:"parents"`

	// version of the commit record
	Version int `json:"version"`
}

// CommitRecordCreation_Metadata defines model for CommitRecordCreation.Metadata.
type CommitRecordCreation_Metadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// CompletePresignMultipartUpload defines model for CompletePresignMultipartUpload.
type CompletePresignMultipartUpload struct {

	// Object media type
	ContentType *string `json:"content_type,omitempty"`

	// List of uploaded parts, should be ordered by ascending part number
	Parts           []UploadPart                                 `json:"parts"`
	PhysicalAddress string                                       `json:"physical_address"`
	UserMetadata    *CompletePresignMultipartUpload_UserMetadata `json:"user_metadata,omitempty"`
}

// CompletePresignMultipartUpload_UserMetadata defines model for CompletePresignMultipartUpload.UserMetadata.
type CompletePresignMultipartUpload_UserMetadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Config defines model for Config.
type Config struct {
	StorageConfig *StorageConfig `json:"storage_config,omitempty"`
	VersionConfig *VersionConfig `json:"version_config,omitempty"`
}

// Credentials defines model for Credentials.
type Credentials struct {
	AccessKeyId string `json:"access_key_id"`

	// Unix Epoch in seconds
	CreationDate int64 `json:"creation_date"`
}

// CredentialsList defines model for CredentialsList.
type CredentialsList struct {
	Pagination Pagination    `json:"pagination"`
	Results    []Credentials `json:"results"`
}

// CredentialsWithSecret defines model for CredentialsWithSecret.
type CredentialsWithSecret struct {
	AccessKeyId string `json:"access_key_id"`

	// Unix Epoch in seconds
	CreationDate    int64  `json:"creation_date"`
	SecretAccessKey string `json:"secret_access_key"`
}

// CurrentUser defines model for CurrentUser.
type CurrentUser struct {
	User User `json:"user"`
}

// Diff defines model for Diff.
type Diff struct {
	Path     string `json:"path"`
	PathType string `json:"path_type"`

	// represents the size of the added/changed/deleted entry
	SizeBytes *int64 `json:"size_bytes,omitempty"`
	Type      string `json:"type"`
}

// DiffList defines model for DiffList.
type DiffList struct {
	Pagination Pagination `json:"pagination"`
	Results    []Diff     `json:"results"`
}

// Error defines model for Error.
type Error struct {

	// short message explaining the error
	Message string `json:"message"`
}

// ErrorNoACL defines model for ErrorNoACL.
type ErrorNoACL struct {

	// short message explaining the error
	Message string `json:"message"`

	// true if the group exists but has no ACL
	NoAcl *bool `json:"no_acl,omitempty"`
}

// ExternalLoginInformation defines model for ExternalLoginInformation.
type ExternalLoginInformation struct {
	IdentityRequest         map[string]interface{} `json:"identityRequest"`
	TokenExpirationDuration *int                   `json:"token_expiration_duration,omitempty"`
}

// ExternalPrincipal defines model for ExternalPrincipal.
type ExternalPrincipal struct {

	// A unique identifier for the external principal i.e aws:sts::123:assumed-role/role-name
	Id       string                  `json:"id"`
	Settings *map[string]interface{} `json:"settings,omitempty"`

	// lakeFS user ID to associate with an external principal.
	UserId string `json:"user_id"`
}

// ExternalPrincipalCreation defines model for ExternalPrincipalCreation.
type ExternalPrincipalCreation struct {
	Settings *map[string]interface{} `json:"settings,omitempty"`
}

// ExternalPrincipalList defines model for ExternalPrincipalList.
type ExternalPrincipalList struct {
	Pagination Pagination          `json:"pagination"`
	Results    []ExternalPrincipal `json:"results"`
}

// ExternalPrincipalSettings defines model for ExternalPrincipalSettings.
type ExternalPrincipalSettings struct {
	AdditionalProperties map[string]string `json:"-"`
}

// FindMergeBaseResult defines model for FindMergeBaseResult.
type FindMergeBaseResult struct {

	// The commit ID of the merge base
	BaseCommitId string `json:"base_commit_id"`

	// The commit ID of the merge destination
	DestinationCommitId string `json:"destination_commit_id"`

	// The commit ID of the merge source
	SourceCommitId string `json:"source_commit_id"`
}

// GarbageCollectionConfig defines model for GarbageCollectionConfig.
type GarbageCollectionConfig struct {

	// Duration in seconds. Objects created in the recent grace_period will not be collected.
	GracePeriod *int `json:"grace_period,omitempty"`
}

// GarbageCollectionPrepareResponse defines model for GarbageCollectionPrepareResponse.
type GarbageCollectionPrepareResponse struct {

	// location to use for expired addresses parquet table (partitioned by run_id)
	GcAddressesLocation string `json:"gc_addresses_location"`

	// location of the resulting commits csv table (partitioned by run_id)
	GcCommitsLocation string `json:"gc_commits_location"`

	// a presigned url to download the commits csv
	GcCommitsPresignedUrl *string `json:"gc_commits_presigned_url,omitempty"`

	// a unique identifier generated for this GC job
	RunId string `json:"run_id"`
}

// GarbageCollectionRule defines model for GarbageCollectionRule.
type GarbageCollectionRule struct {
	BranchId      string `json:"branch_id"`
	RetentionDays int    `json:"retention_days"`
}

// GarbageCollectionRules defines model for GarbageCollectionRules.
type GarbageCollectionRules struct {
	Branches             []GarbageCollectionRule `json:"branches"`
	DefaultRetentionDays int                     `json:"default_retention_days"`
}

// Group defines model for Group.
type Group struct {

	// Unix Epoch in seconds
	CreationDate int64   `json:"creation_date"`
	Id           string  `json:"id"`
	Name         *string `json:"name,omitempty"`
}

// GroupCreation defines model for GroupCreation.
type GroupCreation struct {
	Id string `json:"id"`
}

// GroupList defines model for GroupList.
type GroupList struct {
	Pagination Pagination `json:"pagination"`
	Results    []Group    `json:"results"`
}

// HookRun defines model for HookRun.
type HookRun struct {
	Action    string     `json:"action"`
	EndTime   *time.Time `json:"end_time,omitempty"`
	HookId    string     `json:"hook_id"`
	HookRunId string     `json:"hook_run_id"`
	StartTime time.Time  `json:"start_time"`
	Status    string     `json:"status"`
}

// HookRunList defines model for HookRunList.
type HookRunList struct {
	Pagination Pagination `json:"pagination"`
	Results    []HookRun  `json:"results"`
}

// ImportCreation defines model for ImportCreation.
type ImportCreation struct {
	Commit CommitCreation   `json:"commit"`
	Force  *bool            `json:"force,omitempty"`
	Paths  []ImportLocation `json:"paths"`
}

// ImportCreationResponse defines model for ImportCreationResponse.
type ImportCreationResponse struct {

	// The id of the import process
	Id string `json:"id"`
}

// ImportLocation defines model for ImportLocation.
type ImportLocation struct {

	// Destination for the imported objects on the branch. Must be a relative path to the branch.
	// If the type is an 'object', the destination is the exact object name under the branch.
	// If the type is a 'common_prefix', the destination is the prefix under the branch.
	Destination string `json:"destination"`

	// A source location to a 'common_prefix' or to a single object. Must match the lakeFS installation blockstore type.
	Path string `json:"path"`

	// Path type, can either be 'common_prefix' or 'object'
	Type string `json:"type"`
}

// ImportStatus defines model for ImportStatus.
type ImportStatus struct {
	Commit    *Commit `json:"commit,omitempty"`
	Completed bool    `json:"completed"`
	Error     *Error  `json:"error,omitempty"`

	// Number of objects processed so far
	IngestedObjects *int64    `json:"ingested_objects,omitempty"`
	MetarangeId     *string   `json:"metarange_id,omitempty"`
	UpdateTime      time.Time `json:"update_time"`
}

// InstallationUsageReport defines model for InstallationUsageReport.
type InstallationUsageReport struct {
	InstallationId string        `json:"installation_id"`
	Reports        []UsageReport `json:"reports"`
}

// LoginConfig defines model for LoginConfig.
type LoginConfig struct {

	// RBAC will remain enabled on GUI if "external".  That only works
	// with an external auth service.
	RBAC *string `json:"RBAC,omitempty"`

	// label to place on fallback_login_url.
	FallbackLoginLabel *string `json:"fallback_login_label,omitempty"`

	// secondary URL to offer users to use for login.
	FallbackLoginUrl *string `json:"fallback_login_url,omitempty"`

	// cookie names used to store JWT
	LoginCookieNames []string `json:"login_cookie_names"`

	// message to display to users who fail to login; a full sentence that is rendered
	// in HTML and may contain a link to a secondary login method
	LoginFailedMessage *string `json:"login_failed_message,omitempty"`

	// primary URL to use for login.
	LoginUrl string `json:"login_url"`

	// URL to use for logging out.
	LogoutUrl string `json:"logout_url"`
}

// LoginInformation defines model for LoginInformation.
type LoginInformation struct {
	AccessKeyId     string `json:"access_key_id"`
	SecretAccessKey string `json:"secret_access_key"`
}

// Merge defines model for Merge.
type Merge struct {
	Force    *bool           `json:"force,omitempty"`
	Message  *string         `json:"message,omitempty"`
	Metadata *Merge_Metadata `json:"metadata,omitempty"`

	// In case of a merge conflict, this option will force the merge process to automatically favor changes from the dest branch ('dest-wins') or from the source branch('source-wins'). In case no selection is made, the merge process will fail in case of a conflict
	Strategy *string `json:"strategy,omitempty"`
}

// Merge_Metadata defines model for Merge.Metadata.
type Merge_Metadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// MergeResult defines model for MergeResult.
type MergeResult struct {
	Reference string `json:"reference"`
}

// ObjectCopyCreation defines model for ObjectCopyCreation.
type ObjectCopyCreation struct {
	Force *bool `json:"force,omitempty"`

	// path of the copied object relative to the ref
	SrcPath string `json:"src_path"`

	// a reference, if empty uses the provided branch as ref
	SrcRef *string `json:"src_ref,omitempty"`
}

// ObjectError defines model for ObjectError.
type ObjectError struct {

	// short message explaining status_code
	Message string `json:"message"`

	// affected path
	Path *string `json:"path,omitempty"`

	// HTTP status code associated for operation on path
	StatusCode int `json:"status_code"`
}

// ObjectErrorList defines model for ObjectErrorList.
type ObjectErrorList struct {
	Errors []ObjectError `json:"errors"`
}

// ObjectStageCreation defines model for ObjectStageCreation.
type ObjectStageCreation struct {
	Checksum string `json:"checksum"`

	// Object media type
	ContentType *string             `json:"content_type,omitempty"`
	Force       *bool               `json:"force,omitempty"`
	Metadata    *ObjectUserMetadata `json:"metadata,omitempty"`

	// Unix Epoch in seconds
	Mtime           *int64 `json:"mtime,omitempty"`
	PhysicalAddress string `json:"physical_address"`
	SizeBytes       int64  `json:"size_bytes"`
}

// ObjectStats defines model for ObjectStats.
type ObjectStats struct {
	Checksum string `json:"checksum"`

	// Object media type
	ContentType *string             `json:"content_type,omitempty"`
	Metadata    *ObjectUserMetadata `json:"metadata,omitempty"`

	// Unix Epoch in seconds
	Mtime    int64  `json:"mtime"`
	Path     string `json:"path"`
	PathType string `json:"path_type"`

	// The location of the object on the underlying object store.
	// Formatted as a native URI with the object store type as scheme ("s3://...", "gs://...", etc.)
	// Or, in the case of presign=true, will be an HTTP URL to be consumed via regular HTTP GET
	PhysicalAddress string `json:"physical_address"`

	// If present and nonzero, physical_address is a pre-signed URL and
	// will expire at this Unix Epoch time.  This will be shorter than
	// the pre-signed URL lifetime if an authentication token is about
	// to expire.
	//
	// This field is *optional*.
	PhysicalAddressExpiry *int64 `json:"physical_address_expiry,omitempty"`
	SizeBytes             *int64 `json:"size_bytes,omitempty"`
}

// ObjectStatsList defines model for ObjectStatsList.
type ObjectStatsList struct {
	Pagination Pagination    `json:"pagination"`
	Results    []ObjectStats `json:"results"`
}

// ObjectUserMetadata defines model for ObjectUserMetadata.
type ObjectUserMetadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Pagination defines model for Pagination.
type Pagination struct {

	// Next page is available
	HasMore bool `json:"has_more"`

	// Maximal number of entries per page
	MaxPerPage int `json:"max_per_page"`

	// Token used to retrieve the next page
	NextOffset string `json:"next_offset"`

	// Number of values found in the results
	Results int `json:"results"`
}

// PathList defines model for PathList.
type PathList struct {
	Paths []string `json:"paths"`
}

// Policy defines model for Policy.
type Policy struct {

	// Unix Epoch in seconds
	CreationDate *int64      `json:"creation_date,omitempty"`
	Id           string      `json:"id"`
	Statement    []Statement `json:"statement"`
}

// PolicyList defines model for PolicyList.
type PolicyList struct {
	Pagination Pagination `json:"pagination"`
	Results    []Policy   `json:"results"`
}

// PrepareGCUncommittedRequest defines model for PrepareGCUncommittedRequest.
type PrepareGCUncommittedRequest struct {
	ContinuationToken *string `json:"continuation_token,omitempty"`
}

// PrepareGCUncommittedResponse defines model for PrepareGCUncommittedResponse.
type PrepareGCUncommittedResponse struct {
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// location of uncommitted information data
	GcUncommittedLocation string `json:"gc_uncommitted_location"`
	RunId                 string `json:"run_id"`
}

// PresignMultipartUpload defines model for PresignMultipartUpload.
type PresignMultipartUpload struct {
	PhysicalAddress string    `json:"physical_address"`
	PresignedUrls   *[]string `json:"presigned_urls,omitempty"`
	UploadId        string    `json:"upload_id"`
}

// Ref defines model for Ref.
type Ref struct {
	CommitId string `json:"commit_id"`
	Id       string `json:"id"`
}

// RefList defines model for RefList.
type RefList struct {
	Pagination Pagination `json:"pagination"`
	Results    []Ref      `json:"results"`
}

// RefsDump defines model for RefsDump.
type RefsDump struct {
	BranchesMetaRangeId string `json:"branches_meta_range_id"`
	CommitsMetaRangeId  string `json:"commits_meta_range_id"`
	TagsMetaRangeId     string `json:"tags_meta_range_id"`
}

// RefsRestore defines model for RefsRestore.
type RefsRestore struct {
	BranchesMetaRangeId string `json:"branches_meta_range_id"`
	CommitsMetaRangeId  string `json:"commits_meta_range_id"`
	Force               *bool  `json:"force,omitempty"`
	TagsMetaRangeId     string `json:"tags_meta_range_id"`
}

// Repository defines model for Repository.
type Repository struct {

	// Unix Epoch in seconds
	CreationDate  int64  `json:"creation_date"`
	DefaultBranch string `json:"default_branch"`
	Id            string `json:"id"`

	// Whether the repository is a read-only repository- not relevant for bare repositories
	ReadOnly *bool `json:"read_only,omitempty"`

	// Filesystem URI to store the underlying data in (e.g. "s3://my-bucket/some/path/")
	StorageNamespace string `json:"storage_namespace"`
}

// RepositoryCreation defines model for RepositoryCreation.
type RepositoryCreation struct {
	DefaultBranch *string `json:"default_branch,omitempty"`
	Name          string  `json:"name"`
	ReadOnly      *bool   `json:"read_only,omitempty"`
	SampleData    *bool   `json:"sample_data,omitempty"`

	// Filesystem URI to store the underlying data in (e.g. "s3://my-bucket/some/path/")
	StorageNamespace string `json:"storage_namespace"`
}

// RepositoryDumpStatus defines model for RepositoryDumpStatus.
type RepositoryDumpStatus struct {
	Done  bool    `json:"done"`
	Error *string `json:"error,omitempty"`

	// ID of the task
	Id         string    `json:"id"`
	Refs       *RefsDump `json:"refs,omitempty"`
	UpdateTime time.Time `json:"update_time"`
}

// RepositoryList defines model for RepositoryList.
type RepositoryList struct {
	Pagination Pagination   `json:"pagination"`
	Results    []Repository `json:"results"`
}

// RepositoryMetadata defines model for RepositoryMetadata.
type RepositoryMetadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// RepositoryMetadataKeys defines model for RepositoryMetadataKeys.
type RepositoryMetadataKeys struct {
	Keys []string `json:"keys"`
}

// RepositoryMetadataSet defines model for RepositoryMetadataSet.
type RepositoryMetadataSet struct {
	Metadata RepositoryMetadataSet_Metadata `json:"metadata"`
}

// RepositoryMetadataSet_Metadata defines model for RepositoryMetadataSet.Metadata.
type RepositoryMetadataSet_Metadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// RepositoryRestoreStatus defines model for RepositoryRestoreStatus.
type RepositoryRestoreStatus struct {
	Done  bool    `json:"done"`
	Error *string `json:"error,omitempty"`

	// ID of the task
	Id         string    `json:"id"`
	UpdateTime time.Time `json:"update_time"`
}

// ResetCreation defines model for ResetCreation.
type ResetCreation struct {
	Force *bool   `json:"force,omitempty"`
	Path  *string `json:"path,omitempty"`

	// What to reset according to path.
	Type string `json:"type"`
}

// RevertCreation defines model for RevertCreation.
type RevertCreation struct {

	// allow empty commit (revert without changes)
	AllowEmpty *bool `json:"allow_empty,omitempty"`
	Force      *bool `json:"force,omitempty"`

	// when reverting a merge commit, the parent number (starting from 1) relative to which to perform the revert.
	ParentNumber int `json:"parent_number"`

	// the commit to revert, given by a ref
	Ref string `json:"ref"`
}

// Setup defines model for Setup.
type Setup struct {
	Key *AccessKeyCredentials `json:"key,omitempty"`

	// an identifier for the user (e.g. jane.doe)
	Username string `json:"username"`
}

// SetupState defines model for SetupState.
type SetupState struct {

	// true if the comm prefs are missing.
	CommPrefsMissing *bool        `json:"comm_prefs_missing,omitempty"`
	LoginConfig      *LoginConfig `json:"login_config,omitempty"`
	State            *string      `json:"state,omitempty"`
}

// StagingLocation defines model for StagingLocation.
type StagingLocation struct {
	PhysicalAddress *string `json:"physical_address,omitempty"`

	// if presign=true is passed in the request, this field will contain a pre-signed URL to use when uploading
	PresignedUrl *string `json:"presigned_url"`

	// If present and nonzero, physical_address is a pre-signed URL and
	// will expire at this Unix Epoch time.  This will be shorter than
	// the pre-signed URL lifetime if an authentication token is about
	// to expire.
	//
	// This field is *optional*.
	PresignedUrlExpiry *int64 `json:"presigned_url_expiry,omitempty"`
}

// StagingMetadata defines model for StagingMetadata.
type StagingMetadata struct {

	// unique identifier of object content on backing store (typically ETag)
	Checksum string `json:"checksum"`

	// Object media type
	ContentType *string `json:"content_type,omitempty"`
	Force       *bool   `json:"force,omitempty"`
	SizeBytes   int64   `json:"size_bytes"`

	// location for placing an object when staging it
	Staging      StagingLocation               `json:"staging"`
	UserMetadata *StagingMetadata_UserMetadata `json:"user_metadata,omitempty"`
}

// StagingMetadata_UserMetadata defines model for StagingMetadata.UserMetadata.
type StagingMetadata_UserMetadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Statement defines model for Statement.
type Statement struct {
	Action   []string `json:"action"`
	Effect   string   `json:"effect"`
	Resource string   `json:"resource"`
}

// StatsEvent defines model for StatsEvent.
type StatsEvent struct {

	// stats event class (e.g. "s3_gateway", "openapi_request", "experimental-feature", "ui-event")
	Class string `json:"class"`

	// number of events of the class and name
	Count int `json:"count"`

	// stats event name (e.g. "put_object", "create_repository", "<experimental-feature-name>")
	Name string `json:"name"`
}

// StatsEventsList defines model for StatsEventsList.
type StatsEventsList struct {
	Events []StatsEvent `json:"events"`
}

// StorageConfig defines model for StorageConfig.
type StorageConfig struct {
	BlockstoreNamespaceValidityRegex string  `json:"blockstore_namespace_ValidityRegex"`
	BlockstoreNamespaceExample       string  `json:"blockstore_namespace_example"`
	BlockstoreType                   string  `json:"blockstore_type"`
	DefaultNamespacePrefix           *string `json:"default_namespace_prefix,omitempty"`
	ImportSupport                    bool    `json:"import_support"`
	ImportValidityRegex              string  `json:"import_validity_regex"`
	PreSignMultipartUpload           *bool   `json:"pre_sign_multipart_upload,omitempty"`
	PreSignSupport                   bool    `json:"pre_sign_support"`
	PreSignSupportUi                 bool    `json:"pre_sign_support_ui"`
}

// StorageURI defines model for StorageURI.
type StorageURI struct {
	Location string `json:"location"`
}

// StsAuthRequest defines model for StsAuthRequest.
type StsAuthRequest struct {
	Code        string `json:"code"`
	RedirectUri string `json:"redirect_uri"`
	State       string `json:"state"`

	// The time-to-live for the generated token in seconds.  The default
	// value is 3600 seconds (1 hour) maximum time allowed is 12 hours.
	TtlSeconds *int64 `json:"ttl_seconds,omitempty"`
}

// TagCreation defines model for TagCreation.
type TagCreation struct {
	Force *bool `json:"force,omitempty"`

	// ID of tag to create
	Id string `json:"id"`

	// the commit to tag
	Ref string `json:"ref"`
}

// TaskInfo defines model for TaskInfo.
type TaskInfo struct {

	// ID of the task
	Id string `json:"id"`
}

// UnderlyingObjectProperties defines model for UnderlyingObjectProperties.
type UnderlyingObjectProperties struct {
	StorageClass *string `json:"storage_class"`
}

// UploadPart defines model for UploadPart.
type UploadPart struct {
	Etag       string `json:"etag"`
	PartNumber int    `json:"part_number"`
}

// UsageReport defines model for UsageReport.
type UsageReport struct {
	Count int64 `json:"count"`
	Month int   `json:"month"`
	Year  int   `json:"year"`
}

// User defines model for User.
type User struct {

	// Unix Epoch in seconds
	CreationDate int64 `json:"creation_date"`

	// The email address of the user. If API authentication is enabled, this field is mandatory and will be invited to login.
	// If API authentication is disabled, this field will be ignored. All current APIAuthenticators require the email to be
	// lowercase and unique, although custom authenticators may not enforce this.
	Email *string `json:"email,omitempty"`

	// A shorter name for the user than the id. Unlike id it does not identify the user (it
	// might not be unique). Used in some places in the UI.
	FriendlyName *string `json:"friendly_name,omitempty"`

	// A unique identifier for the user. Cannot be edited.
	Id string `json:"id"`
}

// UserCreation defines model for UserCreation.
type UserCreation struct {

	// a unique identifier for the user.
	Id         string `json:"id"`
	InviteUser *bool  `json:"invite_user,omitempty"`
}

// UserList defines model for UserList.
type UserList struct {
	Pagination Pagination `json:"pagination"`
	Results    []User     `json:"results"`
}

// VersionConfig defines model for VersionConfig.
type VersionConfig struct {
	LatestVersion      *string `json:"latest_version,omitempty"`
	UpgradeRecommended *bool   `json:"upgrade_recommended,omitempty"`
	UpgradeUrl         *string `json:"upgrade_url,omitempty"`
	Version            *string `json:"version,omitempty"`
}

// IfNoneMatch defines model for IfNoneMatch.
type IfNoneMatch string

// PaginationAfter defines model for PaginationAfter.
type PaginationAfter string

// PaginationAmount defines model for PaginationAmount.
type PaginationAmount int

// PaginationDelimiter defines model for PaginationDelimiter.
type PaginationDelimiter string

// PaginationPrefix defines model for PaginationPrefix.
type PaginationPrefix string

// BadRequest defines model for BadRequest.
type BadRequest Error

// Conflict defines model for Conflict.
type Conflict Error

// Forbidden defines model for Forbidden.
type Forbidden Error

// NotFound defines model for NotFound.
type NotFound Error

// NotFoundOrNoACL defines model for NotFoundOrNoACL.
type NotFoundOrNoACL ErrorNoACL

// PreconditionFailed defines model for PreconditionFailed.
type PreconditionFailed Error

// ServerError defines model for ServerError.
type ServerError Error

// Unauthorized defines model for Unauthorized.
type Unauthorized Error

// ValidationError defines model for ValidationError.
type ValidationError Error

// ExternalPrincipalLoginJSONBody defines parameters for ExternalPrincipalLogin.
type ExternalPrincipalLoginJSONBody ExternalLoginInformation

// GetExternalPrincipalParams defines parameters for GetExternalPrincipal.
type GetExternalPrincipalParams struct {
	PrincipalId string `json:"principalId"`
}

// ListGroupsParams defines parameters for ListGroups.
type ListGroupsParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// CreateGroupJSONBody defines parameters for CreateGroup.
type CreateGroupJSONBody GroupCreation

// SetGroupACLJSONBody defines parameters for SetGroupACL.
type SetGroupACLJSONBody ACL

// ListGroupMembersParams defines parameters for ListGroupMembers.
type ListGroupMembersParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// ListGroupPoliciesParams defines parameters for ListGroupPolicies.
type ListGroupPoliciesParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// LoginJSONBody defines parameters for Login.
type LoginJSONBody LoginInformation

// ListPoliciesParams defines parameters for ListPolicies.
type ListPoliciesParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// CreatePolicyJSONBody defines parameters for CreatePolicy.
type CreatePolicyJSONBody Policy

// UpdatePolicyJSONBody defines parameters for UpdatePolicy.
type UpdatePolicyJSONBody Policy

// ListUsersParams defines parameters for ListUsers.
type ListUsersParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// CreateUserJSONBody defines parameters for CreateUser.
type CreateUserJSONBody UserCreation

// ListUserCredentialsParams defines parameters for ListUserCredentials.
type ListUserCredentialsParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// DeleteUserExternalPrincipalParams defines parameters for DeleteUserExternalPrincipal.
type DeleteUserExternalPrincipalParams struct {
	PrincipalId string `json:"principalId"`
}

// CreateUserExternalPrincipalJSONBody defines parameters for CreateUserExternalPrincipal.
type CreateUserExternalPrincipalJSONBody ExternalPrincipalCreation

// CreateUserExternalPrincipalParams defines parameters for CreateUserExternalPrincipal.
type CreateUserExternalPrincipalParams struct {
	PrincipalId string `json:"principalId"`
}

// ListUserExternalPrincipalsParams defines parameters for ListUserExternalPrincipals.
type ListUserExternalPrincipalsParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// ListUserGroupsParams defines parameters for ListUserGroups.
type ListUserGroupsParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// ListUserPoliciesParams defines parameters for ListUserPolicies.
type ListUserPoliciesParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`

	// will return all distinct policies attached to the user or any of its groups
	Effective *bool `json:"effective,omitempty"`
}

// ListRepositoriesParams defines parameters for ListRepositories.
type ListRepositoriesParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// CreateRepositoryJSONBody defines parameters for CreateRepository.
type CreateRepositoryJSONBody RepositoryCreation

// CreateRepositoryParams defines parameters for CreateRepository.
type CreateRepositoryParams struct {

	// If true, create a bare repository with no initial commit and branch
	Bare *bool `json:"bare,omitempty"`
}

// DeleteRepositoryParams defines parameters for DeleteRepository.
type DeleteRepositoryParams struct {

	// Bypass read-only protection and delete the repository
	Force *bool `json:"force,omitempty"`
}

// ListRepositoryRunsParams defines parameters for ListRepositoryRuns.
type ListRepositoryRunsParams struct {

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
	Branch *string           `json:"branch,omitempty"`
	Commit *string           `json:"commit,omitempty"`
}

// ListRunHooksParams defines parameters for ListRunHooks.
type ListRunHooksParams struct {

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// InternalDeleteBranchProtectionRuleJSONBody defines parameters for InternalDeleteBranchProtectionRule.
type InternalDeleteBranchProtectionRuleJSONBody struct {
	Pattern string `json:"pattern"`
}

// InternalCreateBranchProtectionRuleJSONBody defines parameters for InternalCreateBranchProtectionRule.
type InternalCreateBranchProtectionRuleJSONBody BranchProtectionRule

// ListBranchesParams defines parameters for ListBranches.
type ListBranchesParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// CreateBranchJSONBody defines parameters for CreateBranch.
type CreateBranchJSONBody BranchCreation

// DeleteBranchParams defines parameters for DeleteBranch.
type DeleteBranchParams struct {
	Force *bool `json:"force,omitempty"`
}

// ResetBranchJSONBody defines parameters for ResetBranch.
type ResetBranchJSONBody ResetCreation

// CherryPickJSONBody defines parameters for CherryPick.
type CherryPickJSONBody CherryPickCreation

// CommitJSONBody defines parameters for Commit.
type CommitJSONBody CommitCreation

// CommitParams defines parameters for Commit.
type CommitParams struct {

	// The source metarange to commit. Branch must not have uncommitted changes.
	SourceMetarange *string `json:"source_metarange,omitempty"`
}

// DiffBranchParams defines parameters for DiffBranch.
type DiffBranchParams struct {

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// delimiter used to group common prefixes by
	Delimiter *PaginationDelimiter `json:"delimiter,omitempty"`
}

// HardResetBranchParams defines parameters for HardResetBranch.
type HardResetBranchParams struct {

	// After reset, branch will point at this reference.
	Ref   string `json:"ref"`
	Force *bool  `json:"force,omitempty"`
}

// ImportCancelParams defines parameters for ImportCancel.
type ImportCancelParams struct {

	// Unique identifier of the import process
	Id string `json:"id"`
}

// ImportStatusParams defines parameters for ImportStatus.
type ImportStatusParams struct {

	// Unique identifier of the import process
	Id string `json:"id"`
}

// ImportStartJSONBody defines parameters for ImportStart.
type ImportStartJSONBody ImportCreation

// DeleteObjectParams defines parameters for DeleteObject.
type DeleteObjectParams struct {

	// relative to the branch
	Path  string `json:"path"`
	Force *bool  `json:"force,omitempty"`
}

// UploadObjectParams defines parameters for UploadObject.
type UploadObjectParams struct {

	// relative to the branch
	Path string `json:"path"`

	// Deprecated, this capability will not be supported in future releases.
	StorageClass *string `json:"storageClass,omitempty"`
	Force        *bool   `json:"force,omitempty"`

	// Set to "*" to atomically allow the upload only if the key has no object yet. Other values are not supported.
	IfNoneMatch *IfNoneMatch `json:"If-None-Match,omitempty"`
}

// StageObjectJSONBody defines parameters for StageObject.
type StageObjectJSONBody ObjectStageCreation

// StageObjectParams defines parameters for StageObject.
type StageObjectParams struct {

	// relative to the branch
	Path string `json:"path"`
}

// CopyObjectJSONBody defines parameters for CopyObject.
type CopyObjectJSONBody ObjectCopyCreation

// CopyObjectParams defines parameters for CopyObject.
type CopyObjectParams struct {

	// destination path relative to the branch
	DestPath string `json:"dest_path"`
}

// DeleteObjectsJSONBody defines parameters for DeleteObjects.
type DeleteObjectsJSONBody PathList

// DeleteObjectsParams defines parameters for DeleteObjects.
type DeleteObjectsParams struct {
	Force *bool `json:"force,omitempty"`
}

// UploadObjectPreflightParams defines parameters for UploadObjectPreflight.
type UploadObjectPreflightParams struct {

	// relative to the branch
	Path string `json:"path"`
}

// RevertBranchJSONBody defines parameters for RevertBranch.
type RevertBranchJSONBody RevertCreation

// GetPhysicalAddressParams defines parameters for GetPhysicalAddress.
type GetPhysicalAddressParams struct {

	// relative to the branch
	Path    string `json:"path"`
	Presign *bool  `json:"presign,omitempty"`
}

// LinkPhysicalAddressJSONBody defines parameters for LinkPhysicalAddress.
type LinkPhysicalAddressJSONBody StagingMetadata

// LinkPhysicalAddressParams defines parameters for LinkPhysicalAddress.
type LinkPhysicalAddressParams struct {

	// relative to the branch
	Path string `json:"path"`

	// Set to "*" to atomically allow the upload only if the key has no object yet. Other values are not supported.
	IfNoneMatch *IfNoneMatch `json:"If-None-Match,omitempty"`
}

// CreatePresignMultipartUploadParams defines parameters for CreatePresignMultipartUpload.
type CreatePresignMultipartUploadParams struct {

	// relative to the branch
	Path string `json:"path"`

	// number of presigned URL parts required to upload
	Parts *int `json:"parts,omitempty"`
}

// AbortPresignMultipartUploadJSONBody defines parameters for AbortPresignMultipartUpload.
type AbortPresignMultipartUploadJSONBody AbortPresignMultipartUpload

// AbortPresignMultipartUploadParams defines parameters for AbortPresignMultipartUpload.
type AbortPresignMultipartUploadParams struct {

	// relative to the branch
	Path string `json:"path"`
}

// CompletePresignMultipartUploadJSONBody defines parameters for CompletePresignMultipartUpload.
type CompletePresignMultipartUploadJSONBody CompletePresignMultipartUpload

// CompletePresignMultipartUploadParams defines parameters for CompletePresignMultipartUpload.
type CompletePresignMultipartUploadParams struct {

	// relative to the branch
	Path string `json:"path"`
}

// CreateCommitRecordJSONBody defines parameters for CreateCommitRecord.
type CreateCommitRecordJSONBody CommitRecordCreation

// DumpStatusParams defines parameters for DumpStatus.
type DumpStatusParams struct {
	TaskId string `json:"task_id"`
}

// PrepareGarbageCollectionUncommittedJSONBody defines parameters for PrepareGarbageCollectionUncommitted.
type PrepareGarbageCollectionUncommittedJSONBody PrepareGCUncommittedRequest

// InternalSetGarbageCollectionRulesJSONBody defines parameters for InternalSetGarbageCollectionRules.
type InternalSetGarbageCollectionRulesJSONBody GarbageCollectionRules

// DeleteRepositoryMetadataJSONBody defines parameters for DeleteRepositoryMetadata.
type DeleteRepositoryMetadataJSONBody RepositoryMetadataKeys

// SetRepositoryMetadataJSONBody defines parameters for SetRepositoryMetadata.
type SetRepositoryMetadataJSONBody RepositoryMetadataSet

// RestoreRefsJSONBody defines parameters for RestoreRefs.
type RestoreRefsJSONBody RefsRestore

// CreateSymlinkFileParams defines parameters for CreateSymlinkFile.
type CreateSymlinkFileParams struct {

	// path to the table data
	Location *string `json:"location,omitempty"`
}

// DiffRefsParams defines parameters for DiffRefs.
type DiffRefsParams struct {

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// delimiter used to group common prefixes by
	Delimiter *PaginationDelimiter `json:"delimiter,omitempty"`
	Type      *string              `json:"type,omitempty"`
}

// LogCommitsParams defines parameters for LogCommits.
type LogCommitsParams struct {

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`

	// list of paths, each element is a path of a specific object
	Objects *[]string `json:"objects,omitempty"`

	// list of paths, each element is a path of a prefix
	Prefixes *[]string `json:"prefixes,omitempty"`

	// limit the number of items in return to 'amount'. Without further indication on actual number of items.
	Limit *bool `json:"limit,omitempty"`

	// if set to true, follow only the first parent upon reaching a merge commit
	FirstParent *bool `json:"first_parent,omitempty"`

	// Show commits more recent than a specific date-time. In case used with stop_at parameter, will stop at the first commit that meets any of the conditions.
	Since *time.Time `json:"since,omitempty"`

	// A reference to stop at. In case used with since parameter, will stop at the first commit that meets any of the conditions.
	StopAt *string `json:"stop_at,omitempty"`
}

// GetObjectParams defines parameters for GetObject.
type GetObjectParams struct {

	// relative to the ref
	Path    string `json:"path"`
	Presign *bool  `json:"presign,omitempty"`

	// Byte range to retrieve
	Range *string `json:"Range,omitempty"`

	// Returns response only if the object does not have a matching ETag
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// HeadObjectParams defines parameters for HeadObject.
type HeadObjectParams struct {

	// relative to the ref
	Path string `json:"path"`

	// Byte range to retrieve
	Range *string `json:"Range,omitempty"`
}

// ListObjectsParams defines parameters for ListObjects.
type ListObjectsParams struct {
	UserMetadata *bool `json:"user_metadata,omitempty"`
	Presign      *bool `json:"presign,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`

	// delimiter used to group common prefixes by
	Delimiter *PaginationDelimiter `json:"delimiter,omitempty"`

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`
}

// StatObjectParams defines parameters for StatObject.
type StatObjectParams struct {

	// relative to the branch
	Path         string `json:"path"`
	UserMetadata *bool  `json:"user_metadata,omitempty"`
	Presign      *bool  `json:"presign,omitempty"`
}

// GetUnderlyingPropertiesParams defines parameters for GetUnderlyingProperties.
type GetUnderlyingPropertiesParams struct {

	// relative to the branch
	Path string `json:"path"`
}

// MergeIntoBranchJSONBody defines parameters for MergeIntoBranch.
type MergeIntoBranchJSONBody Merge

// RestoreStatusParams defines parameters for RestoreStatus.
type RestoreStatusParams struct {
	TaskId string `json:"task_id"`
}

// RestoreSubmitJSONBody defines parameters for RestoreSubmit.
type RestoreSubmitJSONBody RefsRestore

// SetBranchProtectionRulesJSONBody defines parameters for SetBranchProtectionRules.
type SetBranchProtectionRulesJSONBody []BranchProtectionRule

// SetBranchProtectionRulesParams defines parameters for SetBranchProtectionRules.
type SetBranchProtectionRulesParams struct {

	// if provided, the branch protection rules will be updated only if the current ETag match the provided value
	IfMatch *string `json:"If-Match,omitempty"`
}

// SetGCRulesJSONBody defines parameters for SetGCRules.
type SetGCRulesJSONBody GarbageCollectionRules

// ListTagsParams defines parameters for ListTags.
type ListTagsParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// CreateTagJSONBody defines parameters for CreateTag.
type CreateTagJSONBody TagCreation

// DeleteTagParams defines parameters for DeleteTag.
type DeleteTagParams struct {
	Force *bool `json:"force,omitempty"`
}

// SetupCommPrefsJSONBody defines parameters for SetupCommPrefs.
type SetupCommPrefsJSONBody CommPrefsInput

// SetupJSONBody defines parameters for Setup.
type SetupJSONBody Setup

// PostStatsEventsJSONBody defines parameters for PostStatsEvents.
type PostStatsEventsJSONBody StatsEventsList

// StsLoginJSONBody defines parameters for StsLogin.
type StsLoginJSONBody StsAuthRequest

// ExternalPrincipalLoginJSONRequestBody defines body for ExternalPrincipalLogin for application/json ContentType.
type ExternalPrincipalLoginJSONRequestBody ExternalPrincipalLoginJSONBody

// CreateGroupJSONRequestBody defines body for CreateGroup for application/json ContentType.
type CreateGroupJSONRequestBody CreateGroupJSONBody

// SetGroupACLJSONRequestBody defines body for SetGroupACL for application/json ContentType.
type SetGroupACLJSONRequestBody SetGroupACLJSONBody

// LoginJSONRequestBody defines body for Login for application/json ContentType.
type LoginJSONRequestBody LoginJSONBody

// CreatePolicyJSONRequestBody defines body for CreatePolicy for application/json ContentType.
type CreatePolicyJSONRequestBody CreatePolicyJSONBody

// UpdatePolicyJSONRequestBody defines body for UpdatePolicy for application/json ContentType.
type UpdatePolicyJSONRequestBody UpdatePolicyJSONBody

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody CreateUserJSONBody

// CreateUserExternalPrincipalJSONRequestBody defines body for CreateUserExternalPrincipal for application/json ContentType.
type CreateUserExternalPrincipalJSONRequestBody CreateUserExternalPrincipalJSONBody

// CreateRepositoryJSONRequestBody defines body for CreateRepository for application/json ContentType.
type CreateRepositoryJSONRequestBody CreateRepositoryJSONBody

// InternalDeleteBranchProtectionRuleJSONRequestBody defines body for InternalDeleteBranchProtectionRule for application/json ContentType.
type InternalDeleteBranchProtectionRuleJSONRequestBody InternalDeleteBranchProtectionRuleJSONBody

// InternalCreateBranchProtectionRuleJSONRequestBody defines body for InternalCreateBranchProtectionRule for application/json ContentType.
type InternalCreateBranchProtectionRuleJSONRequestBody InternalCreateBranchProtectionRuleJSONBody

// CreateBranchJSONRequestBody defines body for CreateBranch for application/json ContentType.
type CreateBranchJSONRequestBody CreateBranchJSONBody

// ResetBranchJSONRequestBody defines body for ResetBranch for application/json ContentType.
type ResetBranchJSONRequestBody ResetBranchJSONBody

// CherryPickJSONRequestBody defines body for CherryPick for application/json ContentType.
type CherryPickJSONRequestBody CherryPickJSONBody

// CommitJSONRequestBody defines body for Commit for application/json ContentType.
type CommitJSONRequestBody CommitJSONBody

// ImportStartJSONRequestBody defines body for ImportStart for application/json ContentType.
type ImportStartJSONRequestBody ImportStartJSONBody

// StageObjectJSONRequestBody defines body for StageObject for application/json ContentType.
type StageObjectJSONRequestBody StageObjectJSONBody

// CopyObjectJSONRequestBody defines body for CopyObject for application/json ContentType.
type CopyObjectJSONRequestBody CopyObjectJSONBody

// DeleteObjectsJSONRequestBody defines body for DeleteObjects for application/json ContentType.
type DeleteObjectsJSONRequestBody DeleteObjectsJSONBody

// RevertBranchJSONRequestBody defines body for RevertBranch for application/json ContentType.
type RevertBranchJSONRequestBody RevertBranchJSONBody

// LinkPhysicalAddressJSONRequestBody defines body for LinkPhysicalAddress for application/json ContentType.
type LinkPhysicalAddressJSONRequestBody LinkPhysicalAddressJSONBody

// AbortPresignMultipartUploadJSONRequestBody defines body for AbortPresignMultipartUpload for application/json ContentType.
type AbortPresignMultipartUploadJSONRequestBody AbortPresignMultipartUploadJSONBody

// CompletePresignMultipartUploadJSONRequestBody defines body for CompletePresignMultipartUpload for application/json ContentType.
type CompletePresignMultipartUploadJSONRequestBody CompletePresignMultipartUploadJSONBody

// CreateCommitRecordJSONRequestBody defines body for CreateCommitRecord for application/json ContentType.
type CreateCommitRecordJSONRequestBody CreateCommitRecordJSONBody

// PrepareGarbageCollectionUncommittedJSONRequestBody defines body for PrepareGarbageCollectionUncommitted for application/json ContentType.
type PrepareGarbageCollectionUncommittedJSONRequestBody PrepareGarbageCollectionUncommittedJSONBody

// InternalSetGarbageCollectionRulesJSONRequestBody defines body for InternalSetGarbageCollectionRules for application/json ContentType.
type InternalSetGarbageCollectionRulesJSONRequestBody InternalSetGarbageCollectionRulesJSONBody

// DeleteRepositoryMetadataJSONRequestBody defines body for DeleteRepositoryMetadata for application/json ContentType.
type DeleteRepositoryMetadataJSONRequestBody DeleteRepositoryMetadataJSONBody

// SetRepositoryMetadataJSONRequestBody defines body for SetRepositoryMetadata for application/json ContentType.
type SetRepositoryMetadataJSONRequestBody SetRepositoryMetadataJSONBody

// RestoreRefsJSONRequestBody defines body for RestoreRefs for application/json ContentType.
type RestoreRefsJSONRequestBody RestoreRefsJSONBody

// MergeIntoBranchJSONRequestBody defines body for MergeIntoBranch for application/json ContentType.
type MergeIntoBranchJSONRequestBody MergeIntoBranchJSONBody

// RestoreSubmitJSONRequestBody defines body for RestoreSubmit for application/json ContentType.
type RestoreSubmitJSONRequestBody RestoreSubmitJSONBody

// SetBranchProtectionRulesJSONRequestBody defines body for SetBranchProtectionRules for application/json ContentType.
type SetBranchProtectionRulesJSONRequestBody SetBranchProtectionRulesJSONBody

// SetGCRulesJSONRequestBody defines body for SetGCRules for application/json ContentType.
type SetGCRulesJSONRequestBody SetGCRulesJSONBody

// CreateTagJSONRequestBody defines body for CreateTag for application/json ContentType.
type CreateTagJSONRequestBody CreateTagJSONBody

// SetupCommPrefsJSONRequestBody defines body for SetupCommPrefs for application/json ContentType.
type SetupCommPrefsJSONRequestBody SetupCommPrefsJSONBody

// SetupJSONRequestBody defines body for Setup for application/json ContentType.
type SetupJSONRequestBody SetupJSONBody

// PostStatsEventsJSONRequestBody defines body for PostStatsEvents for application/json ContentType.
type PostStatsEventsJSONRequestBody PostStatsEventsJSONBody

// StsLoginJSONRequestBody defines body for StsLogin for application/json ContentType.
type StsLoginJSONRequestBody StsLoginJSONBody

// Getter for additional properties for Commit_Metadata. Returns the specified
// element and whether it was found
func (a Commit_Metadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Commit_Metadata
func (a *Commit_Metadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Commit_Metadata to handle AdditionalProperties
func (a *Commit_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Commit_Metadata to handle AdditionalProperties
func (a Commit_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CommitCreation_Metadata. Returns the specified
// element and whether it was found
func (a CommitCreation_Metadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CommitCreation_Metadata
func (a *CommitCreation_Metadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CommitCreation_Metadata to handle AdditionalProperties
func (a *CommitCreation_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CommitCreation_Metadata to handle AdditionalProperties
func (a CommitCreation_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CommitRecordCreation_Metadata. Returns the specified
// element and whether it was found
func (a CommitRecordCreation_Metadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CommitRecordCreation_Metadata
func (a *CommitRecordCreation_Metadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CommitRecordCreation_Metadata to handle AdditionalProperties
func (a *CommitRecordCreation_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CommitRecordCreation_Metadata to handle AdditionalProperties
func (a CommitRecordCreation_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CompletePresignMultipartUpload_UserMetadata. Returns the specified
// element and whether it was found
func (a CompletePresignMultipartUpload_UserMetadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CompletePresignMultipartUpload_UserMetadata
func (a *CompletePresignMultipartUpload_UserMetadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CompletePresignMultipartUpload_UserMetadata to handle AdditionalProperties
func (a *CompletePresignMultipartUpload_UserMetadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CompletePresignMultipartUpload_UserMetadata to handle AdditionalProperties
func (a CompletePresignMultipartUpload_UserMetadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ExternalPrincipalSettings. Returns the specified
// element and whether it was found
func (a ExternalPrincipalSettings) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ExternalPrincipalSettings
func (a *ExternalPrincipalSettings) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ExternalPrincipalSettings to handle AdditionalProperties
func (a *ExternalPrincipalSettings) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ExternalPrincipalSettings to handle AdditionalProperties
func (a ExternalPrincipalSettings) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Merge_Metadata. Returns the specified
// element and whether it was found
func (a Merge_Metadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Merge_Metadata
func (a *Merge_Metadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Merge_Metadata to handle AdditionalProperties
func (a *Merge_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Merge_Metadata to handle AdditionalProperties
func (a Merge_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ObjectUserMetadata. Returns the specified
// element and whether it was found
func (a ObjectUserMetadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ObjectUserMetadata
func (a *ObjectUserMetadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ObjectUserMetadata to handle AdditionalProperties
func (a *ObjectUserMetadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ObjectUserMetadata to handle AdditionalProperties
func (a ObjectUserMetadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RepositoryMetadata. Returns the specified
// element and whether it was found
func (a RepositoryMetadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RepositoryMetadata
func (a *RepositoryMetadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RepositoryMetadata to handle AdditionalProperties
func (a *RepositoryMetadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RepositoryMetadata to handle AdditionalProperties
func (a RepositoryMetadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RepositoryMetadataSet_Metadata. Returns the specified
// element and whether it was found
func (a RepositoryMetadataSet_Metadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RepositoryMetadataSet_Metadata
func (a *RepositoryMetadataSet_Metadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RepositoryMetadataSet_Metadata to handle AdditionalProperties
func (a *RepositoryMetadataSet_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RepositoryMetadataSet_Metadata to handle AdditionalProperties
func (a RepositoryMetadataSet_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for StagingMetadata_UserMetadata. Returns the specified
// element and whether it was found
func (a StagingMetadata_UserMetadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for StagingMetadata_UserMetadata
func (a *StagingMetadata_UserMetadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for StagingMetadata_UserMetadata to handle AdditionalProperties
func (a *StagingMetadata_UserMetadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for StagingMetadata_UserMetadata to handle AdditionalProperties
func (a StagingMetadata_UserMetadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = http.DefaultClient
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAuthCapabilities request
	GetAuthCapabilities(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExternalPrincipalLogin request  with any body
	ExternalPrincipalLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExternalPrincipalLogin(ctx context.Context, body ExternalPrincipalLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExternalPrincipal request
	GetExternalPrincipal(ctx context.Context, params *GetExternalPrincipalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGroups request
	ListGroups(ctx context.Context, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGroup request  with any body
	CreateGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGroup(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroup request
	DeleteGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroup request
	GetGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupACL request
	GetGroupACL(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetGroupACL request  with any body
	SetGroupACLWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetGroupACL(ctx context.Context, groupId string, body SetGroupACLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGroupMembers request
	ListGroupMembers(ctx context.Context, groupId string, params *ListGroupMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroupMembership request
	DeleteGroupMembership(ctx context.Context, groupId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddGroupMembership request
	AddGroupMembership(ctx context.Context, groupId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGroupPolicies request
	ListGroupPolicies(ctx context.Context, groupId string, params *ListGroupPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DetachPolicyFromGroup request
	DetachPolicyFromGroup(ctx context.Context, groupId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachPolicyToGroup request
	AttachPolicyToGroup(ctx context.Context, groupId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Login request  with any body
	LoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Login(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPolicies request
	ListPolicies(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePolicy request  with any body
	CreatePolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePolicy(ctx context.Context, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePolicy request
	DeletePolicy(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPolicy request
	GetPolicy(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePolicy request  with any body
	UpdatePolicyWithBody(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePolicy(ctx context.Context, policyId string, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsers request
	ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUser request  with any body
	CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserCredentials request
	ListUserCredentials(ctx context.Context, userId string, params *ListUserCredentialsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCredentials request
	CreateCredentials(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCredentials request
	DeleteCredentials(ctx context.Context, userId string, accessKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCredentials request
	GetCredentials(ctx context.Context, userId string, accessKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserExternalPrincipal request
	DeleteUserExternalPrincipal(ctx context.Context, userId string, params *DeleteUserExternalPrincipalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserExternalPrincipal request  with any body
	CreateUserExternalPrincipalWithBody(ctx context.Context, userId string, params *CreateUserExternalPrincipalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUserExternalPrincipal(ctx context.Context, userId string, params *CreateUserExternalPrincipalParams, body CreateUserExternalPrincipalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserExternalPrincipals request
	ListUserExternalPrincipals(ctx context.Context, userId string, params *ListUserExternalPrincipalsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserGroups request
	ListUserGroups(ctx context.Context, userId string, params *ListUserGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserPolicies request
	ListUserPolicies(ctx context.Context, userId string, params *ListUserPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DetachPolicyFromUser request
	DetachPolicyFromUser(ctx context.Context, userId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachPolicyToUser request
	AttachPolicyToUser(ctx context.Context, userId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfig request
	GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGarbageCollectionConfig request
	GetGarbageCollectionConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStorageConfig request
	GetStorageConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLakeFSVersion request
	GetLakeFSVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HealthCheck request
	HealthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRepositories request
	ListRepositories(ctx context.Context, params *ListRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRepository request  with any body
	CreateRepositoryWithBody(ctx context.Context, params *CreateRepositoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRepository(ctx context.Context, params *CreateRepositoryParams, body CreateRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRepository request
	DeleteRepository(ctx context.Context, repository string, params *DeleteRepositoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRepository request
	GetRepository(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRepositoryRuns request
	ListRepositoryRuns(ctx context.Context, repository string, params *ListRepositoryRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRun request
	GetRun(ctx context.Context, repository string, runId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRunHooks request
	ListRunHooks(ctx context.Context, repository string, runId string, params *ListRunHooksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRunHookOutput request
	GetRunHookOutput(ctx context.Context, repository string, runId string, hookRunId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalDeleteBranchProtectionRule request  with any body
	InternalDeleteBranchProtectionRuleWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InternalDeleteBranchProtectionRule(ctx context.Context, repository string, body InternalDeleteBranchProtectionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalGetBranchProtectionRules request
	InternalGetBranchProtectionRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalCreateBranchProtectionRule request  with any body
	InternalCreateBranchProtectionRuleWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InternalCreateBranchProtectionRule(ctx context.Context, repository string, body InternalCreateBranchProtectionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBranchProtectionRulePreflight request
	CreateBranchProtectionRulePreflight(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBranches request
	ListBranches(ctx context.Context, repository string, params *ListBranchesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBranch request  with any body
	CreateBranchWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBranch(ctx context.Context, repository string, body CreateBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBranch request
	DeleteBranch(ctx context.Context, repository string, branch string, params *DeleteBranchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBranch request
	GetBranch(ctx context.Context, repository string, branch string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetBranch request  with any body
	ResetBranchWithBody(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResetBranch(ctx context.Context, repository string, branch string, body ResetBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CherryPick request  with any body
	CherryPickWithBody(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CherryPick(ctx context.Context, repository string, branch string, body CherryPickJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Commit request  with any body
	CommitWithBody(ctx context.Context, repository string, branch string, params *CommitParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Commit(ctx context.Context, repository string, branch string, params *CommitParams, body CommitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DiffBranch request
	DiffBranch(ctx context.Context, repository string, branch string, params *DiffBranchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HardResetBranch request
	HardResetBranch(ctx context.Context, repository string, branch string, params *HardResetBranchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportCancel request
	ImportCancel(ctx context.Context, repository string, branch string, params *ImportCancelParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportStatus request
	ImportStatus(ctx context.Context, repository string, branch string, params *ImportStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportStart request  with any body
	ImportStartWithBody(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ImportStart(ctx context.Context, repository string, branch string, body ImportStartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteObject request
	DeleteObject(ctx context.Context, repository string, branch string, params *DeleteObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadObject request  with any body
	UploadObjectWithBody(ctx context.Context, repository string, branch string, params *UploadObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StageObject request  with any body
	StageObjectWithBody(ctx context.Context, repository string, branch string, params *StageObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StageObject(ctx context.Context, repository string, branch string, params *StageObjectParams, body StageObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CopyObject request  with any body
	CopyObjectWithBody(ctx context.Context, repository string, branch string, params *CopyObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CopyObject(ctx context.Context, repository string, branch string, params *CopyObjectParams, body CopyObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteObjects request  with any body
	DeleteObjectsWithBody(ctx context.Context, repository string, branch string, params *DeleteObjectsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteObjects(ctx context.Context, repository string, branch string, params *DeleteObjectsParams, body DeleteObjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadObjectPreflight request
	UploadObjectPreflight(ctx context.Context, repository string, branch string, params *UploadObjectPreflightParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevertBranch request  with any body
	RevertBranchWithBody(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevertBranch(ctx context.Context, repository string, branch string, body RevertBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPhysicalAddress request
	GetPhysicalAddress(ctx context.Context, repository string, branch string, params *GetPhysicalAddressParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkPhysicalAddress request  with any body
	LinkPhysicalAddressWithBody(ctx context.Context, repository string, branch string, params *LinkPhysicalAddressParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkPhysicalAddress(ctx context.Context, repository string, branch string, params *LinkPhysicalAddressParams, body LinkPhysicalAddressJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePresignMultipartUpload request
	CreatePresignMultipartUpload(ctx context.Context, repository string, branch string, params *CreatePresignMultipartUploadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AbortPresignMultipartUpload request  with any body
	AbortPresignMultipartUploadWithBody(ctx context.Context, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AbortPresignMultipartUpload(ctx context.Context, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, body AbortPresignMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CompletePresignMultipartUpload request  with any body
	CompletePresignMultipartUploadWithBody(ctx context.Context, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CompletePresignMultipartUpload(ctx context.Context, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, body CompletePresignMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCommitRecord request  with any body
	CreateCommitRecordWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCommitRecord(ctx context.Context, repository string, body CreateCommitRecordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCommit request
	GetCommit(ctx context.Context, repository string, commitId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DumpStatus request
	DumpStatus(ctx context.Context, repository string, params *DumpStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DumpSubmit request
	DumpSubmit(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PrepareGarbageCollectionCommits request
	PrepareGarbageCollectionCommits(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PrepareGarbageCollectionUncommitted request  with any body
	PrepareGarbageCollectionUncommittedWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PrepareGarbageCollectionUncommitted(ctx context.Context, repository string, body PrepareGarbageCollectionUncommittedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalDeleteGarbageCollectionRules request
	InternalDeleteGarbageCollectionRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalGetGarbageCollectionRules request
	InternalGetGarbageCollectionRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalSetGarbageCollectionRules request  with any body
	InternalSetGarbageCollectionRulesWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InternalSetGarbageCollectionRules(ctx context.Context, repository string, body InternalSetGarbageCollectionRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetGarbageCollectionRulesPreflight request
	SetGarbageCollectionRulesPreflight(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRepositoryMetadata request  with any body
	DeleteRepositoryMetadataWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteRepositoryMetadata(ctx context.Context, repository string, body DeleteRepositoryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRepositoryMetadata request
	GetRepositoryMetadata(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetRepositoryMetadata request  with any body
	SetRepositoryMetadataWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetRepositoryMetadata(ctx context.Context, repository string, body SetRepositoryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMetaRange request
	GetMetaRange(ctx context.Context, repository string, metaRange string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRange request
	GetRange(ctx context.Context, repository string, pRange string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DumpRefs request
	DumpRefs(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestoreRefs request  with any body
	RestoreRefsWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RestoreRefs(ctx context.Context, repository string, body RestoreRefsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSymlinkFile request
	CreateSymlinkFile(ctx context.Context, repository string, branch string, params *CreateSymlinkFileParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DiffRefs request
	DiffRefs(ctx context.Context, repository string, leftRef string, rightRef string, params *DiffRefsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LogCommits request
	LogCommits(ctx context.Context, repository string, ref string, params *LogCommitsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetObject request
	GetObject(ctx context.Context, repository string, ref string, params *GetObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HeadObject request
	HeadObject(ctx context.Context, repository string, ref string, params *HeadObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListObjects request
	ListObjects(ctx context.Context, repository string, ref string, params *ListObjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StatObject request
	StatObject(ctx context.Context, repository string, ref string, params *StatObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUnderlyingProperties request
	GetUnderlyingProperties(ctx context.Context, repository string, ref string, params *GetUnderlyingPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindMergeBase request
	FindMergeBase(ctx context.Context, repository string, sourceRef string, destinationBranch string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MergeIntoBranch request  with any body
	MergeIntoBranchWithBody(ctx context.Context, repository string, sourceRef string, destinationBranch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MergeIntoBranch(ctx context.Context, repository string, sourceRef string, destinationBranch string, body MergeIntoBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestoreStatus request
	RestoreStatus(ctx context.Context, repository string, params *RestoreStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestoreSubmit request  with any body
	RestoreSubmitWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RestoreSubmit(ctx context.Context, repository string, body RestoreSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBranchProtectionRules request
	GetBranchProtectionRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetBranchProtectionRules request  with any body
	SetBranchProtectionRulesWithBody(ctx context.Context, repository string, params *SetBranchProtectionRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetBranchProtectionRules(ctx context.Context, repository string, params *SetBranchProtectionRulesParams, body SetBranchProtectionRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGCRules request
	DeleteGCRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGCRules request
	GetGCRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetGCRules request  with any body
	SetGCRulesWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetGCRules(ctx context.Context, repository string, body SetGCRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTags request
	ListTags(ctx context.Context, repository string, params *ListTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTag request  with any body
	CreateTagWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTag(ctx context.Context, repository string, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTag request
	DeleteTag(ctx context.Context, repository string, tag string, params *DeleteTagParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTag request
	GetTag(ctx context.Context, repository string, tag string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetupCommPrefs request  with any body
	SetupCommPrefsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetupCommPrefs(ctx context.Context, body SetupCommPrefsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSetupState request
	GetSetupState(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Setup request  with any body
	SetupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Setup(ctx context.Context, body SetupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostStatsEvents request  with any body
	PostStatsEventsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostStatsEvents(ctx context.Context, body PostStatsEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StsLogin request  with any body
	StsLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StsLogin(ctx context.Context, body StsLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsageReportSummary request
	GetUsageReportSummary(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentUser request
	GetCurrentUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAuthCapabilities(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthCapabilitiesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExternalPrincipalLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExternalPrincipalLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExternalPrincipalLogin(ctx context.Context, body ExternalPrincipalLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExternalPrincipalLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExternalPrincipal(ctx context.Context, params *GetExternalPrincipalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExternalPrincipalRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGroups(ctx context.Context, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroup(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupACL(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupACLRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetGroupACLWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetGroupACLRequestWithBody(c.Server, groupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetGroupACL(ctx context.Context, groupId string, body SetGroupACLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetGroupACLRequest(c.Server, groupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGroupMembers(ctx context.Context, groupId string, params *ListGroupMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGroupMembersRequest(c.Server, groupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroupMembership(ctx context.Context, groupId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupMembershipRequest(c.Server, groupId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddGroupMembership(ctx context.Context, groupId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddGroupMembershipRequest(c.Server, groupId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGroupPolicies(ctx context.Context, groupId string, params *ListGroupPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGroupPoliciesRequest(c.Server, groupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DetachPolicyFromGroup(ctx context.Context, groupId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDetachPolicyFromGroupRequest(c.Server, groupId, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachPolicyToGroup(ctx context.Context, groupId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachPolicyToGroupRequest(c.Server, groupId, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Login(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPolicies(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePolicyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePolicy(ctx context.Context, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePolicyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePolicy(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePolicyRequest(c.Server, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPolicy(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPolicyRequest(c.Server, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePolicyWithBody(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePolicyRequestWithBody(c.Server, policyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePolicy(ctx context.Context, policyId string, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePolicyRequest(c.Server, policyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserCredentials(ctx context.Context, userId string, params *ListUserCredentialsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserCredentialsRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCredentials(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCredentialsRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCredentials(ctx context.Context, userId string, accessKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCredentialsRequest(c.Server, userId, accessKeyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCredentials(ctx context.Context, userId string, accessKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCredentialsRequest(c.Server, userId, accessKeyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserExternalPrincipal(ctx context.Context, userId string, params *DeleteUserExternalPrincipalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserExternalPrincipalRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserExternalPrincipalWithBody(ctx context.Context, userId string, params *CreateUserExternalPrincipalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserExternalPrincipalRequestWithBody(c.Server, userId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserExternalPrincipal(ctx context.Context, userId string, params *CreateUserExternalPrincipalParams, body CreateUserExternalPrincipalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserExternalPrincipalRequest(c.Server, userId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserExternalPrincipals(ctx context.Context, userId string, params *ListUserExternalPrincipalsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserExternalPrincipalsRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserGroups(ctx context.Context, userId string, params *ListUserGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserGroupsRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserPolicies(ctx context.Context, userId string, params *ListUserPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserPoliciesRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DetachPolicyFromUser(ctx context.Context, userId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDetachPolicyFromUserRequest(c.Server, userId, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachPolicyToUser(ctx context.Context, userId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachPolicyToUserRequest(c.Server, userId, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGarbageCollectionConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGarbageCollectionConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStorageConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStorageConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLakeFSVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLakeFSVersionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HealthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthCheckRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRepositories(ctx context.Context, params *ListRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRepositoriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRepositoryWithBody(ctx context.Context, params *CreateRepositoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRepositoryRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRepository(ctx context.Context, params *CreateRepositoryParams, body CreateRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRepositoryRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRepository(ctx context.Context, repository string, params *DeleteRepositoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRepositoryRequest(c.Server, repository, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRepository(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRepositoryRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRepositoryRuns(ctx context.Context, repository string, params *ListRepositoryRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRepositoryRunsRequest(c.Server, repository, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRun(ctx context.Context, repository string, runId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRunRequest(c.Server, repository, runId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRunHooks(ctx context.Context, repository string, runId string, params *ListRunHooksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRunHooksRequest(c.Server, repository, runId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRunHookOutput(ctx context.Context, repository string, runId string, hookRunId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRunHookOutputRequest(c.Server, repository, runId, hookRunId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalDeleteBranchProtectionRuleWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalDeleteBranchProtectionRuleRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalDeleteBranchProtectionRule(ctx context.Context, repository string, body InternalDeleteBranchProtectionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalDeleteBranchProtectionRuleRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalGetBranchProtectionRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalGetBranchProtectionRulesRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalCreateBranchProtectionRuleWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalCreateBranchProtectionRuleRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalCreateBranchProtectionRule(ctx context.Context, repository string, body InternalCreateBranchProtectionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalCreateBranchProtectionRuleRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBranchProtectionRulePreflight(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBranchProtectionRulePreflightRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBranches(ctx context.Context, repository string, params *ListBranchesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBranchesRequest(c.Server, repository, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBranchWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBranchRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBranch(ctx context.Context, repository string, body CreateBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBranchRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBranch(ctx context.Context, repository string, branch string, params *DeleteBranchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBranchRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBranch(ctx context.Context, repository string, branch string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBranchRequest(c.Server, repository, branch)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetBranchWithBody(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetBranchRequestWithBody(c.Server, repository, branch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetBranch(ctx context.Context, repository string, branch string, body ResetBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetBranchRequest(c.Server, repository, branch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CherryPickWithBody(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCherryPickRequestWithBody(c.Server, repository, branch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CherryPick(ctx context.Context, repository string, branch string, body CherryPickJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCherryPickRequest(c.Server, repository, branch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitWithBody(ctx context.Context, repository string, branch string, params *CommitParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitRequestWithBody(c.Server, repository, branch, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Commit(ctx context.Context, repository string, branch string, params *CommitParams, body CommitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitRequest(c.Server, repository, branch, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DiffBranch(ctx context.Context, repository string, branch string, params *DiffBranchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDiffBranchRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HardResetBranch(ctx context.Context, repository string, branch string, params *HardResetBranchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHardResetBranchRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportCancel(ctx context.Context, repository string, branch string, params *ImportCancelParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportCancelRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportStatus(ctx context.Context, repository string, branch string, params *ImportStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportStatusRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportStartWithBody(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportStartRequestWithBody(c.Server, repository, branch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportStart(ctx context.Context, repository string, branch string, body ImportStartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportStartRequest(c.Server, repository, branch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteObject(ctx context.Context, repository string, branch string, params *DeleteObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteObjectRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadObjectWithBody(ctx context.Context, repository string, branch string, params *UploadObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadObjectRequestWithBody(c.Server, repository, branch, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StageObjectWithBody(ctx context.Context, repository string, branch string, params *StageObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStageObjectRequestWithBody(c.Server, repository, branch, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StageObject(ctx context.Context, repository string, branch string, params *StageObjectParams, body StageObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStageObjectRequest(c.Server, repository, branch, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CopyObjectWithBody(ctx context.Context, repository string, branch string, params *CopyObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCopyObjectRequestWithBody(c.Server, repository, branch, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CopyObject(ctx context.Context, repository string, branch string, params *CopyObjectParams, body CopyObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCopyObjectRequest(c.Server, repository, branch, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteObjectsWithBody(ctx context.Context, repository string, branch string, params *DeleteObjectsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteObjectsRequestWithBody(c.Server, repository, branch, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteObjects(ctx context.Context, repository string, branch string, params *DeleteObjectsParams, body DeleteObjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteObjectsRequest(c.Server, repository, branch, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadObjectPreflight(ctx context.Context, repository string, branch string, params *UploadObjectPreflightParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadObjectPreflightRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevertBranchWithBody(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevertBranchRequestWithBody(c.Server, repository, branch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevertBranch(ctx context.Context, repository string, branch string, body RevertBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevertBranchRequest(c.Server, repository, branch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPhysicalAddress(ctx context.Context, repository string, branch string, params *GetPhysicalAddressParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPhysicalAddressRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkPhysicalAddressWithBody(ctx context.Context, repository string, branch string, params *LinkPhysicalAddressParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkPhysicalAddressRequestWithBody(c.Server, repository, branch, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkPhysicalAddress(ctx context.Context, repository string, branch string, params *LinkPhysicalAddressParams, body LinkPhysicalAddressJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkPhysicalAddressRequest(c.Server, repository, branch, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePresignMultipartUpload(ctx context.Context, repository string, branch string, params *CreatePresignMultipartUploadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePresignMultipartUploadRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AbortPresignMultipartUploadWithBody(ctx context.Context, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAbortPresignMultipartUploadRequestWithBody(c.Server, repository, branch, uploadId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AbortPresignMultipartUpload(ctx context.Context, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, body AbortPresignMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAbortPresignMultipartUploadRequest(c.Server, repository, branch, uploadId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompletePresignMultipartUploadWithBody(ctx context.Context, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompletePresignMultipartUploadRequestWithBody(c.Server, repository, branch, uploadId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompletePresignMultipartUpload(ctx context.Context, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, body CompletePresignMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompletePresignMultipartUploadRequest(c.Server, repository, branch, uploadId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCommitRecordWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCommitRecordRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCommitRecord(ctx context.Context, repository string, body CreateCommitRecordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCommitRecordRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCommit(ctx context.Context, repository string, commitId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCommitRequest(c.Server, repository, commitId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DumpStatus(ctx context.Context, repository string, params *DumpStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDumpStatusRequest(c.Server, repository, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DumpSubmit(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDumpSubmitRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrepareGarbageCollectionCommits(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareGarbageCollectionCommitsRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrepareGarbageCollectionUncommittedWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareGarbageCollectionUncommittedRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrepareGarbageCollectionUncommitted(ctx context.Context, repository string, body PrepareGarbageCollectionUncommittedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareGarbageCollectionUncommittedRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalDeleteGarbageCollectionRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalDeleteGarbageCollectionRulesRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalGetGarbageCollectionRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalGetGarbageCollectionRulesRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalSetGarbageCollectionRulesWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalSetGarbageCollectionRulesRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalSetGarbageCollectionRules(ctx context.Context, repository string, body InternalSetGarbageCollectionRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalSetGarbageCollectionRulesRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetGarbageCollectionRulesPreflight(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetGarbageCollectionRulesPreflightRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRepositoryMetadataWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRepositoryMetadataRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRepositoryMetadata(ctx context.Context, repository string, body DeleteRepositoryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRepositoryMetadataRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRepositoryMetadata(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRepositoryMetadataRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRepositoryMetadataWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRepositoryMetadataRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRepositoryMetadata(ctx context.Context, repository string, body SetRepositoryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRepositoryMetadataRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMetaRange(ctx context.Context, repository string, metaRange string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMetaRangeRequest(c.Server, repository, metaRange)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRange(ctx context.Context, repository string, pRange string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRangeRequest(c.Server, repository, pRange)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DumpRefs(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDumpRefsRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreRefsWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreRefsRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreRefs(ctx context.Context, repository string, body RestoreRefsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreRefsRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSymlinkFile(ctx context.Context, repository string, branch string, params *CreateSymlinkFileParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSymlinkFileRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DiffRefs(ctx context.Context, repository string, leftRef string, rightRef string, params *DiffRefsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDiffRefsRequest(c.Server, repository, leftRef, rightRef, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogCommits(ctx context.Context, repository string, ref string, params *LogCommitsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogCommitsRequest(c.Server, repository, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetObject(ctx context.Context, repository string, ref string, params *GetObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetObjectRequest(c.Server, repository, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeadObject(ctx context.Context, repository string, ref string, params *HeadObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeadObjectRequest(c.Server, repository, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListObjects(ctx context.Context, repository string, ref string, params *ListObjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListObjectsRequest(c.Server, repository, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StatObject(ctx context.Context, repository string, ref string, params *StatObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatObjectRequest(c.Server, repository, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUnderlyingProperties(ctx context.Context, repository string, ref string, params *GetUnderlyingPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUnderlyingPropertiesRequest(c.Server, repository, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindMergeBase(ctx context.Context, repository string, sourceRef string, destinationBranch string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindMergeBaseRequest(c.Server, repository, sourceRef, destinationBranch)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeIntoBranchWithBody(ctx context.Context, repository string, sourceRef string, destinationBranch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeIntoBranchRequestWithBody(c.Server, repository, sourceRef, destinationBranch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeIntoBranch(ctx context.Context, repository string, sourceRef string, destinationBranch string, body MergeIntoBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeIntoBranchRequest(c.Server, repository, sourceRef, destinationBranch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreStatus(ctx context.Context, repository string, params *RestoreStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreStatusRequest(c.Server, repository, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreSubmitWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreSubmitRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreSubmit(ctx context.Context, repository string, body RestoreSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreSubmitRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBranchProtectionRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBranchProtectionRulesRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetBranchProtectionRulesWithBody(ctx context.Context, repository string, params *SetBranchProtectionRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetBranchProtectionRulesRequestWithBody(c.Server, repository, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetBranchProtectionRules(ctx context.Context, repository string, params *SetBranchProtectionRulesParams, body SetBranchProtectionRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetBranchProtectionRulesRequest(c.Server, repository, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGCRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGCRulesRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGCRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGCRulesRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetGCRulesWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetGCRulesRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetGCRules(ctx context.Context, repository string, body SetGCRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetGCRulesRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTags(ctx context.Context, repository string, params *ListTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTagsRequest(c.Server, repository, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTagWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTagRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTag(ctx context.Context, repository string, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTagRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTag(ctx context.Context, repository string, tag string, params *DeleteTagParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTagRequest(c.Server, repository, tag, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTag(ctx context.Context, repository string, tag string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTagRequest(c.Server, repository, tag)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetupCommPrefsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetupCommPrefsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetupCommPrefs(ctx context.Context, body SetupCommPrefsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetupCommPrefsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSetupState(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSetupStateRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Setup(ctx context.Context, body SetupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStatsEventsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStatsEventsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStatsEvents(ctx context.Context, body PostStatsEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStatsEventsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StsLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStsLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StsLogin(ctx context.Context, body StsLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStsLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsageReportSummary(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsageReportSummaryRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAuthCapabilitiesRequest generates requests for GetAuthCapabilities
func NewGetAuthCapabilitiesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/capabilities")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExternalPrincipalLoginRequest calls the generic ExternalPrincipalLogin builder with application/json body
func NewExternalPrincipalLoginRequest(server string, body ExternalPrincipalLoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExternalPrincipalLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewExternalPrincipalLoginRequestWithBody generates requests for ExternalPrincipalLogin with any type of body
func NewExternalPrincipalLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/external/principal/login")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetExternalPrincipalRequest generates requests for GetExternalPrincipal
func NewGetExternalPrincipalRequest(server string, params *GetExternalPrincipalParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/external/principals")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "principalId", runtime.ParamLocationQuery, params.PrincipalId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListGroupsRequest generates requests for ListGroups
func NewListGroupsRequest(server string, params *ListGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateGroupRequest calls the generic CreateGroup builder with application/json body
func NewCreateGroupRequest(server string, body CreateGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGroupRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateGroupRequestWithBody generates requests for CreateGroup with any type of body
func NewCreateGroupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGroupRequest generates requests for DeleteGroup
func NewDeleteGroupRequest(server string, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupRequest generates requests for GetGroup
func NewGetGroupRequest(server string, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupACLRequest generates requests for GetGroupACL
func NewGetGroupACLRequest(server string, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s/acl", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetGroupACLRequest calls the generic SetGroupACL builder with application/json body
func NewSetGroupACLRequest(server string, groupId string, body SetGroupACLJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetGroupACLRequestWithBody(server, groupId, "application/json", bodyReader)
}

// NewSetGroupACLRequestWithBody generates requests for SetGroupACL with any type of body
func NewSetGroupACLRequestWithBody(server string, groupId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s/acl", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListGroupMembersRequest generates requests for ListGroupMembers
func NewListGroupMembersRequest(server string, groupId string, params *ListGroupMembersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteGroupMembershipRequest generates requests for DeleteGroupMembership
func NewDeleteGroupMembershipRequest(server string, groupId string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddGroupMembershipRequest generates requests for AddGroupMembership
func NewAddGroupMembershipRequest(server string, groupId string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListGroupPoliciesRequest generates requests for ListGroupPolicies
func NewListGroupPoliciesRequest(server string, groupId string, params *ListGroupPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s/policies", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDetachPolicyFromGroupRequest generates requests for DetachPolicyFromGroup
func NewDetachPolicyFromGroupRequest(server string, groupId string, policyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s/policies/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachPolicyToGroupRequest generates requests for AttachPolicyToGroup
func NewAttachPolicyToGroupRequest(server string, groupId string, policyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s/policies/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoginRequest calls the generic Login builder with application/json body
func NewLoginRequest(server string, body LoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewLoginRequestWithBody generates requests for Login with any type of body
func NewLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/login")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPoliciesRequest generates requests for ListPolicies
func NewListPoliciesRequest(server string, params *ListPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/policies")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePolicyRequest calls the generic CreatePolicy builder with application/json body
func NewCreatePolicyRequest(server string, body CreatePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePolicyRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePolicyRequestWithBody generates requests for CreatePolicy with any type of body
func NewCreatePolicyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/policies")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePolicyRequest generates requests for DeletePolicy
func NewDeletePolicyRequest(server string, policyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPolicyRequest generates requests for GetPolicy
func NewGetPolicyRequest(server string, policyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePolicyRequest calls the generic UpdatePolicy builder with application/json body
func NewUpdatePolicyRequest(server string, policyId string, body UpdatePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePolicyRequestWithBody(server, policyId, "application/json", bodyReader)
}

// NewUpdatePolicyRequestWithBody generates requests for UpdatePolicy with any type of body
func NewUpdatePolicyRequestWithBody(server string, policyId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListUsersRequest generates requests for ListUsers
func NewListUsersRequest(server string, params *ListUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserRequest calls the generic CreateUser builder with application/json body
func NewCreateUserRequest(server string, body CreateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateUserRequestWithBody generates requests for CreateUser with any type of body
func NewCreateUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUserCredentialsRequest generates requests for ListUserCredentials
func NewListUserCredentialsRequest(server string, userId string, params *ListUserCredentialsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/credentials", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCredentialsRequest generates requests for CreateCredentials
func NewCreateCredentialsRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/credentials", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteCredentialsRequest generates requests for DeleteCredentials
func NewDeleteCredentialsRequest(server string, userId string, accessKeyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "accessKeyId", runtime.ParamLocationPath, accessKeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/credentials/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCredentialsRequest generates requests for GetCredentials
func NewGetCredentialsRequest(server string, userId string, accessKeyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "accessKeyId", runtime.ParamLocationPath, accessKeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/credentials/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteUserExternalPrincipalRequest generates requests for DeleteUserExternalPrincipal
func NewDeleteUserExternalPrincipalRequest(server string, userId string, params *DeleteUserExternalPrincipalParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/external/principals", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "principalId", runtime.ParamLocationQuery, params.PrincipalId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserExternalPrincipalRequest calls the generic CreateUserExternalPrincipal builder with application/json body
func NewCreateUserExternalPrincipalRequest(server string, userId string, params *CreateUserExternalPrincipalParams, body CreateUserExternalPrincipalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserExternalPrincipalRequestWithBody(server, userId, params, "application/json", bodyReader)
}

// NewCreateUserExternalPrincipalRequestWithBody generates requests for CreateUserExternalPrincipal with any type of body
func NewCreateUserExternalPrincipalRequestWithBody(server string, userId string, params *CreateUserExternalPrincipalParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/external/principals", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "principalId", runtime.ParamLocationQuery, params.PrincipalId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListUserExternalPrincipalsRequest generates requests for ListUserExternalPrincipals
func NewListUserExternalPrincipalsRequest(server string, userId string, params *ListUserExternalPrincipalsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/external/principals/ls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUserGroupsRequest generates requests for ListUserGroups
func NewListUserGroupsRequest(server string, userId string, params *ListUserGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUserPoliciesRequest generates requests for ListUserPolicies
func NewListUserPoliciesRequest(server string, userId string, params *ListUserPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/policies", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Effective != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective", runtime.ParamLocationQuery, *params.Effective); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDetachPolicyFromUserRequest generates requests for DetachPolicyFromUser
func NewDetachPolicyFromUserRequest(server string, userId string, policyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/policies/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachPolicyToUserRequest generates requests for AttachPolicyToUser
func NewAttachPolicyToUserRequest(server string, userId string, policyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/policies/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigRequest generates requests for GetConfig
func NewGetConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/config")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGarbageCollectionConfigRequest generates requests for GetGarbageCollectionConfig
func NewGetGarbageCollectionConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/config/garbage-collection")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStorageConfigRequest generates requests for GetStorageConfig
func NewGetStorageConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/config/storage")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLakeFSVersionRequest generates requests for GetLakeFSVersion
func NewGetLakeFSVersionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/config/version")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHealthCheckRequest generates requests for HealthCheck
func NewHealthCheckRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/healthcheck")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRepositoriesRequest generates requests for ListRepositories
func NewListRepositoriesRequest(server string, params *ListRepositoriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRepositoryRequest calls the generic CreateRepository builder with application/json body
func NewCreateRepositoryRequest(server string, params *CreateRepositoryParams, body CreateRepositoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRepositoryRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateRepositoryRequestWithBody generates requests for CreateRepository with any type of body
func NewCreateRepositoryRequestWithBody(server string, params *CreateRepositoryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Bare != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bare", runtime.ParamLocationQuery, *params.Bare); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRepositoryRequest generates requests for DeleteRepository
func NewDeleteRepositoryRequest(server string, repository string, params *DeleteRepositoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRepositoryRequest generates requests for GetRepository
func NewGetRepositoryRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRepositoryRunsRequest generates requests for ListRepositoryRuns
func NewListRepositoryRunsRequest(server string, repository string, params *ListRepositoryRunsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/actions/runs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Branch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "branch", runtime.ParamLocationQuery, *params.Branch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Commit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "commit", runtime.ParamLocationQuery, *params.Commit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRunRequest generates requests for GetRun
func NewGetRunRequest(server string, repository string, runId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/actions/runs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRunHooksRequest generates requests for ListRunHooks
func NewListRunHooksRequest(server string, repository string, runId string, params *ListRunHooksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/actions/runs/%s/hooks", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRunHookOutputRequest generates requests for GetRunHookOutput
func NewGetRunHookOutputRequest(server string, repository string, runId string, hookRunId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "hook_run_id", runtime.ParamLocationPath, hookRunId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/actions/runs/%s/hooks/%s/output", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalDeleteBranchProtectionRuleRequest calls the generic InternalDeleteBranchProtectionRule builder with application/json body
func NewInternalDeleteBranchProtectionRuleRequest(server string, repository string, body InternalDeleteBranchProtectionRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInternalDeleteBranchProtectionRuleRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewInternalDeleteBranchProtectionRuleRequestWithBody generates requests for InternalDeleteBranchProtectionRule with any type of body
func NewInternalDeleteBranchProtectionRuleRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branch_protection", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInternalGetBranchProtectionRulesRequest generates requests for InternalGetBranchProtectionRules
func NewInternalGetBranchProtectionRulesRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branch_protection", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalCreateBranchProtectionRuleRequest calls the generic InternalCreateBranchProtectionRule builder with application/json body
func NewInternalCreateBranchProtectionRuleRequest(server string, repository string, body InternalCreateBranchProtectionRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInternalCreateBranchProtectionRuleRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewInternalCreateBranchProtectionRuleRequestWithBody generates requests for InternalCreateBranchProtectionRule with any type of body
func NewInternalCreateBranchProtectionRuleRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branch_protection", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateBranchProtectionRulePreflightRequest generates requests for CreateBranchProtectionRulePreflight
func NewCreateBranchProtectionRulePreflightRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branch_protection/set_allowed", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBranchesRequest generates requests for ListBranches
func NewListBranchesRequest(server string, repository string, params *ListBranchesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBranchRequest calls the generic CreateBranch builder with application/json body
func NewCreateBranchRequest(server string, repository string, body CreateBranchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBranchRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewCreateBranchRequestWithBody generates requests for CreateBranch with any type of body
func NewCreateBranchRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBranchRequest generates requests for DeleteBranch
func NewDeleteBranchRequest(server string, repository string, branch string, params *DeleteBranchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBranchRequest generates requests for GetBranch
func NewGetBranchRequest(server string, repository string, branch string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResetBranchRequest calls the generic ResetBranch builder with application/json body
func NewResetBranchRequest(server string, repository string, branch string, body ResetBranchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResetBranchRequestWithBody(server, repository, branch, "application/json", bodyReader)
}

// NewResetBranchRequestWithBody generates requests for ResetBranch with any type of body
func NewResetBranchRequestWithBody(server string, repository string, branch string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCherryPickRequest calls the generic CherryPick builder with application/json body
func NewCherryPickRequest(server string, repository string, branch string, body CherryPickJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCherryPickRequestWithBody(server, repository, branch, "application/json", bodyReader)
}

// NewCherryPickRequestWithBody generates requests for CherryPick with any type of body
func NewCherryPickRequestWithBody(server string, repository string, branch string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/cherry-pick", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCommitRequest calls the generic Commit builder with application/json body
func NewCommitRequest(server string, repository string, branch string, params *CommitParams, body CommitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCommitRequestWithBody(server, repository, branch, params, "application/json", bodyReader)
}

// NewCommitRequestWithBody generates requests for Commit with any type of body
func NewCommitRequestWithBody(server string, repository string, branch string, params *CommitParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/commits", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.SourceMetarange != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "source_metarange", runtime.ParamLocationQuery, *params.SourceMetarange); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDiffBranchRequest generates requests for DiffBranch
func NewDiffBranchRequest(server string, repository string, branch string, params *DiffBranchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/diff", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Delimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delimiter", runtime.ParamLocationQuery, *params.Delimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHardResetBranchRequest generates requests for HardResetBranch
func NewHardResetBranchRequest(server string, repository string, branch string, params *HardResetBranchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/hard_reset", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ref", runtime.ParamLocationQuery, params.Ref); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewImportCancelRequest generates requests for ImportCancel
func NewImportCancelRequest(server string, repository string, branch string, params *ImportCancelParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/import", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewImportStatusRequest generates requests for ImportStatus
func NewImportStatusRequest(server string, repository string, branch string, params *ImportStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/import", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewImportStartRequest calls the generic ImportStart builder with application/json body
func NewImportStartRequest(server string, repository string, branch string, body ImportStartJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewImportStartRequestWithBody(server, repository, branch, "application/json", bodyReader)
}

// NewImportStartRequestWithBody generates requests for ImportStart with any type of body
func NewImportStartRequestWithBody(server string, repository string, branch string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/import", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteObjectRequest generates requests for DeleteObject
func NewDeleteObjectRequest(server string, repository string, branch string, params *DeleteObjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/objects", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadObjectRequestWithBody generates requests for UploadObject with any type of body
func NewUploadObjectRequestWithBody(server string, repository string, branch string, params *UploadObjectParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/objects", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.StorageClass != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storageClass", runtime.ParamLocationQuery, *params.StorageClass); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.IfNoneMatch != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, *params.IfNoneMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-None-Match", headerParam0)
	}

	return req, nil
}

// NewStageObjectRequest calls the generic StageObject builder with application/json body
func NewStageObjectRequest(server string, repository string, branch string, params *StageObjectParams, body StageObjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStageObjectRequestWithBody(server, repository, branch, params, "application/json", bodyReader)
}

// NewStageObjectRequestWithBody generates requests for StageObject with any type of body
func NewStageObjectRequestWithBody(server string, repository string, branch string, params *StageObjectParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/objects", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCopyObjectRequest calls the generic CopyObject builder with application/json body
func NewCopyObjectRequest(server string, repository string, branch string, params *CopyObjectParams, body CopyObjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCopyObjectRequestWithBody(server, repository, branch, params, "application/json", bodyReader)
}

// NewCopyObjectRequestWithBody generates requests for CopyObject with any type of body
func NewCopyObjectRequestWithBody(server string, repository string, branch string, params *CopyObjectParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/objects/copy", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dest_path", runtime.ParamLocationQuery, params.DestPath); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteObjectsRequest calls the generic DeleteObjects builder with application/json body
func NewDeleteObjectsRequest(server string, repository string, branch string, params *DeleteObjectsParams, body DeleteObjectsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteObjectsRequestWithBody(server, repository, branch, params, "application/json", bodyReader)
}

// NewDeleteObjectsRequestWithBody generates requests for DeleteObjects with any type of body
func NewDeleteObjectsRequestWithBody(server string, repository string, branch string, params *DeleteObjectsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/objects/delete", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUploadObjectPreflightRequest generates requests for UploadObjectPreflight
func NewUploadObjectPreflightRequest(server string, repository string, branch string, params *UploadObjectPreflightParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/objects/stage_allowed", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevertBranchRequest calls the generic RevertBranch builder with application/json body
func NewRevertBranchRequest(server string, repository string, branch string, body RevertBranchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevertBranchRequestWithBody(server, repository, branch, "application/json", bodyReader)
}

// NewRevertBranchRequestWithBody generates requests for RevertBranch with any type of body
func NewRevertBranchRequestWithBody(server string, repository string, branch string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/revert", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPhysicalAddressRequest generates requests for GetPhysicalAddress
func NewGetPhysicalAddressRequest(server string, repository string, branch string, params *GetPhysicalAddressParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/staging/backing", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Presign != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "presign", runtime.ParamLocationQuery, *params.Presign); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLinkPhysicalAddressRequest calls the generic LinkPhysicalAddress builder with application/json body
func NewLinkPhysicalAddressRequest(server string, repository string, branch string, params *LinkPhysicalAddressParams, body LinkPhysicalAddressJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkPhysicalAddressRequestWithBody(server, repository, branch, params, "application/json", bodyReader)
}

// NewLinkPhysicalAddressRequestWithBody generates requests for LinkPhysicalAddress with any type of body
func NewLinkPhysicalAddressRequestWithBody(server string, repository string, branch string, params *LinkPhysicalAddressParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/staging/backing", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.IfNoneMatch != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, *params.IfNoneMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-None-Match", headerParam0)
	}

	return req, nil
}

// NewCreatePresignMultipartUploadRequest generates requests for CreatePresignMultipartUpload
func NewCreatePresignMultipartUploadRequest(server string, repository string, branch string, params *CreatePresignMultipartUploadParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/staging/pmpu", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Parts != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parts", runtime.ParamLocationQuery, *params.Parts); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAbortPresignMultipartUploadRequest calls the generic AbortPresignMultipartUpload builder with application/json body
func NewAbortPresignMultipartUploadRequest(server string, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, body AbortPresignMultipartUploadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAbortPresignMultipartUploadRequestWithBody(server, repository, branch, uploadId, params, "application/json", bodyReader)
}

// NewAbortPresignMultipartUploadRequestWithBody generates requests for AbortPresignMultipartUpload with any type of body
func NewAbortPresignMultipartUploadRequestWithBody(server string, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "uploadId", runtime.ParamLocationPath, uploadId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/staging/pmpu/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCompletePresignMultipartUploadRequest calls the generic CompletePresignMultipartUpload builder with application/json body
func NewCompletePresignMultipartUploadRequest(server string, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, body CompletePresignMultipartUploadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCompletePresignMultipartUploadRequestWithBody(server, repository, branch, uploadId, params, "application/json", bodyReader)
}

// NewCompletePresignMultipartUploadRequestWithBody generates requests for CompletePresignMultipartUpload with any type of body
func NewCompletePresignMultipartUploadRequestWithBody(server string, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "uploadId", runtime.ParamLocationPath, uploadId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/staging/pmpu/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateCommitRecordRequest calls the generic CreateCommitRecord builder with application/json body
func NewCreateCommitRecordRequest(server string, repository string, body CreateCommitRecordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCommitRecordRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewCreateCommitRecordRequestWithBody generates requests for CreateCommitRecord with any type of body
func NewCreateCommitRecordRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/commits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCommitRequest generates requests for GetCommit
func NewGetCommitRequest(server string, repository string, commitId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/commits/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDumpStatusRequest generates requests for DumpStatus
func NewDumpStatusRequest(server string, repository string, params *DumpStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/dump", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "task_id", runtime.ParamLocationQuery, params.TaskId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDumpSubmitRequest generates requests for DumpSubmit
func NewDumpSubmitRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/dump", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPrepareGarbageCollectionCommitsRequest generates requests for PrepareGarbageCollectionCommits
func NewPrepareGarbageCollectionCommitsRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/gc/prepare_commits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPrepareGarbageCollectionUncommittedRequest calls the generic PrepareGarbageCollectionUncommitted builder with application/json body
func NewPrepareGarbageCollectionUncommittedRequest(server string, repository string, body PrepareGarbageCollectionUncommittedJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPrepareGarbageCollectionUncommittedRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewPrepareGarbageCollectionUncommittedRequestWithBody generates requests for PrepareGarbageCollectionUncommitted with any type of body
func NewPrepareGarbageCollectionUncommittedRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/gc/prepare_uncommited", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInternalDeleteGarbageCollectionRulesRequest generates requests for InternalDeleteGarbageCollectionRules
func NewInternalDeleteGarbageCollectionRulesRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/gc/rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalGetGarbageCollectionRulesRequest generates requests for InternalGetGarbageCollectionRules
func NewInternalGetGarbageCollectionRulesRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/gc/rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalSetGarbageCollectionRulesRequest calls the generic InternalSetGarbageCollectionRules builder with application/json body
func NewInternalSetGarbageCollectionRulesRequest(server string, repository string, body InternalSetGarbageCollectionRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInternalSetGarbageCollectionRulesRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewInternalSetGarbageCollectionRulesRequestWithBody generates requests for InternalSetGarbageCollectionRules with any type of body
func NewInternalSetGarbageCollectionRulesRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/gc/rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSetGarbageCollectionRulesPreflightRequest generates requests for SetGarbageCollectionRulesPreflight
func NewSetGarbageCollectionRulesPreflightRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/gc/rules/set_allowed", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteRepositoryMetadataRequest calls the generic DeleteRepositoryMetadata builder with application/json body
func NewDeleteRepositoryMetadataRequest(server string, repository string, body DeleteRepositoryMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteRepositoryMetadataRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewDeleteRepositoryMetadataRequestWithBody generates requests for DeleteRepositoryMetadata with any type of body
func NewDeleteRepositoryMetadataRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/metadata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRepositoryMetadataRequest generates requests for GetRepositoryMetadata
func NewGetRepositoryMetadataRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/metadata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetRepositoryMetadataRequest calls the generic SetRepositoryMetadata builder with application/json body
func NewSetRepositoryMetadataRequest(server string, repository string, body SetRepositoryMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetRepositoryMetadataRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewSetRepositoryMetadataRequestWithBody generates requests for SetRepositoryMetadata with any type of body
func NewSetRepositoryMetadataRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/metadata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMetaRangeRequest generates requests for GetMetaRange
func NewGetMetaRangeRequest(server string, repository string, metaRange string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "meta_range", runtime.ParamLocationPath, metaRange)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/metadata/meta_range/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRangeRequest generates requests for GetRange
func NewGetRangeRequest(server string, repository string, pRange string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "range", runtime.ParamLocationPath, pRange)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/metadata/range/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDumpRefsRequest generates requests for DumpRefs
func NewDumpRefsRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/dump", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreRefsRequest calls the generic RestoreRefs builder with application/json body
func NewRestoreRefsRequest(server string, repository string, body RestoreRefsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRestoreRefsRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewRestoreRefsRequestWithBody generates requests for RestoreRefs with any type of body
func NewRestoreRefsRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/restore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateSymlinkFileRequest generates requests for CreateSymlinkFile
func NewCreateSymlinkFileRequest(server string, repository string, branch string, params *CreateSymlinkFileParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/symlink", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Location != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "location", runtime.ParamLocationQuery, *params.Location); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDiffRefsRequest generates requests for DiffRefs
func NewDiffRefsRequest(server string, repository string, leftRef string, rightRef string, params *DiffRefsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "leftRef", runtime.ParamLocationPath, leftRef)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "rightRef", runtime.ParamLocationPath, rightRef)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/diff/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Delimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delimiter", runtime.ParamLocationQuery, *params.Delimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLogCommitsRequest generates requests for LogCommits
func NewLogCommitsRequest(server string, repository string, ref string, params *LogCommitsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/commits", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Objects != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "objects", runtime.ParamLocationQuery, *params.Objects); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Prefixes != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefixes", runtime.ParamLocationQuery, *params.Prefixes); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FirstParent != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first_parent", runtime.ParamLocationQuery, *params.FirstParent); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Since != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StopAt != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stop_at", runtime.ParamLocationQuery, *params.StopAt); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetObjectRequest generates requests for GetObject
func NewGetObjectRequest(server string, repository string, ref string, params *GetObjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/objects", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Presign != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "presign", runtime.ParamLocationQuery, *params.Presign); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.Range != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Range", runtime.ParamLocationHeader, *params.Range)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Range", headerParam0)
	}

	if params.IfNoneMatch != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, *params.IfNoneMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-None-Match", headerParam1)
	}

	return req, nil
}

// NewHeadObjectRequest generates requests for HeadObject
func NewHeadObjectRequest(server string, repository string, ref string, params *HeadObjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/objects", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.Range != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Range", runtime.ParamLocationHeader, *params.Range)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Range", headerParam0)
	}

	return req, nil
}

// NewListObjectsRequest generates requests for ListObjects
func NewListObjectsRequest(server string, repository string, ref string, params *ListObjectsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/objects/ls", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.UserMetadata != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_metadata", runtime.ParamLocationQuery, *params.UserMetadata); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Presign != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "presign", runtime.ParamLocationQuery, *params.Presign); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Delimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delimiter", runtime.ParamLocationQuery, *params.Delimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStatObjectRequest generates requests for StatObject
func NewStatObjectRequest(server string, repository string, ref string, params *StatObjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/objects/stat", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.UserMetadata != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_metadata", runtime.ParamLocationQuery, *params.UserMetadata); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Presign != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "presign", runtime.ParamLocationQuery, *params.Presign); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUnderlyingPropertiesRequest generates requests for GetUnderlyingProperties
func NewGetUnderlyingPropertiesRequest(server string, repository string, ref string, params *GetUnderlyingPropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/objects/underlyingProperties", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindMergeBaseRequest generates requests for FindMergeBase
func NewFindMergeBaseRequest(server string, repository string, sourceRef string, destinationBranch string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sourceRef", runtime.ParamLocationPath, sourceRef)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "destinationBranch", runtime.ParamLocationPath, destinationBranch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/merge/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMergeIntoBranchRequest calls the generic MergeIntoBranch builder with application/json body
func NewMergeIntoBranchRequest(server string, repository string, sourceRef string, destinationBranch string, body MergeIntoBranchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeIntoBranchRequestWithBody(server, repository, sourceRef, destinationBranch, "application/json", bodyReader)
}

// NewMergeIntoBranchRequestWithBody generates requests for MergeIntoBranch with any type of body
func NewMergeIntoBranchRequestWithBody(server string, repository string, sourceRef string, destinationBranch string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sourceRef", runtime.ParamLocationPath, sourceRef)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "destinationBranch", runtime.ParamLocationPath, destinationBranch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/merge/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRestoreStatusRequest generates requests for RestoreStatus
func NewRestoreStatusRequest(server string, repository string, params *RestoreStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/restore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "task_id", runtime.ParamLocationQuery, params.TaskId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreSubmitRequest calls the generic RestoreSubmit builder with application/json body
func NewRestoreSubmitRequest(server string, repository string, body RestoreSubmitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRestoreSubmitRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewRestoreSubmitRequestWithBody generates requests for RestoreSubmit with any type of body
func NewRestoreSubmitRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/restore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBranchProtectionRulesRequest generates requests for GetBranchProtectionRules
func NewGetBranchProtectionRulesRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/settings/branch_protection", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetBranchProtectionRulesRequest calls the generic SetBranchProtectionRules builder with application/json body
func NewSetBranchProtectionRulesRequest(server string, repository string, params *SetBranchProtectionRulesParams, body SetBranchProtectionRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetBranchProtectionRulesRequestWithBody(server, repository, params, "application/json", bodyReader)
}

// NewSetBranchProtectionRulesRequestWithBody generates requests for SetBranchProtectionRules with any type of body
func NewSetBranchProtectionRulesRequestWithBody(server string, repository string, params *SetBranchProtectionRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/settings/branch_protection", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.IfMatch != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-Match", headerParam0)
	}

	return req, nil
}

// NewDeleteGCRulesRequest generates requests for DeleteGCRules
func NewDeleteGCRulesRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/settings/gc_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGCRulesRequest generates requests for GetGCRules
func NewGetGCRulesRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/settings/gc_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetGCRulesRequest calls the generic SetGCRules builder with application/json body
func NewSetGCRulesRequest(server string, repository string, body SetGCRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetGCRulesRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewSetGCRulesRequestWithBody generates requests for SetGCRules with any type of body
func NewSetGCRulesRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/settings/gc_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListTagsRequest generates requests for ListTags
func NewListTagsRequest(server string, repository string, params *ListTagsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTagRequest calls the generic CreateTag builder with application/json body
func NewCreateTagRequest(server string, repository string, body CreateTagJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTagRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewCreateTagRequestWithBody generates requests for CreateTag with any type of body
func NewCreateTagRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTagRequest generates requests for DeleteTag
func NewDeleteTagRequest(server string, repository string, tag string, params *DeleteTagParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tag", runtime.ParamLocationPath, tag)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/tags/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTagRequest generates requests for GetTag
func NewGetTagRequest(server string, repository string, tag string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tag", runtime.ParamLocationPath, tag)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/tags/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetupCommPrefsRequest calls the generic SetupCommPrefs builder with application/json body
func NewSetupCommPrefsRequest(server string, body SetupCommPrefsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetupCommPrefsRequestWithBody(server, "application/json", bodyReader)
}

// NewSetupCommPrefsRequestWithBody generates requests for SetupCommPrefs with any type of body
func NewSetupCommPrefsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setup_comm_prefs")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSetupStateRequest generates requests for GetSetupState
func NewGetSetupStateRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setup_lakefs")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetupRequest calls the generic Setup builder with application/json body
func NewSetupRequest(server string, body SetupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetupRequestWithBody(server, "application/json", bodyReader)
}

// NewSetupRequestWithBody generates requests for Setup with any type of body
func NewSetupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setup_lakefs")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostStatsEventsRequest calls the generic PostStatsEvents builder with application/json body
func NewPostStatsEventsRequest(server string, body PostStatsEventsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostStatsEventsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostStatsEventsRequestWithBody generates requests for PostStatsEvents with any type of body
func NewPostStatsEventsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/statistics")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStsLoginRequest calls the generic StsLogin builder with application/json body
func NewStsLoginRequest(server string, body StsLoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStsLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewStsLoginRequestWithBody generates requests for StsLogin with any type of body
func NewStsLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sts/login")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUsageReportSummaryRequest generates requests for GetUsageReportSummary
func NewGetUsageReportSummaryRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/usage-report/summary")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrentUserRequest generates requests for GetCurrentUser
func NewGetCurrentUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAuthCapabilities request
	GetAuthCapabilitiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAuthCapabilitiesResponse, error)

	// ExternalPrincipalLogin request  with any body
	ExternalPrincipalLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExternalPrincipalLoginResponse, error)

	ExternalPrincipalLoginWithResponse(ctx context.Context, body ExternalPrincipalLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*ExternalPrincipalLoginResponse, error)

	// GetExternalPrincipal request
	GetExternalPrincipalWithResponse(ctx context.Context, params *GetExternalPrincipalParams, reqEditors ...RequestEditorFn) (*GetExternalPrincipalResponse, error)

	// ListGroups request
	ListGroupsWithResponse(ctx context.Context, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*ListGroupsResponse, error)

	// CreateGroup request  with any body
	CreateGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	CreateGroupWithResponse(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	// DeleteGroup request
	DeleteGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error)

	// GetGroup request
	GetGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*GetGroupResponse, error)

	// GetGroupACL request
	GetGroupACLWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*GetGroupACLResponse, error)

	// SetGroupACL request  with any body
	SetGroupACLWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetGroupACLResponse, error)

	SetGroupACLWithResponse(ctx context.Context, groupId string, body SetGroupACLJSONRequestBody, reqEditors ...RequestEditorFn) (*SetGroupACLResponse, error)

	// ListGroupMembers request
	ListGroupMembersWithResponse(ctx context.Context, groupId string, params *ListGroupMembersParams, reqEditors ...RequestEditorFn) (*ListGroupMembersResponse, error)

	// DeleteGroupMembership request
	DeleteGroupMembershipWithResponse(ctx context.Context, groupId string, userId string, reqEditors ...RequestEditorFn) (*DeleteGroupMembershipResponse, error)

	// AddGroupMembership request
	AddGroupMembershipWithResponse(ctx context.Context, groupId string, userId string, reqEditors ...RequestEditorFn) (*AddGroupMembershipResponse, error)

	// ListGroupPolicies request
	ListGroupPoliciesWithResponse(ctx context.Context, groupId string, params *ListGroupPoliciesParams, reqEditors ...RequestEditorFn) (*ListGroupPoliciesResponse, error)

	// DetachPolicyFromGroup request
	DetachPolicyFromGroupWithResponse(ctx context.Context, groupId string, policyId string, reqEditors ...RequestEditorFn) (*DetachPolicyFromGroupResponse, error)

	// AttachPolicyToGroup request
	AttachPolicyToGroupWithResponse(ctx context.Context, groupId string, policyId string, reqEditors ...RequestEditorFn) (*AttachPolicyToGroupResponse, error)

	// Login request  with any body
	LoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	LoginWithResponse(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	// ListPolicies request
	ListPoliciesWithResponse(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*ListPoliciesResponse, error)

	// CreatePolicy request  with any body
	CreatePolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error)

	CreatePolicyWithResponse(ctx context.Context, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error)

	// DeletePolicy request
	DeletePolicyWithResponse(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*DeletePolicyResponse, error)

	// GetPolicy request
	GetPolicyWithResponse(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*GetPolicyResponse, error)

	// UpdatePolicy request  with any body
	UpdatePolicyWithBodyWithResponse(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error)

	UpdatePolicyWithResponse(ctx context.Context, policyId string, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error)

	// ListUsers request
	ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error)

	// CreateUser request  with any body
	CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	// DeleteUser request
	DeleteUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// GetUser request
	GetUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// ListUserCredentials request
	ListUserCredentialsWithResponse(ctx context.Context, userId string, params *ListUserCredentialsParams, reqEditors ...RequestEditorFn) (*ListUserCredentialsResponse, error)

	// CreateCredentials request
	CreateCredentialsWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*CreateCredentialsResponse, error)

	// DeleteCredentials request
	DeleteCredentialsWithResponse(ctx context.Context, userId string, accessKeyId string, reqEditors ...RequestEditorFn) (*DeleteCredentialsResponse, error)

	// GetCredentials request
	GetCredentialsWithResponse(ctx context.Context, userId string, accessKeyId string, reqEditors ...RequestEditorFn) (*GetCredentialsResponse, error)

	// DeleteUserExternalPrincipal request
	DeleteUserExternalPrincipalWithResponse(ctx context.Context, userId string, params *DeleteUserExternalPrincipalParams, reqEditors ...RequestEditorFn) (*DeleteUserExternalPrincipalResponse, error)

	// CreateUserExternalPrincipal request  with any body
	CreateUserExternalPrincipalWithBodyWithResponse(ctx context.Context, userId string, params *CreateUserExternalPrincipalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserExternalPrincipalResponse, error)

	CreateUserExternalPrincipalWithResponse(ctx context.Context, userId string, params *CreateUserExternalPrincipalParams, body CreateUserExternalPrincipalJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserExternalPrincipalResponse, error)

	// ListUserExternalPrincipals request
	ListUserExternalPrincipalsWithResponse(ctx context.Context, userId string, params *ListUserExternalPrincipalsParams, reqEditors ...RequestEditorFn) (*ListUserExternalPrincipalsResponse, error)

	// ListUserGroups request
	ListUserGroupsWithResponse(ctx context.Context, userId string, params *ListUserGroupsParams, reqEditors ...RequestEditorFn) (*ListUserGroupsResponse, error)

	// ListUserPolicies request
	ListUserPoliciesWithResponse(ctx context.Context, userId string, params *ListUserPoliciesParams, reqEditors ...RequestEditorFn) (*ListUserPoliciesResponse, error)

	// DetachPolicyFromUser request
	DetachPolicyFromUserWithResponse(ctx context.Context, userId string, policyId string, reqEditors ...RequestEditorFn) (*DetachPolicyFromUserResponse, error)

	// AttachPolicyToUser request
	AttachPolicyToUserWithResponse(ctx context.Context, userId string, policyId string, reqEditors ...RequestEditorFn) (*AttachPolicyToUserResponse, error)

	// GetConfig request
	GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigResponse, error)

	// GetGarbageCollectionConfig request
	GetGarbageCollectionConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGarbageCollectionConfigResponse, error)

	// GetStorageConfig request
	GetStorageConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStorageConfigResponse, error)

	// GetLakeFSVersion request
	GetLakeFSVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLakeFSVersionResponse, error)

	// HealthCheck request
	HealthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error)

	// ListRepositories request
	ListRepositoriesWithResponse(ctx context.Context, params *ListRepositoriesParams, reqEditors ...RequestEditorFn) (*ListRepositoriesResponse, error)

	// CreateRepository request  with any body
	CreateRepositoryWithBodyWithResponse(ctx context.Context, params *CreateRepositoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRepositoryResponse, error)

	CreateRepositoryWithResponse(ctx context.Context, params *CreateRepositoryParams, body CreateRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRepositoryResponse, error)

	// DeleteRepository request
	DeleteRepositoryWithResponse(ctx context.Context, repository string, params *DeleteRepositoryParams, reqEditors ...RequestEditorFn) (*DeleteRepositoryResponse, error)

	// GetRepository request
	GetRepositoryWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*GetRepositoryResponse, error)

	// ListRepositoryRuns request
	ListRepositoryRunsWithResponse(ctx context.Context, repository string, params *ListRepositoryRunsParams, reqEditors ...RequestEditorFn) (*ListRepositoryRunsResponse, error)

	// GetRun request
	GetRunWithResponse(ctx context.Context, repository string, runId string, reqEditors ...RequestEditorFn) (*GetRunResponse, error)

	// ListRunHooks request
	ListRunHooksWithResponse(ctx context.Context, repository string, runId string, params *ListRunHooksParams, reqEditors ...RequestEditorFn) (*ListRunHooksResponse, error)

	// GetRunHookOutput request
	GetRunHookOutputWithResponse(ctx context.Context, repository string, runId string, hookRunId string, reqEditors ...RequestEditorFn) (*GetRunHookOutputResponse, error)

	// InternalDeleteBranchProtectionRule request  with any body
	InternalDeleteBranchProtectionRuleWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalDeleteBranchProtectionRuleResponse, error)

	InternalDeleteBranchProtectionRuleWithResponse(ctx context.Context, repository string, body InternalDeleteBranchProtectionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalDeleteBranchProtectionRuleResponse, error)

	// InternalGetBranchProtectionRules request
	InternalGetBranchProtectionRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*InternalGetBranchProtectionRulesResponse, error)

	// InternalCreateBranchProtectionRule request  with any body
	InternalCreateBranchProtectionRuleWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalCreateBranchProtectionRuleResponse, error)

	InternalCreateBranchProtectionRuleWithResponse(ctx context.Context, repository string, body InternalCreateBranchProtectionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalCreateBranchProtectionRuleResponse, error)

	// CreateBranchProtectionRulePreflight request
	CreateBranchProtectionRulePreflightWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*CreateBranchProtectionRulePreflightResponse, error)

	// ListBranches request
	ListBranchesWithResponse(ctx context.Context, repository string, params *ListBranchesParams, reqEditors ...RequestEditorFn) (*ListBranchesResponse, error)

	// CreateBranch request  with any body
	CreateBranchWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBranchResponse, error)

	CreateBranchWithResponse(ctx context.Context, repository string, body CreateBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBranchResponse, error)

	// DeleteBranch request
	DeleteBranchWithResponse(ctx context.Context, repository string, branch string, params *DeleteBranchParams, reqEditors ...RequestEditorFn) (*DeleteBranchResponse, error)

	// GetBranch request
	GetBranchWithResponse(ctx context.Context, repository string, branch string, reqEditors ...RequestEditorFn) (*GetBranchResponse, error)

	// ResetBranch request  with any body
	ResetBranchWithBodyWithResponse(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetBranchResponse, error)

	ResetBranchWithResponse(ctx context.Context, repository string, branch string, body ResetBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetBranchResponse, error)

	// CherryPick request  with any body
	CherryPickWithBodyWithResponse(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CherryPickResponse, error)

	CherryPickWithResponse(ctx context.Context, repository string, branch string, body CherryPickJSONRequestBody, reqEditors ...RequestEditorFn) (*CherryPickResponse, error)

	// Commit request  with any body
	CommitWithBodyWithResponse(ctx context.Context, repository string, branch string, params *CommitParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommitResponse, error)

	CommitWithResponse(ctx context.Context, repository string, branch string, params *CommitParams, body CommitJSONRequestBody, reqEditors ...RequestEditorFn) (*CommitResponse, error)

	// DiffBranch request
	DiffBranchWithResponse(ctx context.Context, repository string, branch string, params *DiffBranchParams, reqEditors ...RequestEditorFn) (*DiffBranchResponse, error)

	// HardResetBranch request
	HardResetBranchWithResponse(ctx context.Context, repository string, branch string, params *HardResetBranchParams, reqEditors ...RequestEditorFn) (*HardResetBranchResponse, error)

	// ImportCancel request
	ImportCancelWithResponse(ctx context.Context, repository string, branch string, params *ImportCancelParams, reqEditors ...RequestEditorFn) (*ImportCancelResponse, error)

	// ImportStatus request
	ImportStatusWithResponse(ctx context.Context, repository string, branch string, params *ImportStatusParams, reqEditors ...RequestEditorFn) (*ImportStatusResponse, error)

	// ImportStart request  with any body
	ImportStartWithBodyWithResponse(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportStartResponse, error)

	ImportStartWithResponse(ctx context.Context, repository string, branch string, body ImportStartJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportStartResponse, error)

	// DeleteObject request
	DeleteObjectWithResponse(ctx context.Context, repository string, branch string, params *DeleteObjectParams, reqEditors ...RequestEditorFn) (*DeleteObjectResponse, error)

	// UploadObject request  with any body
	UploadObjectWithBodyWithResponse(ctx context.Context, repository string, branch string, params *UploadObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadObjectResponse, error)

	// StageObject request  with any body
	StageObjectWithBodyWithResponse(ctx context.Context, repository string, branch string, params *StageObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StageObjectResponse, error)

	StageObjectWithResponse(ctx context.Context, repository string, branch string, params *StageObjectParams, body StageObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*StageObjectResponse, error)

	// CopyObject request  with any body
	CopyObjectWithBodyWithResponse(ctx context.Context, repository string, branch string, params *CopyObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CopyObjectResponse, error)

	CopyObjectWithResponse(ctx context.Context, repository string, branch string, params *CopyObjectParams, body CopyObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CopyObjectResponse, error)

	// DeleteObjects request  with any body
	DeleteObjectsWithBodyWithResponse(ctx context.Context, repository string, branch string, params *DeleteObjectsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteObjectsResponse, error)

	DeleteObjectsWithResponse(ctx context.Context, repository string, branch string, params *DeleteObjectsParams, body DeleteObjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteObjectsResponse, error)

	// UploadObjectPreflight request
	UploadObjectPreflightWithResponse(ctx context.Context, repository string, branch string, params *UploadObjectPreflightParams, reqEditors ...RequestEditorFn) (*UploadObjectPreflightResponse, error)

	// RevertBranch request  with any body
	RevertBranchWithBodyWithResponse(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevertBranchResponse, error)

	RevertBranchWithResponse(ctx context.Context, repository string, branch string, body RevertBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*RevertBranchResponse, error)

	// GetPhysicalAddress request
	GetPhysicalAddressWithResponse(ctx context.Context, repository string, branch string, params *GetPhysicalAddressParams, reqEditors ...RequestEditorFn) (*GetPhysicalAddressResponse, error)

	// LinkPhysicalAddress request  with any body
	LinkPhysicalAddressWithBodyWithResponse(ctx context.Context, repository string, branch string, params *LinkPhysicalAddressParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkPhysicalAddressResponse, error)

	LinkPhysicalAddressWithResponse(ctx context.Context, repository string, branch string, params *LinkPhysicalAddressParams, body LinkPhysicalAddressJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkPhysicalAddressResponse, error)

	// CreatePresignMultipartUpload request
	CreatePresignMultipartUploadWithResponse(ctx context.Context, repository string, branch string, params *CreatePresignMultipartUploadParams, reqEditors ...RequestEditorFn) (*CreatePresignMultipartUploadResponse, error)

	// AbortPresignMultipartUpload request  with any body
	AbortPresignMultipartUploadWithBodyWithResponse(ctx context.Context, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AbortPresignMultipartUploadResponse, error)

	AbortPresignMultipartUploadWithResponse(ctx context.Context, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, body AbortPresignMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*AbortPresignMultipartUploadResponse, error)

	// CompletePresignMultipartUpload request  with any body
	CompletePresignMultipartUploadWithBodyWithResponse(ctx context.Context, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompletePresignMultipartUploadResponse, error)

	CompletePresignMultipartUploadWithResponse(ctx context.Context, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, body CompletePresignMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*CompletePresignMultipartUploadResponse, error)

	// CreateCommitRecord request  with any body
	CreateCommitRecordWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCommitRecordResponse, error)

	CreateCommitRecordWithResponse(ctx context.Context, repository string, body CreateCommitRecordJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCommitRecordResponse, error)

	// GetCommit request
	GetCommitWithResponse(ctx context.Context, repository string, commitId string, reqEditors ...RequestEditorFn) (*GetCommitResponse, error)

	// DumpStatus request
	DumpStatusWithResponse(ctx context.Context, repository string, params *DumpStatusParams, reqEditors ...RequestEditorFn) (*DumpStatusResponse, error)

	// DumpSubmit request
	DumpSubmitWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*DumpSubmitResponse, error)

	// PrepareGarbageCollectionCommits request
	PrepareGarbageCollectionCommitsWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*PrepareGarbageCollectionCommitsResponse, error)

	// PrepareGarbageCollectionUncommitted request  with any body
	PrepareGarbageCollectionUncommittedWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrepareGarbageCollectionUncommittedResponse, error)

	PrepareGarbageCollectionUncommittedWithResponse(ctx context.Context, repository string, body PrepareGarbageCollectionUncommittedJSONRequestBody, reqEditors ...RequestEditorFn) (*PrepareGarbageCollectionUncommittedResponse, error)

	// InternalDeleteGarbageCollectionRules request
	InternalDeleteGarbageCollectionRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*InternalDeleteGarbageCollectionRulesResponse, error)

	// InternalGetGarbageCollectionRules request
	InternalGetGarbageCollectionRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*InternalGetGarbageCollectionRulesResponse, error)

	// InternalSetGarbageCollectionRules request  with any body
	InternalSetGarbageCollectionRulesWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalSetGarbageCollectionRulesResponse, error)

	InternalSetGarbageCollectionRulesWithResponse(ctx context.Context, repository string, body InternalSetGarbageCollectionRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalSetGarbageCollectionRulesResponse, error)

	// SetGarbageCollectionRulesPreflight request
	SetGarbageCollectionRulesPreflightWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*SetGarbageCollectionRulesPreflightResponse, error)

	// DeleteRepositoryMetadata request  with any body
	DeleteRepositoryMetadataWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteRepositoryMetadataResponse, error)

	DeleteRepositoryMetadataWithResponse(ctx context.Context, repository string, body DeleteRepositoryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteRepositoryMetadataResponse, error)

	// GetRepositoryMetadata request
	GetRepositoryMetadataWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*GetRepositoryMetadataResponse, error)

	// SetRepositoryMetadata request  with any body
	SetRepositoryMetadataWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetRepositoryMetadataResponse, error)

	SetRepositoryMetadataWithResponse(ctx context.Context, repository string, body SetRepositoryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*SetRepositoryMetadataResponse, error)

	// GetMetaRange request
	GetMetaRangeWithResponse(ctx context.Context, repository string, metaRange string, reqEditors ...RequestEditorFn) (*GetMetaRangeResponse, error)

	// GetRange request
	GetRangeWithResponse(ctx context.Context, repository string, pRange string, reqEditors ...RequestEditorFn) (*GetRangeResponse, error)

	// DumpRefs request
	DumpRefsWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*DumpRefsResponse, error)

	// RestoreRefs request  with any body
	RestoreRefsWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestoreRefsResponse, error)

	RestoreRefsWithResponse(ctx context.Context, repository string, body RestoreRefsJSONRequestBody, reqEditors ...RequestEditorFn) (*RestoreRefsResponse, error)

	// CreateSymlinkFile request
	CreateSymlinkFileWithResponse(ctx context.Context, repository string, branch string, params *CreateSymlinkFileParams, reqEditors ...RequestEditorFn) (*CreateSymlinkFileResponse, error)

	// DiffRefs request
	DiffRefsWithResponse(ctx context.Context, repository string, leftRef string, rightRef string, params *DiffRefsParams, reqEditors ...RequestEditorFn) (*DiffRefsResponse, error)

	// LogCommits request
	LogCommitsWithResponse(ctx context.Context, repository string, ref string, params *LogCommitsParams, reqEditors ...RequestEditorFn) (*LogCommitsResponse, error)

	// GetObject request
	GetObjectWithResponse(ctx context.Context, repository string, ref string, params *GetObjectParams, reqEditors ...RequestEditorFn) (*GetObjectResponse, error)

	// HeadObject request
	HeadObjectWithResponse(ctx context.Context, repository string, ref string, params *HeadObjectParams, reqEditors ...RequestEditorFn) (*HeadObjectResponse, error)

	// ListObjects request
	ListObjectsWithResponse(ctx context.Context, repository string, ref string, params *ListObjectsParams, reqEditors ...RequestEditorFn) (*ListObjectsResponse, error)

	// StatObject request
	StatObjectWithResponse(ctx context.Context, repository string, ref string, params *StatObjectParams, reqEditors ...RequestEditorFn) (*StatObjectResponse, error)

	// GetUnderlyingProperties request
	GetUnderlyingPropertiesWithResponse(ctx context.Context, repository string, ref string, params *GetUnderlyingPropertiesParams, reqEditors ...RequestEditorFn) (*GetUnderlyingPropertiesResponse, error)

	// FindMergeBase request
	FindMergeBaseWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, reqEditors ...RequestEditorFn) (*FindMergeBaseResponse, error)

	// MergeIntoBranch request  with any body
	MergeIntoBranchWithBodyWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeIntoBranchResponse, error)

	MergeIntoBranchWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, body MergeIntoBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeIntoBranchResponse, error)

	// RestoreStatus request
	RestoreStatusWithResponse(ctx context.Context, repository string, params *RestoreStatusParams, reqEditors ...RequestEditorFn) (*RestoreStatusResponse, error)

	// RestoreSubmit request  with any body
	RestoreSubmitWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestoreSubmitResponse, error)

	RestoreSubmitWithResponse(ctx context.Context, repository string, body RestoreSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*RestoreSubmitResponse, error)

	// GetBranchProtectionRules request
	GetBranchProtectionRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*GetBranchProtectionRulesResponse, error)

	// SetBranchProtectionRules request  with any body
	SetBranchProtectionRulesWithBodyWithResponse(ctx context.Context, repository string, params *SetBranchProtectionRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetBranchProtectionRulesResponse, error)

	SetBranchProtectionRulesWithResponse(ctx context.Context, repository string, params *SetBranchProtectionRulesParams, body SetBranchProtectionRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetBranchProtectionRulesResponse, error)

	// DeleteGCRules request
	DeleteGCRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*DeleteGCRulesResponse, error)

	// GetGCRules request
	GetGCRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*GetGCRulesResponse, error)

	// SetGCRules request  with any body
	SetGCRulesWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetGCRulesResponse, error)

	SetGCRulesWithResponse(ctx context.Context, repository string, body SetGCRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetGCRulesResponse, error)

	// ListTags request
	ListTagsWithResponse(ctx context.Context, repository string, params *ListTagsParams, reqEditors ...RequestEditorFn) (*ListTagsResponse, error)

	// CreateTag request  with any body
	CreateTagWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTagResponse, error)

	CreateTagWithResponse(ctx context.Context, repository string, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTagResponse, error)

	// DeleteTag request
	DeleteTagWithResponse(ctx context.Context, repository string, tag string, params *DeleteTagParams, reqEditors ...RequestEditorFn) (*DeleteTagResponse, error)

	// GetTag request
	GetTagWithResponse(ctx context.Context, repository string, tag string, reqEditors ...RequestEditorFn) (*GetTagResponse, error)

	// SetupCommPrefs request  with any body
	SetupCommPrefsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetupCommPrefsResponse, error)

	SetupCommPrefsWithResponse(ctx context.Context, body SetupCommPrefsJSONRequestBody, reqEditors ...RequestEditorFn) (*SetupCommPrefsResponse, error)

	// GetSetupState request
	GetSetupStateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSetupStateResponse, error)

	// Setup request  with any body
	SetupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetupResponse, error)

	SetupWithResponse(ctx context.Context, body SetupJSONRequestBody, reqEditors ...RequestEditorFn) (*SetupResponse, error)

	// PostStatsEvents request  with any body
	PostStatsEventsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStatsEventsResponse, error)

	PostStatsEventsWithResponse(ctx context.Context, body PostStatsEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStatsEventsResponse, error)

	// StsLogin request  with any body
	StsLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StsLoginResponse, error)

	StsLoginWithResponse(ctx context.Context, body StsLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*StsLoginResponse, error)

	// GetUsageReportSummary request
	GetUsageReportSummaryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUsageReportSummaryResponse, error)

	// GetCurrentUser request
	GetCurrentUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentUserResponse, error)
}

type GetAuthCapabilitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthCapabilities
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetAuthCapabilitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthCapabilitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExternalPrincipalLoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthenticationToken
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ExternalPrincipalLoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExternalPrincipalLoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExternalPrincipalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExternalPrincipal
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetExternalPrincipalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExternalPrincipalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupList
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Group
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Group
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupACLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ACL
	JSON401      *Error
	JSON404      *ErrorNoACL
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetGroupACLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupACLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetGroupACLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SetGroupACLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetGroupACLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGroupMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserList
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListGroupMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGroupMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupMembershipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteGroupMembershipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupMembershipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddGroupMembershipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AddGroupMembershipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddGroupMembershipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGroupPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyList
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListGroupPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGroupPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DetachPolicyFromGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DetachPolicyFromGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DetachPolicyFromGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachPolicyToGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AttachPolicyToGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachPolicyToGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthenticationToken
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r LoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyList
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Policy
	JSON400      *Error
	JSON401      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreatePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeletePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Policy
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Policy
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdatePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserList
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *User
	JSON400      *Error
	JSON401      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CredentialsList
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListUserCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CredentialsWithSecret
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Credentials
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserExternalPrincipalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteUserExternalPrincipalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserExternalPrincipalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserExternalPrincipalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateUserExternalPrincipalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserExternalPrincipalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserExternalPrincipalsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExternalPrincipalList
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListUserExternalPrincipalsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserExternalPrincipalsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupList
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListUserGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyList
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListUserPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DetachPolicyFromUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DetachPolicyFromUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DetachPolicyFromUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachPolicyToUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AttachPolicyToUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachPolicyToUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Config
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r GetConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGarbageCollectionConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GarbageCollectionConfig
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r GetGarbageCollectionConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGarbageCollectionConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStorageConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StorageConfig
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r GetStorageConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStorageConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLakeFSVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VersionConfig
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r GetLakeFSVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLakeFSVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HealthCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HealthCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRepositoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RepositoryList
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListRepositoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRepositoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Repository
	JSON400      *Error
	JSON401      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Repository
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRepositoryRunsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionRunList
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListRepositoryRunsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRepositoryRunsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionRun
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRunHooksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HookRunList
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListRunHooksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRunHooksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRunHookOutputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRunHookOutputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRunHookOutputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalDeleteBranchProtectionRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r InternalDeleteBranchProtectionRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalDeleteBranchProtectionRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalGetBranchProtectionRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]BranchProtectionRule
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r InternalGetBranchProtectionRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalGetBranchProtectionRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalCreateBranchProtectionRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r InternalCreateBranchProtectionRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalCreateBranchProtectionRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBranchProtectionRulePreflightResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateBranchProtectionRulePreflightResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBranchProtectionRulePreflightResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBranchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RefList
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListBranchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBranchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Ref
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ResetBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CherryPickResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Commit
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CherryPickResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CherryPickResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Commit
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	JSON412      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CommitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DiffBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DiffList
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DiffBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DiffBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HardResetBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r HardResetBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HardResetBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ImportCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ImportStatus
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ImportStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportStartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *ImportCreationResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ImportStartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportStartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ObjectStats
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON412      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UploadObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StageObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ObjectStats
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r StageObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StageObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CopyObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ObjectStats
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CopyObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CopyObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteObjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectErrorList
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteObjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteObjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadObjectPreflightResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UploadObjectPreflightResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadObjectPreflightResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevertBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r RevertBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevertBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPhysicalAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StagingLocation
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetPhysicalAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPhysicalAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkPhysicalAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStats
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *StagingLocation
	JSON412      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r LinkPhysicalAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkPhysicalAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePresignMultipartUploadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PresignMultipartUpload
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreatePresignMultipartUploadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePresignMultipartUploadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AbortPresignMultipartUploadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AbortPresignMultipartUploadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AbortPresignMultipartUploadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompletePresignMultipartUploadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStats
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON409      *StagingLocation
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CompletePresignMultipartUploadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompletePresignMultipartUploadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCommitRecordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateCommitRecordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCommitRecordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCommitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Commit
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetCommitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCommitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DumpStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RepositoryDumpStatus
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DumpStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DumpStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DumpSubmitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *TaskInfo
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DumpSubmitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DumpSubmitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PrepareGarbageCollectionCommitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *GarbageCollectionPrepareResponse
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PrepareGarbageCollectionCommitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PrepareGarbageCollectionCommitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PrepareGarbageCollectionUncommittedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PrepareGCUncommittedResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PrepareGarbageCollectionUncommittedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PrepareGarbageCollectionUncommittedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalDeleteGarbageCollectionRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r InternalDeleteGarbageCollectionRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalDeleteGarbageCollectionRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalGetGarbageCollectionRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GarbageCollectionRules
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r InternalGetGarbageCollectionRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalGetGarbageCollectionRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalSetGarbageCollectionRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r InternalSetGarbageCollectionRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalSetGarbageCollectionRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetGarbageCollectionRulesPreflightResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SetGarbageCollectionRulesPreflightResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetGarbageCollectionRulesPreflightResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRepositoryMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteRepositoryMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRepositoryMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRepositoryMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RepositoryMetadata
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRepositoryMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRepositoryMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetRepositoryMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SetRepositoryMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetRepositoryMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMetaRangeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StorageURI
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetMetaRangeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetaRangeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRangeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StorageURI
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRangeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRangeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DumpRefsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RefsDump
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DumpRefsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DumpRefsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreRefsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r RestoreRefsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreRefsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSymlinkFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *StorageURI
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateSymlinkFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSymlinkFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DiffRefsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DiffList
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DiffRefsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DiffRefsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogCommitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommitList
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r LogCommitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogCommitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSON410      *Error
	JSON416      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HeadObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HeadObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HeadObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListObjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStatsList
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListObjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListObjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StatObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStats
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r StatObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StatObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUnderlyingPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UnderlyingObjectProperties
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetUnderlyingPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUnderlyingPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindMergeBaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FindMergeBaseResult
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r FindMergeBaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindMergeBaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeIntoBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MergeResult
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *MergeResult
	JSON412      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r MergeIntoBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeIntoBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RepositoryRestoreStatus
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r RestoreStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreSubmitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *TaskInfo
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r RestoreSubmitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreSubmitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBranchProtectionRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]BranchProtectionRule
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetBranchProtectionRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBranchProtectionRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetBranchProtectionRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON412      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SetBranchProtectionRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetBranchProtectionRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGCRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteGCRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGCRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGCRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GarbageCollectionRules
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetGCRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGCRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetGCRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SetGCRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetGCRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RefList
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Ref
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Ref
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetupCommPrefsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON409      *Error
	JSON412      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SetupCommPrefsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetupCommPrefsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSetupStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SetupState
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSetupStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSetupStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CredentialsWithSecret
	JSON400      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SetupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostStatsEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostStatsEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostStatsEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StsLoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthenticationToken
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r StsLoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StsLoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsageReportSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InstallationUsageReport
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetUsageReportSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsageReportSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CurrentUser
}

// Status returns HTTPResponse.Status
func (r GetCurrentUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAuthCapabilitiesWithResponse request returning *GetAuthCapabilitiesResponse
func (c *ClientWithResponses) GetAuthCapabilitiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAuthCapabilitiesResponse, error) {
	rsp, err := c.GetAuthCapabilities(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthCapabilitiesResponse(rsp)
}

// ExternalPrincipalLoginWithBodyWithResponse request with arbitrary body returning *ExternalPrincipalLoginResponse
func (c *ClientWithResponses) ExternalPrincipalLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExternalPrincipalLoginResponse, error) {
	rsp, err := c.ExternalPrincipalLoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExternalPrincipalLoginResponse(rsp)
}

func (c *ClientWithResponses) ExternalPrincipalLoginWithResponse(ctx context.Context, body ExternalPrincipalLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*ExternalPrincipalLoginResponse, error) {
	rsp, err := c.ExternalPrincipalLogin(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExternalPrincipalLoginResponse(rsp)
}

// GetExternalPrincipalWithResponse request returning *GetExternalPrincipalResponse
func (c *ClientWithResponses) GetExternalPrincipalWithResponse(ctx context.Context, params *GetExternalPrincipalParams, reqEditors ...RequestEditorFn) (*GetExternalPrincipalResponse, error) {
	rsp, err := c.GetExternalPrincipal(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExternalPrincipalResponse(rsp)
}

// ListGroupsWithResponse request returning *ListGroupsResponse
func (c *ClientWithResponses) ListGroupsWithResponse(ctx context.Context, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*ListGroupsResponse, error) {
	rsp, err := c.ListGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGroupsResponse(rsp)
}

// CreateGroupWithBodyWithResponse request with arbitrary body returning *CreateGroupResponse
func (c *ClientWithResponses) CreateGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateGroupWithResponse(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

// DeleteGroupWithResponse request returning *DeleteGroupResponse
func (c *ClientWithResponses) DeleteGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error) {
	rsp, err := c.DeleteGroup(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupResponse(rsp)
}

// GetGroupWithResponse request returning *GetGroupResponse
func (c *ClientWithResponses) GetGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*GetGroupResponse, error) {
	rsp, err := c.GetGroup(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupResponse(rsp)
}

// GetGroupACLWithResponse request returning *GetGroupACLResponse
func (c *ClientWithResponses) GetGroupACLWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*GetGroupACLResponse, error) {
	rsp, err := c.GetGroupACL(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupACLResponse(rsp)
}

// SetGroupACLWithBodyWithResponse request with arbitrary body returning *SetGroupACLResponse
func (c *ClientWithResponses) SetGroupACLWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetGroupACLResponse, error) {
	rsp, err := c.SetGroupACLWithBody(ctx, groupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetGroupACLResponse(rsp)
}

func (c *ClientWithResponses) SetGroupACLWithResponse(ctx context.Context, groupId string, body SetGroupACLJSONRequestBody, reqEditors ...RequestEditorFn) (*SetGroupACLResponse, error) {
	rsp, err := c.SetGroupACL(ctx, groupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetGroupACLResponse(rsp)
}

// ListGroupMembersWithResponse request returning *ListGroupMembersResponse
func (c *ClientWithResponses) ListGroupMembersWithResponse(ctx context.Context, groupId string, params *ListGroupMembersParams, reqEditors ...RequestEditorFn) (*ListGroupMembersResponse, error) {
	rsp, err := c.ListGroupMembers(ctx, groupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGroupMembersResponse(rsp)
}

// DeleteGroupMembershipWithResponse request returning *DeleteGroupMembershipResponse
func (c *ClientWithResponses) DeleteGroupMembershipWithResponse(ctx context.Context, groupId string, userId string, reqEditors ...RequestEditorFn) (*DeleteGroupMembershipResponse, error) {
	rsp, err := c.DeleteGroupMembership(ctx, groupId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupMembershipResponse(rsp)
}

// AddGroupMembershipWithResponse request returning *AddGroupMembershipResponse
func (c *ClientWithResponses) AddGroupMembershipWithResponse(ctx context.Context, groupId string, userId string, reqEditors ...RequestEditorFn) (*AddGroupMembershipResponse, error) {
	rsp, err := c.AddGroupMembership(ctx, groupId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddGroupMembershipResponse(rsp)
}

// ListGroupPoliciesWithResponse request returning *ListGroupPoliciesResponse
func (c *ClientWithResponses) ListGroupPoliciesWithResponse(ctx context.Context, groupId string, params *ListGroupPoliciesParams, reqEditors ...RequestEditorFn) (*ListGroupPoliciesResponse, error) {
	rsp, err := c.ListGroupPolicies(ctx, groupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGroupPoliciesResponse(rsp)
}

// DetachPolicyFromGroupWithResponse request returning *DetachPolicyFromGroupResponse
func (c *ClientWithResponses) DetachPolicyFromGroupWithResponse(ctx context.Context, groupId string, policyId string, reqEditors ...RequestEditorFn) (*DetachPolicyFromGroupResponse, error) {
	rsp, err := c.DetachPolicyFromGroup(ctx, groupId, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDetachPolicyFromGroupResponse(rsp)
}

// AttachPolicyToGroupWithResponse request returning *AttachPolicyToGroupResponse
func (c *ClientWithResponses) AttachPolicyToGroupWithResponse(ctx context.Context, groupId string, policyId string, reqEditors ...RequestEditorFn) (*AttachPolicyToGroupResponse, error) {
	rsp, err := c.AttachPolicyToGroup(ctx, groupId, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachPolicyToGroupResponse(rsp)
}

// LoginWithBodyWithResponse request with arbitrary body returning *LoginResponse
func (c *ClientWithResponses) LoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.LoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

func (c *ClientWithResponses) LoginWithResponse(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.Login(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

// ListPoliciesWithResponse request returning *ListPoliciesResponse
func (c *ClientWithResponses) ListPoliciesWithResponse(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*ListPoliciesResponse, error) {
	rsp, err := c.ListPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPoliciesResponse(rsp)
}

// CreatePolicyWithBodyWithResponse request with arbitrary body returning *CreatePolicyResponse
func (c *ClientWithResponses) CreatePolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error) {
	rsp, err := c.CreatePolicyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePolicyResponse(rsp)
}

func (c *ClientWithResponses) CreatePolicyWithResponse(ctx context.Context, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error) {
	rsp, err := c.CreatePolicy(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePolicyResponse(rsp)
}

// DeletePolicyWithResponse request returning *DeletePolicyResponse
func (c *ClientWithResponses) DeletePolicyWithResponse(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*DeletePolicyResponse, error) {
	rsp, err := c.DeletePolicy(ctx, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePolicyResponse(rsp)
}

// GetPolicyWithResponse request returning *GetPolicyResponse
func (c *ClientWithResponses) GetPolicyWithResponse(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*GetPolicyResponse, error) {
	rsp, err := c.GetPolicy(ctx, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPolicyResponse(rsp)
}

// UpdatePolicyWithBodyWithResponse request with arbitrary body returning *UpdatePolicyResponse
func (c *ClientWithResponses) UpdatePolicyWithBodyWithResponse(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error) {
	rsp, err := c.UpdatePolicyWithBody(ctx, policyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePolicyResponse(rsp)
}

func (c *ClientWithResponses) UpdatePolicyWithResponse(ctx context.Context, policyId string, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error) {
	rsp, err := c.UpdatePolicy(ctx, policyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePolicyResponse(rsp)
}

// ListUsersWithResponse request returning *ListUsersResponse
func (c *ClientWithResponses) ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error) {
	rsp, err := c.ListUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersResponse(rsp)
}

// CreateUserWithBodyWithResponse request with arbitrary body returning *CreateUserResponse
func (c *ClientWithResponses) CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

func (c *ClientWithResponses) CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// ListUserCredentialsWithResponse request returning *ListUserCredentialsResponse
func (c *ClientWithResponses) ListUserCredentialsWithResponse(ctx context.Context, userId string, params *ListUserCredentialsParams, reqEditors ...RequestEditorFn) (*ListUserCredentialsResponse, error) {
	rsp, err := c.ListUserCredentials(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserCredentialsResponse(rsp)
}

// CreateCredentialsWithResponse request returning *CreateCredentialsResponse
func (c *ClientWithResponses) CreateCredentialsWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*CreateCredentialsResponse, error) {
	rsp, err := c.CreateCredentials(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCredentialsResponse(rsp)
}

// DeleteCredentialsWithResponse request returning *DeleteCredentialsResponse
func (c *ClientWithResponses) DeleteCredentialsWithResponse(ctx context.Context, userId string, accessKeyId string, reqEditors ...RequestEditorFn) (*DeleteCredentialsResponse, error) {
	rsp, err := c.DeleteCredentials(ctx, userId, accessKeyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCredentialsResponse(rsp)
}

// GetCredentialsWithResponse request returning *GetCredentialsResponse
func (c *ClientWithResponses) GetCredentialsWithResponse(ctx context.Context, userId string, accessKeyId string, reqEditors ...RequestEditorFn) (*GetCredentialsResponse, error) {
	rsp, err := c.GetCredentials(ctx, userId, accessKeyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCredentialsResponse(rsp)
}

// DeleteUserExternalPrincipalWithResponse request returning *DeleteUserExternalPrincipalResponse
func (c *ClientWithResponses) DeleteUserExternalPrincipalWithResponse(ctx context.Context, userId string, params *DeleteUserExternalPrincipalParams, reqEditors ...RequestEditorFn) (*DeleteUserExternalPrincipalResponse, error) {
	rsp, err := c.DeleteUserExternalPrincipal(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserExternalPrincipalResponse(rsp)
}

// CreateUserExternalPrincipalWithBodyWithResponse request with arbitrary body returning *CreateUserExternalPrincipalResponse
func (c *ClientWithResponses) CreateUserExternalPrincipalWithBodyWithResponse(ctx context.Context, userId string, params *CreateUserExternalPrincipalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserExternalPrincipalResponse, error) {
	rsp, err := c.CreateUserExternalPrincipalWithBody(ctx, userId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserExternalPrincipalResponse(rsp)
}

func (c *ClientWithResponses) CreateUserExternalPrincipalWithResponse(ctx context.Context, userId string, params *CreateUserExternalPrincipalParams, body CreateUserExternalPrincipalJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserExternalPrincipalResponse, error) {
	rsp, err := c.CreateUserExternalPrincipal(ctx, userId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserExternalPrincipalResponse(rsp)
}

// ListUserExternalPrincipalsWithResponse request returning *ListUserExternalPrincipalsResponse
func (c *ClientWithResponses) ListUserExternalPrincipalsWithResponse(ctx context.Context, userId string, params *ListUserExternalPrincipalsParams, reqEditors ...RequestEditorFn) (*ListUserExternalPrincipalsResponse, error) {
	rsp, err := c.ListUserExternalPrincipals(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserExternalPrincipalsResponse(rsp)
}

// ListUserGroupsWithResponse request returning *ListUserGroupsResponse
func (c *ClientWithResponses) ListUserGroupsWithResponse(ctx context.Context, userId string, params *ListUserGroupsParams, reqEditors ...RequestEditorFn) (*ListUserGroupsResponse, error) {
	rsp, err := c.ListUserGroups(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserGroupsResponse(rsp)
}

// ListUserPoliciesWithResponse request returning *ListUserPoliciesResponse
func (c *ClientWithResponses) ListUserPoliciesWithResponse(ctx context.Context, userId string, params *ListUserPoliciesParams, reqEditors ...RequestEditorFn) (*ListUserPoliciesResponse, error) {
	rsp, err := c.ListUserPolicies(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserPoliciesResponse(rsp)
}

// DetachPolicyFromUserWithResponse request returning *DetachPolicyFromUserResponse
func (c *ClientWithResponses) DetachPolicyFromUserWithResponse(ctx context.Context, userId string, policyId string, reqEditors ...RequestEditorFn) (*DetachPolicyFromUserResponse, error) {
	rsp, err := c.DetachPolicyFromUser(ctx, userId, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDetachPolicyFromUserResponse(rsp)
}

// AttachPolicyToUserWithResponse request returning *AttachPolicyToUserResponse
func (c *ClientWithResponses) AttachPolicyToUserWithResponse(ctx context.Context, userId string, policyId string, reqEditors ...RequestEditorFn) (*AttachPolicyToUserResponse, error) {
	rsp, err := c.AttachPolicyToUser(ctx, userId, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachPolicyToUserResponse(rsp)
}

// GetConfigWithResponse request returning *GetConfigResponse
func (c *ClientWithResponses) GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigResponse, error) {
	rsp, err := c.GetConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigResponse(rsp)
}

// GetGarbageCollectionConfigWithResponse request returning *GetGarbageCollectionConfigResponse
func (c *ClientWithResponses) GetGarbageCollectionConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGarbageCollectionConfigResponse, error) {
	rsp, err := c.GetGarbageCollectionConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGarbageCollectionConfigResponse(rsp)
}

// GetStorageConfigWithResponse request returning *GetStorageConfigResponse
func (c *ClientWithResponses) GetStorageConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStorageConfigResponse, error) {
	rsp, err := c.GetStorageConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStorageConfigResponse(rsp)
}

// GetLakeFSVersionWithResponse request returning *GetLakeFSVersionResponse
func (c *ClientWithResponses) GetLakeFSVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLakeFSVersionResponse, error) {
	rsp, err := c.GetLakeFSVersion(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLakeFSVersionResponse(rsp)
}

// HealthCheckWithResponse request returning *HealthCheckResponse
func (c *ClientWithResponses) HealthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error) {
	rsp, err := c.HealthCheck(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthCheckResponse(rsp)
}

// ListRepositoriesWithResponse request returning *ListRepositoriesResponse
func (c *ClientWithResponses) ListRepositoriesWithResponse(ctx context.Context, params *ListRepositoriesParams, reqEditors ...RequestEditorFn) (*ListRepositoriesResponse, error) {
	rsp, err := c.ListRepositories(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRepositoriesResponse(rsp)
}

// CreateRepositoryWithBodyWithResponse request with arbitrary body returning *CreateRepositoryResponse
func (c *ClientWithResponses) CreateRepositoryWithBodyWithResponse(ctx context.Context, params *CreateRepositoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRepositoryResponse, error) {
	rsp, err := c.CreateRepositoryWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRepositoryResponse(rsp)
}

func (c *ClientWithResponses) CreateRepositoryWithResponse(ctx context.Context, params *CreateRepositoryParams, body CreateRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRepositoryResponse, error) {
	rsp, err := c.CreateRepository(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRepositoryResponse(rsp)
}

// DeleteRepositoryWithResponse request returning *DeleteRepositoryResponse
func (c *ClientWithResponses) DeleteRepositoryWithResponse(ctx context.Context, repository string, params *DeleteRepositoryParams, reqEditors ...RequestEditorFn) (*DeleteRepositoryResponse, error) {
	rsp, err := c.DeleteRepository(ctx, repository, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRepositoryResponse(rsp)
}

// GetRepositoryWithResponse request returning *GetRepositoryResponse
func (c *ClientWithResponses) GetRepositoryWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*GetRepositoryResponse, error) {
	rsp, err := c.GetRepository(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRepositoryResponse(rsp)
}

// ListRepositoryRunsWithResponse request returning *ListRepositoryRunsResponse
func (c *ClientWithResponses) ListRepositoryRunsWithResponse(ctx context.Context, repository string, params *ListRepositoryRunsParams, reqEditors ...RequestEditorFn) (*ListRepositoryRunsResponse, error) {
	rsp, err := c.ListRepositoryRuns(ctx, repository, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRepositoryRunsResponse(rsp)
}

// GetRunWithResponse request returning *GetRunResponse
func (c *ClientWithResponses) GetRunWithResponse(ctx context.Context, repository string, runId string, reqEditors ...RequestEditorFn) (*GetRunResponse, error) {
	rsp, err := c.GetRun(ctx, repository, runId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRunResponse(rsp)
}

// ListRunHooksWithResponse request returning *ListRunHooksResponse
func (c *ClientWithResponses) ListRunHooksWithResponse(ctx context.Context, repository string, runId string, params *ListRunHooksParams, reqEditors ...RequestEditorFn) (*ListRunHooksResponse, error) {
	rsp, err := c.ListRunHooks(ctx, repository, runId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRunHooksResponse(rsp)
}

// GetRunHookOutputWithResponse request returning *GetRunHookOutputResponse
func (c *ClientWithResponses) GetRunHookOutputWithResponse(ctx context.Context, repository string, runId string, hookRunId string, reqEditors ...RequestEditorFn) (*GetRunHookOutputResponse, error) {
	rsp, err := c.GetRunHookOutput(ctx, repository, runId, hookRunId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRunHookOutputResponse(rsp)
}

// InternalDeleteBranchProtectionRuleWithBodyWithResponse request with arbitrary body returning *InternalDeleteBranchProtectionRuleResponse
func (c *ClientWithResponses) InternalDeleteBranchProtectionRuleWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalDeleteBranchProtectionRuleResponse, error) {
	rsp, err := c.InternalDeleteBranchProtectionRuleWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalDeleteBranchProtectionRuleResponse(rsp)
}

func (c *ClientWithResponses) InternalDeleteBranchProtectionRuleWithResponse(ctx context.Context, repository string, body InternalDeleteBranchProtectionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalDeleteBranchProtectionRuleResponse, error) {
	rsp, err := c.InternalDeleteBranchProtectionRule(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalDeleteBranchProtectionRuleResponse(rsp)
}

// InternalGetBranchProtectionRulesWithResponse request returning *InternalGetBranchProtectionRulesResponse
func (c *ClientWithResponses) InternalGetBranchProtectionRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*InternalGetBranchProtectionRulesResponse, error) {
	rsp, err := c.InternalGetBranchProtectionRules(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalGetBranchProtectionRulesResponse(rsp)
}

// InternalCreateBranchProtectionRuleWithBodyWithResponse request with arbitrary body returning *InternalCreateBranchProtectionRuleResponse
func (c *ClientWithResponses) InternalCreateBranchProtectionRuleWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalCreateBranchProtectionRuleResponse, error) {
	rsp, err := c.InternalCreateBranchProtectionRuleWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalCreateBranchProtectionRuleResponse(rsp)
}

func (c *ClientWithResponses) InternalCreateBranchProtectionRuleWithResponse(ctx context.Context, repository string, body InternalCreateBranchProtectionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalCreateBranchProtectionRuleResponse, error) {
	rsp, err := c.InternalCreateBranchProtectionRule(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalCreateBranchProtectionRuleResponse(rsp)
}

// CreateBranchProtectionRulePreflightWithResponse request returning *CreateBranchProtectionRulePreflightResponse
func (c *ClientWithResponses) CreateBranchProtectionRulePreflightWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*CreateBranchProtectionRulePreflightResponse, error) {
	rsp, err := c.CreateBranchProtectionRulePreflight(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBranchProtectionRulePreflightResponse(rsp)
}

// ListBranchesWithResponse request returning *ListBranchesResponse
func (c *ClientWithResponses) ListBranchesWithResponse(ctx context.Context, repository string, params *ListBranchesParams, reqEditors ...RequestEditorFn) (*ListBranchesResponse, error) {
	rsp, err := c.ListBranches(ctx, repository, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBranchesResponse(rsp)
}

// CreateBranchWithBodyWithResponse request with arbitrary body returning *CreateBranchResponse
func (c *ClientWithResponses) CreateBranchWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBranchResponse, error) {
	rsp, err := c.CreateBranchWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBranchResponse(rsp)
}

func (c *ClientWithResponses) CreateBranchWithResponse(ctx context.Context, repository string, body CreateBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBranchResponse, error) {
	rsp, err := c.CreateBranch(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBranchResponse(rsp)
}

// DeleteBranchWithResponse request returning *DeleteBranchResponse
func (c *ClientWithResponses) DeleteBranchWithResponse(ctx context.Context, repository string, branch string, params *DeleteBranchParams, reqEditors ...RequestEditorFn) (*DeleteBranchResponse, error) {
	rsp, err := c.DeleteBranch(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBranchResponse(rsp)
}

// GetBranchWithResponse request returning *GetBranchResponse
func (c *ClientWithResponses) GetBranchWithResponse(ctx context.Context, repository string, branch string, reqEditors ...RequestEditorFn) (*GetBranchResponse, error) {
	rsp, err := c.GetBranch(ctx, repository, branch, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBranchResponse(rsp)
}

// ResetBranchWithBodyWithResponse request with arbitrary body returning *ResetBranchResponse
func (c *ClientWithResponses) ResetBranchWithBodyWithResponse(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetBranchResponse, error) {
	rsp, err := c.ResetBranchWithBody(ctx, repository, branch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetBranchResponse(rsp)
}

func (c *ClientWithResponses) ResetBranchWithResponse(ctx context.Context, repository string, branch string, body ResetBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetBranchResponse, error) {
	rsp, err := c.ResetBranch(ctx, repository, branch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetBranchResponse(rsp)
}

// CherryPickWithBodyWithResponse request with arbitrary body returning *CherryPickResponse
func (c *ClientWithResponses) CherryPickWithBodyWithResponse(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CherryPickResponse, error) {
	rsp, err := c.CherryPickWithBody(ctx, repository, branch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCherryPickResponse(rsp)
}

func (c *ClientWithResponses) CherryPickWithResponse(ctx context.Context, repository string, branch string, body CherryPickJSONRequestBody, reqEditors ...RequestEditorFn) (*CherryPickResponse, error) {
	rsp, err := c.CherryPick(ctx, repository, branch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCherryPickResponse(rsp)
}

// CommitWithBodyWithResponse request with arbitrary body returning *CommitResponse
func (c *ClientWithResponses) CommitWithBodyWithResponse(ctx context.Context, repository string, branch string, params *CommitParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommitResponse, error) {
	rsp, err := c.CommitWithBody(ctx, repository, branch, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitResponse(rsp)
}

func (c *ClientWithResponses) CommitWithResponse(ctx context.Context, repository string, branch string, params *CommitParams, body CommitJSONRequestBody, reqEditors ...RequestEditorFn) (*CommitResponse, error) {
	rsp, err := c.Commit(ctx, repository, branch, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitResponse(rsp)
}

// DiffBranchWithResponse request returning *DiffBranchResponse
func (c *ClientWithResponses) DiffBranchWithResponse(ctx context.Context, repository string, branch string, params *DiffBranchParams, reqEditors ...RequestEditorFn) (*DiffBranchResponse, error) {
	rsp, err := c.DiffBranch(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDiffBranchResponse(rsp)
}

// HardResetBranchWithResponse request returning *HardResetBranchResponse
func (c *ClientWithResponses) HardResetBranchWithResponse(ctx context.Context, repository string, branch string, params *HardResetBranchParams, reqEditors ...RequestEditorFn) (*HardResetBranchResponse, error) {
	rsp, err := c.HardResetBranch(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHardResetBranchResponse(rsp)
}

// ImportCancelWithResponse request returning *ImportCancelResponse
func (c *ClientWithResponses) ImportCancelWithResponse(ctx context.Context, repository string, branch string, params *ImportCancelParams, reqEditors ...RequestEditorFn) (*ImportCancelResponse, error) {
	rsp, err := c.ImportCancel(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportCancelResponse(rsp)
}

// ImportStatusWithResponse request returning *ImportStatusResponse
func (c *ClientWithResponses) ImportStatusWithResponse(ctx context.Context, repository string, branch string, params *ImportStatusParams, reqEditors ...RequestEditorFn) (*ImportStatusResponse, error) {
	rsp, err := c.ImportStatus(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportStatusResponse(rsp)
}

// ImportStartWithBodyWithResponse request with arbitrary body returning *ImportStartResponse
func (c *ClientWithResponses) ImportStartWithBodyWithResponse(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportStartResponse, error) {
	rsp, err := c.ImportStartWithBody(ctx, repository, branch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportStartResponse(rsp)
}

func (c *ClientWithResponses) ImportStartWithResponse(ctx context.Context, repository string, branch string, body ImportStartJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportStartResponse, error) {
	rsp, err := c.ImportStart(ctx, repository, branch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportStartResponse(rsp)
}

// DeleteObjectWithResponse request returning *DeleteObjectResponse
func (c *ClientWithResponses) DeleteObjectWithResponse(ctx context.Context, repository string, branch string, params *DeleteObjectParams, reqEditors ...RequestEditorFn) (*DeleteObjectResponse, error) {
	rsp, err := c.DeleteObject(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteObjectResponse(rsp)
}

// UploadObjectWithBodyWithResponse request with arbitrary body returning *UploadObjectResponse
func (c *ClientWithResponses) UploadObjectWithBodyWithResponse(ctx context.Context, repository string, branch string, params *UploadObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadObjectResponse, error) {
	rsp, err := c.UploadObjectWithBody(ctx, repository, branch, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadObjectResponse(rsp)
}

// StageObjectWithBodyWithResponse request with arbitrary body returning *StageObjectResponse
func (c *ClientWithResponses) StageObjectWithBodyWithResponse(ctx context.Context, repository string, branch string, params *StageObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StageObjectResponse, error) {
	rsp, err := c.StageObjectWithBody(ctx, repository, branch, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStageObjectResponse(rsp)
}

func (c *ClientWithResponses) StageObjectWithResponse(ctx context.Context, repository string, branch string, params *StageObjectParams, body StageObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*StageObjectResponse, error) {
	rsp, err := c.StageObject(ctx, repository, branch, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStageObjectResponse(rsp)
}

// CopyObjectWithBodyWithResponse request with arbitrary body returning *CopyObjectResponse
func (c *ClientWithResponses) CopyObjectWithBodyWithResponse(ctx context.Context, repository string, branch string, params *CopyObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CopyObjectResponse, error) {
	rsp, err := c.CopyObjectWithBody(ctx, repository, branch, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCopyObjectResponse(rsp)
}

func (c *ClientWithResponses) CopyObjectWithResponse(ctx context.Context, repository string, branch string, params *CopyObjectParams, body CopyObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CopyObjectResponse, error) {
	rsp, err := c.CopyObject(ctx, repository, branch, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCopyObjectResponse(rsp)
}

// DeleteObjectsWithBodyWithResponse request with arbitrary body returning *DeleteObjectsResponse
func (c *ClientWithResponses) DeleteObjectsWithBodyWithResponse(ctx context.Context, repository string, branch string, params *DeleteObjectsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteObjectsResponse, error) {
	rsp, err := c.DeleteObjectsWithBody(ctx, repository, branch, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteObjectsResponse(rsp)
}

func (c *ClientWithResponses) DeleteObjectsWithResponse(ctx context.Context, repository string, branch string, params *DeleteObjectsParams, body DeleteObjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteObjectsResponse, error) {
	rsp, err := c.DeleteObjects(ctx, repository, branch, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteObjectsResponse(rsp)
}

// UploadObjectPreflightWithResponse request returning *UploadObjectPreflightResponse
func (c *ClientWithResponses) UploadObjectPreflightWithResponse(ctx context.Context, repository string, branch string, params *UploadObjectPreflightParams, reqEditors ...RequestEditorFn) (*UploadObjectPreflightResponse, error) {
	rsp, err := c.UploadObjectPreflight(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadObjectPreflightResponse(rsp)
}

// RevertBranchWithBodyWithResponse request with arbitrary body returning *RevertBranchResponse
func (c *ClientWithResponses) RevertBranchWithBodyWithResponse(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevertBranchResponse, error) {
	rsp, err := c.RevertBranchWithBody(ctx, repository, branch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevertBranchResponse(rsp)
}

func (c *ClientWithResponses) RevertBranchWithResponse(ctx context.Context, repository string, branch string, body RevertBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*RevertBranchResponse, error) {
	rsp, err := c.RevertBranch(ctx, repository, branch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevertBranchResponse(rsp)
}

// GetPhysicalAddressWithResponse request returning *GetPhysicalAddressResponse
func (c *ClientWithResponses) GetPhysicalAddressWithResponse(ctx context.Context, repository string, branch string, params *GetPhysicalAddressParams, reqEditors ...RequestEditorFn) (*GetPhysicalAddressResponse, error) {
	rsp, err := c.GetPhysicalAddress(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPhysicalAddressResponse(rsp)
}

// LinkPhysicalAddressWithBodyWithResponse request with arbitrary body returning *LinkPhysicalAddressResponse
func (c *ClientWithResponses) LinkPhysicalAddressWithBodyWithResponse(ctx context.Context, repository string, branch string, params *LinkPhysicalAddressParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkPhysicalAddressResponse, error) {
	rsp, err := c.LinkPhysicalAddressWithBody(ctx, repository, branch, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkPhysicalAddressResponse(rsp)
}

func (c *ClientWithResponses) LinkPhysicalAddressWithResponse(ctx context.Context, repository string, branch string, params *LinkPhysicalAddressParams, body LinkPhysicalAddressJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkPhysicalAddressResponse, error) {
	rsp, err := c.LinkPhysicalAddress(ctx, repository, branch, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkPhysicalAddressResponse(rsp)
}

// CreatePresignMultipartUploadWithResponse request returning *CreatePresignMultipartUploadResponse
func (c *ClientWithResponses) CreatePresignMultipartUploadWithResponse(ctx context.Context, repository string, branch string, params *CreatePresignMultipartUploadParams, reqEditors ...RequestEditorFn) (*CreatePresignMultipartUploadResponse, error) {
	rsp, err := c.CreatePresignMultipartUpload(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePresignMultipartUploadResponse(rsp)
}

// AbortPresignMultipartUploadWithBodyWithResponse request with arbitrary body returning *AbortPresignMultipartUploadResponse
func (c *ClientWithResponses) AbortPresignMultipartUploadWithBodyWithResponse(ctx context.Context, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AbortPresignMultipartUploadResponse, error) {
	rsp, err := c.AbortPresignMultipartUploadWithBody(ctx, repository, branch, uploadId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAbortPresignMultipartUploadResponse(rsp)
}

func (c *ClientWithResponses) AbortPresignMultipartUploadWithResponse(ctx context.Context, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, body AbortPresignMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*AbortPresignMultipartUploadResponse, error) {
	rsp, err := c.AbortPresignMultipartUpload(ctx, repository, branch, uploadId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAbortPresignMultipartUploadResponse(rsp)
}

// CompletePresignMultipartUploadWithBodyWithResponse request with arbitrary body returning *CompletePresignMultipartUploadResponse
func (c *ClientWithResponses) CompletePresignMultipartUploadWithBodyWithResponse(ctx context.Context, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompletePresignMultipartUploadResponse, error) {
	rsp, err := c.CompletePresignMultipartUploadWithBody(ctx, repository, branch, uploadId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompletePresignMultipartUploadResponse(rsp)
}

func (c *ClientWithResponses) CompletePresignMultipartUploadWithResponse(ctx context.Context, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, body CompletePresignMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*CompletePresignMultipartUploadResponse, error) {
	rsp, err := c.CompletePresignMultipartUpload(ctx, repository, branch, uploadId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompletePresignMultipartUploadResponse(rsp)
}

// CreateCommitRecordWithBodyWithResponse request with arbitrary body returning *CreateCommitRecordResponse
func (c *ClientWithResponses) CreateCommitRecordWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCommitRecordResponse, error) {
	rsp, err := c.CreateCommitRecordWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCommitRecordResponse(rsp)
}

func (c *ClientWithResponses) CreateCommitRecordWithResponse(ctx context.Context, repository string, body CreateCommitRecordJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCommitRecordResponse, error) {
	rsp, err := c.CreateCommitRecord(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCommitRecordResponse(rsp)
}

// GetCommitWithResponse request returning *GetCommitResponse
func (c *ClientWithResponses) GetCommitWithResponse(ctx context.Context, repository string, commitId string, reqEditors ...RequestEditorFn) (*GetCommitResponse, error) {
	rsp, err := c.GetCommit(ctx, repository, commitId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCommitResponse(rsp)
}

// DumpStatusWithResponse request returning *DumpStatusResponse
func (c *ClientWithResponses) DumpStatusWithResponse(ctx context.Context, repository string, params *DumpStatusParams, reqEditors ...RequestEditorFn) (*DumpStatusResponse, error) {
	rsp, err := c.DumpStatus(ctx, repository, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDumpStatusResponse(rsp)
}

// DumpSubmitWithResponse request returning *DumpSubmitResponse
func (c *ClientWithResponses) DumpSubmitWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*DumpSubmitResponse, error) {
	rsp, err := c.DumpSubmit(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDumpSubmitResponse(rsp)
}

// PrepareGarbageCollectionCommitsWithResponse request returning *PrepareGarbageCollectionCommitsResponse
func (c *ClientWithResponses) PrepareGarbageCollectionCommitsWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*PrepareGarbageCollectionCommitsResponse, error) {
	rsp, err := c.PrepareGarbageCollectionCommits(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareGarbageCollectionCommitsResponse(rsp)
}

// PrepareGarbageCollectionUncommittedWithBodyWithResponse request with arbitrary body returning *PrepareGarbageCollectionUncommittedResponse
func (c *ClientWithResponses) PrepareGarbageCollectionUncommittedWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrepareGarbageCollectionUncommittedResponse, error) {
	rsp, err := c.PrepareGarbageCollectionUncommittedWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareGarbageCollectionUncommittedResponse(rsp)
}

func (c *ClientWithResponses) PrepareGarbageCollectionUncommittedWithResponse(ctx context.Context, repository string, body PrepareGarbageCollectionUncommittedJSONRequestBody, reqEditors ...RequestEditorFn) (*PrepareGarbageCollectionUncommittedResponse, error) {
	rsp, err := c.PrepareGarbageCollectionUncommitted(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareGarbageCollectionUncommittedResponse(rsp)
}

// InternalDeleteGarbageCollectionRulesWithResponse request returning *InternalDeleteGarbageCollectionRulesResponse
func (c *ClientWithResponses) InternalDeleteGarbageCollectionRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*InternalDeleteGarbageCollectionRulesResponse, error) {
	rsp, err := c.InternalDeleteGarbageCollectionRules(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalDeleteGarbageCollectionRulesResponse(rsp)
}

// InternalGetGarbageCollectionRulesWithResponse request returning *InternalGetGarbageCollectionRulesResponse
func (c *ClientWithResponses) InternalGetGarbageCollectionRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*InternalGetGarbageCollectionRulesResponse, error) {
	rsp, err := c.InternalGetGarbageCollectionRules(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalGetGarbageCollectionRulesResponse(rsp)
}

// InternalSetGarbageCollectionRulesWithBodyWithResponse request with arbitrary body returning *InternalSetGarbageCollectionRulesResponse
func (c *ClientWithResponses) InternalSetGarbageCollectionRulesWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalSetGarbageCollectionRulesResponse, error) {
	rsp, err := c.InternalSetGarbageCollectionRulesWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalSetGarbageCollectionRulesResponse(rsp)
}

func (c *ClientWithResponses) InternalSetGarbageCollectionRulesWithResponse(ctx context.Context, repository string, body InternalSetGarbageCollectionRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalSetGarbageCollectionRulesResponse, error) {
	rsp, err := c.InternalSetGarbageCollectionRules(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalSetGarbageCollectionRulesResponse(rsp)
}

// SetGarbageCollectionRulesPreflightWithResponse request returning *SetGarbageCollectionRulesPreflightResponse
func (c *ClientWithResponses) SetGarbageCollectionRulesPreflightWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*SetGarbageCollectionRulesPreflightResponse, error) {
	rsp, err := c.SetGarbageCollectionRulesPreflight(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetGarbageCollectionRulesPreflightResponse(rsp)
}

// DeleteRepositoryMetadataWithBodyWithResponse request with arbitrary body returning *DeleteRepositoryMetadataResponse
func (c *ClientWithResponses) DeleteRepositoryMetadataWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteRepositoryMetadataResponse, error) {
	rsp, err := c.DeleteRepositoryMetadataWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRepositoryMetadataResponse(rsp)
}

func (c *ClientWithResponses) DeleteRepositoryMetadataWithResponse(ctx context.Context, repository string, body DeleteRepositoryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteRepositoryMetadataResponse, error) {
	rsp, err := c.DeleteRepositoryMetadata(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRepositoryMetadataResponse(rsp)
}

// GetRepositoryMetadataWithResponse request returning *GetRepositoryMetadataResponse
func (c *ClientWithResponses) GetRepositoryMetadataWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*GetRepositoryMetadataResponse, error) {
	rsp, err := c.GetRepositoryMetadata(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRepositoryMetadataResponse(rsp)
}

// SetRepositoryMetadataWithBodyWithResponse request with arbitrary body returning *SetRepositoryMetadataResponse
func (c *ClientWithResponses) SetRepositoryMetadataWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetRepositoryMetadataResponse, error) {
	rsp, err := c.SetRepositoryMetadataWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRepositoryMetadataResponse(rsp)
}

func (c *ClientWithResponses) SetRepositoryMetadataWithResponse(ctx context.Context, repository string, body SetRepositoryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*SetRepositoryMetadataResponse, error) {
	rsp, err := c.SetRepositoryMetadata(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRepositoryMetadataResponse(rsp)
}

// GetMetaRangeWithResponse request returning *GetMetaRangeResponse
func (c *ClientWithResponses) GetMetaRangeWithResponse(ctx context.Context, repository string, metaRange string, reqEditors ...RequestEditorFn) (*GetMetaRangeResponse, error) {
	rsp, err := c.GetMetaRange(ctx, repository, metaRange, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMetaRangeResponse(rsp)
}

// GetRangeWithResponse request returning *GetRangeResponse
func (c *ClientWithResponses) GetRangeWithResponse(ctx context.Context, repository string, pRange string, reqEditors ...RequestEditorFn) (*GetRangeResponse, error) {
	rsp, err := c.GetRange(ctx, repository, pRange, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRangeResponse(rsp)
}

// DumpRefsWithResponse request returning *DumpRefsResponse
func (c *ClientWithResponses) DumpRefsWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*DumpRefsResponse, error) {
	rsp, err := c.DumpRefs(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDumpRefsResponse(rsp)
}

// RestoreRefsWithBodyWithResponse request with arbitrary body returning *RestoreRefsResponse
func (c *ClientWithResponses) RestoreRefsWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestoreRefsResponse, error) {
	rsp, err := c.RestoreRefsWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreRefsResponse(rsp)
}

func (c *ClientWithResponses) RestoreRefsWithResponse(ctx context.Context, repository string, body RestoreRefsJSONRequestBody, reqEditors ...RequestEditorFn) (*RestoreRefsResponse, error) {
	rsp, err := c.RestoreRefs(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreRefsResponse(rsp)
}

// CreateSymlinkFileWithResponse request returning *CreateSymlinkFileResponse
func (c *ClientWithResponses) CreateSymlinkFileWithResponse(ctx context.Context, repository string, branch string, params *CreateSymlinkFileParams, reqEditors ...RequestEditorFn) (*CreateSymlinkFileResponse, error) {
	rsp, err := c.CreateSymlinkFile(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSymlinkFileResponse(rsp)
}

// DiffRefsWithResponse request returning *DiffRefsResponse
func (c *ClientWithResponses) DiffRefsWithResponse(ctx context.Context, repository string, leftRef string, rightRef string, params *DiffRefsParams, reqEditors ...RequestEditorFn) (*DiffRefsResponse, error) {
	rsp, err := c.DiffRefs(ctx, repository, leftRef, rightRef, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDiffRefsResponse(rsp)
}

// LogCommitsWithResponse request returning *LogCommitsResponse
func (c *ClientWithResponses) LogCommitsWithResponse(ctx context.Context, repository string, ref string, params *LogCommitsParams, reqEditors ...RequestEditorFn) (*LogCommitsResponse, error) {
	rsp, err := c.LogCommits(ctx, repository, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogCommitsResponse(rsp)
}

// GetObjectWithResponse request returning *GetObjectResponse
func (c *ClientWithResponses) GetObjectWithResponse(ctx context.Context, repository string, ref string, params *GetObjectParams, reqEditors ...RequestEditorFn) (*GetObjectResponse, error) {
	rsp, err := c.GetObject(ctx, repository, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetObjectResponse(rsp)
}

// HeadObjectWithResponse request returning *HeadObjectResponse
func (c *ClientWithResponses) HeadObjectWithResponse(ctx context.Context, repository string, ref string, params *HeadObjectParams, reqEditors ...RequestEditorFn) (*HeadObjectResponse, error) {
	rsp, err := c.HeadObject(ctx, repository, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeadObjectResponse(rsp)
}

// ListObjectsWithResponse request returning *ListObjectsResponse
func (c *ClientWithResponses) ListObjectsWithResponse(ctx context.Context, repository string, ref string, params *ListObjectsParams, reqEditors ...RequestEditorFn) (*ListObjectsResponse, error) {
	rsp, err := c.ListObjects(ctx, repository, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListObjectsResponse(rsp)
}

// StatObjectWithResponse request returning *StatObjectResponse
func (c *ClientWithResponses) StatObjectWithResponse(ctx context.Context, repository string, ref string, params *StatObjectParams, reqEditors ...RequestEditorFn) (*StatObjectResponse, error) {
	rsp, err := c.StatObject(ctx, repository, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatObjectResponse(rsp)
}

// GetUnderlyingPropertiesWithResponse request returning *GetUnderlyingPropertiesResponse
func (c *ClientWithResponses) GetUnderlyingPropertiesWithResponse(ctx context.Context, repository string, ref string, params *GetUnderlyingPropertiesParams, reqEditors ...RequestEditorFn) (*GetUnderlyingPropertiesResponse, error) {
	rsp, err := c.GetUnderlyingProperties(ctx, repository, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUnderlyingPropertiesResponse(rsp)
}

// FindMergeBaseWithResponse request returning *FindMergeBaseResponse
func (c *ClientWithResponses) FindMergeBaseWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, reqEditors ...RequestEditorFn) (*FindMergeBaseResponse, error) {
	rsp, err := c.FindMergeBase(ctx, repository, sourceRef, destinationBranch, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindMergeBaseResponse(rsp)
}

// MergeIntoBranchWithBodyWithResponse request with arbitrary body returning *MergeIntoBranchResponse
func (c *ClientWithResponses) MergeIntoBranchWithBodyWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeIntoBranchResponse, error) {
	rsp, err := c.MergeIntoBranchWithBody(ctx, repository, sourceRef, destinationBranch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeIntoBranchResponse(rsp)
}

func (c *ClientWithResponses) MergeIntoBranchWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, body MergeIntoBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeIntoBranchResponse, error) {
	rsp, err := c.MergeIntoBranch(ctx, repository, sourceRef, destinationBranch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeIntoBranchResponse(rsp)
}

// RestoreStatusWithResponse request returning *RestoreStatusResponse
func (c *ClientWithResponses) RestoreStatusWithResponse(ctx context.Context, repository string, params *RestoreStatusParams, reqEditors ...RequestEditorFn) (*RestoreStatusResponse, error) {
	rsp, err := c.RestoreStatus(ctx, repository, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreStatusResponse(rsp)
}

// RestoreSubmitWithBodyWithResponse request with arbitrary body returning *RestoreSubmitResponse
func (c *ClientWithResponses) RestoreSubmitWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestoreSubmitResponse, error) {
	rsp, err := c.RestoreSubmitWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreSubmitResponse(rsp)
}

func (c *ClientWithResponses) RestoreSubmitWithResponse(ctx context.Context, repository string, body RestoreSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*RestoreSubmitResponse, error) {
	rsp, err := c.RestoreSubmit(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreSubmitResponse(rsp)
}

// GetBranchProtectionRulesWithResponse request returning *GetBranchProtectionRulesResponse
func (c *ClientWithResponses) GetBranchProtectionRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*GetBranchProtectionRulesResponse, error) {
	rsp, err := c.GetBranchProtectionRules(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBranchProtectionRulesResponse(rsp)
}

// SetBranchProtectionRulesWithBodyWithResponse request with arbitrary body returning *SetBranchProtectionRulesResponse
func (c *ClientWithResponses) SetBranchProtectionRulesWithBodyWithResponse(ctx context.Context, repository string, params *SetBranchProtectionRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetBranchProtectionRulesResponse, error) {
	rsp, err := c.SetBranchProtectionRulesWithBody(ctx, repository, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetBranchProtectionRulesResponse(rsp)
}

func (c *ClientWithResponses) SetBranchProtectionRulesWithResponse(ctx context.Context, repository string, params *SetBranchProtectionRulesParams, body SetBranchProtectionRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetBranchProtectionRulesResponse, error) {
	rsp, err := c.SetBranchProtectionRules(ctx, repository, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetBranchProtectionRulesResponse(rsp)
}

// DeleteGCRulesWithResponse request returning *DeleteGCRulesResponse
func (c *ClientWithResponses) DeleteGCRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*DeleteGCRulesResponse, error) {
	rsp, err := c.DeleteGCRules(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGCRulesResponse(rsp)
}

// GetGCRulesWithResponse request returning *GetGCRulesResponse
func (c *ClientWithResponses) GetGCRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*GetGCRulesResponse, error) {
	rsp, err := c.GetGCRules(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGCRulesResponse(rsp)
}

// SetGCRulesWithBodyWithResponse request with arbitrary body returning *SetGCRulesResponse
func (c *ClientWithResponses) SetGCRulesWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetGCRulesResponse, error) {
	rsp, err := c.SetGCRulesWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetGCRulesResponse(rsp)
}

func (c *ClientWithResponses) SetGCRulesWithResponse(ctx context.Context, repository string, body SetGCRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetGCRulesResponse, error) {
	rsp, err := c.SetGCRules(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetGCRulesResponse(rsp)
}

// ListTagsWithResponse request returning *ListTagsResponse
func (c *ClientWithResponses) ListTagsWithResponse(ctx context.Context, repository string, params *ListTagsParams, reqEditors ...RequestEditorFn) (*ListTagsResponse, error) {
	rsp, err := c.ListTags(ctx, repository, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTagsResponse(rsp)
}

// CreateTagWithBodyWithResponse request with arbitrary body returning *CreateTagResponse
func (c *ClientWithResponses) CreateTagWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTagResponse, error) {
	rsp, err := c.CreateTagWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTagResponse(rsp)
}

func (c *ClientWithResponses) CreateTagWithResponse(ctx context.Context, repository string, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTagResponse, error) {
	rsp, err := c.CreateTag(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTagResponse(rsp)
}

// DeleteTagWithResponse request returning *DeleteTagResponse
func (c *ClientWithResponses) DeleteTagWithResponse(ctx context.Context, repository string, tag string, params *DeleteTagParams, reqEditors ...RequestEditorFn) (*DeleteTagResponse, error) {
	rsp, err := c.DeleteTag(ctx, repository, tag, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTagResponse(rsp)
}

// GetTagWithResponse request returning *GetTagResponse
func (c *ClientWithResponses) GetTagWithResponse(ctx context.Context, repository string, tag string, reqEditors ...RequestEditorFn) (*GetTagResponse, error) {
	rsp, err := c.GetTag(ctx, repository, tag, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTagResponse(rsp)
}

// SetupCommPrefsWithBodyWithResponse request with arbitrary body returning *SetupCommPrefsResponse
func (c *ClientWithResponses) SetupCommPrefsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetupCommPrefsResponse, error) {
	rsp, err := c.SetupCommPrefsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetupCommPrefsResponse(rsp)
}

func (c *ClientWithResponses) SetupCommPrefsWithResponse(ctx context.Context, body SetupCommPrefsJSONRequestBody, reqEditors ...RequestEditorFn) (*SetupCommPrefsResponse, error) {
	rsp, err := c.SetupCommPrefs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetupCommPrefsResponse(rsp)
}

// GetSetupStateWithResponse request returning *GetSetupStateResponse
func (c *ClientWithResponses) GetSetupStateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSetupStateResponse, error) {
	rsp, err := c.GetSetupState(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSetupStateResponse(rsp)
}

// SetupWithBodyWithResponse request with arbitrary body returning *SetupResponse
func (c *ClientWithResponses) SetupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetupResponse, error) {
	rsp, err := c.SetupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetupResponse(rsp)
}

func (c *ClientWithResponses) SetupWithResponse(ctx context.Context, body SetupJSONRequestBody, reqEditors ...RequestEditorFn) (*SetupResponse, error) {
	rsp, err := c.Setup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetupResponse(rsp)
}

// PostStatsEventsWithBodyWithResponse request with arbitrary body returning *PostStatsEventsResponse
func (c *ClientWithResponses) PostStatsEventsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStatsEventsResponse, error) {
	rsp, err := c.PostStatsEventsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStatsEventsResponse(rsp)
}

func (c *ClientWithResponses) PostStatsEventsWithResponse(ctx context.Context, body PostStatsEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStatsEventsResponse, error) {
	rsp, err := c.PostStatsEvents(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStatsEventsResponse(rsp)
}

// StsLoginWithBodyWithResponse request with arbitrary body returning *StsLoginResponse
func (c *ClientWithResponses) StsLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StsLoginResponse, error) {
	rsp, err := c.StsLoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStsLoginResponse(rsp)
}

func (c *ClientWithResponses) StsLoginWithResponse(ctx context.Context, body StsLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*StsLoginResponse, error) {
	rsp, err := c.StsLogin(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStsLoginResponse(rsp)
}

// GetUsageReportSummaryWithResponse request returning *GetUsageReportSummaryResponse
func (c *ClientWithResponses) GetUsageReportSummaryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUsageReportSummaryResponse, error) {
	rsp, err := c.GetUsageReportSummary(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsageReportSummaryResponse(rsp)
}

// GetCurrentUserWithResponse request returning *GetCurrentUserResponse
func (c *ClientWithResponses) GetCurrentUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentUserResponse, error) {
	rsp, err := c.GetCurrentUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentUserResponse(rsp)
}

// ParseGetAuthCapabilitiesResponse parses an HTTP response from a GetAuthCapabilitiesWithResponse call
func ParseGetAuthCapabilitiesResponse(rsp *http.Response) (*GetAuthCapabilitiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetAuthCapabilitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthCapabilities
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseExternalPrincipalLoginResponse parses an HTTP response from a ExternalPrincipalLoginWithResponse call
func ParseExternalPrincipalLoginResponse(rsp *http.Response) (*ExternalPrincipalLoginResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ExternalPrincipalLoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthenticationToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetExternalPrincipalResponse parses an HTTP response from a GetExternalPrincipalWithResponse call
func ParseGetExternalPrincipalResponse(rsp *http.Response) (*GetExternalPrincipalResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetExternalPrincipalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExternalPrincipal
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListGroupsResponse parses an HTTP response from a ListGroupsWithResponse call
func ParseListGroupsResponse(rsp *http.Response) (*ListGroupsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateGroupResponse parses an HTTP response from a CreateGroupWithResponse call
func ParseCreateGroupResponse(rsp *http.Response) (*CreateGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteGroupResponse parses an HTTP response from a DeleteGroupWithResponse call
func ParseDeleteGroupResponse(rsp *http.Response) (*DeleteGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetGroupResponse parses an HTTP response from a GetGroupWithResponse call
func ParseGetGroupResponse(rsp *http.Response) (*GetGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetGroupACLResponse parses an HTTP response from a GetGroupACLWithResponse call
func ParseGetGroupACLResponse(rsp *http.Response) (*GetGroupACLResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetGroupACLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ACL
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNoACL
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetGroupACLResponse parses an HTTP response from a SetGroupACLWithResponse call
func ParseSetGroupACLResponse(rsp *http.Response) (*SetGroupACLResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SetGroupACLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListGroupMembersResponse parses an HTTP response from a ListGroupMembersWithResponse call
func ParseListGroupMembersResponse(rsp *http.Response) (*ListGroupMembersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListGroupMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteGroupMembershipResponse parses an HTTP response from a DeleteGroupMembershipWithResponse call
func ParseDeleteGroupMembershipResponse(rsp *http.Response) (*DeleteGroupMembershipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupMembershipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddGroupMembershipResponse parses an HTTP response from a AddGroupMembershipWithResponse call
func ParseAddGroupMembershipResponse(rsp *http.Response) (*AddGroupMembershipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AddGroupMembershipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListGroupPoliciesResponse parses an HTTP response from a ListGroupPoliciesWithResponse call
func ParseListGroupPoliciesResponse(rsp *http.Response) (*ListGroupPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListGroupPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDetachPolicyFromGroupResponse parses an HTTP response from a DetachPolicyFromGroupWithResponse call
func ParseDetachPolicyFromGroupResponse(rsp *http.Response) (*DetachPolicyFromGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DetachPolicyFromGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAttachPolicyToGroupResponse parses an HTTP response from a AttachPolicyToGroupWithResponse call
func ParseAttachPolicyToGroupResponse(rsp *http.Response) (*AttachPolicyToGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AttachPolicyToGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseLoginResponse parses an HTTP response from a LoginWithResponse call
func ParseLoginResponse(rsp *http.Response) (*LoginResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &LoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthenticationToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListPoliciesResponse parses an HTTP response from a ListPoliciesWithResponse call
func ParseListPoliciesResponse(rsp *http.Response) (*ListPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreatePolicyResponse parses an HTTP response from a CreatePolicyWithResponse call
func ParseCreatePolicyResponse(rsp *http.Response) (*CreatePolicyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreatePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeletePolicyResponse parses an HTTP response from a DeletePolicyWithResponse call
func ParseDeletePolicyResponse(rsp *http.Response) (*DeletePolicyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeletePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPolicyResponse parses an HTTP response from a GetPolicyWithResponse call
func ParseGetPolicyResponse(rsp *http.Response) (*GetPolicyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdatePolicyResponse parses an HTTP response from a UpdatePolicyWithResponse call
func ParseUpdatePolicyResponse(rsp *http.Response) (*UpdatePolicyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdatePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListUsersResponse parses an HTTP response from a ListUsersWithResponse call
func ParseListUsersResponse(rsp *http.Response) (*ListUsersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateUserResponse parses an HTTP response from a CreateUserWithResponse call
func ParseCreateUserResponse(rsp *http.Response) (*CreateUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListUserCredentialsResponse parses an HTTP response from a ListUserCredentialsWithResponse call
func ParseListUserCredentialsResponse(rsp *http.Response) (*ListUserCredentialsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListUserCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CredentialsList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateCredentialsResponse parses an HTTP response from a CreateCredentialsWithResponse call
func ParseCreateCredentialsResponse(rsp *http.Response) (*CreateCredentialsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CredentialsWithSecret
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteCredentialsResponse parses an HTTP response from a DeleteCredentialsWithResponse call
func ParseDeleteCredentialsResponse(rsp *http.Response) (*DeleteCredentialsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCredentialsResponse parses an HTTP response from a GetCredentialsWithResponse call
func ParseGetCredentialsResponse(rsp *http.Response) (*GetCredentialsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Credentials
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteUserExternalPrincipalResponse parses an HTTP response from a DeleteUserExternalPrincipalWithResponse call
func ParseDeleteUserExternalPrincipalResponse(rsp *http.Response) (*DeleteUserExternalPrincipalResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserExternalPrincipalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateUserExternalPrincipalResponse parses an HTTP response from a CreateUserExternalPrincipalWithResponse call
func ParseCreateUserExternalPrincipalResponse(rsp *http.Response) (*CreateUserExternalPrincipalResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateUserExternalPrincipalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListUserExternalPrincipalsResponse parses an HTTP response from a ListUserExternalPrincipalsWithResponse call
func ParseListUserExternalPrincipalsResponse(rsp *http.Response) (*ListUserExternalPrincipalsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListUserExternalPrincipalsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExternalPrincipalList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListUserGroupsResponse parses an HTTP response from a ListUserGroupsWithResponse call
func ParseListUserGroupsResponse(rsp *http.Response) (*ListUserGroupsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListUserGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListUserPoliciesResponse parses an HTTP response from a ListUserPoliciesWithResponse call
func ParseListUserPoliciesResponse(rsp *http.Response) (*ListUserPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListUserPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDetachPolicyFromUserResponse parses an HTTP response from a DetachPolicyFromUserWithResponse call
func ParseDetachPolicyFromUserResponse(rsp *http.Response) (*DetachPolicyFromUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DetachPolicyFromUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAttachPolicyToUserResponse parses an HTTP response from a AttachPolicyToUserWithResponse call
func ParseAttachPolicyToUserResponse(rsp *http.Response) (*AttachPolicyToUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AttachPolicyToUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetConfigResponse parses an HTTP response from a GetConfigWithResponse call
func ParseGetConfigResponse(rsp *http.Response) (*GetConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Config
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetGarbageCollectionConfigResponse parses an HTTP response from a GetGarbageCollectionConfigWithResponse call
func ParseGetGarbageCollectionConfigResponse(rsp *http.Response) (*GetGarbageCollectionConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetGarbageCollectionConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GarbageCollectionConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetStorageConfigResponse parses an HTTP response from a GetStorageConfigWithResponse call
func ParseGetStorageConfigResponse(rsp *http.Response) (*GetStorageConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetStorageConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StorageConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetLakeFSVersionResponse parses an HTTP response from a GetLakeFSVersionWithResponse call
func ParseGetLakeFSVersionResponse(rsp *http.Response) (*GetLakeFSVersionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetLakeFSVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VersionConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseHealthCheckResponse parses an HTTP response from a HealthCheckWithResponse call
func ParseHealthCheckResponse(rsp *http.Response) (*HealthCheckResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &HealthCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseListRepositoriesResponse parses an HTTP response from a ListRepositoriesWithResponse call
func ParseListRepositoriesResponse(rsp *http.Response) (*ListRepositoriesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListRepositoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RepositoryList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateRepositoryResponse parses an HTTP response from a CreateRepositoryWithResponse call
func ParseCreateRepositoryResponse(rsp *http.Response) (*CreateRepositoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Repository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteRepositoryResponse parses an HTTP response from a DeleteRepositoryWithResponse call
func ParseDeleteRepositoryResponse(rsp *http.Response) (*DeleteRepositoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRepositoryResponse parses an HTTP response from a GetRepositoryWithResponse call
func ParseGetRepositoryResponse(rsp *http.Response) (*GetRepositoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Repository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListRepositoryRunsResponse parses an HTTP response from a ListRepositoryRunsWithResponse call
func ParseListRepositoryRunsResponse(rsp *http.Response) (*ListRepositoryRunsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListRepositoryRunsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionRunList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRunResponse parses an HTTP response from a GetRunWithResponse call
func ParseGetRunResponse(rsp *http.Response) (*GetRunResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListRunHooksResponse parses an HTTP response from a ListRunHooksWithResponse call
func ParseListRunHooksResponse(rsp *http.Response) (*ListRunHooksResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListRunHooksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HookRunList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRunHookOutputResponse parses an HTTP response from a GetRunHookOutputWithResponse call
func ParseGetRunHookOutputResponse(rsp *http.Response) (*GetRunHookOutputResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetRunHookOutputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInternalDeleteBranchProtectionRuleResponse parses an HTTP response from a InternalDeleteBranchProtectionRuleWithResponse call
func ParseInternalDeleteBranchProtectionRuleResponse(rsp *http.Response) (*InternalDeleteBranchProtectionRuleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &InternalDeleteBranchProtectionRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInternalGetBranchProtectionRulesResponse parses an HTTP response from a InternalGetBranchProtectionRulesWithResponse call
func ParseInternalGetBranchProtectionRulesResponse(rsp *http.Response) (*InternalGetBranchProtectionRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &InternalGetBranchProtectionRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []BranchProtectionRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInternalCreateBranchProtectionRuleResponse parses an HTTP response from a InternalCreateBranchProtectionRuleWithResponse call
func ParseInternalCreateBranchProtectionRuleResponse(rsp *http.Response) (*InternalCreateBranchProtectionRuleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &InternalCreateBranchProtectionRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBranchProtectionRulePreflightResponse parses an HTTP response from a CreateBranchProtectionRulePreflightWithResponse call
func ParseCreateBranchProtectionRulePreflightResponse(rsp *http.Response) (*CreateBranchProtectionRulePreflightResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateBranchProtectionRulePreflightResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListBranchesResponse parses an HTTP response from a ListBranchesWithResponse call
func ParseListBranchesResponse(rsp *http.Response) (*ListBranchesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListBranchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RefList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBranchResponse parses an HTTP response from a CreateBranchWithResponse call
func ParseCreateBranchResponse(rsp *http.Response) (*CreateBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteBranchResponse parses an HTTP response from a DeleteBranchWithResponse call
func ParseDeleteBranchResponse(rsp *http.Response) (*DeleteBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBranchResponse parses an HTTP response from a GetBranchWithResponse call
func ParseGetBranchResponse(rsp *http.Response) (*GetBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Ref
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseResetBranchResponse parses an HTTP response from a ResetBranchWithResponse call
func ParseResetBranchResponse(rsp *http.Response) (*ResetBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ResetBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCherryPickResponse parses an HTTP response from a CherryPickWithResponse call
func ParseCherryPickResponse(rsp *http.Response) (*CherryPickResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CherryPickResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Commit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCommitResponse parses an HTTP response from a CommitWithResponse call
func ParseCommitResponse(rsp *http.Response) (*CommitResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CommitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Commit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDiffBranchResponse parses an HTTP response from a DiffBranchWithResponse call
func ParseDiffBranchResponse(rsp *http.Response) (*DiffBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DiffBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DiffList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseHardResetBranchResponse parses an HTTP response from a HardResetBranchWithResponse call
func ParseHardResetBranchResponse(rsp *http.Response) (*HardResetBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &HardResetBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseImportCancelResponse parses an HTTP response from a ImportCancelWithResponse call
func ParseImportCancelResponse(rsp *http.Response) (*ImportCancelResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ImportCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseImportStatusResponse parses an HTTP response from a ImportStatusWithResponse call
func ParseImportStatusResponse(rsp *http.Response) (*ImportStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ImportStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ImportStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseImportStartResponse parses an HTTP response from a ImportStartWithResponse call
func ParseImportStartResponse(rsp *http.Response) (*ImportStartResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ImportStartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ImportCreationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteObjectResponse parses an HTTP response from a DeleteObjectWithResponse call
func ParseDeleteObjectResponse(rsp *http.Response) (*DeleteObjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUploadObjectResponse parses an HTTP response from a UploadObjectWithResponse call
func ParseUploadObjectResponse(rsp *http.Response) (*UploadObjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UploadObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ObjectStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStageObjectResponse parses an HTTP response from a StageObjectWithResponse call
func ParseStageObjectResponse(rsp *http.Response) (*StageObjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &StageObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ObjectStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCopyObjectResponse parses an HTTP response from a CopyObjectWithResponse call
func ParseCopyObjectResponse(rsp *http.Response) (*CopyObjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CopyObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ObjectStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteObjectsResponse parses an HTTP response from a DeleteObjectsWithResponse call
func ParseDeleteObjectsResponse(rsp *http.Response) (*DeleteObjectsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteObjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUploadObjectPreflightResponse parses an HTTP response from a UploadObjectPreflightWithResponse call
func ParseUploadObjectPreflightResponse(rsp *http.Response) (*UploadObjectPreflightResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UploadObjectPreflightResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRevertBranchResponse parses an HTTP response from a RevertBranchWithResponse call
func ParseRevertBranchResponse(rsp *http.Response) (*RevertBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &RevertBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPhysicalAddressResponse parses an HTTP response from a GetPhysicalAddressWithResponse call
func ParseGetPhysicalAddressResponse(rsp *http.Response) (*GetPhysicalAddressResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetPhysicalAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StagingLocation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseLinkPhysicalAddressResponse parses an HTTP response from a LinkPhysicalAddressWithResponse call
func ParseLinkPhysicalAddressResponse(rsp *http.Response) (*LinkPhysicalAddressResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &LinkPhysicalAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest StagingLocation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreatePresignMultipartUploadResponse parses an HTTP response from a CreatePresignMultipartUploadWithResponse call
func ParseCreatePresignMultipartUploadResponse(rsp *http.Response) (*CreatePresignMultipartUploadResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreatePresignMultipartUploadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PresignMultipartUpload
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAbortPresignMultipartUploadResponse parses an HTTP response from a AbortPresignMultipartUploadWithResponse call
func ParseAbortPresignMultipartUploadResponse(rsp *http.Response) (*AbortPresignMultipartUploadResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AbortPresignMultipartUploadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCompletePresignMultipartUploadResponse parses an HTTP response from a CompletePresignMultipartUploadWithResponse call
func ParseCompletePresignMultipartUploadResponse(rsp *http.Response) (*CompletePresignMultipartUploadResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CompletePresignMultipartUploadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest StagingLocation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateCommitRecordResponse parses an HTTP response from a CreateCommitRecordWithResponse call
func ParseCreateCommitRecordResponse(rsp *http.Response) (*CreateCommitRecordResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateCommitRecordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCommitResponse parses an HTTP response from a GetCommitWithResponse call
func ParseGetCommitResponse(rsp *http.Response) (*GetCommitResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetCommitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Commit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDumpStatusResponse parses an HTTP response from a DumpStatusWithResponse call
func ParseDumpStatusResponse(rsp *http.Response) (*DumpStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DumpStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RepositoryDumpStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDumpSubmitResponse parses an HTTP response from a DumpSubmitWithResponse call
func ParseDumpSubmitResponse(rsp *http.Response) (*DumpSubmitResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DumpSubmitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TaskInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePrepareGarbageCollectionCommitsResponse parses an HTTP response from a PrepareGarbageCollectionCommitsWithResponse call
func ParsePrepareGarbageCollectionCommitsResponse(rsp *http.Response) (*PrepareGarbageCollectionCommitsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PrepareGarbageCollectionCommitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest GarbageCollectionPrepareResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePrepareGarbageCollectionUncommittedResponse parses an HTTP response from a PrepareGarbageCollectionUncommittedWithResponse call
func ParsePrepareGarbageCollectionUncommittedResponse(rsp *http.Response) (*PrepareGarbageCollectionUncommittedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PrepareGarbageCollectionUncommittedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PrepareGCUncommittedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInternalDeleteGarbageCollectionRulesResponse parses an HTTP response from a InternalDeleteGarbageCollectionRulesWithResponse call
func ParseInternalDeleteGarbageCollectionRulesResponse(rsp *http.Response) (*InternalDeleteGarbageCollectionRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &InternalDeleteGarbageCollectionRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInternalGetGarbageCollectionRulesResponse parses an HTTP response from a InternalGetGarbageCollectionRulesWithResponse call
func ParseInternalGetGarbageCollectionRulesResponse(rsp *http.Response) (*InternalGetGarbageCollectionRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &InternalGetGarbageCollectionRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GarbageCollectionRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInternalSetGarbageCollectionRulesResponse parses an HTTP response from a InternalSetGarbageCollectionRulesWithResponse call
func ParseInternalSetGarbageCollectionRulesResponse(rsp *http.Response) (*InternalSetGarbageCollectionRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &InternalSetGarbageCollectionRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetGarbageCollectionRulesPreflightResponse parses an HTTP response from a SetGarbageCollectionRulesPreflightWithResponse call
func ParseSetGarbageCollectionRulesPreflightResponse(rsp *http.Response) (*SetGarbageCollectionRulesPreflightResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SetGarbageCollectionRulesPreflightResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteRepositoryMetadataResponse parses an HTTP response from a DeleteRepositoryMetadataWithResponse call
func ParseDeleteRepositoryMetadataResponse(rsp *http.Response) (*DeleteRepositoryMetadataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteRepositoryMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRepositoryMetadataResponse parses an HTTP response from a GetRepositoryMetadataWithResponse call
func ParseGetRepositoryMetadataResponse(rsp *http.Response) (*GetRepositoryMetadataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetRepositoryMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RepositoryMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetRepositoryMetadataResponse parses an HTTP response from a SetRepositoryMetadataWithResponse call
func ParseSetRepositoryMetadataResponse(rsp *http.Response) (*SetRepositoryMetadataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SetRepositoryMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMetaRangeResponse parses an HTTP response from a GetMetaRangeWithResponse call
func ParseGetMetaRangeResponse(rsp *http.Response) (*GetMetaRangeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetMetaRangeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StorageURI
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRangeResponse parses an HTTP response from a GetRangeWithResponse call
func ParseGetRangeResponse(rsp *http.Response) (*GetRangeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetRangeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StorageURI
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDumpRefsResponse parses an HTTP response from a DumpRefsWithResponse call
func ParseDumpRefsResponse(rsp *http.Response) (*DumpRefsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DumpRefsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RefsDump
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRestoreRefsResponse parses an HTTP response from a RestoreRefsWithResponse call
func ParseRestoreRefsResponse(rsp *http.Response) (*RestoreRefsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &RestoreRefsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSymlinkFileResponse parses an HTTP response from a CreateSymlinkFileWithResponse call
func ParseCreateSymlinkFileResponse(rsp *http.Response) (*CreateSymlinkFileResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateSymlinkFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest StorageURI
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDiffRefsResponse parses an HTTP response from a DiffRefsWithResponse call
func ParseDiffRefsResponse(rsp *http.Response) (*DiffRefsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DiffRefsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DiffList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseLogCommitsResponse parses an HTTP response from a LogCommitsWithResponse call
func ParseLogCommitsResponse(rsp *http.Response) (*LogCommitsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &LogCommitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommitList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetObjectResponse parses an HTTP response from a GetObjectWithResponse call
func ParseGetObjectResponse(rsp *http.Response) (*GetObjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 416:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON416 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseHeadObjectResponse parses an HTTP response from a HeadObjectWithResponse call
func ParseHeadObjectResponse(rsp *http.Response) (*HeadObjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &HeadObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseListObjectsResponse parses an HTTP response from a ListObjectsWithResponse call
func ParseListObjectsResponse(rsp *http.Response) (*ListObjectsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListObjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStatsList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStatObjectResponse parses an HTTP response from a StatObjectWithResponse call
func ParseStatObjectResponse(rsp *http.Response) (*StatObjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &StatObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUnderlyingPropertiesResponse parses an HTTP response from a GetUnderlyingPropertiesWithResponse call
func ParseGetUnderlyingPropertiesResponse(rsp *http.Response) (*GetUnderlyingPropertiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetUnderlyingPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UnderlyingObjectProperties
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseFindMergeBaseResponse parses an HTTP response from a FindMergeBaseWithResponse call
func ParseFindMergeBaseResponse(rsp *http.Response) (*FindMergeBaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &FindMergeBaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FindMergeBaseResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMergeIntoBranchResponse parses an HTTP response from a MergeIntoBranchWithResponse call
func ParseMergeIntoBranchResponse(rsp *http.Response) (*MergeIntoBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &MergeIntoBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MergeResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest MergeResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRestoreStatusResponse parses an HTTP response from a RestoreStatusWithResponse call
func ParseRestoreStatusResponse(rsp *http.Response) (*RestoreStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &RestoreStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RepositoryRestoreStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRestoreSubmitResponse parses an HTTP response from a RestoreSubmitWithResponse call
func ParseRestoreSubmitResponse(rsp *http.Response) (*RestoreSubmitResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &RestoreSubmitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TaskInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBranchProtectionRulesResponse parses an HTTP response from a GetBranchProtectionRulesWithResponse call
func ParseGetBranchProtectionRulesResponse(rsp *http.Response) (*GetBranchProtectionRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetBranchProtectionRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []BranchProtectionRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetBranchProtectionRulesResponse parses an HTTP response from a SetBranchProtectionRulesWithResponse call
func ParseSetBranchProtectionRulesResponse(rsp *http.Response) (*SetBranchProtectionRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SetBranchProtectionRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteGCRulesResponse parses an HTTP response from a DeleteGCRulesWithResponse call
func ParseDeleteGCRulesResponse(rsp *http.Response) (*DeleteGCRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteGCRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetGCRulesResponse parses an HTTP response from a GetGCRulesWithResponse call
func ParseGetGCRulesResponse(rsp *http.Response) (*GetGCRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetGCRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GarbageCollectionRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetGCRulesResponse parses an HTTP response from a SetGCRulesWithResponse call
func ParseSetGCRulesResponse(rsp *http.Response) (*SetGCRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SetGCRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListTagsResponse parses an HTTP response from a ListTagsWithResponse call
func ParseListTagsResponse(rsp *http.Response) (*ListTagsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RefList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTagResponse parses an HTTP response from a CreateTagWithResponse call
func ParseCreateTagResponse(rsp *http.Response) (*CreateTagResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Ref
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTagResponse parses an HTTP response from a DeleteTagWithResponse call
func ParseDeleteTagResponse(rsp *http.Response) (*DeleteTagResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTagResponse parses an HTTP response from a GetTagWithResponse call
func ParseGetTagResponse(rsp *http.Response) (*GetTagResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Ref
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetupCommPrefsResponse parses an HTTP response from a SetupCommPrefsWithResponse call
func ParseSetupCommPrefsResponse(rsp *http.Response) (*SetupCommPrefsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SetupCommPrefsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSetupStateResponse parses an HTTP response from a GetSetupStateWithResponse call
func ParseGetSetupStateResponse(rsp *http.Response) (*GetSetupStateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetSetupStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SetupState
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetupResponse parses an HTTP response from a SetupWithResponse call
func ParseSetupResponse(rsp *http.Response) (*SetupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SetupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CredentialsWithSecret
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostStatsEventsResponse parses an HTTP response from a PostStatsEventsWithResponse call
func ParsePostStatsEventsResponse(rsp *http.Response) (*PostStatsEventsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostStatsEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStsLoginResponse parses an HTTP response from a StsLoginWithResponse call
func ParseStsLoginResponse(rsp *http.Response) (*StsLoginResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &StsLoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthenticationToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUsageReportSummaryResponse parses an HTTP response from a GetUsageReportSummaryWithResponse call
func ParseGetUsageReportSummaryResponse(rsp *http.Response) (*GetUsageReportSummaryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetUsageReportSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InstallationUsageReport
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/text) unsupported

	}

	return response, nil
}

// ParseGetCurrentUserResponse parses an HTTP response from a GetCurrentUserWithResponse call
func ParseGetCurrentUserResponse(rsp *http.Response) (*GetCurrentUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CurrentUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// chi-interface.tmpl based on https://github.com/deepmap/oapi-codegen/tree/master/pkg/codegen/templates

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// list authentication capabilities supported
	// (GET /auth/capabilities)
	GetAuthCapabilities(w http.ResponseWriter, r *http.Request)
	// perform a login using an external authenticator
	// (POST /auth/external/principal/login)
	ExternalPrincipalLogin(w http.ResponseWriter, r *http.Request, body ExternalPrincipalLoginJSONRequestBody)
	// describe external principal by id
	// (GET /auth/external/principals)
	GetExternalPrincipal(w http.ResponseWriter, r *http.Request, params GetExternalPrincipalParams)
	// list groups
	// (GET /auth/groups)
	ListGroups(w http.ResponseWriter, r *http.Request, params ListGroupsParams)
	// create group
	// (POST /auth/groups)
	CreateGroup(w http.ResponseWriter, r *http.Request, body CreateGroupJSONRequestBody)
	// delete group
	// (DELETE /auth/groups/{groupId})
	DeleteGroup(w http.ResponseWriter, r *http.Request, groupId string)
	// get group
	// (GET /auth/groups/{groupId})
	GetGroup(w http.ResponseWriter, r *http.Request, groupId string)
	// get ACL of group
	// (GET /auth/groups/{groupId}/acl)
	GetGroupACL(w http.ResponseWriter, r *http.Request, groupId string)
	// set ACL of group
	// (POST /auth/groups/{groupId}/acl)
	SetGroupACL(w http.ResponseWriter, r *http.Request, body SetGroupACLJSONRequestBody, groupId string)
	// list group members
	// (GET /auth/groups/{groupId}/members)
	ListGroupMembers(w http.ResponseWriter, r *http.Request, groupId string, params ListGroupMembersParams)
	// delete group membership
	// (DELETE /auth/groups/{groupId}/members/{userId})
	DeleteGroupMembership(w http.ResponseWriter, r *http.Request, groupId string, userId string)
	// add group membership
	// (PUT /auth/groups/{groupId}/members/{userId})
	AddGroupMembership(w http.ResponseWriter, r *http.Request, groupId string, userId string)
	// list group policies
	// (GET /auth/groups/{groupId}/policies)
	ListGroupPolicies(w http.ResponseWriter, r *http.Request, groupId string, params ListGroupPoliciesParams)
	// detach policy from group
	// (DELETE /auth/groups/{groupId}/policies/{policyId})
	DetachPolicyFromGroup(w http.ResponseWriter, r *http.Request, groupId string, policyId string)
	// attach policy to group
	// (PUT /auth/groups/{groupId}/policies/{policyId})
	AttachPolicyToGroup(w http.ResponseWriter, r *http.Request, groupId string, policyId string)
	// perform a login
	// (POST /auth/login)
	Login(w http.ResponseWriter, r *http.Request, body LoginJSONRequestBody)
	// list policies
	// (GET /auth/policies)
	ListPolicies(w http.ResponseWriter, r *http.Request, params ListPoliciesParams)
	// create policy
	// (POST /auth/policies)
	CreatePolicy(w http.ResponseWriter, r *http.Request, body CreatePolicyJSONRequestBody)
	// delete policy
	// (DELETE /auth/policies/{policyId})
	DeletePolicy(w http.ResponseWriter, r *http.Request, policyId string)
	// get policy
	// (GET /auth/policies/{policyId})
	GetPolicy(w http.ResponseWriter, r *http.Request, policyId string)
	// update policy
	// (PUT /auth/policies/{policyId})
	UpdatePolicy(w http.ResponseWriter, r *http.Request, body UpdatePolicyJSONRequestBody, policyId string)
	// list users
	// (GET /auth/users)
	ListUsers(w http.ResponseWriter, r *http.Request, params ListUsersParams)
	// create user
	// (POST /auth/users)
	CreateUser(w http.ResponseWriter, r *http.Request, body CreateUserJSONRequestBody)
	// delete user
	// (DELETE /auth/users/{userId})
	DeleteUser(w http.ResponseWriter, r *http.Request, userId string)
	// get user
	// (GET /auth/users/{userId})
	GetUser(w http.ResponseWriter, r *http.Request, userId string)
	// list user credentials
	// (GET /auth/users/{userId}/credentials)
	ListUserCredentials(w http.ResponseWriter, r *http.Request, userId string, params ListUserCredentialsParams)
	// create credentials
	// (POST /auth/users/{userId}/credentials)
	CreateCredentials(w http.ResponseWriter, r *http.Request, userId string)
	// delete credentials
	// (DELETE /auth/users/{userId}/credentials/{accessKeyId})
	DeleteCredentials(w http.ResponseWriter, r *http.Request, userId string, accessKeyId string)
	// get credentials
	// (GET /auth/users/{userId}/credentials/{accessKeyId})
	GetCredentials(w http.ResponseWriter, r *http.Request, userId string, accessKeyId string)
	// delete external principal from user
	// (DELETE /auth/users/{userId}/external/principals)
	DeleteUserExternalPrincipal(w http.ResponseWriter, r *http.Request, userId string, params DeleteUserExternalPrincipalParams)
	// attach external principal to user
	// (POST /auth/users/{userId}/external/principals)
	CreateUserExternalPrincipal(w http.ResponseWriter, r *http.Request, body CreateUserExternalPrincipalJSONRequestBody, userId string, params CreateUserExternalPrincipalParams)
	// list user external policies attached to a user
	// (GET /auth/users/{userId}/external/principals/ls)
	ListUserExternalPrincipals(w http.ResponseWriter, r *http.Request, userId string, params ListUserExternalPrincipalsParams)
	// list user groups
	// (GET /auth/users/{userId}/groups)
	ListUserGroups(w http.ResponseWriter, r *http.Request, userId string, params ListUserGroupsParams)
	// list user policies
	// (GET /auth/users/{userId}/policies)
	ListUserPolicies(w http.ResponseWriter, r *http.Request, userId string, params ListUserPoliciesParams)
	// detach policy from user
	// (DELETE /auth/users/{userId}/policies/{policyId})
	DetachPolicyFromUser(w http.ResponseWriter, r *http.Request, userId string, policyId string)
	// attach policy to user
	// (PUT /auth/users/{userId}/policies/{policyId})
	AttachPolicyToUser(w http.ResponseWriter, r *http.Request, userId string, policyId string)

	// (GET /config)
	GetConfig(w http.ResponseWriter, r *http.Request)

	// (GET /config/garbage-collection)
	GetGarbageCollectionConfig(w http.ResponseWriter, r *http.Request)

	// (GET /config/storage)
	GetStorageConfig(w http.ResponseWriter, r *http.Request)

	// (GET /config/version)
	GetLakeFSVersion(w http.ResponseWriter, r *http.Request)

	// (GET /healthcheck)
	HealthCheck(w http.ResponseWriter, r *http.Request)
	// list repositories
	// (GET /repositories)
	ListRepositories(w http.ResponseWriter, r *http.Request, params ListRepositoriesParams)
	// create repository
	// (POST /repositories)
	CreateRepository(w http.ResponseWriter, r *http.Request, body CreateRepositoryJSONRequestBody, params CreateRepositoryParams)
	// delete repository
	// (DELETE /repositories/{repository})
	DeleteRepository(w http.ResponseWriter, r *http.Request, repository string, params DeleteRepositoryParams)
	// get repository
	// (GET /repositories/{repository})
	GetRepository(w http.ResponseWriter, r *http.Request, repository string)
	// list runs
	// (GET /repositories/{repository}/actions/runs)
	ListRepositoryRuns(w http.ResponseWriter, r *http.Request, repository string, params ListRepositoryRunsParams)
	// get a run
	// (GET /repositories/{repository}/actions/runs/{run_id})
	GetRun(w http.ResponseWriter, r *http.Request, repository string, runId string)
	// list run hooks
	// (GET /repositories/{repository}/actions/runs/{run_id}/hooks)
	ListRunHooks(w http.ResponseWriter, r *http.Request, repository string, runId string, params ListRunHooksParams)
	// get run hook output
	// (GET /repositories/{repository}/actions/runs/{run_id}/hooks/{hook_run_id}/output)
	GetRunHookOutput(w http.ResponseWriter, r *http.Request, repository string, runId string, hookRunId string)

	// (DELETE /repositories/{repository}/branch_protection)
	InternalDeleteBranchProtectionRule(w http.ResponseWriter, r *http.Request, body InternalDeleteBranchProtectionRuleJSONRequestBody, repository string)
	// get branch protection rules
	// (GET /repositories/{repository}/branch_protection)
	InternalGetBranchProtectionRules(w http.ResponseWriter, r *http.Request, repository string)

	// (POST /repositories/{repository}/branch_protection)
	InternalCreateBranchProtectionRule(w http.ResponseWriter, r *http.Request, body InternalCreateBranchProtectionRuleJSONRequestBody, repository string)

	// (GET /repositories/{repository}/branch_protection/set_allowed)
	CreateBranchProtectionRulePreflight(w http.ResponseWriter, r *http.Request, repository string)
	// list branches
	// (GET /repositories/{repository}/branches)
	ListBranches(w http.ResponseWriter, r *http.Request, repository string, params ListBranchesParams)
	// create branch
	// (POST /repositories/{repository}/branches)
	CreateBranch(w http.ResponseWriter, r *http.Request, body CreateBranchJSONRequestBody, repository string)
	// delete branch
	// (DELETE /repositories/{repository}/branches/{branch})
	DeleteBranch(w http.ResponseWriter, r *http.Request, repository string, branch string, params DeleteBranchParams)
	// get branch
	// (GET /repositories/{repository}/branches/{branch})
	GetBranch(w http.ResponseWriter, r *http.Request, repository string, branch string)
	// reset branch
	// (PUT /repositories/{repository}/branches/{branch})
	ResetBranch(w http.ResponseWriter, r *http.Request, body ResetBranchJSONRequestBody, repository string, branch string)
	// Replay the changes from the given commit on the branch
	// (POST /repositories/{repository}/branches/{branch}/cherry-pick)
	CherryPick(w http.ResponseWriter, r *http.Request, body CherryPickJSONRequestBody, repository string, branch string)
	// create commit
	// (POST /repositories/{repository}/branches/{branch}/commits)
	Commit(w http.ResponseWriter, r *http.Request, body CommitJSONRequestBody, repository string, branch string, params CommitParams)
	// diff branch
	// (GET /repositories/{repository}/branches/{branch}/diff)
	DiffBranch(w http.ResponseWriter, r *http.Request, repository string, branch string, params DiffBranchParams)
	// hard reset branch
	// (PUT /repositories/{repository}/branches/{branch}/hard_reset)
	HardResetBranch(w http.ResponseWriter, r *http.Request, repository string, branch string, params HardResetBranchParams)
	// cancel ongoing import
	// (DELETE /repositories/{repository}/branches/{branch}/import)
	ImportCancel(w http.ResponseWriter, r *http.Request, repository string, branch string, params ImportCancelParams)
	// get import status
	// (GET /repositories/{repository}/branches/{branch}/import)
	ImportStatus(w http.ResponseWriter, r *http.Request, repository string, branch string, params ImportStatusParams)
	// import data from object store
	// (POST /repositories/{repository}/branches/{branch}/import)
	ImportStart(w http.ResponseWriter, r *http.Request, body ImportStartJSONRequestBody, repository string, branch string)
	// delete object. Missing objects will not return a NotFound error.
	// (DELETE /repositories/{repository}/branches/{branch}/objects)
	DeleteObject(w http.ResponseWriter, r *http.Request, repository string, branch string, params DeleteObjectParams)

	// (POST /repositories/{repository}/branches/{branch}/objects)
	UploadObject(w http.ResponseWriter, r *http.Request, repository string, branch string, params UploadObjectParams)
	// stage an object's metadata for the given branch
	// (PUT /repositories/{repository}/branches/{branch}/objects)
	StageObject(w http.ResponseWriter, r *http.Request, body StageObjectJSONRequestBody, repository string, branch string, params StageObjectParams)
	// create a copy of an object
	// (POST /repositories/{repository}/branches/{branch}/objects/copy)
	CopyObject(w http.ResponseWriter, r *http.Request, body CopyObjectJSONRequestBody, repository string, branch string, params CopyObjectParams)
	// delete objects. Missing objects will not return a NotFound error.
	// (POST /repositories/{repository}/branches/{branch}/objects/delete)
	DeleteObjects(w http.ResponseWriter, r *http.Request, body DeleteObjectsJSONRequestBody, repository string, branch string, params DeleteObjectsParams)

	// (GET /repositories/{repository}/branches/{branch}/objects/stage_allowed)
	UploadObjectPreflight(w http.ResponseWriter, r *http.Request, repository string, branch string, params UploadObjectPreflightParams)
	// revert
	// (POST /repositories/{repository}/branches/{branch}/revert)
	RevertBranch(w http.ResponseWriter, r *http.Request, body RevertBranchJSONRequestBody, repository string, branch string)
	// generate an address to which the client can upload an object
	// (GET /repositories/{repository}/branches/{branch}/staging/backing)
	GetPhysicalAddress(w http.ResponseWriter, r *http.Request, repository string, branch string, params GetPhysicalAddressParams)
	// associate staging on this physical address with a path
	// (PUT /repositories/{repository}/branches/{branch}/staging/backing)
	LinkPhysicalAddress(w http.ResponseWriter, r *http.Request, body LinkPhysicalAddressJSONRequestBody, repository string, branch string, params LinkPhysicalAddressParams)
	// Initiate a multipart upload
	// (POST /repositories/{repository}/branches/{branch}/staging/pmpu)
	CreatePresignMultipartUpload(w http.ResponseWriter, r *http.Request, repository string, branch string, params CreatePresignMultipartUploadParams)
	// Abort a presign multipart upload
	// (DELETE /repositories/{repository}/branches/{branch}/staging/pmpu/{uploadId})
	AbortPresignMultipartUpload(w http.ResponseWriter, r *http.Request, body AbortPresignMultipartUploadJSONRequestBody, repository string, branch string, uploadId string, params AbortPresignMultipartUploadParams)
	// Complete a presign multipart upload request
	// (PUT /repositories/{repository}/branches/{branch}/staging/pmpu/{uploadId})
	CompletePresignMultipartUpload(w http.ResponseWriter, r *http.Request, body CompletePresignMultipartUploadJSONRequestBody, repository string, branch string, uploadId string, params CompletePresignMultipartUploadParams)
	// create commit record
	// (POST /repositories/{repository}/commits)
	CreateCommitRecord(w http.ResponseWriter, r *http.Request, body CreateCommitRecordJSONRequestBody, repository string)
	// get commit
	// (GET /repositories/{repository}/commits/{commitId})
	GetCommit(w http.ResponseWriter, r *http.Request, repository string, commitId string)
	// Status of a repository dump task
	// (GET /repositories/{repository}/dump)
	DumpStatus(w http.ResponseWriter, r *http.Request, repository string, params DumpStatusParams)
	// Backup the repository metadata (tags, commits, branches) and save the backup to the object store.
	// (POST /repositories/{repository}/dump)
	DumpSubmit(w http.ResponseWriter, r *http.Request, repository string)
	// save lists of active commits for garbage collection
	// (POST /repositories/{repository}/gc/prepare_commits)
	PrepareGarbageCollectionCommits(w http.ResponseWriter, r *http.Request, repository string)
	// save repository uncommitted metadata for garbage collection
	// (POST /repositories/{repository}/gc/prepare_uncommited)
	PrepareGarbageCollectionUncommitted(w http.ResponseWriter, r *http.Request, body PrepareGarbageCollectionUncommittedJSONRequestBody, repository string)

	// (DELETE /repositories/{repository}/gc/rules)
	InternalDeleteGarbageCollectionRules(w http.ResponseWriter, r *http.Request, repository string)

	// (GET /repositories/{repository}/gc/rules)
	InternalGetGarbageCollectionRules(w http.ResponseWriter, r *http.Request, repository string)

	// (POST /repositories/{repository}/gc/rules)
	InternalSetGarbageCollectionRules(w http.ResponseWriter, r *http.Request, body InternalSetGarbageCollectionRulesJSONRequestBody, repository string)

	// (GET /repositories/{repository}/gc/rules/set_allowed)
	SetGarbageCollectionRulesPreflight(w http.ResponseWriter, r *http.Request, repository string)
	// delete repository metadata
	// (DELETE /repositories/{repository}/metadata)
	DeleteRepositoryMetadata(w http.ResponseWriter, r *http.Request, body DeleteRepositoryMetadataJSONRequestBody, repository string)
	// get repository metadata
	// (GET /repositories/{repository}/metadata)
	GetRepositoryMetadata(w http.ResponseWriter, r *http.Request, repository string)
	// set repository metadata
	// (POST /repositories/{repository}/metadata)
	SetRepositoryMetadata(w http.ResponseWriter, r *http.Request, body SetRepositoryMetadataJSONRequestBody, repository string)
	// return URI to a meta-range file
	// (GET /repositories/{repository}/metadata/meta_range/{meta_range})
	GetMetaRange(w http.ResponseWriter, r *http.Request, repository string, metaRange string)
	// return URI to a range file
	// (GET /repositories/{repository}/metadata/range/{range})
	GetRange(w http.ResponseWriter, r *http.Request, repository string, pRange string)
	// Dump repository refs (tags, commits, branches) to object store
	// Deprecated: a new API will introduce long running operations
	// (PUT /repositories/{repository}/refs/dump)
	DumpRefs(w http.ResponseWriter, r *http.Request, repository string)
	// Restore repository refs (tags, commits, branches) from object store.
	// Deprecated: a new API will introduce long running operations
	// (PUT /repositories/{repository}/refs/restore)
	RestoreRefs(w http.ResponseWriter, r *http.Request, body RestoreRefsJSONRequestBody, repository string)
	// creates symlink files corresponding to the given directory
	// (POST /repositories/{repository}/refs/{branch}/symlink)
	CreateSymlinkFile(w http.ResponseWriter, r *http.Request, repository string, branch string, params CreateSymlinkFileParams)
	// diff references
	// (GET /repositories/{repository}/refs/{leftRef}/diff/{rightRef})
	DiffRefs(w http.ResponseWriter, r *http.Request, repository string, leftRef string, rightRef string, params DiffRefsParams)
	// get commit log from ref. If both objects and prefixes are empty, return all commits.
	// (GET /repositories/{repository}/refs/{ref}/commits)
	LogCommits(w http.ResponseWriter, r *http.Request, repository string, ref string, params LogCommitsParams)
	// get object content
	// (GET /repositories/{repository}/refs/{ref}/objects)
	GetObject(w http.ResponseWriter, r *http.Request, repository string, ref string, params GetObjectParams)
	// check if object exists
	// (HEAD /repositories/{repository}/refs/{ref}/objects)
	HeadObject(w http.ResponseWriter, r *http.Request, repository string, ref string, params HeadObjectParams)
	// list objects under a given prefix
	// (GET /repositories/{repository}/refs/{ref}/objects/ls)
	ListObjects(w http.ResponseWriter, r *http.Request, repository string, ref string, params ListObjectsParams)
	// get object metadata
	// (GET /repositories/{repository}/refs/{ref}/objects/stat)
	StatObject(w http.ResponseWriter, r *http.Request, repository string, ref string, params StatObjectParams)
	// get object properties on underlying storage
	// (GET /repositories/{repository}/refs/{ref}/objects/underlyingProperties)
	GetUnderlyingProperties(w http.ResponseWriter, r *http.Request, repository string, ref string, params GetUnderlyingPropertiesParams)
	// find the merge base for 2 references
	// (GET /repositories/{repository}/refs/{sourceRef}/merge/{destinationBranch})
	FindMergeBase(w http.ResponseWriter, r *http.Request, repository string, sourceRef string, destinationBranch string)
	// merge references
	// (POST /repositories/{repository}/refs/{sourceRef}/merge/{destinationBranch})
	MergeIntoBranch(w http.ResponseWriter, r *http.Request, body MergeIntoBranchJSONRequestBody, repository string, sourceRef string, destinationBranch string)
	// Status of a restore request
	// (GET /repositories/{repository}/restore)
	RestoreStatus(w http.ResponseWriter, r *http.Request, repository string, params RestoreStatusParams)
	// Restore repository from a dump in the object store
	// (POST /repositories/{repository}/restore)
	RestoreSubmit(w http.ResponseWriter, r *http.Request, body RestoreSubmitJSONRequestBody, repository string)
	// get branch protection rules
	// (GET /repositories/{repository}/settings/branch_protection)
	GetBranchProtectionRules(w http.ResponseWriter, r *http.Request, repository string)

	// (PUT /repositories/{repository}/settings/branch_protection)
	SetBranchProtectionRules(w http.ResponseWriter, r *http.Request, body SetBranchProtectionRulesJSONRequestBody, repository string, params SetBranchProtectionRulesParams)

	// (DELETE /repositories/{repository}/settings/gc_rules)
	DeleteGCRules(w http.ResponseWriter, r *http.Request, repository string)
	// get repository GC rules
	// (GET /repositories/{repository}/settings/gc_rules)
	GetGCRules(w http.ResponseWriter, r *http.Request, repository string)

	// (PUT /repositories/{repository}/settings/gc_rules)
	SetGCRules(w http.ResponseWriter, r *http.Request, body SetGCRulesJSONRequestBody, repository string)
	// list tags
	// (GET /repositories/{repository}/tags)
	ListTags(w http.ResponseWriter, r *http.Request, repository string, params ListTagsParams)
	// create tag
	// (POST /repositories/{repository}/tags)
	CreateTag(w http.ResponseWriter, r *http.Request, body CreateTagJSONRequestBody, repository string)
	// delete tag
	// (DELETE /repositories/{repository}/tags/{tag})
	DeleteTag(w http.ResponseWriter, r *http.Request, repository string, tag string, params DeleteTagParams)
	// get tag
	// (GET /repositories/{repository}/tags/{tag})
	GetTag(w http.ResponseWriter, r *http.Request, repository string, tag string)
	// setup communications preferences
	// (POST /setup_comm_prefs)
	SetupCommPrefs(w http.ResponseWriter, r *http.Request, body SetupCommPrefsJSONRequestBody)
	// check if the lakeFS installation is already set up
	// (GET /setup_lakefs)
	GetSetupState(w http.ResponseWriter, r *http.Request)
	// setup lakeFS and create a first user
	// (POST /setup_lakefs)
	Setup(w http.ResponseWriter, r *http.Request, body SetupJSONRequestBody)
	// post stats events, this endpoint is meant for internal use only
	// (POST /statistics)
	PostStatsEvents(w http.ResponseWriter, r *http.Request, body PostStatsEventsJSONRequestBody)
	// perform a login with STS
	// (POST /sts/login)
	StsLogin(w http.ResponseWriter, r *http.Request, body StsLoginJSONRequestBody)
	// get usage report summary
	// (GET /usage-report/summary)
	GetUsageReportSummary(w http.ResponseWriter, r *http.Request)
	// get current user
	// (GET /user)
	GetCurrentUser(w http.ResponseWriter, r *http.Request)
}

// chi-middleware.tmpl based on https://github.com/deepmap/oapi-codegen/tree/master/pkg/codegen/templates

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// GetAuthCapabilities operation middleware
func (siw *ServerInterfaceWrapper) GetAuthCapabilities(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAuthCapabilities(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ExternalPrincipalLogin operation middleware
func (siw *ServerInterfaceWrapper) ExternalPrincipalLogin(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// ------------- Body parse -------------
	var body ExternalPrincipalLoginJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'ExternalPrincipalLogin' as JSON", http.StatusBadRequest)
			return
		}
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ExternalPrincipalLogin(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetExternalPrincipal operation middleware
func (siw *ServerInterfaceWrapper) GetExternalPrincipal(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetExternalPrincipalParams

	// ------------- Required query parameter "principalId" -------------
	if paramValue := r.URL.Query().Get("principalId"); paramValue != "" {

	} else {
		http.Error(w, "Query argument principalId is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "principalId", r.URL.Query(), &params.PrincipalId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter principalId: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetExternalPrincipal(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListGroups operation middleware
func (siw *ServerInterfaceWrapper) ListGroups(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListGroupsParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListGroups(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateGroup operation middleware
func (siw *ServerInterfaceWrapper) CreateGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// ------------- Body parse -------------
	var body CreateGroupJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreateGroup' as JSON", http.StatusBadRequest)
			return
		}
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateGroup(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteGroup operation middleware
func (siw *ServerInterfaceWrapper) DeleteGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGroup(w, r, groupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetGroup operation middleware
func (siw *ServerInterfaceWrapper) GetGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGroup(w, r, groupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetGroupACL operation middleware
func (siw *ServerInterfaceWrapper) GetGroupACL(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGroupACL(w, r, groupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SetGroupACL operation middleware
func (siw *ServerInterfaceWrapper) SetGroupACL(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body SetGroupACLJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'SetGroupACL' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetGroupACL(w, r, body, groupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListGroupMembers operation middleware
func (siw *ServerInterfaceWrapper) ListGroupMembers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListGroupMembersParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListGroupMembers(w, r, groupId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteGroupMembership operation middleware
func (siw *ServerInterfaceWrapper) DeleteGroupMembership(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGroupMembership(w, r, groupId, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddGroupMembership operation middleware
func (siw *ServerInterfaceWrapper) AddGroupMembership(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddGroupMembership(w, r, groupId, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListGroupPolicies operation middleware
func (siw *ServerInterfaceWrapper) ListGroupPolicies(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListGroupPoliciesParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListGroupPolicies(w, r, groupId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DetachPolicyFromGroup operation middleware
func (siw *ServerInterfaceWrapper) DetachPolicyFromGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DetachPolicyFromGroup(w, r, groupId, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AttachPolicyToGroup operation middleware
func (siw *ServerInterfaceWrapper) AttachPolicyToGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachPolicyToGroup(w, r, groupId, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Login operation middleware
func (siw *ServerInterfaceWrapper) Login(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// ------------- Body parse -------------
	var body LoginJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'Login' as JSON", http.StatusBadRequest)
			return
		}
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Login(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListPolicies operation middleware
func (siw *ServerInterfaceWrapper) ListPolicies(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPoliciesParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListPolicies(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreatePolicy operation middleware
func (siw *ServerInterfaceWrapper) CreatePolicy(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// ------------- Body parse -------------
	var body CreatePolicyJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreatePolicy' as JSON", http.StatusBadRequest)
			return
		}
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreatePolicy(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeletePolicy operation middleware
func (siw *ServerInterfaceWrapper) DeletePolicy(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeletePolicy(w, r, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetPolicy operation middleware
func (siw *ServerInterfaceWrapper) GetPolicy(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPolicy(w, r, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdatePolicy operation middleware
func (siw *ServerInterfaceWrapper) UpdatePolicy(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body UpdatePolicyJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'UpdatePolicy' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdatePolicy(w, r, body, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListUsers operation middleware
func (siw *ServerInterfaceWrapper) ListUsers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUsersParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUsers(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateUser operation middleware
func (siw *ServerInterfaceWrapper) CreateUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// ------------- Body parse -------------
	var body CreateUserJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreateUser' as JSON", http.StatusBadRequest)
			return
		}
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateUser(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteUser operation middleware
func (siw *ServerInterfaceWrapper) DeleteUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUser(w, r, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetUser operation middleware
func (siw *ServerInterfaceWrapper) GetUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUser(w, r, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListUserCredentials operation middleware
func (siw *ServerInterfaceWrapper) ListUserCredentials(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUserCredentialsParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUserCredentials(w, r, userId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateCredentials operation middleware
func (siw *ServerInterfaceWrapper) CreateCredentials(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateCredentials(w, r, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteCredentials operation middleware
func (siw *ServerInterfaceWrapper) DeleteCredentials(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "accessKeyId" -------------
	var accessKeyId string

	err = runtime.BindStyledParameter("simple", false, "accessKeyId", chi.URLParam(r, "accessKeyId"), &accessKeyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter accessKeyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteCredentials(w, r, userId, accessKeyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetCredentials operation middleware
func (siw *ServerInterfaceWrapper) GetCredentials(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "accessKeyId" -------------
	var accessKeyId string

	err = runtime.BindStyledParameter("simple", false, "accessKeyId", chi.URLParam(r, "accessKeyId"), &accessKeyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter accessKeyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCredentials(w, r, userId, accessKeyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteUserExternalPrincipal operation middleware
func (siw *ServerInterfaceWrapper) DeleteUserExternalPrincipal(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteUserExternalPrincipalParams

	// ------------- Required query parameter "principalId" -------------
	if paramValue := r.URL.Query().Get("principalId"); paramValue != "" {

	} else {
		http.Error(w, "Query argument principalId is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "principalId", r.URL.Query(), &params.PrincipalId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter principalId: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUserExternalPrincipal(w, r, userId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateUserExternalPrincipal operation middleware
func (siw *ServerInterfaceWrapper) CreateUserExternalPrincipal(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body CreateUserExternalPrincipalJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreateUserExternalPrincipal' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateUserExternalPrincipalParams

	// ------------- Required query parameter "principalId" -------------
	if paramValue := r.URL.Query().Get("principalId"); paramValue != "" {

	} else {
		http.Error(w, "Query argument principalId is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "principalId", r.URL.Query(), &params.PrincipalId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter principalId: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateUserExternalPrincipal(w, r, body, userId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListUserExternalPrincipals operation middleware
func (siw *ServerInterfaceWrapper) ListUserExternalPrincipals(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUserExternalPrincipalsParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUserExternalPrincipals(w, r, userId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListUserGroups operation middleware
func (siw *ServerInterfaceWrapper) ListUserGroups(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUserGroupsParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUserGroups(w, r, userId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListUserPolicies operation middleware
func (siw *ServerInterfaceWrapper) ListUserPolicies(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUserPoliciesParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "effective" -------------
	if paramValue := r.URL.Query().Get("effective"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "effective", r.URL.Query(), &params.Effective)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter effective: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUserPolicies(w, r, userId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DetachPolicyFromUser operation middleware
func (siw *ServerInterfaceWrapper) DetachPolicyFromUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DetachPolicyFromUser(w, r, userId, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AttachPolicyToUser operation middleware
func (siw *ServerInterfaceWrapper) AttachPolicyToUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachPolicyToUser(w, r, userId, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetConfig operation middleware
func (siw *ServerInterfaceWrapper) GetConfig(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetConfig(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetGarbageCollectionConfig operation middleware
func (siw *ServerInterfaceWrapper) GetGarbageCollectionConfig(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGarbageCollectionConfig(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetStorageConfig operation middleware
func (siw *ServerInterfaceWrapper) GetStorageConfig(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetStorageConfig(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetLakeFSVersion operation middleware
func (siw *ServerInterfaceWrapper) GetLakeFSVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLakeFSVersion(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// HealthCheck operation middleware
func (siw *ServerInterfaceWrapper) HealthCheck(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HealthCheck(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListRepositories operation middleware
func (siw *ServerInterfaceWrapper) ListRepositories(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRepositoriesParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListRepositories(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateRepository operation middleware
func (siw *ServerInterfaceWrapper) CreateRepository(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body CreateRepositoryJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreateRepository' as JSON", http.StatusBadRequest)
			return
		}
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateRepositoryParams

	// ------------- Optional query parameter "bare" -------------
	if paramValue := r.URL.Query().Get("bare"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "bare", r.URL.Query(), &params.Bare)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter bare: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateRepository(w, r, body, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteRepository operation middleware
func (siw *ServerInterfaceWrapper) DeleteRepository(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteRepositoryParams

	// ------------- Optional query parameter "force" -------------
	if paramValue := r.URL.Query().Get("force"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "force", r.URL.Query(), &params.Force)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter force: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteRepository(w, r, repository, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetRepository operation middleware
func (siw *ServerInterfaceWrapper) GetRepository(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRepository(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListRepositoryRuns operation middleware
func (siw *ServerInterfaceWrapper) ListRepositoryRuns(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRepositoryRunsParams

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "branch" -------------
	if paramValue := r.URL.Query().Get("branch"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "branch", r.URL.Query(), &params.Branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "commit" -------------
	if paramValue := r.URL.Query().Get("commit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "commit", r.URL.Query(), &params.Commit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter commit: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListRepositoryRuns(w, r, repository, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetRun operation middleware
func (siw *ServerInterfaceWrapper) GetRun(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "run_id" -------------
	var runId string

	err = runtime.BindStyledParameter("simple", false, "run_id", chi.URLParam(r, "run_id"), &runId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter run_id: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRun(w, r, repository, runId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListRunHooks operation middleware
func (siw *ServerInterfaceWrapper) ListRunHooks(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "run_id" -------------
	var runId string

	err = runtime.BindStyledParameter("simple", false, "run_id", chi.URLParam(r, "run_id"), &runId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter run_id: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRunHooksParams

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListRunHooks(w, r, repository, runId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetRunHookOutput operation middleware
func (siw *ServerInterfaceWrapper) GetRunHookOutput(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "run_id" -------------
	var runId string

	err = runtime.BindStyledParameter("simple", false, "run_id", chi.URLParam(r, "run_id"), &runId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter run_id: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "hook_run_id" -------------
	var hookRunId string

	err = runtime.BindStyledParameter("simple", false, "hook_run_id", chi.URLParam(r, "hook_run_id"), &hookRunId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter hook_run_id: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRunHookOutput(w, r, repository, runId, hookRunId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// InternalDeleteBranchProtectionRule operation middleware
func (siw *ServerInterfaceWrapper) InternalDeleteBranchProtectionRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body InternalDeleteBranchProtectionRuleJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'InternalDeleteBranchProtectionRule' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.InternalDeleteBranchProtectionRule(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// InternalGetBranchProtectionRules operation middleware
func (siw *ServerInterfaceWrapper) InternalGetBranchProtectionRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.InternalGetBranchProtectionRules(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// InternalCreateBranchProtectionRule operation middleware
func (siw *ServerInterfaceWrapper) InternalCreateBranchProtectionRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body InternalCreateBranchProtectionRuleJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'InternalCreateBranchProtectionRule' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.InternalCreateBranchProtectionRule(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateBranchProtectionRulePreflight operation middleware
func (siw *ServerInterfaceWrapper) CreateBranchProtectionRulePreflight(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateBranchProtectionRulePreflight(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListBranches operation middleware
func (siw *ServerInterfaceWrapper) ListBranches(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListBranchesParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListBranches(w, r, repository, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateBranch operation middleware
func (siw *ServerInterfaceWrapper) CreateBranch(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body CreateBranchJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreateBranch' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateBranch(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteBranch operation middleware
func (siw *ServerInterfaceWrapper) DeleteBranch(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteBranchParams

	// ------------- Optional query parameter "force" -------------
	if paramValue := r.URL.Query().Get("force"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "force", r.URL.Query(), &params.Force)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter force: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteBranch(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetBranch operation middleware
func (siw *ServerInterfaceWrapper) GetBranch(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetBranch(w, r, repository, branch)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ResetBranch operation middleware
func (siw *ServerInterfaceWrapper) ResetBranch(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body ResetBranchJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'ResetBranch' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ResetBranch(w, r, body, repository, branch)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CherryPick operation middleware
func (siw *ServerInterfaceWrapper) CherryPick(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body CherryPickJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CherryPick' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CherryPick(w, r, body, repository, branch)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Commit operation middleware
func (siw *ServerInterfaceWrapper) Commit(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body CommitJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'Commit' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CommitParams

	// ------------- Optional query parameter "source_metarange" -------------
	if paramValue := r.URL.Query().Get("source_metarange"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "source_metarange", r.URL.Query(), &params.SourceMetarange)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter source_metarange: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Commit(w, r, body, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DiffBranch operation middleware
func (siw *ServerInterfaceWrapper) DiffBranch(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DiffBranchParams

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "delimiter" -------------
	if paramValue := r.URL.Query().Get("delimiter"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "delimiter", r.URL.Query(), &params.Delimiter)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter delimiter: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DiffBranch(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// HardResetBranch operation middleware
func (siw *ServerInterfaceWrapper) HardResetBranch(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params HardResetBranchParams

	// ------------- Required query parameter "ref" -------------
	if paramValue := r.URL.Query().Get("ref"); paramValue != "" {

	} else {
		http.Error(w, "Query argument ref is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "ref", r.URL.Query(), &params.Ref)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ref: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "force" -------------
	if paramValue := r.URL.Query().Get("force"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "force", r.URL.Query(), &params.Force)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter force: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HardResetBranch(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ImportCancel operation middleware
func (siw *ServerInterfaceWrapper) ImportCancel(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ImportCancelParams

	// ------------- Required query parameter "id" -------------
	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		http.Error(w, "Query argument id is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter id: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ImportCancel(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ImportStatus operation middleware
func (siw *ServerInterfaceWrapper) ImportStatus(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ImportStatusParams

	// ------------- Required query parameter "id" -------------
	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		http.Error(w, "Query argument id is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter id: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ImportStatus(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ImportStart operation middleware
func (siw *ServerInterfaceWrapper) ImportStart(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body ImportStartJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'ImportStart' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ImportStart(w, r, body, repository, branch)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteObject operation middleware
func (siw *ServerInterfaceWrapper) DeleteObject(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteObjectParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "force" -------------
	if paramValue := r.URL.Query().Get("force"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "force", r.URL.Query(), &params.Force)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter force: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteObject(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UploadObject operation middleware
func (siw *ServerInterfaceWrapper) UploadObject(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UploadObjectParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "storageClass" -------------
	if paramValue := r.URL.Query().Get("storageClass"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "storageClass", r.URL.Query(), &params.StorageClass)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter storageClass: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "force" -------------
	if paramValue := r.URL.Query().Get("force"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "force", r.URL.Query(), &params.Force)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter force: %s", err), http.StatusBadRequest)
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch IfNoneMatch
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for If-None-Match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "If-None-Match", valueList[0], &IfNoneMatch)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter If-None-Match: %s", err), http.StatusBadRequest)
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UploadObject(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// StageObject operation middleware
func (siw *ServerInterfaceWrapper) StageObject(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body StageObjectJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'StageObject' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params StageObjectParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.StageObject(w, r, body, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CopyObject operation middleware
func (siw *ServerInterfaceWrapper) CopyObject(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body CopyObjectJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CopyObject' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CopyObjectParams

	// ------------- Required query parameter "dest_path" -------------
	if paramValue := r.URL.Query().Get("dest_path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument dest_path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "dest_path", r.URL.Query(), &params.DestPath)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter dest_path: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CopyObject(w, r, body, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteObjects operation middleware
func (siw *ServerInterfaceWrapper) DeleteObjects(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body DeleteObjectsJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'DeleteObjects' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteObjectsParams

	// ------------- Optional query parameter "force" -------------
	if paramValue := r.URL.Query().Get("force"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "force", r.URL.Query(), &params.Force)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter force: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteObjects(w, r, body, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UploadObjectPreflight operation middleware
func (siw *ServerInterfaceWrapper) UploadObjectPreflight(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UploadObjectPreflightParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UploadObjectPreflight(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RevertBranch operation middleware
func (siw *ServerInterfaceWrapper) RevertBranch(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body RevertBranchJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'RevertBranch' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RevertBranch(w, r, body, repository, branch)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetPhysicalAddress operation middleware
func (siw *ServerInterfaceWrapper) GetPhysicalAddress(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPhysicalAddressParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "presign" -------------
	if paramValue := r.URL.Query().Get("presign"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "presign", r.URL.Query(), &params.Presign)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter presign: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPhysicalAddress(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// LinkPhysicalAddress operation middleware
func (siw *ServerInterfaceWrapper) LinkPhysicalAddress(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body LinkPhysicalAddressJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'LinkPhysicalAddress' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params LinkPhysicalAddressParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch IfNoneMatch
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for If-None-Match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "If-None-Match", valueList[0], &IfNoneMatch)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter If-None-Match: %s", err), http.StatusBadRequest)
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LinkPhysicalAddress(w, r, body, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreatePresignMultipartUpload operation middleware
func (siw *ServerInterfaceWrapper) CreatePresignMultipartUpload(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreatePresignMultipartUploadParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "parts" -------------
	if paramValue := r.URL.Query().Get("parts"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "parts", r.URL.Query(), &params.Parts)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter parts: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreatePresignMultipartUpload(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AbortPresignMultipartUpload operation middleware
func (siw *ServerInterfaceWrapper) AbortPresignMultipartUpload(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body AbortPresignMultipartUploadJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'AbortPresignMultipartUpload' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "uploadId" -------------
	var uploadId string

	err = runtime.BindStyledParameter("simple", false, "uploadId", chi.URLParam(r, "uploadId"), &uploadId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uploadId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AbortPresignMultipartUploadParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AbortPresignMultipartUpload(w, r, body, repository, branch, uploadId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CompletePresignMultipartUpload operation middleware
func (siw *ServerInterfaceWrapper) CompletePresignMultipartUpload(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body CompletePresignMultipartUploadJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CompletePresignMultipartUpload' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "uploadId" -------------
	var uploadId string

	err = runtime.BindStyledParameter("simple", false, "uploadId", chi.URLParam(r, "uploadId"), &uploadId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uploadId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CompletePresignMultipartUploadParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CompletePresignMultipartUpload(w, r, body, repository, branch, uploadId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateCommitRecord operation middleware
func (siw *ServerInterfaceWrapper) CreateCommitRecord(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body CreateCommitRecordJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreateCommitRecord' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateCommitRecord(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetCommit operation middleware
func (siw *ServerInterfaceWrapper) GetCommit(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "commitId" -------------
	var commitId string

	err = runtime.BindStyledParameter("simple", false, "commitId", chi.URLParam(r, "commitId"), &commitId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter commitId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCommit(w, r, repository, commitId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DumpStatus operation middleware
func (siw *ServerInterfaceWrapper) DumpStatus(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DumpStatusParams

	// ------------- Required query parameter "task_id" -------------
	if paramValue := r.URL.Query().Get("task_id"); paramValue != "" {

	} else {
		http.Error(w, "Query argument task_id is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "task_id", r.URL.Query(), &params.TaskId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter task_id: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DumpStatus(w, r, repository, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DumpSubmit operation middleware
func (siw *ServerInterfaceWrapper) DumpSubmit(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DumpSubmit(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PrepareGarbageCollectionCommits operation middleware
func (siw *ServerInterfaceWrapper) PrepareGarbageCollectionCommits(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PrepareGarbageCollectionCommits(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PrepareGarbageCollectionUncommitted operation middleware
func (siw *ServerInterfaceWrapper) PrepareGarbageCollectionUncommitted(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body PrepareGarbageCollectionUncommittedJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'PrepareGarbageCollectionUncommitted' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PrepareGarbageCollectionUncommitted(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// InternalDeleteGarbageCollectionRules operation middleware
func (siw *ServerInterfaceWrapper) InternalDeleteGarbageCollectionRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.InternalDeleteGarbageCollectionRules(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// InternalGetGarbageCollectionRules operation middleware
func (siw *ServerInterfaceWrapper) InternalGetGarbageCollectionRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.InternalGetGarbageCollectionRules(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// InternalSetGarbageCollectionRules operation middleware
func (siw *ServerInterfaceWrapper) InternalSetGarbageCollectionRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body InternalSetGarbageCollectionRulesJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'InternalSetGarbageCollectionRules' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.InternalSetGarbageCollectionRules(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SetGarbageCollectionRulesPreflight operation middleware
func (siw *ServerInterfaceWrapper) SetGarbageCollectionRulesPreflight(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetGarbageCollectionRulesPreflight(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteRepositoryMetadata operation middleware
func (siw *ServerInterfaceWrapper) DeleteRepositoryMetadata(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body DeleteRepositoryMetadataJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'DeleteRepositoryMetadata' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteRepositoryMetadata(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetRepositoryMetadata operation middleware
func (siw *ServerInterfaceWrapper) GetRepositoryMetadata(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRepositoryMetadata(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SetRepositoryMetadata operation middleware
func (siw *ServerInterfaceWrapper) SetRepositoryMetadata(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body SetRepositoryMetadataJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'SetRepositoryMetadata' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetRepositoryMetadata(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetMetaRange operation middleware
func (siw *ServerInterfaceWrapper) GetMetaRange(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "meta_range" -------------
	var metaRange string

	err = runtime.BindStyledParameter("simple", false, "meta_range", chi.URLParam(r, "meta_range"), &metaRange)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter meta_range: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMetaRange(w, r, repository, metaRange)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetRange operation middleware
func (siw *ServerInterfaceWrapper) GetRange(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "range" -------------
	var pRange string

	err = runtime.BindStyledParameter("simple", false, "range", chi.URLParam(r, "range"), &pRange)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter range: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRange(w, r, repository, pRange)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DumpRefs operation middleware
func (siw *ServerInterfaceWrapper) DumpRefs(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DumpRefs(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RestoreRefs operation middleware
func (siw *ServerInterfaceWrapper) RestoreRefs(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body RestoreRefsJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'RestoreRefs' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RestoreRefs(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateSymlinkFile operation middleware
func (siw *ServerInterfaceWrapper) CreateSymlinkFile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateSymlinkFileParams

	// ------------- Optional query parameter "location" -------------
	if paramValue := r.URL.Query().Get("location"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "location", r.URL.Query(), &params.Location)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter location: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateSymlinkFile(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DiffRefs operation middleware
func (siw *ServerInterfaceWrapper) DiffRefs(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "leftRef" -------------
	var leftRef string

	err = runtime.BindStyledParameter("simple", false, "leftRef", chi.URLParam(r, "leftRef"), &leftRef)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter leftRef: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "rightRef" -------------
	var rightRef string

	err = runtime.BindStyledParameter("simple", false, "rightRef", chi.URLParam(r, "rightRef"), &rightRef)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter rightRef: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DiffRefsParams

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "delimiter" -------------
	if paramValue := r.URL.Query().Get("delimiter"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "delimiter", r.URL.Query(), &params.Delimiter)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter delimiter: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "type" -------------
	if paramValue := r.URL.Query().Get("type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "type", r.URL.Query(), &params.Type)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter type: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DiffRefs(w, r, repository, leftRef, rightRef, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// LogCommits operation middleware
func (siw *ServerInterfaceWrapper) LogCommits(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameter("simple", false, "ref", chi.URLParam(r, "ref"), &ref)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ref: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params LogCommitsParams

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "objects" -------------
	if paramValue := r.URL.Query().Get("objects"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "objects", r.URL.Query(), &params.Objects)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter objects: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "prefixes" -------------
	if paramValue := r.URL.Query().Get("prefixes"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefixes", r.URL.Query(), &params.Prefixes)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefixes: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "first_parent" -------------
	if paramValue := r.URL.Query().Get("first_parent"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "first_parent", r.URL.Query(), &params.FirstParent)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter first_parent: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "since" -------------
	if paramValue := r.URL.Query().Get("since"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "since", r.URL.Query(), &params.Since)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter since: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "stop_at" -------------
	if paramValue := r.URL.Query().Get("stop_at"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "stop_at", r.URL.Query(), &params.StopAt)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter stop_at: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LogCommits(w, r, repository, ref, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetObject operation middleware
func (siw *ServerInterfaceWrapper) GetObject(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameter("simple", false, "ref", chi.URLParam(r, "ref"), &ref)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ref: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetObjectParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "presign" -------------
	if paramValue := r.URL.Query().Get("presign"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "presign", r.URL.Query(), &params.Presign)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter presign: %s", err), http.StatusBadRequest)
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "Range" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Range")]; found {
		var Range string
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for Range, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "Range", valueList[0], &Range)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter Range: %s", err), http.StatusBadRequest)
			return
		}

		params.Range = &Range

	}

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for If-None-Match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "If-None-Match", valueList[0], &IfNoneMatch)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter If-None-Match: %s", err), http.StatusBadRequest)
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetObject(w, r, repository, ref, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// HeadObject operation middleware
func (siw *ServerInterfaceWrapper) HeadObject(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameter("simple", false, "ref", chi.URLParam(r, "ref"), &ref)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ref: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params HeadObjectParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "Range" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Range")]; found {
		var Range string
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for Range, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "Range", valueList[0], &Range)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter Range: %s", err), http.StatusBadRequest)
			return
		}

		params.Range = &Range

	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HeadObject(w, r, repository, ref, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListObjects operation middleware
func (siw *ServerInterfaceWrapper) ListObjects(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameter("simple", false, "ref", chi.URLParam(r, "ref"), &ref)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ref: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListObjectsParams

	// ------------- Optional query parameter "user_metadata" -------------
	if paramValue := r.URL.Query().Get("user_metadata"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "user_metadata", r.URL.Query(), &params.UserMetadata)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter user_metadata: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "presign" -------------
	if paramValue := r.URL.Query().Get("presign"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "presign", r.URL.Query(), &params.Presign)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter presign: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "delimiter" -------------
	if paramValue := r.URL.Query().Get("delimiter"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "delimiter", r.URL.Query(), &params.Delimiter)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter delimiter: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListObjects(w, r, repository, ref, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// StatObject operation middleware
func (siw *ServerInterfaceWrapper) StatObject(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameter("simple", false, "ref", chi.URLParam(r, "ref"), &ref)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ref: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params StatObjectParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "user_metadata" -------------
	if paramValue := r.URL.Query().Get("user_metadata"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "user_metadata", r.URL.Query(), &params.UserMetadata)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter user_metadata: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "presign" -------------
	if paramValue := r.URL.Query().Get("presign"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "presign", r.URL.Query(), &params.Presign)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter presign: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.StatObject(w, r, repository, ref, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetUnderlyingProperties operation middleware
func (siw *ServerInterfaceWrapper) GetUnderlyingProperties(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameter("simple", false, "ref", chi.URLParam(r, "ref"), &ref)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ref: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUnderlyingPropertiesParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUnderlyingProperties(w, r, repository, ref, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindMergeBase operation middleware
func (siw *ServerInterfaceWrapper) FindMergeBase(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "sourceRef" -------------
	var sourceRef string

	err = runtime.BindStyledParameter("simple", false, "sourceRef", chi.URLParam(r, "sourceRef"), &sourceRef)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter sourceRef: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "destinationBranch" -------------
	var destinationBranch string

	err = runtime.BindStyledParameter("simple", false, "destinationBranch", chi.URLParam(r, "destinationBranch"), &destinationBranch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter destinationBranch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindMergeBase(w, r, repository, sourceRef, destinationBranch)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// MergeIntoBranch operation middleware
func (siw *ServerInterfaceWrapper) MergeIntoBranch(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body MergeIntoBranchJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'MergeIntoBranch' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "sourceRef" -------------
	var sourceRef string

	err = runtime.BindStyledParameter("simple", false, "sourceRef", chi.URLParam(r, "sourceRef"), &sourceRef)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter sourceRef: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "destinationBranch" -------------
	var destinationBranch string

	err = runtime.BindStyledParameter("simple", false, "destinationBranch", chi.URLParam(r, "destinationBranch"), &destinationBranch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter destinationBranch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.MergeIntoBranch(w, r, body, repository, sourceRef, destinationBranch)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RestoreStatus operation middleware
func (siw *ServerInterfaceWrapper) RestoreStatus(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RestoreStatusParams

	// ------------- Required query parameter "task_id" -------------
	if paramValue := r.URL.Query().Get("task_id"); paramValue != "" {

	} else {
		http.Error(w, "Query argument task_id is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "task_id", r.URL.Query(), &params.TaskId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter task_id: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RestoreStatus(w, r, repository, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RestoreSubmit operation middleware
func (siw *ServerInterfaceWrapper) RestoreSubmit(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body RestoreSubmitJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'RestoreSubmit' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RestoreSubmit(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetBranchProtectionRules operation middleware
func (siw *ServerInterfaceWrapper) GetBranchProtectionRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetBranchProtectionRules(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SetBranchProtectionRules operation middleware
func (siw *ServerInterfaceWrapper) SetBranchProtectionRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body SetBranchProtectionRulesJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'SetBranchProtectionRules' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SetBranchProtectionRulesParams

	headers := r.Header

	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch string
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for If-Match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "If-Match", valueList[0], &IfMatch)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter If-Match: %s", err), http.StatusBadRequest)
			return
		}

		params.IfMatch = &IfMatch

	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetBranchProtectionRules(w, r, body, repository, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteGCRules operation middleware
func (siw *ServerInterfaceWrapper) DeleteGCRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGCRules(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetGCRules operation middleware
func (siw *ServerInterfaceWrapper) GetGCRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGCRules(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SetGCRules operation middleware
func (siw *ServerInterfaceWrapper) SetGCRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body SetGCRulesJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'SetGCRules' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetGCRules(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListTags operation middleware
func (siw *ServerInterfaceWrapper) ListTags(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListTagsParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListTags(w, r, repository, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateTag operation middleware
func (siw *ServerInterfaceWrapper) CreateTag(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body CreateTagJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreateTag' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateTag(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteTag operation middleware
func (siw *ServerInterfaceWrapper) DeleteTag(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "tag" -------------
	var tag string

	err = runtime.BindStyledParameter("simple", false, "tag", chi.URLParam(r, "tag"), &tag)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter tag: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteTagParams

	// ------------- Optional query parameter "force" -------------
	if paramValue := r.URL.Query().Get("force"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "force", r.URL.Query(), &params.Force)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter force: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteTag(w, r, repository, tag, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetTag operation middleware
func (siw *ServerInterfaceWrapper) GetTag(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "tag" -------------
	var tag string

	err = runtime.BindStyledParameter("simple", false, "tag", chi.URLParam(r, "tag"), &tag)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter tag: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTag(w, r, repository, tag)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SetupCommPrefs operation middleware
func (siw *ServerInterfaceWrapper) SetupCommPrefs(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// ------------- Body parse -------------
	var body SetupCommPrefsJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'SetupCommPrefs' as JSON", http.StatusBadRequest)
			return
		}
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetupCommPrefs(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetSetupState operation middleware
func (siw *ServerInterfaceWrapper) GetSetupState(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSetupState(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Setup operation middleware
func (siw *ServerInterfaceWrapper) Setup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// ------------- Body parse -------------
	var body SetupJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'Setup' as JSON", http.StatusBadRequest)
			return
		}
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Setup(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostStatsEvents operation middleware
func (siw *ServerInterfaceWrapper) PostStatsEvents(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// ------------- Body parse -------------
	var body PostStatsEventsJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'PostStatsEvents' as JSON", http.StatusBadRequest)
			return
		}
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostStatsEvents(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// StsLogin operation middleware
func (siw *ServerInterfaceWrapper) StsLogin(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// ------------- Body parse -------------
	var body StsLoginJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'StsLogin' as JSON", http.StatusBadRequest)
			return
		}
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.StsLogin(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetUsageReportSummary operation middleware
func (siw *ServerInterfaceWrapper) GetUsageReportSummary(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUsageReportSummary(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetCurrentUser operation middleware
func (siw *ServerInterfaceWrapper) GetCurrentUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCurrentUser(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL     string
	BaseRouter  chi.Router
	Middlewares []MiddlewareFunc
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/capabilities", wrapper.GetAuthCapabilities)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/external/principal/login", wrapper.ExternalPrincipalLogin)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/external/principals", wrapper.GetExternalPrincipal)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/groups", wrapper.ListGroups)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/groups", wrapper.CreateGroup)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/groups/{groupId}", wrapper.DeleteGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/groups/{groupId}", wrapper.GetGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/groups/{groupId}/acl", wrapper.GetGroupACL)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/groups/{groupId}/acl", wrapper.SetGroupACL)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/groups/{groupId}/members", wrapper.ListGroupMembers)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/groups/{groupId}/members/{userId}", wrapper.DeleteGroupMembership)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/auth/groups/{groupId}/members/{userId}", wrapper.AddGroupMembership)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/groups/{groupId}/policies", wrapper.ListGroupPolicies)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/groups/{groupId}/policies/{policyId}", wrapper.DetachPolicyFromGroup)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/auth/groups/{groupId}/policies/{policyId}", wrapper.AttachPolicyToGroup)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/login", wrapper.Login)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/policies", wrapper.ListPolicies)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/policies", wrapper.CreatePolicy)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/policies/{policyId}", wrapper.DeletePolicy)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/policies/{policyId}", wrapper.GetPolicy)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/auth/policies/{policyId}", wrapper.UpdatePolicy)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/users", wrapper.ListUsers)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/users", wrapper.CreateUser)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/users/{userId}", wrapper.DeleteUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/users/{userId}", wrapper.GetUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/users/{userId}/credentials", wrapper.ListUserCredentials)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/users/{userId}/credentials", wrapper.CreateCredentials)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/users/{userId}/credentials/{accessKeyId}", wrapper.DeleteCredentials)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/users/{userId}/credentials/{accessKeyId}", wrapper.GetCredentials)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/users/{userId}/external/principals", wrapper.DeleteUserExternalPrincipal)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/users/{userId}/external/principals", wrapper.CreateUserExternalPrincipal)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/users/{userId}/external/principals/ls", wrapper.ListUserExternalPrincipals)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/users/{userId}/groups", wrapper.ListUserGroups)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/users/{userId}/policies", wrapper.ListUserPolicies)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/users/{userId}/policies/{policyId}", wrapper.DetachPolicyFromUser)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/auth/users/{userId}/policies/{policyId}", wrapper.AttachPolicyToUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/config", wrapper.GetConfig)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/config/garbage-collection", wrapper.GetGarbageCollectionConfig)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/config/storage", wrapper.GetStorageConfig)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/config/version", wrapper.GetLakeFSVersion)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/healthcheck", wrapper.HealthCheck)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories", wrapper.ListRepositories)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories", wrapper.CreateRepository)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}", wrapper.DeleteRepository)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}", wrapper.GetRepository)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/actions/runs", wrapper.ListRepositoryRuns)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/actions/runs/{run_id}", wrapper.GetRun)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/actions/runs/{run_id}/hooks", wrapper.ListRunHooks)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/actions/runs/{run_id}/hooks/{hook_run_id}/output", wrapper.GetRunHookOutput)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/branch_protection", wrapper.InternalDeleteBranchProtectionRule)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/branch_protection", wrapper.InternalGetBranchProtectionRules)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branch_protection", wrapper.InternalCreateBranchProtectionRule)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/branch_protection/set_allowed", wrapper.CreateBranchProtectionRulePreflight)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/branches", wrapper.ListBranches)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches", wrapper.CreateBranch)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/branches/{branch}", wrapper.DeleteBranch)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/branches/{branch}", wrapper.GetBranch)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/branches/{branch}", wrapper.ResetBranch)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches/{branch}/cherry-pick", wrapper.CherryPick)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches/{branch}/commits", wrapper.Commit)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/branches/{branch}/diff", wrapper.DiffBranch)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/branches/{branch}/hard_reset", wrapper.HardResetBranch)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/branches/{branch}/import", wrapper.ImportCancel)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/branches/{branch}/import", wrapper.ImportStatus)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches/{branch}/import", wrapper.ImportStart)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/branches/{branch}/objects", wrapper.DeleteObject)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches/{branch}/objects", wrapper.UploadObject)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/branches/{branch}/objects", wrapper.StageObject)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches/{branch}/objects/copy", wrapper.CopyObject)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches/{branch}/objects/delete", wrapper.DeleteObjects)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/branches/{branch}/objects/stage_allowed", wrapper.UploadObjectPreflight)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches/{branch}/revert", wrapper.RevertBranch)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/branches/{branch}/staging/backing", wrapper.GetPhysicalAddress)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/branches/{branch}/staging/backing", wrapper.LinkPhysicalAddress)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches/{branch}/staging/pmpu", wrapper.CreatePresignMultipartUpload)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/branches/{branch}/staging/pmpu/{uploadId}", wrapper.AbortPresignMultipartUpload)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/branches/{branch}/staging/pmpu/{uploadId}", wrapper.CompletePresignMultipartUpload)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/commits", wrapper.CreateCommitRecord)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/commits/{commitId}", wrapper.GetCommit)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/dump", wrapper.DumpStatus)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/dump", wrapper.DumpSubmit)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/gc/prepare_commits", wrapper.PrepareGarbageCollectionCommits)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/gc/prepare_uncommited", wrapper.PrepareGarbageCollectionUncommitted)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/gc/rules", wrapper.InternalDeleteGarbageCollectionRules)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/gc/rules", wrapper.InternalGetGarbageCollectionRules)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/gc/rules", wrapper.InternalSetGarbageCollectionRules)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/gc/rules/set_allowed", wrapper.SetGarbageCollectionRulesPreflight)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/metadata", wrapper.DeleteRepositoryMetadata)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/metadata", wrapper.GetRepositoryMetadata)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/metadata", wrapper.SetRepositoryMetadata)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/metadata/meta_range/{meta_range}", wrapper.GetMetaRange)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/metadata/range/{range}", wrapper.GetRange)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/refs/dump", wrapper.DumpRefs)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/refs/restore", wrapper.RestoreRefs)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/refs/{branch}/symlink", wrapper.CreateSymlinkFile)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/refs/{leftRef}/diff/{rightRef}", wrapper.DiffRefs)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/refs/{ref}/commits", wrapper.LogCommits)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/refs/{ref}/objects", wrapper.GetObject)
	})
	r.Group(func(r chi.Router) {
		r.Head(options.BaseURL+"/repositories/{repository}/refs/{ref}/objects", wrapper.HeadObject)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/refs/{ref}/objects/ls", wrapper.ListObjects)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/refs/{ref}/objects/stat", wrapper.StatObject)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/refs/{ref}/objects/underlyingProperties", wrapper.GetUnderlyingProperties)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/refs/{sourceRef}/merge/{destinationBranch}", wrapper.FindMergeBase)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/refs/{sourceRef}/merge/{destinationBranch}", wrapper.MergeIntoBranch)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/restore", wrapper.RestoreStatus)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/restore", wrapper.RestoreSubmit)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/settings/branch_protection", wrapper.GetBranchProtectionRules)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/settings/branch_protection", wrapper.SetBranchProtectionRules)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/settings/gc_rules", wrapper.DeleteGCRules)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/settings/gc_rules", wrapper.GetGCRules)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/settings/gc_rules", wrapper.SetGCRules)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/tags", wrapper.ListTags)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/tags", wrapper.CreateTag)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/tags/{tag}", wrapper.DeleteTag)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/tags/{tag}", wrapper.GetTag)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/setup_comm_prefs", wrapper.SetupCommPrefs)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/setup_lakefs", wrapper.GetSetupState)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/setup_lakefs", wrapper.Setup)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/statistics", wrapper.PostStatsEvents)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/sts/login", wrapper.StsLogin)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/usage-report/summary", wrapper.GetUsageReportSummary)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/user", wrapper.GetCurrentUser)
	})

	return r
}

// inline.tmpl based on https://github.com/deepmap/oapi-codegen/tree/master/pkg/codegen/templates

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9+XPbOJY4/q+g9J2qTvorS87RPTvZmppKnKO9naRdPrZ3q51VQeSThDEJsAHQtibj",
	"//1TOHiJAEnZouQ4/qU7FkkcDw/vPr4OAhYnjAKVYvDq6yDBHMcggeu/DmefGYVPWAYL9WcIIuAkkYTR",
	"wavBCUgkGTof/Hg+UP/AksUkwFG0RDiK2BWSC0BpEjEcIkajJSIz/dMFLNECC0QZYtN/QiDREuQI/SYX",
	"wNEljlIQCHNAlEkk0iRhXEI4GgwHcI3jJILBq8GPg+GAqDUsAIfAB8MBxbF6cDjbUyveM0seDkSwgBir",
	"tctlol4QkhM6H9zcDAdHeE4oVpt5PZPA6xvkIFNOEZEQC4TVO0guiDBrzFbwZwp8WSxAv9Z94pilVNZn",
	"XrArFGO6tHNLhsxafJOaYcqzhjDDaSQHr57t7w8HMb4mcRrrv9SfhJo/954Ns/URKmEOfGWBbyEiMXFC",
	"J8weoVRAqNY45yxNUMDimFGUcJiRaxBouvSsOh+gM7iO9JgtB2UnDtEVkYv2AzOvNy7hZjjgIBJGBehb",
	"8QaHx/BnCkKfXMCoBHOIOEkiEuiljv8p1NK+lob9C4fZ4NXg/xsXN25snorxO84ZN1NVt/YGhyib7GY4",
	"OGB0FpFgCxMfg2ApDwBlUwr0uwLoKeZz0Gt5z/iUhCHQ/hdTTHUzHHxm8j1LabhFGHxmEpk5S/P/xj+z",
	"1wcfN7sMM6RjLR/05VI0caYmHyLG7YXTf6NpKjOqqkcYDo44BIyGRA3wHpMItgCx8pzITnozHJwAvwRu",
	"vup9DYdUAqc4QmZWZF8cDs4oTuWCcfKvbYCiMtvNcPDfOCKhnmFLcCgmzEBwk1E5TcYs7iacJcAlMbQt",
	"AR4TIYhZwcrh5s9QBJcQaZpPLsEQ2dcHH0cInQ+OAYfngyE6H/zOiQTzz5M0AX4+QJiG5/R88DqMCVV/",
	"clCyQonNnyseV+cBHP5MCVfH9kd5iV/yd40koeD8esq4POIgyJx+SiNJEszlmRZDHNtdLIWSWSY4DDkI",
	"4eZAldlXv3CuIQhAiF9hecAhBCoJjkR9cqzfmlzAckLCOrjNYy0uHb5VsBagLr/mtzz7ByIUadbNzUlL",
	"EJLQeVVcev3r4evD307e//b28+e/vvuf15+OPr4baDHgI9C5XAxePasBfTgQEHCQk2KV9SWaV1BppXdZ",
	"5tV/4Yj/z5mk7999Ohz/+tdPb999/jCeHl0fz8jB/9p1//ruf9uWvnJiVTC79uU+QrXQ45TWz23KMTUC",
	"cQ1mSvgh0h5n7SnQcCKJEju+DmaMx1gqMQhL2NO/Os4ALoHKifnZMSBPqW8uITGXa84mJJap3iJQJR7+",
	"MZgZEq43lkQgISwBywNvu6hhBqfKWsogqmwvn73xMD4SI3St3OJcQmwjloUsOTBSXRoZvUfLjm1fFzhx",
	"ky8Sc46XdSpRzFNM49xZKhcHOMFTEpF8O5XNzRifMzlJsBBXjJcPe8pYBFgvhtBLImGirpzrhRvPzIo0",
	"GaZzyi7Ageoy+3mFNKH/+v0U6YdILrBEAUujEE0h1wVwMTogbgRY4cI5PcgErhPC8xNcZaTkGr1LWLBQ",
	"VERoAUMNleM0ofLnlwOnJlM+E7MX1yG80Yh6wCFfQe0IAqhoVTMcCRg6DsJoFa77qCXJdv6iB8hf96/2",
	"iDMJFh8jcN0JqcSgOjhnNFbKMbIvaAqt1HJzW5Gaf5gxZELn6EfFtNE/0BWJwgBzDfqCZguJpxFMflyT",
	"Jmerc+3vYAGcL49IcLGRE0kwV0SGpvHUpcb+vgCKAj3lXkKCC7VljGLgc0CGVA01eMwwyAyDnmiSpt6d",
	"cRajZ0+Ntnm1IMFCoX8CXKGn/jIks9nonJ6qf5rVZrAmIhv2WUXwyTFYAW1WX7Ma1axNzVVa/FDLYxRN",
	"lwgj9WkrrYaZ+wxYHCttWxzSJHVQXIgxidwLSzi7JCGEyLzjuPIzwDLlcJYoZiTqo2jBQenlwIEGYMwf",
	"AShJ036KUvut68AFBCkncnmb8bNvGyZYgeDKZurT+8BLHGA1hyorRLwkXNjrMFEDb5BODgdzoFCQ3w4f",
	"eISOGITAc/A8k3jCMZ3DxPu1xCGWWuPBoVEicXRUZUg1/rEKW3Ojqkzd95Vl3sPBJfBM5ylsZSVD2X4r",
	"d9HyTDb3sHSSBVRWT3AVJn5M8RNCbWmdQJzIpYscrorrUqCrBWhLK85ISIApUpooJhRRRU7UetxXy414",
	"SuBXT9RFYpfAOQkBZVs1TwhFJaL1xImqT7vh6hqkvw0d74psKyiQTec/x92Kr5bqbEx2NeMdQ8B46MfQ",
	"ikpURRwSIjYrIwbXY7l4RoUyVkfJH3UfrDdCugZyVmludQXFM9+eOqylhP3V0e2DzuC61VVZndIM0TJn",
	"gVvqgzKzqA+XPe28jRJjqI5mH/gGuhUXqc5gH/hmuCXLKWvS2dQ+zlOBZ50RFYyrhJaeO6/tAF0NbNbE",
	"mZswqnD5zfj/YggJRtYM4Do316kpWqoAajyMECL93hCJRaaLMh4Ch1BLwyIAGip5Xb1lpfjy2TbRTbO3",
	"I8yl69A7mBCHWuSc9MByapNn4HKfHZ2Ref2MhGQcz2ES5M+boHFi3raDFVjf8fP/Nm9nn7skuPWMpluj",
	"7qu3b+UKVRf2pXlfOxYESgDenDRQDPo7kYsTbWW9T+fnsWivZzxePfVuxuSDlCv6embNc1WIZEa7RhIk",
	"HBioP3RN95bMZk6LkNtorR7kBDqz/Bo3/iR3j9vRv7jMxuRfMJkunbo2h4SD0OxVcT71asYFcRhCODbq",
	"RjgOQZuXEVCp3fMdjnN1yXpAjaUxuzRWazO45orWcT60Hv9J9qzVnm35kgZfGVg+yO/2buuz39ilzl2V",
	"1c14RUuxYFzxcyNgwnUSYUIV21UHDnqwNnA3aVElF3m/axoOKJvgwGXi4ilkkUzG/w7XREix6oBvNRw1",
	"7vPauLA/sjmhh9TcBad2RTTNlctSQEpttFUT+yRMC8Wj1axRHb9ptUec0IAkOHItsw7J1yil5E8FTT3H",
	"jFh3oT4WOyRKsjERGQHCV+KVkOLVq2fPX7zCQqQxhHucRTBW/9mztnOHJ1NKQufdL1FtRyfZCC55RQt3",
	"rh1G+ALenxhHqHHhYiFYQLAEYy/G1LHTLj7wbEptiet0Jn4FvVfo3HRZ224pZh19N0c+vZC6vSr9Ov8M",
	"ZSenMGuq1Eqqb4RSeNQlUnxQQtkVVyZ1xSrfExp+Aj6HN1jAsd6Ow+mNhdIQvLac00KvPXybsXjjRlGf",
	"uq5lqIMADEm63cilEZz3XjvRbjm29cC13cTaHL59DVdB6EKYD5hPtXIVRca559PZ5hwHMEmAE+bY1ltL",
	"4EsS8ggZZVsYyyyEmU2WQwBUovKA6IpEkY4101il12JCcB3con0PRxwSzBVm6RhKx2aCTH8FMYlY4LGK",
	"ZU8UuqcCNLPQXA1ClH+vFPw/U5BIOybRE6UO6/ti7oUJTnha9WG+eDUex8s9qwdrNiISHMB4oij4TIw5",
	"SHWDGB3n87jwbR7Y4+20C4tthn4oecR+iwJx2dPq7Qwta0+MbQfCScojl/M/fwGlXEeBheyK6jjvwrql",
	"t+GaqIhZWR22Lg5YYxSEVjAgAn04QP9k0woEfn4JGD/bf7EX/vX5z3sv8YsXe9Ng+h97fw32py/xdAb7",
	"f2u/x3nUiusQhx4U7XSF3f554wL26cD5kU1CvBQd5LRiuNrHnRcpfKuE7szUvXuH2cwayCdr79Tz4bBY",
	"q3PDSlR3mCd7szV4DtYTH9JiW/JxC7Upv2DnXELdbekdebdimTmxNlEsG3VYXpdrR78wduGM5sPBiip0",
	"l3i9BWMXvjutn93LiL3yyoYZQIrNrATwNcTpWSDvFnGyk96YFH8YJ4xXfPA57zFWNTF49cfXstinvZIZ",
	"BRTjzHpUMOtpGlyAHCechWlgWXPlfbuIqhXuZtg0y4xE8GzdqbKPVjb95WbodON2czHnoFrPI2pB2fGY",
	"zal8zFhx+2mrwTP3WIdz9ourPkWi8EUSPRJKOAuMU+ZWRHhlh7V1VFChpgIUD3OrilkWhDbvTiBGS6F/",
	"I/QpFVrkx4hDhCW5BKTApiS80mvn9NDsUi0YEYEwRT+YEX8wsXKlhannxqCDA5nl+ykmiFIaAm8eF/1Q",
	"wX//6Oa5a8iKoOi+Y1VDuMtOZbOAyvpHbW1IwVj9LgidR2C3amFqIi7VwqxJiFAhcRSZ4aYRCy6U+G62",
	"PnKK910pxqrnsJbEoQ90mcBQB/4A0cFAU3DtJztVtaB13QKNRvQy5vox/yRnbrcnRTZ2xHJCZ+w0ZDbu",
	"Dlk2wwGhcxASwom9Q3UIfzYhomyWXzNLByBEgqEZ5l3jN6ohEHWnso4wXEtiWDUjlkZwSwylMymh7JnA",
	"czgGdUgO8lh60a/fqG+7E/vyhG2UfnX+YjbXtrSJ3WdlOX7z+qB+wOpXYyLhEGNCEVClrYeKnH44O0Rk",
	"hs4HmV33fDBC6HSBpcmBvmL8QpzTmvUXp3KBBPBLEoAlW/bGCRInkVKHdcKEfd/ph5vhKJri4GISqT1N",
	"IjyFyGWUnprUrSTCAag1r3yX8mg0aB/eaRswKhLmS3R2/FHHA85mJkOYi7LZRg/hnMUMHjB2QWCibRmu",
	"iC/1VLMRkWccGAL6X7+frhWyY6YzQvOkNWJKMhQSkUR4aTfDBbpaqDtNNEj1aP+JMJqlUYQEUGkCjNXx",
	"E4E4UB2Rck4JRb+cfvqoQ+tjvMzjLzGKCL2wjCSHpR4WxSAXLDynfqg5jyThJC4dSKcTYKl0D1YfZE7o",
	"HLFUjlqJTbFG5ylXJvbe1EZnWHtswQYiALp5/LU9/U55C30HrypFjmMJc0de3yFFARbaU1/kQhgH+tCY",
	"4Zh+1VBBvamS5dyyO5sGxNRpmbIQM3zJeBZgbDInMoEuS4l48oP6a++KUPHDUyWD5G9ZIcy89+QH86d9",
	"cYSyFVOGBFixSF25GIcwdKzNLFxdW1LeaylMoI4V7kP2OUzy/IJ2FCtedaGSsdsfsGS5kXwYwYOJW9DV",
	"sn4eopiQXFEo1AGrCThTS8zQzoQVnYxitjhU7FHHqysqkonvNmXEIgEWnZJX8p34obax+AVj9JgELITu",
	"mgOezbTnBFmx12O+MaPWvv7l9PTIzovUG4Xz2JjD1YasJ4GuzOCznVZ30RSBUAKf25qjpebuAlz5ONoE",
	"ODu0f1knEs+hIeJ8AcGFUNKTM0P3zgGpaxHxglC3g+dMAP+UfaG+zkT7jVmlOwWrVuO51o2LdISk5gdS",
	"GbvxfKXY/rneu8PqK2DPhQV1c9aqo9LyAmsz0raWaKmlP/NAC+Cjc/pe70xRKSwQRtRwjrPjw6wiD1S+",
	"MOYeLJAGL6An58bmMRqNTO2IuSj+AhmMnp7T3/gwTymyvNv6JP8ueQpDw96noFQsTUat3FoOkrgkiivN",
	"0whz886Hd6du4XoVXCaUyiU2mWUAlVqwp4z+CzgbotUBjHEr4bBn3ahqebo0hl638WkjLI2oVcIghWJa",
	"nSQi36JmWdrshek5tdaw8sARmYH6UDFeTMvhIMaWdQFaUsJTlspzKpmdf3ROz6meaUYgCtUrPxqpD0c/",
	"GhW1S8jtnWhJiXA4I91XIjKzS9hCWXbrniiTuI25KBwk6U6qwVEFGFVALbCYxIw7aN1nuJYoUZKTwqdL",
	"TCI8jcCZSRjj60kCfJI4xbBP+JrEOMqyrdlMhwUTECgBrmcYNGfKDAcUruWEzWYCHPXVdLWD3HLAQY19",
	"aVQYmu3BGbtQnLXP5mcL2JmiTHmITeakXCO7JwfzCrCGJZ9neZNfnMcoFz5sX/W1OBmmT3Dt4GpxrodF",
	"JFjeAze8EoQhtrWXOl3bk/yLG32Mh+ajZ23GSOs+td/6gbJbomQPZmP0yIZ8fTg4o1k+WrlmXj1HjNDU",
	"YEBecaSD/u2exee26zSNjvRJi+E6BnKVvkCkMFEhTYmHaxTuaYhKcq7KA/xNFb/S2RJFMNiaWfUmNa/T",
	"RotXh91KbB3DrCXXuLa8jvEw5RJFnpl3e1nV1jd2U49hJt6mceKP/Zq0V27IAuba35R43v6aM7atthDn",
	"YL61+LZ+DFoJ2dLu17Ac3C9AJUwQyfhWWXcW6NdQbs3rXcThhNFo6Sz3ox3eRizLtmUUMvXZnvbSFU/2",
	"dBg0hwguMTV17aaYl74lvio0Nqk2D8etr+U9iUAshYRYa8e5D2tFvdZ584SiJzCaj9D5akSAYDGMlcg1",
	"Ph88bbWZOiILa5B2Lb4ZLfy2uPohFqENMSZOfTuLkcxLWA3+7w+896/9vb99sf/f+/L1+fDn5zd/cQvp",
	"ldOvXrRidslTt2oi9BuTTIm6zQi7OvuVsBH7Z/a20ZUzkD4RL/49F/9eSJmIf/w7hvjfSqiI/i05poIA",
	"lU9fjcejH//SilJZxbI1cUYxHV+ER8gotARreGjBikEmz+mQWFy4kWXWhd8aFrmRmAtz49QGq6M1Q2vX",
	"EkfOADYoeGRjbsZkUR/vV1g6cOvC/upRfPNKJRewXFvz1WN32+yJKzm+l6JEdsjmZVk5aPcXctsXTIDc",
	"UJlBj7He7ZD4fYGlsT0JU0CXcV2eRDJtcxmVAoDsaoc1C7/+tmPonXvzl8A3VVvMtHwwjt2szBfXE2iz",
	"P0tl5vh/6uSZm6voeLUAiszUty3mWPZ3O2s6muFHty3ZaD5fu1pjdeNDb/XGE5CuZBcb7tJc4dZRuNqm",
	"OGdi2cq5U1f+tk55NkLLPzGFUcjgaaekZj2Jd0/aCOdW+/W1EBNdGZzOm/P21fs6Ztg0GrHfjJx4mUUq",
	"daltU44lzIyMZRcdoURBVFeEHw4ok5PyL186xZycSMVg5x/bzVLqLJIIB/oS0Mznpm+HMIMgYuph3M0o",
	"5KjrVnXHmTqnOv41N4hrU6CNJTL+Je3PKuLgVpxYNuhMr97YitRShgOaRsbJ8Eo7/lqW+ui56+q5a0C9",
	"sri2cu4ly6deVFGcK2difpf+SpHWWjJoHlCNrK8fMYqm2JTsNdrTE7lMbKzZu1M8f+quJLjNAJA1/Z+a",
	"aMwtAWtxR1TIQI81xrIVrRPHcVL2r/jy7fyG5Ab/ynAAOqqqUvhHyR7ajkGXzoAHDl3Lb9vBS5/kCXG+",
	"fYp3l86NBhF2hVYoriCQrnyP9Csl5X4yxxKu8NIEPrAEKE7IxFJL8yNcJ8CJAi2O9mzxYfMkJXt6VKcZ",
	"SOG9s9VUycV6WamCqJemiWGlqkrZxeoUCMr704k+2faSVNqkCbNeU4dgUtjazM/n6f7+i8C1TZ3arh9D",
	"J1OXhv8ws0+Y/Tcfoic0wEBmLVehRYrWUDczsntV5Tp7dft0njRUWFwmuuWLrtYzh2vnzXJ+VkpnbPrA",
	"24YiM/IVIyZ5p666Wqhzeya2wrynnYF559JuZ8K9+0k4TBTHnMSZt2uS5u4uh+qQvd44/epbk5R4uipU",
	"rO8rkGoB9rDLETpW7F5eDa4+IDag2tnxoSvi/9CkI+joYC2aWUtfFrbLq9ZJY2x8ZsySko2zK/+0xvzL",
	"rtW21IEGd+eJFK9TuWhwL4ee7ikQEg6BnKSc+KME3BxTRpPMmeEMnlNi255ke5GuWm+1oqKchZXdStVZ",
	"UKk/wDnVUSRKcHvx8/5+9hJ68gwtWMqfIlswVs9imi2CFvOePdcviO5CXrWebJjld5swkxJ4XIA/xfOy",
	"8WA1hOcCkMRzdPgWJYwowdpKxcfv3o9quLCGSNVgV8LagGIYi8fa26aaSzzvZmHyKd+nWFwc0hnrljfc",
	"ZhDrlil8lnsMjPxalfc81V4z8aRFhXJpAqWKuHVmqSDojlrlZaNNWxhx6e2hGdS586ZMxFzk6ZJtyWjF",
	"gFd6tATcZcX6tWygJnnDXQa0P0eqp1mHIjj6UVY8KcNEpUiM0OEMvT46XFU6iciyHSvKu860oSHWzlQl",
	"NGY6rmlMFObJcSbL2z1wSER95HygOWUcwhF6HUUoMPVU1Tivy9XNBLIHYnLOY5uWNwV0ThWR5DpaWK3P",
	"qJdDhCO5YOl8gYJUSBZXi6UJnZtHmURAsyQnIkbuKOEZJ0DDaDlxi8Wvc3VfC8UVQ5lcYGMXIeEIndGI",
	"XOhiAkSikIHQC7B68LJkXSPynMZkvpBZpS6zp6cjdGZNLYLFYNI8RWZ5OTv0LH/dCo0GSQ4wtZNDSKo1",
	"whoDbCq47rsjbZVt2utHVRbr3HVr36wu1FcA361/zpQH3pRnrlqiu7apCEsQclIqdu9w4sw5DpVupxgr",
	"0NCXe5+9aM2ItYH8kzjNFlnvnROdSpDVLSTBRF3rvKWmXoP6ucCIhZSJUZJ1Rmr2OimyjYuOwcT2F9Vv",
	"TQQIUSk/iBPyK2hDxT+vZBFnOAXMgb/PqLXJUy6Wo5/W18NIGDSvJn+jaSUCx1HzMPkb/mFu9H0xgo2z",
	"zqnOonh9dDgYDiISgA3CtBO8TnCwAPR8tD8YDvRx602KV+Px1dXVCOvHI8bnY/utGH88PHj3+eTd3vPR",
	"/mghY1OXk0gd32CnNLPlWDJ4Ntof7WvAGdvJ4NXghf6pVF1mrLY5Dlaa7s2NPzZPqjsMB68GH0DWGvSt",
	"NIN+vr+/sVautbkcXV11oYDK4m+Gg5fP9x1yLWOmiXjefq9Q1X0rybc2LrfsLV+twas/vgwHIo1jzJfq",
	"IIiQq7y8vLyit6uNQzOOkKyMgRraHEhW2mCcF8Ida4lBEyAmHKdTryOr3zdUD4R8w8Ll5trs+koy39Qb",
	"hG8aJ1bbNDrQQqTaczdLo6KmhAGfQg+znuYDL3U11588a/9ktcXxy/0X7R9Venm/3H/Z/kXe8Hu3mJ75",
	"f7Gtx5AK61mrFPGoVNq16J5X7RhWzLeDob7NzZegkTjVSxf3iImOOsl1PKyXs74DNt1D3MixwcwydZYq",
	"ny4RKZM7fcpDLxp8McoxjkECN7XkNI/+MwXdCsFy0Hz8w3BQluyM1l6c4aqg9CXHLl2v3o9QSob9YF6p",
	"LcgFpuKVkvh6VJSq6/zN65nU8us6n8Ravb750iPCF0UwHYhuav9H5C7kcpv4qvn0PDvdCmZq/HNyWK2B",
	"ganE2Q9brZYwdfLSZ5udzHuYD5RQGWuoOfr6ya/QhvFX/f/D8MYsMAJji6qixVv9e4EWleN66Whnp+9K",
	"1uGlEFWi5YNlDmqrPpgPvfzcA9L9xxtwl9OYg/QfhYvx2qxXy3ftjbgTzy3u1dh2lWlEAdNApj+d4uCj",
	"CwdeH3xEbIa2iAq/2WY+u8CIym63hxg+VnuycvSbZ7X5qVdX62G4ddQo022Udc96mBRDtOKH/37HEE+B",
	"d5CyP9kXH2Vta8FuFrUNXL9JiRvF+VHvnv/YtYy/pgJ4d0HPYuuCdBP54vz171XuQ3EZYls696FzJHPS",
	"a/Op1EG9XodhKzo8a0QH3aXxe0AGHIYdMMF/URMWkaDJO5FzkqPszUdWktcy8TETDdXlHdnIvca7Et9J",
	"CsTYPePJFjP+as6glfdIHCzMYb7nLO5ubrBHHOoBvhfGo/aK7M51GtuWFRs358lOejO8RxYYcco8+PDM",
	"iw9Yfj/4YPaa4YNkrWpMi6u1T8/q/feoRnb3C8ChVe1OQO4dmBiKysRFBQZbIFwHgPwdT4MQnj1/8dPP",
	"/4mOsFz8ffyf6Bcpk99o5Mgy16u5twpON/doA651EmweZZotyzRbF1EahZMGd5StVdcPMcoK4XW2k218",
	"VtfRdg7i0NkjegV5qe1bcre/tX90kBXL35FLK8kQoY3QdJY41e8l9OosaH5vBg4f5P2eLR9U97d8hx6k",
	"c8t/HO2y/kYl9DNdbuXeEOj9h0yg7zNSmrI77QRad1BqFAPPxKOLpIOLRGeEfGPyXyp8LpEG4U9nOvRD",
	"WSopJz1HIpmEDfc5lmjJZuI27QHUJrvMaRGChy8tpgZzGknRGk6xHBHbhER9Nb8/EdENbr+A6Ibn/hZv",
	"3IMUDX3H0C4Y3sZp6LlN46BUTayN25crjz3yfSzGJYD42H8B3wfv2NLkNKjgyJaQu1kwqaJtb4JDaZrf",
	"iVyc6GaUzSghHnZgcyMudCBI4684K3rYifE3HrSD/5em+g7FgJab6pMGGoHcC2n9Pu+QEhF2QUzd3uLS",
	"RdyM3OFJp2uX7Dsk1jmuuiMV7PsKQtBX3gEFHZDgEkXXT4rbGOptKruu3V7hRqb+UpTzeTpYM1oReNdR",
	"E/fatGDDLBxgs+3h18H3NYjYuIMeVcOGR3XKfUt8SlX9VMX3oV0VG7f+04II6EqA94SQe7l+hzRndUEe",
	"U523mOr8jaB+Q4L0VlG4U4iUQuJvL0xqWOvXQKIIcZAppwhHEQqJkIQG0k1+8vpnjCOFCmyGiBTFwblk",
	"O1PUmVzCoHwYbZUmH4PUt3Ll7haj3selu2WAemeP0GN8uk8d3LK9ocfodDcyPAanO4PT/a7Zou/K3NXH",
	"O+/cbcvBmddTnlU5rNsVzXh9mhRt+5c6UXeu8XYnfFMAy0KoDK7xHPMpnsNewKII8nYLTgjOQVYaFrMZ",
	"mgdIgJSEzoULhB/M4Af52P3D1DelH8gWAqiAgIX73QG+UrvOgtxWVa7AOeEQYFnQlGbczaqqt+JwtTFA",
	"j2CvTuQHtnvlPQG6VBG0I6AVituvFHpni9bkyQXfj/oFWwS1T/hW66z64ZttedMQXQCO5EI3dfHSB/0U",
	"Sd2tbgG6cLOBHCICpYmupcxTSk2DmCosf9HjH+jxu8hFn9mBBWs9zyTbwqI0ptlFpRNvk7p0XG3Z+6j1",
	"j1faizowsNQi+RuLLlxt0Gzxp/JzW7Bhqe1pDV9q/cM06bG9BxBe6RK91E0QEWXIdnzLOg6o+5O3XXbp",
	"rmqcW6itm/cuOLo9bzlLptyFtglVH7NlXHESvIzMnuuwSk/HX4uvOoRGdL8vb5YJFqLUcT3hTFpBTV0J",
	"60qsdmn33BDTOuSOlp2XLuUiv7zfX9xGF2zxh29UEGEL7KsLPXiQsRvdjqndpMKrB7aWKc1LMMamcZ4Y",
	"85R2FM2Wx+rVHle8PSO3k5lnnH7t8AQjLgxaDFP95czrkzxOqU9QNGXgDQHXx/2Azdbc4GhurjJY3sY+",
	"K7dh/JWndEKMgdlLRVPa81VwDabXta5FtH/Ec/ZCyPENmX4mD5jSY7XNTWHdeMHYRQtJTukv+qVvAQMf",
	"gC6ugN1GX0UCAZmRQGO8OcKHTWbtJjeK9eOv6n+T7DeWSuvOaSDD6nB+My9+I9fBMVBp2z2SdxZIkHtC",
	"csBxFfvzTnVTQjF3lr2pyfAWBZA9pQcsyK/sdH2UN7LlpFCkq/p63UpeRfRDaxs2mvwbPdhRPtZxGsEd",
	"olZXu6JJNVd729fsxXqTsi6GJ4dKb2BUNjbwNIKHr947HABDv/vEjRgfQLqw4s75GZ0a3Dnxsd7wrkZA",
	"3Af+kLM5fDv2IEF/poHCtN4Vw4zRfcOkZ32s2ixtMdbX74u2rMmoxgLkxHax9gpifuQ44jCLyHwhOzkZ",
	"zwRwtMACJcBjolsdiqJpNMKeC2T6pxKBdmJWvIf+hS1Tky4o1eL/fZO99Oj71cbzmU/XtDfgoUefTgt8",
	"yJA5/2lbrNFP43pleXfz4Eq4lmPdkLUybbs2BzPgQAPYgYO2/8aU34IPOPc/OBC+G4UdfzX/6uANzvG4",
	"Q2/Dvny4lpRtWMF7EF1OVz2+Tbjh9/SWiFV/jMrPpB68Ird15uS2HU7LPOlucfLHICpo00ekktAVJNZg",
	"cc7wDwGyRDEeGynfHp8NLDfIfcbBAjhf7iXExK5+G9fBLfTpnRwRGyS7+etQTLCrwL0DE7zgoOJyAah0",
	"lDYq8gHLh/1WdMzkS7Sba34MSYSXyBwqpnMQJtVL/TAnl0CzqFdG9W8bJQh6ZPGtE4MszKcxevJ0AUiw",
	"lAeAYpCYK1BrG5b+eoQMd0VxKiSiTKIFvgSUUvNYycH2dEaeiEoz9iQfuz3sqAeqpRd7/yjWg6dQa2iw",
	"z573T9KOOASMhkRbYt9jEkGInsBoPkIYJRz2LEXRvlOTRA4hwmiGSZRyeLqzqnTZRS7y9Ax9Wp+yhWQ2",
	"8xo235LZrH8dTM3isxaq5SE2y+zmDjLzUCOl1cbX0tK2FHnaqzn7LUQkJtny7iNvXfd+LTAPJ1pD+XaE",
	"h9SRqncMEQsKK58SCLTF1f5jhGpygaINmNDKnQ2xxKN6Kh/mYVVxbxRQNP4iDdNhthxd5iNhhEqkkwm1",
	"L80ahH2CiELKDdR26y9D5NFEsClqqm4h8tgJHIXS1rngJE4Yl00G60P9xgGmAURtuH1GyZ8pIKJrZs4I",
	"cMX8lDZjpkEJZwodPBh959g7BxraiQO9/G/Jyn2/XSYanIjROSN0bk+3HEZjfvAaxw1OnUgsU3HPcWpz",
	"gmJl0w5h0e5H2BcerPG+uk8n0nzDVor8lLnsyWZpCfJa2v/znmY/ttO48PkwP2cuM9x8YFaBbV4de22U",
	"DGoshybeV1cYAdc1WlcUMON1KAL9mwk03qnz2m7+0Xnd7rw2oBqhT0QIxa3tORulQ6k6WX1BlK3UtDwa",
	"lZAqw41vgzgP68pIhCW5hKxIYmNVCTv9BnjBWRIxHPquS4tZ4XD2mVH4hKX25LeX8nmbPx8aDTLACZ6S",
	"iMhlcdRTQCJNFIGAEBGKZqlMdS2OCLBoMHrbakcR1oLW1pTMLszzLkk1w0GcRpIkmMuxentPUdem9IzS",
	"GqrQ/41GS4SRumARoBmJACXAUaoxAF0tSGZbmAJSQAnReTbY+UCBvctia4kefZr5DdoqcdUprVoCHIPE",
	"GmgPkb0bG37zB2UbvDHBbznIOCfNw8H1XtG2bg+ugygNYW+qr48VC3PjWHPWwYnE84LN9yHE5tg1h135",
	"sR4RfKvSiFBnjTC18scPIgctmjFe8oPXTFxrZk84ZNpxwJJl3xbsFdcPCGndApmVN9umXsywL1mnPLEa",
	"Ha0l/KivJ5uTgA5YstwCHVHT3FMyopaWqWo815YfackmHMlYXyXEZgVZceost6UahRr8Teg8m5O83Ze5",
	"rP2LvlqYY7kovOnba2JudqVxzefMf1tWp8XKZX68lFVzg9iUveG2d1eLG62Zk2UNfTO5klbj0xp4Znk5",
	"VX+EDITe/jzFHFMJUJSOzdREBSGtomfWLMQ4AiUUJUwIMo1ghA4lIjRUWA4C6fqAaoRiFciOKUkMijQG",
	"OIrUMegVAQ21m/k7R9rtJmh+s3atde8eh0vg8hsPMz3Wm+g5CUNNsYEsDDXMbWIsHmPD71VsuL03G4n1",
	"VnyP0Pl4ioMLhekNxZuOFktBAhy9DkNuPOgdHDoJB0Hm1GUF3k53oBOzwY8sKN2elb4hdmMIm51pzdsC",
	"BmEO+MF616k6Ym1lybYumbU+a8tDRIDqaJhM5HApThZSj0xxnQjDj4ReGElsFfl0dXP9BMsFItR2WbD1",
	"0DVKUkdo8OicnuY2sWwsdXJTQIwCyg47RNMlmtdu89A0Acu/ZKkUJFwtG/2DyDtUKICIBAdq4lqMo9pd",
	"K7lYx6HVU2aEJQ6fcqPtLrTI782kXCFIm+XYHYh9kPFufc+wzS4YIsmXaAEc7r8np9T9SQgWEEXBM27F",
	"bGkdN1XByNKvOum+rdyQxEn6zVi8tkn4a9PRNJ6aaEQrE0GIzo4/ogRzbR4yAxc2Ae9CuHQ61ZVyOge+",
	"Wi+sEmKlG2ZIEAij3JNdsPbQmloEKhj+4VuDOpU1GwkJdOcxNcITpmfA0dPROT1Sv5jNChPNZbHv2Qi9",
	"yz+B6wASY3mIsJCaRS2wQDGhJE5jJMi/AIWQAA1FluOY0hB4tFR4Po1YcKFDmRCJkwh0QLNaw+icvldr",
	"u8bqZ3TFuBJrzQJOXpS+G1anIgL99OkNemLcoMYAYpem1vvUxeVMjZkjA5lPGTzPstPrzYXgmdGd8aXe",
	"rB82sZgQbjfO/j5Lw9nlcNyNzcXPl8nm+KsZvdYbcyUBZMrUFcLZFaytrp5ioj9pwMvNC1JNMzoDTxz2",
	"CS+y4injj6haQlUN7QaM8OPr8BtyTa10KrV35VtU9g6YYkaG7/rOTKllWAiIp1HGfcwDCI2IUL/m2bBb",
	"vektkzov+9Y0Ji8JCeyq7zkRuYeq0DbpWoZbTdfETnlblryN2hYtRQlNQYRjCBjv8ZLmU9zZb2DLAnA9",
	"WlaE9zEmZZPFDSxwbxPEZhF6/NX847C5D05eFKXHps1dyn08yEy1hkIVW5e7MmzYpAc3TOPEXz0jjRNf",
	"hqZLuJJYXNyn7khF37TSTlw1OtI4QWrxlczLrRLC+3wPDOB0jF25ZWsOtd301vOGqKmjTqdOkri5HMhT",
	"LC4O6Yw1o1Opdfz9x6kNYMobHFykyYqDqQjyfqLQZGhpqhjmJaafakOlwJfGNzW1oxh1rpzjOLplb9bx",
	"PBgnHBLMYbJTafHILMLRsd8sqkcLY21Ou5am/F0FDFGUTtOZpwIeq3LkCQ0KZSMipKGOgTZDWATT9vS5",
	"AToKcqjfRh4sYW/mJDYBjfcHgc8K53VfYcF25oPSVLk2328enHvqW16bR/3qbtetxFjKEROVTKKNXTvT",
	"HOgOncJqF8XTFMqho2eJ7fXNmJ5Fj/24WvpxdYX9fn881szoIBHzwPTNeXBdRO59G62TRsTYPN9qwolb",
	"WO4EyEeK0J12d2qe5UWJzeSDNB4Z22XjrO+sD1YeddfgmrcpXraXMIToApalOt2VuMlsPFcgiRmnsEDl",
	"8Yh95ROsTvQrLMUd8grq2rsGxGar7ewgN82xs0GzxFHveOw+1N6NmNWQ1tYDe8jtgBsPcSdGyOrmT9yL",
	"tHmAOslP5+3hMESMozQJsTTGr4SzSxJaujPUhrFS1mTMLgEpoMI1ETpwXL3moj8nXjzdBvE5AblR2lMt",
	"JPvAhJuSgtuK250FoOxb/Y+J7lMw/lr8u9GjqE7x2HY26DGJRycdnB0fuuiZWume6dyg3hgOFoBDfYG/",
	"DvL4BwfqhIRDIJXUdfKisUzVzcPEIJtYfXZ8qGCAUQmOMxKViwTmyLUDT2aBh32Id2OL7e2IvmMkf8Tv",
	"O+P3vUPtjWM1h5nI3fS9SjKpx5t6DLNePVNqfDWPpymq0J7mR5985R4oeJVFBQ0nv39Vsoof9ZwWpSJf",
	"IYwoXKHXR4dG0iRUchamAaCI0TniKaU6DSnDC3F+K2u6xmMOplbtLlD52MydY3MfcvBM2FnWSDt0IHxZ",
	"1EUmYPgR/1d6qZlMoe5XoFYwebSzW1CkjizjiNCLbzTZTicz2ygNiacRIKusuGLDokyouUOU7YkB13vD",
	"7XvjR81CW7aRatTsg7tgZncCWRTVIpZAAePmY5NOx0o1G41karDzltcigpk8hpnp6TX+ysl8of9ubO/l",
	"lk622NxrCvIKgGr685B7eeXtiETF1jbrPxa2uklcrAQ9CVgahWgKCIhcAEc4q7TJeJ79gA7fPnUX27QI",
	"t4P12OiQBHNAeI4J1ekPLqjZS7DuGh9oM7XViGO1cWdpw4FccIBJyBRcgaaxwlZ5xewvxdMvw1tpZF+5",
	"IlSlYEIngfrI5kVo327a3a1wLyKkzlfHciGGJt8bTK41IsJWEzChvtYFFhTVYVwnwPJakMUhEAmxcOBl",
	"DmnMOV667tIay0sMQg19JYpm5Bo2tyx1bRWvKzL+9WiI0KyWoWToB6zB/sMI/U7kgqUSzVKuyYAt16fE",
	"BkYRDmSKo9WxfJX39eTNxZZqCyYzbTJXDFqRCjRjUcSuilqBM8JNFrwCbJowtQscLHQlGhQDn5dadDpr",
	"iqrvJ+b7NZd2smBXeYxkbGT4QC1DLjAto12IJexJEsMIHVIUYAEoFRCazDYhWTLBegsG+4dGbFe/Z+UP",
	"zSYtzdWFFmMAKbT/xDaQyqt9+PseELpSPTUv058v0FWpv5byXeISkmXrdG5NzbiFjRkIDnaVnGHook+y",
	"spuL2PzBJxepTRrtVLehPJyhKVNEztZMxTREGTlDSlyAOJHLYV5CNYqy2zTatlzmHGy2ceOnYbWl3kQ+",
	"c76vzUr1RN8sJaC8KTgHyQlcqjtsC4wo8rWUIP6+v/ds//mL7PoYA32x0+Na6+8ES6XuDF4N/s8M8OTJ",
	"+Xn44576z/Af6B9P//+nf+lCKo5txZYMjQzZJrNyOkReSlY3L8coxtKQ73eneF7Zy4sX+OeX4eynn569",
	"fP7TLAh++glehi+f42cv/+Ovf/sp/Nvs+U+z//hb+NK3z8PZ3mdGYc9U7bpF/ekeygXepeGLryRXNlXF",
	"FXNgftz7CHQuF56pCJU/vyxmKor2DAf6NCpf1Vu6fMRC7n1ioQ43an5Zvf58/+dtQSbBXBIcoT4hlH1v",
	"rlO1784t71MfUH9hcsdWL2rhjjPt1ks1oLJWD7n07PHwtc370lV7QsNM3/8428L22OSz/f7LsVqUg+tE",
	"8xE97c/9T2sTSiBEGh/RZybRCZZEzAieRrATKaF2+1wd2RRy1XniL+DvPXa/meKXLr6SHEmI0BroN0G4",
	"u5BYnTj6XdJZS8JW+/86SZYTGRRNnK2Qqo6kZTukYEVRtxZyJDQNMG0QVk3xCwgulPy3iu/bbs3Ymx2W",
	"39UGu1oDygy4jRL4dQ1lHDXYA4mQ5e4p/ZdU8inYFpciE0b6QJVsY060irQuNYmwdVfl5sPv+RK5Lkgq",
	"gE9KkacO27oZ2WXqu7X+dw89FlXvw9qOjvXphpBY+nOUJJalNmrfVvXqnRRea+D9c0YBPZmmphCskr/y",
	"SPMYL9UNxJeYRIrPP92lzO8IAH/k9b3XeL4/VHF9GlLUUz6qdC32mUzPXO/3SGCK+bKOW/ms7fQGMVou",
	"GG3bFjxgB4Hdf9GA2gOBR/JwTxpimRspWMoD0JFM2pc6/lrqyGraSvljmt4TGn5SX73BotfchMpExyAU",
	"vjruoGnPpyBp/MJTvJPupff5qs5IDULa/Pv83sRMGYwsq8XVeXKM3XjHYz2Bc87andhMhSKN0odUsl77",
	"t+lZ+q6MrCfx38w8TmPNMsjfaeu3FmhmDeCqUeGZQdYMYkIxrOddAw8Z26v20lOm/m/886g02zktNaDp",
	"13+RlBrYoJnuYIOewGg+sv4pgzILxi7sLiBEWL+Y8h2oOmY5TUSyjd3m6SROXmqzBB5GDdPqZpy5UiYn",
	"4rGSabdKplkGyWrx8XtQxDQ766KO6T3IVtpO9dQKFj/gyuT9JEHpODJsavMSWiugetv6qQKkJHQubPub",
	"ScKZtIX1GowLRgI7yt/dSP21PIq3CcFcMzsCfWvIZ4XWYnumSlPVFVt3e1YHUc+zOEz/gN9JwvYcZBMQ",
	"dkJyU3cNMB+6rqxFVxN7p4S8/8ZRCtmUtQDsrJLLsAkR8obvpgRMWIn1C1KuA7Q1QukIv2qJmEs9vz9u",
	"rz1k7w49ODd8D29RKMYN0oxnOOrFbMtT0b9adK+bWd6Nw8yDiaPqqqu42oeD+1dM9SEU3PUSZR+f9x7E",
	"LiqrloShDweW0XwXldDy3d4ztlrGjsfyqg+bRjTTePNRQ2jUqXrh9omSt8kxvUMwSb9mH2/SucTzh1c2",
	"eiVmSxpEyLBM/383lhhTecIk1fRBv07xfL1ubhutu+TBrwfsSmj+IHMC7Kp1nNR4toL27UR1/FXi+U27",
	"xGzQuIMVfMb4StZrh4wtBztVtGqzJYMfWEsLW5XYee5+gTsjR/0xn0bC8CAlac8RbDl/VuaMZo14FAEy",
	"TXRjq0mi/Wavvnq42Yl684DF8RHvrwxaPv4hVTrBbSuhqf2kNCubkBReQt0pzEVP/ta/g1WDGl1hgXDE",
	"AYfLFf/7Npy8V5zROTIrEVKxDZNrSERRnmxbVwiClBO5HLz648tKIeM0QZUTFOUj9NeIMrgc4QuLxz4S",
	"qDH5RO2+1/qtxSyuUmD4At6flE9ix2DPM4XkApBdHaFC4igyt4gUeKs03TTx1b5vIB89UQ0zdndisRlS",
	"xSEEKgmOxO9ELk4g4OBUulIBfLOW5d0QKxxtzw7cTBwsemKa9Z9G2BY2UbBuIBASSyIkCRrY3BETJonh",
	"3aVaY18YW8xQ6Oq3LHjPd+qx2KaspU5ME0uBQMNuaFgX0DBhxNR5igFTqblanh+Z2joYTYghxhGbE9og",
	"/kjxUb/RF0KI16lclLoSbpOWqakVLTMfn7ILoE6ikCMZOjk9QQZi9xlzPFQkAT5jPEbYbMHUTjo5PSkh",
	"CFwnwEkMVOZIkgo8hz1z48b5YA35Eer9Y/36iX27xyM8LPHq0swaDuVRJVzLllzqYa05FZ6bSBEu73fe",
	"1rYVv7QEGSTyQ/ZQGc2cmrrxG5/9meFh/QkupWk84oqr4JQNKFjhsOrE1Paqt+3r4J9XciI1HXn1xxel",
	"sE6xIMFEv25/CRi7IFD5iZGw+o7AcVT8oC6xPg9XGYpcojbJ8JYlDIaDlEeDV4MxTsj48tng5svN/wsA",
	"AP//MR3pu5rFAQA=",
}

// GetSwaggerSpecReader returns a reader to the Swagger specification corresponding to the generated code in this file.
func GetSwaggerSpecReader() (io.Reader, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	return zr, err
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zr, err := GetSwaggerSpecReader()
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
