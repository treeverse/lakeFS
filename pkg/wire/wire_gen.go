// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/goforj/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package wire

import (
	"context"
	"github.com/treeverse/lakefs/pkg/auth"
	"github.com/treeverse/lakefs/pkg/authentication"
	"github.com/treeverse/lakefs/pkg/block"
	"github.com/treeverse/lakefs/pkg/config"
	"github.com/treeverse/lakefs/pkg/graveler"
	"github.com/treeverse/lakefs/pkg/icebergsync"
	"github.com/treeverse/lakefs/pkg/kv"
	"github.com/treeverse/lakefs/pkg/license"
	"github.com/treeverse/lakefs/pkg/logging"
	"github.com/treeverse/lakefs/pkg/stats"
	"github.com/treeverse/lakefs/pkg/wire/api"
	auth2 "github.com/treeverse/lakefs/pkg/wire/auth"
	authentication2 "github.com/treeverse/lakefs/pkg/wire/authentication"
	block2 "github.com/treeverse/lakefs/pkg/wire/block"
	"github.com/treeverse/lakefs/pkg/wire/catalog"
	config2 "github.com/treeverse/lakefs/pkg/wire/config"
	"github.com/treeverse/lakefs/pkg/wire/gateway"
	license2 "github.com/treeverse/lakefs/pkg/wire/license"
)

// Injectors from injector.go:

// InitializeConfig creates the application configuration.
func InitializeConfig(cfgType string) (config.Config, error) {
	configImpl, err := config2.BuildConfig(cfgType)
	if err != nil {
		return nil, err
	}
	return configImpl, nil
}

// InitializeAuthService creates the auth service with all its dependencies.
func InitializeAuthService(ctx context.Context, cfg config.Config, logger logging.Logger, kvStore kv.Store) (auth.Service, error) {
	kvMetadataManager := auth2.NewMetadataManager(kvStore, cfg)
	service, err := auth2.NewAuthService(ctx, cfg, logger, kvStore, kvMetadataManager)
	if err != nil {
		return nil, err
	}
	return service, nil
}

// InitializeAuthenticationService creates the authentication service.
func InitializeAuthenticationService(ctx context.Context, cfg config.Config, logger logging.Logger) (authentication.Service, error) {
	service, err := authentication2.NewAuthenticationService(ctx, cfg, logger)
	if err != nil {
		return nil, err
	}
	return service, nil
}

// InitializeAuthenticatorChain creates the authenticator chain.
func InitializeAuthenticatorChain(cfg config.Config, logger logging.Logger, authService auth.Service) (auth.ChainAuthenticator, error) {
	chainAuthenticator, err := authentication2.BuildAuthenticatorChain(cfg, logger, authService)
	if err != nil {
		return nil, err
	}
	return chainAuthenticator, nil
}

// InitializeLoginTokenProvider creates the login token provider.
func InitializeLoginTokenProvider(ctx context.Context, cfg config.Config, logger logging.Logger, kvStore kv.Store) (authentication.LoginTokenProvider, error) {
	loginTokenProvider, err := authentication2.NewLoginTokenProvider(ctx, cfg, logger, kvStore)
	if err != nil {
		return nil, err
	}
	return loginTokenProvider, nil
}

// InitializeBlockAdapter creates the block adapter.
func InitializeBlockAdapter(ctx context.Context, statsCollector stats.Collector, cfg config.Config) (block.Adapter, error) {
	adapter, err := block2.BuildBlockAdapter(ctx, statsCollector, cfg)
	if err != nil {
		return nil, err
	}
	return adapter, nil
}

// InitializeLicenseManager creates the license manager.
func InitializeLicenseManager(ctx context.Context, cfg config.Config) (license.Manager, error) {
	manager, err := license2.NewLicenseManager(ctx, cfg)
	if err != nil {
		return nil, err
	}
	return manager, nil
}

// InitializeGatewayMiddleware creates the gateway middleware factory.
func InitializeGatewayMiddleware(ctx context.Context, cfg config.Config, logger logging.Logger) (gateway.MiddlewareFactory, error) {
	middlewareFactory, err := gateway.BuildMiddleware(ctx, cfg, logger)
	if err != nil {
		return nil, err
	}
	return middlewareFactory, nil
}

// InitializeIcebergController creates the Iceberg sync controller.
func InitializeIcebergController(cfg config.Config) icebergsync.Controller {
	controller := api.NewIcebergSyncController(cfg)
	return controller
}

// InitializeConflictResolvers creates the conflict resolvers for merge operations.
func InitializeConflictResolvers(cfg config.Config, blockAdapter block.Adapter) []graveler.ConflictResolver {
	v := catalog.BuildConflictResolvers(cfg, blockAdapter)
	return v
}
