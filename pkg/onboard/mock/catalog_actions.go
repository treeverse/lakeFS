// Code generated by MockGen. DO NOT EDIT.
// Source: catalog_actions.go

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	gomock "github.com/golang/mock/gomock"
	catalog "github.com/treeverse/lakefs/pkg/catalog"
	cmdutils "github.com/treeverse/lakefs/pkg/cmdutils"
	graveler "github.com/treeverse/lakefs/pkg/graveler"
	onboard "github.com/treeverse/lakefs/pkg/onboard"
	reflect "reflect"
)

// MockRepoActions is a mock of RepoActions interface
type MockRepoActions struct {
	ctrl     *gomock.Controller
	recorder *MockRepoActionsMockRecorder
}

// MockRepoActionsMockRecorder is the mock recorder for MockRepoActions
type MockRepoActionsMockRecorder struct {
	mock *MockRepoActions
}

// NewMockRepoActions creates a new mock instance
func NewMockRepoActions(ctrl *gomock.Controller) *MockRepoActions {
	mock := &MockRepoActions{ctrl: ctrl}
	mock.recorder = &MockRepoActionsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockRepoActions) EXPECT() *MockRepoActionsMockRecorder {
	return m.recorder
}

// Progress mocks base method
func (m *MockRepoActions) Progress() []*cmdutils.Progress {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Progress")
	ret0, _ := ret[0].([]*cmdutils.Progress)
	return ret0
}

// Progress indicates an expected call of Progress
func (mr *MockRepoActionsMockRecorder) Progress() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Progress", reflect.TypeOf((*MockRepoActions)(nil).Progress))
}

// ApplyImport mocks base method
func (m *MockRepoActions) ApplyImport(ctx context.Context, it onboard.Iterator, dryRun bool) (*onboard.Stats, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ApplyImport", ctx, it, dryRun)
	ret0, _ := ret[0].(*onboard.Stats)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ApplyImport indicates an expected call of ApplyImport
func (mr *MockRepoActionsMockRecorder) ApplyImport(ctx, it, dryRun interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ApplyImport", reflect.TypeOf((*MockRepoActions)(nil).ApplyImport), ctx, it, dryRun)
}

// Init mocks base method
func (m *MockRepoActions) Init(ctx context.Context, baseCommit graveler.CommitID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Init", ctx, baseCommit)
	ret0, _ := ret[0].(error)
	return ret0
}

// Init indicates an expected call of Init
func (mr *MockRepoActionsMockRecorder) Init(ctx, baseCommit interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Init", reflect.TypeOf((*MockRepoActions)(nil).Init), ctx, baseCommit)
}

// Commit mocks base method
func (m *MockRepoActions) Commit(ctx context.Context, commitMsg string, metadata catalog.Metadata) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit", ctx, commitMsg, metadata)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Commit indicates an expected call of Commit
func (mr *MockRepoActionsMockRecorder) Commit(ctx, commitMsg, metadata interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockRepoActions)(nil).Commit), ctx, commitMsg, metadata)
}

// MockEntryCatalog is a mock of EntryCatalog interface
type MockEntryCatalog struct {
	ctrl     *gomock.Controller
	recorder *MockEntryCatalogMockRecorder
}

// MockEntryCatalogMockRecorder is the mock recorder for MockEntryCatalog
type MockEntryCatalogMockRecorder struct {
	mock *MockEntryCatalog
}

// NewMockEntryCatalog creates a new mock instance
func NewMockEntryCatalog(ctrl *gomock.Controller) *MockEntryCatalog {
	mock := &MockEntryCatalog{ctrl: ctrl}
	mock.recorder = &MockEntryCatalogMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockEntryCatalog) EXPECT() *MockEntryCatalogMockRecorder {
	return m.recorder
}

// WriteMetaRange mocks base method
func (m *MockEntryCatalog) WriteMetaRange(ctx context.Context, repositoryID graveler.RepositoryID, it graveler.ValueIterator) (*graveler.MetaRangeID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WriteMetaRange", ctx, repositoryID, it)
	ret0, _ := ret[0].(*graveler.MetaRangeID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WriteMetaRange indicates an expected call of WriteMetaRange
func (mr *MockEntryCatalogMockRecorder) WriteMetaRange(ctx, repositoryID, it interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteMetaRange", reflect.TypeOf((*MockEntryCatalog)(nil).WriteMetaRange), ctx, repositoryID, it)
}

// AddCommitToBranchHead mocks base method
func (m *MockEntryCatalog) AddCommitToBranchHead(ctx context.Context, repositoryID graveler.RepositoryID, branchID graveler.BranchID, commit graveler.Commit) (graveler.CommitID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddCommitToBranchHead", ctx, repositoryID, branchID, commit)
	ret0, _ := ret[0].(graveler.CommitID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AddCommitToBranchHead indicates an expected call of AddCommitToBranchHead
func (mr *MockEntryCatalogMockRecorder) AddCommitToBranchHead(ctx, repositoryID, branchID, commit interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddCommitToBranchHead", reflect.TypeOf((*MockEntryCatalog)(nil).AddCommitToBranchHead), ctx, repositoryID, branchID, commit)
}

// List mocks base method
func (m *MockEntryCatalog) List(ctx context.Context, repositoryID graveler.RepositoryID, ref graveler.Ref) (graveler.ValueIterator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "List", ctx, repositoryID, ref)
	ret0, _ := ret[0].(graveler.ValueIterator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// List indicates an expected call of List
func (mr *MockEntryCatalogMockRecorder) List(ctx, repositoryID, ref interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockEntryCatalog)(nil).List), ctx, repositoryID, ref)
}

// AddCommit mocks base method
func (m *MockEntryCatalog) AddCommit(ctx context.Context, repositoryID graveler.RepositoryID, commit graveler.Commit) (graveler.CommitID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddCommit", ctx, repositoryID, commit)
	ret0, _ := ret[0].(graveler.CommitID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AddCommit indicates an expected call of AddCommit
func (mr *MockEntryCatalogMockRecorder) AddCommit(ctx, repositoryID, commit interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddCommit", reflect.TypeOf((*MockEntryCatalog)(nil).AddCommit), ctx, repositoryID, commit)
}

// UpdateBranch mocks base method
func (m *MockEntryCatalog) UpdateBranch(ctx context.Context, repositoryID graveler.RepositoryID, branchID graveler.BranchID, ref graveler.Ref) (*graveler.Branch, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateBranch", ctx, repositoryID, branchID, ref)
	ret0, _ := ret[0].(*graveler.Branch)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateBranch indicates an expected call of UpdateBranch
func (mr *MockEntryCatalogMockRecorder) UpdateBranch(ctx, repositoryID, branchID, ref interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateBranch", reflect.TypeOf((*MockEntryCatalog)(nil).UpdateBranch), ctx, repositoryID, branchID, ref)
}

// GetBranch mocks base method
func (m *MockEntryCatalog) GetBranch(ctx context.Context, repositoryID graveler.RepositoryID, branchID graveler.BranchID) (*graveler.Branch, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBranch", ctx, repositoryID, branchID)
	ret0, _ := ret[0].(*graveler.Branch)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBranch indicates an expected call of GetBranch
func (mr *MockEntryCatalogMockRecorder) GetBranch(ctx, repositoryID, branchID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBranch", reflect.TypeOf((*MockEntryCatalog)(nil).GetBranch), ctx, repositoryID, branchID)
}

// CreateBranch mocks base method
func (m *MockEntryCatalog) CreateBranch(ctx context.Context, repositoryID graveler.RepositoryID, branchID graveler.BranchID, ref graveler.Ref) (*graveler.Branch, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateBranch", ctx, repositoryID, branchID, ref)
	ret0, _ := ret[0].(*graveler.Branch)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateBranch indicates an expected call of CreateBranch
func (mr *MockEntryCatalogMockRecorder) CreateBranch(ctx, repositoryID, branchID, ref interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateBranch", reflect.TypeOf((*MockEntryCatalog)(nil).CreateBranch), ctx, repositoryID, branchID, ref)
}
