/*
 * lakeFS API
 *
 * lakeFS HTTP API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: services@treeverse.io
 * Generated by: https://openapi-generator.tech
 */

use crate::models;

#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct ObjectStats {
    #[serde(rename = "path")]
    pub path: String,
    #[serde(rename = "path_type")]
    pub path_type: PathType,
    /// The location of the object on the underlying object store. Formatted as a native URI with the object store type as scheme (\"s3://...\", \"gs://...\", etc.) Or, in the case of presign=true, will be an HTTP URL to be consumed via regular HTTP GET 
    #[serde(rename = "physical_address")]
    pub physical_address: String,
    /// If present and nonzero, physical_address is a pre-signed URL and will expire at this Unix Epoch time.  This will be shorter than the pre-signed URL lifetime if an authentication token is about to expire.  This field is *optional*. 
    #[serde(rename = "physical_address_expiry", skip_serializing_if = "Option::is_none")]
    pub physical_address_expiry: Option<i64>,
    #[serde(rename = "checksum")]
    pub checksum: String,
    /// The number of bytes in the object.  lakeFS always populates this field when returning ObjectStats.  This field is optional _for the client_ to supply, for instance on upload. 
    #[serde(rename = "size_bytes", skip_serializing_if = "Option::is_none")]
    pub size_bytes: Option<i64>,
    /// Unix Epoch in seconds
    #[serde(rename = "mtime")]
    pub mtime: i64,
    #[serde(rename = "metadata", skip_serializing_if = "Option::is_none")]
    pub metadata: Option<std::collections::HashMap<String, String>>,
    /// Object media type
    #[serde(rename = "content_type", skip_serializing_if = "Option::is_none")]
    pub content_type: Option<String>,
}

impl ObjectStats {
    pub fn new(path: String, path_type: PathType, physical_address: String, checksum: String, mtime: i64) -> ObjectStats {
        ObjectStats {
            path,
            path_type,
            physical_address,
            physical_address_expiry: None,
            checksum,
            size_bytes: None,
            mtime,
            metadata: None,
            content_type: None,
        }
    }
}
/// 
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum PathType {
    #[serde(rename = "common_prefix")]
    CommonPrefix,
    #[serde(rename = "object")]
    Object,
}

impl Default for PathType {
    fn default() -> PathType {
        Self::CommonPrefix
    }
}

