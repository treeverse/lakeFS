/* tslint:disable */
/* eslint-disable */
/**
 * lakeFS API
 * lakeFS HTTP API
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AbortPresignMultipartUpload,
  AuthenticationToken,
  CommitAsyncStatus,
  CommitCreation,
  CompletePresignMultipartUpload,
  ExternalLoginInformation,
  ExternalPrincipal,
  ExternalPrincipalCreation,
  ExternalPrincipalList,
  License,
  Merge,
  MergeAsyncStatus,
  MergeResult,
  ObjectStats,
  PresignMultipartUpload,
  PullRequest,
  PullRequestBasic,
  PullRequestCreation,
  PullRequestCreationResponse,
  PullRequestsList,
  StagingLocation,
  StsAuthRequest,
  TaskCreation,
  UpdateObjectUserMetadata,
  UploadPartCopyFrom,
  UploadPartFrom,
  UploadTo,
} from '../models/index';
import {
    AbortPresignMultipartUploadFromJSON,
    AbortPresignMultipartUploadToJSON,
    AuthenticationTokenFromJSON,
    AuthenticationTokenToJSON,
    CommitAsyncStatusFromJSON,
    CommitAsyncStatusToJSON,
    CommitCreationFromJSON,
    CommitCreationToJSON,
    CompletePresignMultipartUploadFromJSON,
    CompletePresignMultipartUploadToJSON,
    ExternalLoginInformationFromJSON,
    ExternalLoginInformationToJSON,
    ExternalPrincipalFromJSON,
    ExternalPrincipalToJSON,
    ExternalPrincipalCreationFromJSON,
    ExternalPrincipalCreationToJSON,
    ExternalPrincipalListFromJSON,
    ExternalPrincipalListToJSON,
    LicenseFromJSON,
    LicenseToJSON,
    MergeFromJSON,
    MergeToJSON,
    MergeAsyncStatusFromJSON,
    MergeAsyncStatusToJSON,
    MergeResultFromJSON,
    MergeResultToJSON,
    ObjectStatsFromJSON,
    ObjectStatsToJSON,
    PresignMultipartUploadFromJSON,
    PresignMultipartUploadToJSON,
    PullRequestFromJSON,
    PullRequestToJSON,
    PullRequestBasicFromJSON,
    PullRequestBasicToJSON,
    PullRequestCreationFromJSON,
    PullRequestCreationToJSON,
    PullRequestCreationResponseFromJSON,
    PullRequestCreationResponseToJSON,
    PullRequestsListFromJSON,
    PullRequestsListToJSON,
    StagingLocationFromJSON,
    StagingLocationToJSON,
    StsAuthRequestFromJSON,
    StsAuthRequestToJSON,
    TaskCreationFromJSON,
    TaskCreationToJSON,
    UpdateObjectUserMetadataFromJSON,
    UpdateObjectUserMetadataToJSON,
    UploadPartCopyFromFromJSON,
    UploadPartCopyFromToJSON,
    UploadPartFromFromJSON,
    UploadPartFromToJSON,
    UploadToFromJSON,
    UploadToToJSON,
} from '../models/index';

export interface AbortPresignMultipartUploadRequest {
    repository: string;
    branch: string;
    uploadId: string;
    path: string;
    abortPresignMultipartUpload?: AbortPresignMultipartUpload;
}

export interface CommitAsyncRequest {
    repository: string;
    branch: string;
    commitCreation: CommitCreation;
    sourceMetarange?: string;
}

export interface CommitAsyncStatusRequest {
    repository: string;
    branch: string;
    id: string;
}

export interface CompletePresignMultipartUploadRequest {
    repository: string;
    branch: string;
    uploadId: string;
    path: string;
    completePresignMultipartUpload?: CompletePresignMultipartUpload;
}

export interface CreatePresignMultipartUploadRequest {
    repository: string;
    branch: string;
    path: string;
    parts?: number;
}

export interface CreatePullRequestRequest {
    repository: string;
    pullRequestCreation: PullRequestCreation;
}

export interface CreateUserExternalPrincipalRequest {
    userId: string;
    principalId: string;
    externalPrincipalCreation?: ExternalPrincipalCreation;
}

export interface DeleteUserExternalPrincipalRequest {
    userId: string;
    principalId: string;
}

export interface ExternalPrincipalLoginRequest {
    externalLoginInformation?: ExternalLoginInformation;
}

export interface GetExternalPrincipalRequest {
    principalId: string;
}

export interface GetPullRequestRequest {
    repository: string;
    pullRequest: string;
}

export interface GetTokenFromMailboxRequest {
    mailbox: string;
}

export interface HardResetBranchRequest {
    repository: string;
    branch: string;
    ref: string;
    force?: boolean;
}

export interface ListPullRequestsRequest {
    repository: string;
    prefix?: string;
    after?: string;
    amount?: number;
    status?: ListPullRequestsStatus;
}

export interface ListUserExternalPrincipalsRequest {
    userId: string;
    prefix?: string;
    after?: string;
    amount?: number;
}

export interface MergeIntoBranchAsyncRequest {
    repository: string;
    sourceRef: string;
    destinationBranch: string;
    merge?: Merge;
}

export interface MergeIntoBranchAsyncStatusRequest {
    repository: string;
    sourceRef: string;
    destinationBranch: string;
    id: string;
}

export interface MergePullRequestRequest {
    repository: string;
    pullRequest: string;
}

export interface ReleaseTokenToMailboxRequest {
    loginRequestToken: string;
}

export interface StsLoginRequest {
    stsAuthRequest: StsAuthRequest;
}

export interface UpdateObjectUserMetadataRequest {
    repository: string;
    branch: string;
    path: string;
    updateObjectUserMetadata: UpdateObjectUserMetadata;
}

export interface UpdatePullRequestRequest {
    repository: string;
    pullRequest: string;
    pullRequestBasic: PullRequestBasic;
}

export interface UploadPartRequest {
    repository: string;
    branch: string;
    uploadId: string;
    path: string;
    partNumber: number;
    uploadPartFrom: UploadPartFrom;
}

export interface UploadPartCopyRequest {
    repository: string;
    branch: string;
    uploadId: string;
    path: string;
    partNumber: number;
    uploadPartCopyFrom: UploadPartCopyFrom;
}

/**
 * ExperimentalApi - interface
 * 
 * @export
 * @interface ExperimentalApiInterface
 */
export interface ExperimentalApiInterface {
    /**
     * Aborts a presign multipart upload.
     * @summary Abort a presign multipart upload
     * @param {string} repository 
     * @param {string} branch 
     * @param {string} uploadId 
     * @param {string} path relative to the branch
     * @param {AbortPresignMultipartUpload} [abortPresignMultipartUpload] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentalApiInterface
     */
    abortPresignMultipartUploadRaw(requestParameters: AbortPresignMultipartUploadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Aborts a presign multipart upload.
     * Abort a presign multipart upload
     */
    abortPresignMultipartUpload(requestParameters: AbortPresignMultipartUploadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary create commit asynchronously
     * @param {string} repository 
     * @param {string} branch 
     * @param {CommitCreation} commitCreation 
     * @param {string} [sourceMetarange] The source metarange to commit. Branch must not have uncommitted changes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentalApiInterface
     */
    commitAsyncRaw(requestParameters: CommitAsyncRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TaskCreation>>;

    /**
     * create commit asynchronously
     */
    commitAsync(requestParameters: CommitAsyncRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TaskCreation>;

    /**
     * 
     * @summary get status of async commit operation
     * @param {string} repository 
     * @param {string} branch 
     * @param {string} id Unique identifier of the commit async task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentalApiInterface
     */
    commitAsyncStatusRaw(requestParameters: CommitAsyncStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CommitAsyncStatus>>;

    /**
     * get status of async commit operation
     */
    commitAsyncStatus(requestParameters: CommitAsyncStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CommitAsyncStatus>;

    /**
     * Completes a presign multipart upload by assembling the uploaded parts.
     * @summary Complete a presign multipart upload request
     * @param {string} repository 
     * @param {string} branch 
     * @param {string} uploadId 
     * @param {string} path relative to the branch
     * @param {CompletePresignMultipartUpload} [completePresignMultipartUpload] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentalApiInterface
     */
    completePresignMultipartUploadRaw(requestParameters: CompletePresignMultipartUploadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ObjectStats>>;

    /**
     * Completes a presign multipart upload by assembling the uploaded parts.
     * Complete a presign multipart upload request
     */
    completePresignMultipartUpload(requestParameters: CompletePresignMultipartUploadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ObjectStats>;

    /**
     * Initiates a multipart upload and returns an upload ID with presigned URLs for each part (optional). Part numbers starts with 1. Each part except the last one has minimum size depends on the underlying blockstore implementation. For example working with S3 blockstore, minimum size is 5MB (excluding the last part). 
     * @summary Initiate a multipart upload
     * @param {string} repository 
     * @param {string} branch 
     * @param {string} path relative to the branch
     * @param {number} [parts] number of presigned URL parts required to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentalApiInterface
     */
    createPresignMultipartUploadRaw(requestParameters: CreatePresignMultipartUploadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PresignMultipartUpload>>;

    /**
     * Initiates a multipart upload and returns an upload ID with presigned URLs for each part (optional). Part numbers starts with 1. Each part except the last one has minimum size depends on the underlying blockstore implementation. For example working with S3 blockstore, minimum size is 5MB (excluding the last part). 
     * Initiate a multipart upload
     */
    createPresignMultipartUpload(requestParameters: CreatePresignMultipartUploadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PresignMultipartUpload>;

    /**
     * 
     * @summary create pull request
     * @param {string} repository 
     * @param {PullRequestCreation} pullRequestCreation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentalApiInterface
     */
    createPullRequestRaw(requestParameters: CreatePullRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PullRequestCreationResponse>>;

    /**
     * create pull request
     */
    createPullRequest(requestParameters: CreatePullRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PullRequestCreationResponse>;

    /**
     * 
     * @summary attach external principal to user
     * @param {string} userId 
     * @param {string} principalId 
     * @param {ExternalPrincipalCreation} [externalPrincipalCreation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentalApiInterface
     */
    createUserExternalPrincipalRaw(requestParameters: CreateUserExternalPrincipalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * attach external principal to user
     */
    createUserExternalPrincipal(requestParameters: CreateUserExternalPrincipalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary delete external principal from user
     * @param {string} userId 
     * @param {string} principalId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentalApiInterface
     */
    deleteUserExternalPrincipalRaw(requestParameters: DeleteUserExternalPrincipalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * delete external principal from user
     */
    deleteUserExternalPrincipal(requestParameters: DeleteUserExternalPrincipalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary perform a login using an external authenticator
     * @param {ExternalLoginInformation} [externalLoginInformation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentalApiInterface
     */
    externalPrincipalLoginRaw(requestParameters: ExternalPrincipalLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthenticationToken>>;

    /**
     * perform a login using an external authenticator
     */
    externalPrincipalLogin(requestParameters: ExternalPrincipalLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthenticationToken>;

    /**
     * 
     * @summary describe external principal by id
     * @param {string} principalId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentalApiInterface
     */
    getExternalPrincipalRaw(requestParameters: GetExternalPrincipalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExternalPrincipal>>;

    /**
     * describe external principal by id
     */
    getExternalPrincipal(requestParameters: GetExternalPrincipalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExternalPrincipal>;

    /**
     * retrieve lakeFS license information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentalApiInterface
     */
    getLicenseRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<License>>;

    /**
     * retrieve lakeFS license information
     */
    getLicense(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<License>;

    /**
     * 
     * @summary get pull request
     * @param {string} repository 
     * @param {string} pullRequest pull request id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentalApiInterface
     */
    getPullRequestRaw(requestParameters: GetPullRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PullRequest>>;

    /**
     * get pull request
     */
    getPullRequest(requestParameters: GetPullRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PullRequest>;

    /**
     * 
     * @summary receive the token after user has authenticated on redirect URL.
     * @param {string} mailbox mailbox returned by getTokenRedirect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentalApiInterface
     */
    getTokenFromMailboxRaw(requestParameters: GetTokenFromMailboxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthenticationToken>>;

    /**
     * receive the token after user has authenticated on redirect URL.
     */
    getTokenFromMailbox(requestParameters: GetTokenFromMailboxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthenticationToken>;

    /**
     * 
     * @summary start acquiring a token by logging in on a browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentalApiInterface
     */
    getTokenRedirectRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Error>>;

    /**
     * start acquiring a token by logging in on a browser
     */
    getTokenRedirect(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Error>;

    /**
     * Relocate branch to refer to ref.  Branch must not contain uncommitted data.
     * @summary hard reset branch
     * @param {string} repository 
     * @param {string} branch 
     * @param {string} ref After reset, branch will point at this reference.
     * @param {boolean} [force] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentalApiInterface
     */
    hardResetBranchRaw(requestParameters: HardResetBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Relocate branch to refer to ref.  Branch must not contain uncommitted data.
     * hard reset branch
     */
    hardResetBranch(requestParameters: HardResetBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary list pull requests
     * @param {string} repository 
     * @param {string} [prefix] return items prefixed with this value
     * @param {string} [after] return items after this value
     * @param {number} [amount] how many items to return
     * @param {'open' | 'closed' | 'all'} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentalApiInterface
     */
    listPullRequestsRaw(requestParameters: ListPullRequestsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PullRequestsList>>;

    /**
     * list pull requests
     */
    listPullRequests(requestParameters: ListPullRequestsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PullRequestsList>;

    /**
     * 
     * @summary list user external policies attached to a user
     * @param {string} userId 
     * @param {string} [prefix] return items prefixed with this value
     * @param {string} [after] return items after this value
     * @param {number} [amount] how many items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentalApiInterface
     */
    listUserExternalPrincipalsRaw(requestParameters: ListUserExternalPrincipalsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExternalPrincipalList>>;

    /**
     * list user external policies attached to a user
     */
    listUserExternalPrincipals(requestParameters: ListUserExternalPrincipalsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExternalPrincipalList>;

    /**
     * 
     * @summary merge references asynchronously
     * @param {string} repository 
     * @param {string} sourceRef source ref
     * @param {string} destinationBranch destination branch name
     * @param {Merge} [merge] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentalApiInterface
     */
    mergeIntoBranchAsyncRaw(requestParameters: MergeIntoBranchAsyncRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TaskCreation>>;

    /**
     * merge references asynchronously
     */
    mergeIntoBranchAsync(requestParameters: MergeIntoBranchAsyncRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TaskCreation>;

    /**
     * 
     * @summary get status of async merge operation
     * @param {string} repository 
     * @param {string} sourceRef source ref
     * @param {string} destinationBranch destination branch name
     * @param {string} id Unique identifier of the merge async task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentalApiInterface
     */
    mergeIntoBranchAsyncStatusRaw(requestParameters: MergeIntoBranchAsyncStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MergeAsyncStatus>>;

    /**
     * get status of async merge operation
     */
    mergeIntoBranchAsyncStatus(requestParameters: MergeIntoBranchAsyncStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MergeAsyncStatus>;

    /**
     * 
     * @summary merge pull request
     * @param {string} repository 
     * @param {string} pullRequest pull request id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentalApiInterface
     */
    mergePullRequestRaw(requestParameters: MergePullRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MergeResult>>;

    /**
     * merge pull request
     */
    mergePullRequest(requestParameters: MergePullRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MergeResult>;

    /**
     * 
     * @summary release a token for the current (authenticated) user to the mailbox of this login request.
     * @param {string} loginRequestToken login request token returned by getTokenRedirect.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentalApiInterface
     */
    releaseTokenToMailboxRaw(requestParameters: ReleaseTokenToMailboxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * release a token for the current (authenticated) user to the mailbox of this login request.
     */
    releaseTokenToMailbox(requestParameters: ReleaseTokenToMailboxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary perform a login with STS
     * @param {StsAuthRequest} stsAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentalApiInterface
     */
    stsLoginRaw(requestParameters: StsLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthenticationToken>>;

    /**
     * perform a login with STS
     */
    stsLogin(requestParameters: StsLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthenticationToken>;

    /**
     * 
     * @summary rewrite (all) object metadata
     * @param {string} repository 
     * @param {string} branch branch to update
     * @param {string} path path to object relative to the branch
     * @param {UpdateObjectUserMetadata} updateObjectUserMetadata 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentalApiInterface
     */
    updateObjectUserMetadataRaw(requestParameters: UpdateObjectUserMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * rewrite (all) object metadata
     */
    updateObjectUserMetadata(requestParameters: UpdateObjectUserMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary update pull request
     * @param {string} repository 
     * @param {string} pullRequest pull request id
     * @param {PullRequestBasic} pullRequestBasic 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentalApiInterface
     */
    updatePullRequestRaw(requestParameters: UpdatePullRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * update pull request
     */
    updatePullRequest(requestParameters: UpdatePullRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Return a presigned URL to upload into a presigned multipart upload.
     * @param {string} repository 
     * @param {string} branch 
     * @param {string} uploadId 
     * @param {string} path 
     * @param {number} partNumber 
     * @param {UploadPartFrom} uploadPartFrom 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentalApiInterface
     */
    uploadPartRaw(requestParameters: UploadPartRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UploadTo>>;

    /**
     * Return a presigned URL to upload into a presigned multipart upload.
     */
    uploadPart(requestParameters: UploadPartRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UploadTo>;

    /**
     * Upload a part by copying part of another object.
     * @param {string} repository 
     * @param {string} branch 
     * @param {string} uploadId 
     * @param {string} path 
     * @param {number} partNumber 
     * @param {UploadPartCopyFrom} uploadPartCopyFrom 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentalApiInterface
     */
    uploadPartCopyRaw(requestParameters: UploadPartCopyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Upload a part by copying part of another object.
     */
    uploadPartCopy(requestParameters: UploadPartCopyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

}

/**
 * 
 */
export class ExperimentalApi extends runtime.BaseAPI implements ExperimentalApiInterface {

    /**
     * Aborts a presign multipart upload.
     * Abort a presign multipart upload
     */
    async abortPresignMultipartUploadRaw(requestParameters: AbortPresignMultipartUploadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling abortPresignMultipartUpload.');
        }

        if (requestParameters.branch === null || requestParameters.branch === undefined) {
            throw new runtime.RequiredError('branch','Required parameter requestParameters.branch was null or undefined when calling abortPresignMultipartUpload.');
        }

        if (requestParameters.uploadId === null || requestParameters.uploadId === undefined) {
            throw new runtime.RequiredError('uploadId','Required parameter requestParameters.uploadId was null or undefined when calling abortPresignMultipartUpload.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling abortPresignMultipartUpload.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/branches/{branch}/staging/pmpu/{uploadId}`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))).replace(`{${"branch"}}`, encodeURIComponent(String(requestParameters.branch))).replace(`{${"uploadId"}}`, encodeURIComponent(String(requestParameters.uploadId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: AbortPresignMultipartUploadToJSON(requestParameters.abortPresignMultipartUpload),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Aborts a presign multipart upload.
     * Abort a presign multipart upload
     */
    async abortPresignMultipartUpload(requestParameters: AbortPresignMultipartUploadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.abortPresignMultipartUploadRaw(requestParameters, initOverrides);
    }

    /**
     * create commit asynchronously
     */
    async commitAsyncRaw(requestParameters: CommitAsyncRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TaskCreation>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling commitAsync.');
        }

        if (requestParameters.branch === null || requestParameters.branch === undefined) {
            throw new runtime.RequiredError('branch','Required parameter requestParameters.branch was null or undefined when calling commitAsync.');
        }

        if (requestParameters.commitCreation === null || requestParameters.commitCreation === undefined) {
            throw new runtime.RequiredError('commitCreation','Required parameter requestParameters.commitCreation was null or undefined when calling commitAsync.');
        }

        const queryParameters: any = {};

        if (requestParameters.sourceMetarange !== undefined) {
            queryParameters['source_metarange'] = requestParameters.sourceMetarange;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/branches/{branch}/commits/async`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))).replace(`{${"branch"}}`, encodeURIComponent(String(requestParameters.branch))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CommitCreationToJSON(requestParameters.commitCreation),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskCreationFromJSON(jsonValue));
    }

    /**
     * create commit asynchronously
     */
    async commitAsync(requestParameters: CommitAsyncRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TaskCreation> {
        const response = await this.commitAsyncRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get status of async commit operation
     */
    async commitAsyncStatusRaw(requestParameters: CommitAsyncStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CommitAsyncStatus>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling commitAsyncStatus.');
        }

        if (requestParameters.branch === null || requestParameters.branch === undefined) {
            throw new runtime.RequiredError('branch','Required parameter requestParameters.branch was null or undefined when calling commitAsyncStatus.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling commitAsyncStatus.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/branches/{branch}/commits/async/{id}/status`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))).replace(`{${"branch"}}`, encodeURIComponent(String(requestParameters.branch))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CommitAsyncStatusFromJSON(jsonValue));
    }

    /**
     * get status of async commit operation
     */
    async commitAsyncStatus(requestParameters: CommitAsyncStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CommitAsyncStatus> {
        const response = await this.commitAsyncStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Completes a presign multipart upload by assembling the uploaded parts.
     * Complete a presign multipart upload request
     */
    async completePresignMultipartUploadRaw(requestParameters: CompletePresignMultipartUploadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ObjectStats>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling completePresignMultipartUpload.');
        }

        if (requestParameters.branch === null || requestParameters.branch === undefined) {
            throw new runtime.RequiredError('branch','Required parameter requestParameters.branch was null or undefined when calling completePresignMultipartUpload.');
        }

        if (requestParameters.uploadId === null || requestParameters.uploadId === undefined) {
            throw new runtime.RequiredError('uploadId','Required parameter requestParameters.uploadId was null or undefined when calling completePresignMultipartUpload.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling completePresignMultipartUpload.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/branches/{branch}/staging/pmpu/{uploadId}`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))).replace(`{${"branch"}}`, encodeURIComponent(String(requestParameters.branch))).replace(`{${"uploadId"}}`, encodeURIComponent(String(requestParameters.uploadId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: CompletePresignMultipartUploadToJSON(requestParameters.completePresignMultipartUpload),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ObjectStatsFromJSON(jsonValue));
    }

    /**
     * Completes a presign multipart upload by assembling the uploaded parts.
     * Complete a presign multipart upload request
     */
    async completePresignMultipartUpload(requestParameters: CompletePresignMultipartUploadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ObjectStats> {
        const response = await this.completePresignMultipartUploadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Initiates a multipart upload and returns an upload ID with presigned URLs for each part (optional). Part numbers starts with 1. Each part except the last one has minimum size depends on the underlying blockstore implementation. For example working with S3 blockstore, minimum size is 5MB (excluding the last part). 
     * Initiate a multipart upload
     */
    async createPresignMultipartUploadRaw(requestParameters: CreatePresignMultipartUploadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PresignMultipartUpload>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling createPresignMultipartUpload.');
        }

        if (requestParameters.branch === null || requestParameters.branch === undefined) {
            throw new runtime.RequiredError('branch','Required parameter requestParameters.branch was null or undefined when calling createPresignMultipartUpload.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling createPresignMultipartUpload.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        if (requestParameters.parts !== undefined) {
            queryParameters['parts'] = requestParameters.parts;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/branches/{branch}/staging/pmpu`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))).replace(`{${"branch"}}`, encodeURIComponent(String(requestParameters.branch))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PresignMultipartUploadFromJSON(jsonValue));
    }

    /**
     * Initiates a multipart upload and returns an upload ID with presigned URLs for each part (optional). Part numbers starts with 1. Each part except the last one has minimum size depends on the underlying blockstore implementation. For example working with S3 blockstore, minimum size is 5MB (excluding the last part). 
     * Initiate a multipart upload
     */
    async createPresignMultipartUpload(requestParameters: CreatePresignMultipartUploadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PresignMultipartUpload> {
        const response = await this.createPresignMultipartUploadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create pull request
     */
    async createPullRequestRaw(requestParameters: CreatePullRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PullRequestCreationResponse>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling createPullRequest.');
        }

        if (requestParameters.pullRequestCreation === null || requestParameters.pullRequestCreation === undefined) {
            throw new runtime.RequiredError('pullRequestCreation','Required parameter requestParameters.pullRequestCreation was null or undefined when calling createPullRequest.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/pulls`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PullRequestCreationToJSON(requestParameters.pullRequestCreation),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PullRequestCreationResponseFromJSON(jsonValue));
    }

    /**
     * create pull request
     */
    async createPullRequest(requestParameters: CreatePullRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PullRequestCreationResponse> {
        const response = await this.createPullRequestRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * attach external principal to user
     */
    async createUserExternalPrincipalRaw(requestParameters: CreateUserExternalPrincipalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling createUserExternalPrincipal.');
        }

        if (requestParameters.principalId === null || requestParameters.principalId === undefined) {
            throw new runtime.RequiredError('principalId','Required parameter requestParameters.principalId was null or undefined when calling createUserExternalPrincipal.');
        }

        const queryParameters: any = {};

        if (requestParameters.principalId !== undefined) {
            queryParameters['principalId'] = requestParameters.principalId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/users/{userId}/external/principals`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ExternalPrincipalCreationToJSON(requestParameters.externalPrincipalCreation),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * attach external principal to user
     */
    async createUserExternalPrincipal(requestParameters: CreateUserExternalPrincipalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.createUserExternalPrincipalRaw(requestParameters, initOverrides);
    }

    /**
     * delete external principal from user
     */
    async deleteUserExternalPrincipalRaw(requestParameters: DeleteUserExternalPrincipalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling deleteUserExternalPrincipal.');
        }

        if (requestParameters.principalId === null || requestParameters.principalId === undefined) {
            throw new runtime.RequiredError('principalId','Required parameter requestParameters.principalId was null or undefined when calling deleteUserExternalPrincipal.');
        }

        const queryParameters: any = {};

        if (requestParameters.principalId !== undefined) {
            queryParameters['principalId'] = requestParameters.principalId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/users/{userId}/external/principals`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * delete external principal from user
     */
    async deleteUserExternalPrincipal(requestParameters: DeleteUserExternalPrincipalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteUserExternalPrincipalRaw(requestParameters, initOverrides);
    }

    /**
     * perform a login using an external authenticator
     */
    async externalPrincipalLoginRaw(requestParameters: ExternalPrincipalLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthenticationToken>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/auth/external/principal/login`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ExternalLoginInformationToJSON(requestParameters.externalLoginInformation),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthenticationTokenFromJSON(jsonValue));
    }

    /**
     * perform a login using an external authenticator
     */
    async externalPrincipalLogin(requestParameters: ExternalPrincipalLoginRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthenticationToken> {
        const response = await this.externalPrincipalLoginRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * describe external principal by id
     */
    async getExternalPrincipalRaw(requestParameters: GetExternalPrincipalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExternalPrincipal>> {
        if (requestParameters.principalId === null || requestParameters.principalId === undefined) {
            throw new runtime.RequiredError('principalId','Required parameter requestParameters.principalId was null or undefined when calling getExternalPrincipal.');
        }

        const queryParameters: any = {};

        if (requestParameters.principalId !== undefined) {
            queryParameters['principalId'] = requestParameters.principalId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/external/principals`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExternalPrincipalFromJSON(jsonValue));
    }

    /**
     * describe external principal by id
     */
    async getExternalPrincipal(requestParameters: GetExternalPrincipalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExternalPrincipal> {
        const response = await this.getExternalPrincipalRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * retrieve lakeFS license information
     */
    async getLicenseRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<License>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/license`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LicenseFromJSON(jsonValue));
    }

    /**
     * retrieve lakeFS license information
     */
    async getLicense(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<License> {
        const response = await this.getLicenseRaw(initOverrides);
        return await response.value();
    }

    /**
     * get pull request
     */
    async getPullRequestRaw(requestParameters: GetPullRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PullRequest>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling getPullRequest.');
        }

        if (requestParameters.pullRequest === null || requestParameters.pullRequest === undefined) {
            throw new runtime.RequiredError('pullRequest','Required parameter requestParameters.pullRequest was null or undefined when calling getPullRequest.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/pulls/{pull_request}`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))).replace(`{${"pull_request"}}`, encodeURIComponent(String(requestParameters.pullRequest))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PullRequestFromJSON(jsonValue));
    }

    /**
     * get pull request
     */
    async getPullRequest(requestParameters: GetPullRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PullRequest> {
        const response = await this.getPullRequestRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * receive the token after user has authenticated on redirect URL.
     */
    async getTokenFromMailboxRaw(requestParameters: GetTokenFromMailboxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthenticationToken>> {
        if (requestParameters.mailbox === null || requestParameters.mailbox === undefined) {
            throw new runtime.RequiredError('mailbox','Required parameter requestParameters.mailbox was null or undefined when calling getTokenFromMailbox.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/auth/get-token/mailboxes/{mailbox}`.replace(`{${"mailbox"}}`, encodeURIComponent(String(requestParameters.mailbox))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthenticationTokenFromJSON(jsonValue));
    }

    /**
     * receive the token after user has authenticated on redirect URL.
     */
    async getTokenFromMailbox(requestParameters: GetTokenFromMailboxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthenticationToken> {
        const response = await this.getTokenFromMailboxRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * start acquiring a token by logging in on a browser
     */
    async getTokenRedirectRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Error>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/auth/get-token/start`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<Error>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * start acquiring a token by logging in on a browser
     */
    async getTokenRedirect(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Error> {
        const response = await this.getTokenRedirectRaw(initOverrides);
        return await response.value();
    }

    /**
     * Relocate branch to refer to ref.  Branch must not contain uncommitted data.
     * hard reset branch
     */
    async hardResetBranchRaw(requestParameters: HardResetBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling hardResetBranch.');
        }

        if (requestParameters.branch === null || requestParameters.branch === undefined) {
            throw new runtime.RequiredError('branch','Required parameter requestParameters.branch was null or undefined when calling hardResetBranch.');
        }

        if (requestParameters.ref === null || requestParameters.ref === undefined) {
            throw new runtime.RequiredError('ref','Required parameter requestParameters.ref was null or undefined when calling hardResetBranch.');
        }

        const queryParameters: any = {};

        if (requestParameters.ref !== undefined) {
            queryParameters['ref'] = requestParameters.ref;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/branches/{branch}/hard_reset`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))).replace(`{${"branch"}}`, encodeURIComponent(String(requestParameters.branch))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Relocate branch to refer to ref.  Branch must not contain uncommitted data.
     * hard reset branch
     */
    async hardResetBranch(requestParameters: HardResetBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.hardResetBranchRaw(requestParameters, initOverrides);
    }

    /**
     * list pull requests
     */
    async listPullRequestsRaw(requestParameters: ListPullRequestsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PullRequestsList>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling listPullRequests.');
        }

        const queryParameters: any = {};

        if (requestParameters.prefix !== undefined) {
            queryParameters['prefix'] = requestParameters.prefix;
        }

        if (requestParameters.after !== undefined) {
            queryParameters['after'] = requestParameters.after;
        }

        if (requestParameters.amount !== undefined) {
            queryParameters['amount'] = requestParameters.amount;
        }

        if (requestParameters.status !== undefined) {
            queryParameters['status'] = requestParameters.status;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/pulls`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PullRequestsListFromJSON(jsonValue));
    }

    /**
     * list pull requests
     */
    async listPullRequests(requestParameters: ListPullRequestsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PullRequestsList> {
        const response = await this.listPullRequestsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list user external policies attached to a user
     */
    async listUserExternalPrincipalsRaw(requestParameters: ListUserExternalPrincipalsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExternalPrincipalList>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling listUserExternalPrincipals.');
        }

        const queryParameters: any = {};

        if (requestParameters.prefix !== undefined) {
            queryParameters['prefix'] = requestParameters.prefix;
        }

        if (requestParameters.after !== undefined) {
            queryParameters['after'] = requestParameters.after;
        }

        if (requestParameters.amount !== undefined) {
            queryParameters['amount'] = requestParameters.amount;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/users/{userId}/external/principals/ls`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExternalPrincipalListFromJSON(jsonValue));
    }

    /**
     * list user external policies attached to a user
     */
    async listUserExternalPrincipals(requestParameters: ListUserExternalPrincipalsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExternalPrincipalList> {
        const response = await this.listUserExternalPrincipalsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * merge references asynchronously
     */
    async mergeIntoBranchAsyncRaw(requestParameters: MergeIntoBranchAsyncRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TaskCreation>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling mergeIntoBranchAsync.');
        }

        if (requestParameters.sourceRef === null || requestParameters.sourceRef === undefined) {
            throw new runtime.RequiredError('sourceRef','Required parameter requestParameters.sourceRef was null or undefined when calling mergeIntoBranchAsync.');
        }

        if (requestParameters.destinationBranch === null || requestParameters.destinationBranch === undefined) {
            throw new runtime.RequiredError('destinationBranch','Required parameter requestParameters.destinationBranch was null or undefined when calling mergeIntoBranchAsync.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/refs/{sourceRef}/merge/{destinationBranch}/async`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))).replace(`{${"sourceRef"}}`, encodeURIComponent(String(requestParameters.sourceRef))).replace(`{${"destinationBranch"}}`, encodeURIComponent(String(requestParameters.destinationBranch))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MergeToJSON(requestParameters.merge),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskCreationFromJSON(jsonValue));
    }

    /**
     * merge references asynchronously
     */
    async mergeIntoBranchAsync(requestParameters: MergeIntoBranchAsyncRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TaskCreation> {
        const response = await this.mergeIntoBranchAsyncRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get status of async merge operation
     */
    async mergeIntoBranchAsyncStatusRaw(requestParameters: MergeIntoBranchAsyncStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MergeAsyncStatus>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling mergeIntoBranchAsyncStatus.');
        }

        if (requestParameters.sourceRef === null || requestParameters.sourceRef === undefined) {
            throw new runtime.RequiredError('sourceRef','Required parameter requestParameters.sourceRef was null or undefined when calling mergeIntoBranchAsyncStatus.');
        }

        if (requestParameters.destinationBranch === null || requestParameters.destinationBranch === undefined) {
            throw new runtime.RequiredError('destinationBranch','Required parameter requestParameters.destinationBranch was null or undefined when calling mergeIntoBranchAsyncStatus.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling mergeIntoBranchAsyncStatus.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/refs/{sourceRef}/merge/{destinationBranch}/async/{id}/status`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))).replace(`{${"sourceRef"}}`, encodeURIComponent(String(requestParameters.sourceRef))).replace(`{${"destinationBranch"}}`, encodeURIComponent(String(requestParameters.destinationBranch))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MergeAsyncStatusFromJSON(jsonValue));
    }

    /**
     * get status of async merge operation
     */
    async mergeIntoBranchAsyncStatus(requestParameters: MergeIntoBranchAsyncStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MergeAsyncStatus> {
        const response = await this.mergeIntoBranchAsyncStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * merge pull request
     */
    async mergePullRequestRaw(requestParameters: MergePullRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MergeResult>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling mergePullRequest.');
        }

        if (requestParameters.pullRequest === null || requestParameters.pullRequest === undefined) {
            throw new runtime.RequiredError('pullRequest','Required parameter requestParameters.pullRequest was null or undefined when calling mergePullRequest.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/pulls/{pull_request}/merge`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))).replace(`{${"pull_request"}}`, encodeURIComponent(String(requestParameters.pullRequest))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MergeResultFromJSON(jsonValue));
    }

    /**
     * merge pull request
     */
    async mergePullRequest(requestParameters: MergePullRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MergeResult> {
        const response = await this.mergePullRequestRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * release a token for the current (authenticated) user to the mailbox of this login request.
     */
    async releaseTokenToMailboxRaw(requestParameters: ReleaseTokenToMailboxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.loginRequestToken === null || requestParameters.loginRequestToken === undefined) {
            throw new runtime.RequiredError('loginRequestToken','Required parameter requestParameters.loginRequestToken was null or undefined when calling releaseTokenToMailbox.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/get-token/release-token/{loginRequestToken}`.replace(`{${"loginRequestToken"}}`, encodeURIComponent(String(requestParameters.loginRequestToken))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * release a token for the current (authenticated) user to the mailbox of this login request.
     */
    async releaseTokenToMailbox(requestParameters: ReleaseTokenToMailboxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.releaseTokenToMailboxRaw(requestParameters, initOverrides);
    }

    /**
     * perform a login with STS
     */
    async stsLoginRaw(requestParameters: StsLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthenticationToken>> {
        if (requestParameters.stsAuthRequest === null || requestParameters.stsAuthRequest === undefined) {
            throw new runtime.RequiredError('stsAuthRequest','Required parameter requestParameters.stsAuthRequest was null or undefined when calling stsLogin.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sts/login`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StsAuthRequestToJSON(requestParameters.stsAuthRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthenticationTokenFromJSON(jsonValue));
    }

    /**
     * perform a login with STS
     */
    async stsLogin(requestParameters: StsLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthenticationToken> {
        const response = await this.stsLoginRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * rewrite (all) object metadata
     */
    async updateObjectUserMetadataRaw(requestParameters: UpdateObjectUserMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling updateObjectUserMetadata.');
        }

        if (requestParameters.branch === null || requestParameters.branch === undefined) {
            throw new runtime.RequiredError('branch','Required parameter requestParameters.branch was null or undefined when calling updateObjectUserMetadata.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling updateObjectUserMetadata.');
        }

        if (requestParameters.updateObjectUserMetadata === null || requestParameters.updateObjectUserMetadata === undefined) {
            throw new runtime.RequiredError('updateObjectUserMetadata','Required parameter requestParameters.updateObjectUserMetadata was null or undefined when calling updateObjectUserMetadata.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/branches/{branch}/objects/stat/user_metadata`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))).replace(`{${"branch"}}`, encodeURIComponent(String(requestParameters.branch))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateObjectUserMetadataToJSON(requestParameters.updateObjectUserMetadata),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * rewrite (all) object metadata
     */
    async updateObjectUserMetadata(requestParameters: UpdateObjectUserMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateObjectUserMetadataRaw(requestParameters, initOverrides);
    }

    /**
     * update pull request
     */
    async updatePullRequestRaw(requestParameters: UpdatePullRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling updatePullRequest.');
        }

        if (requestParameters.pullRequest === null || requestParameters.pullRequest === undefined) {
            throw new runtime.RequiredError('pullRequest','Required parameter requestParameters.pullRequest was null or undefined when calling updatePullRequest.');
        }

        if (requestParameters.pullRequestBasic === null || requestParameters.pullRequestBasic === undefined) {
            throw new runtime.RequiredError('pullRequestBasic','Required parameter requestParameters.pullRequestBasic was null or undefined when calling updatePullRequest.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/pulls/{pull_request}`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))).replace(`{${"pull_request"}}`, encodeURIComponent(String(requestParameters.pullRequest))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PullRequestBasicToJSON(requestParameters.pullRequestBasic),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * update pull request
     */
    async updatePullRequest(requestParameters: UpdatePullRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updatePullRequestRaw(requestParameters, initOverrides);
    }

    /**
     * Return a presigned URL to upload into a presigned multipart upload.
     */
    async uploadPartRaw(requestParameters: UploadPartRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UploadTo>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling uploadPart.');
        }

        if (requestParameters.branch === null || requestParameters.branch === undefined) {
            throw new runtime.RequiredError('branch','Required parameter requestParameters.branch was null or undefined when calling uploadPart.');
        }

        if (requestParameters.uploadId === null || requestParameters.uploadId === undefined) {
            throw new runtime.RequiredError('uploadId','Required parameter requestParameters.uploadId was null or undefined when calling uploadPart.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling uploadPart.');
        }

        if (requestParameters.partNumber === null || requestParameters.partNumber === undefined) {
            throw new runtime.RequiredError('partNumber','Required parameter requestParameters.partNumber was null or undefined when calling uploadPart.');
        }

        if (requestParameters.uploadPartFrom === null || requestParameters.uploadPartFrom === undefined) {
            throw new runtime.RequiredError('uploadPartFrom','Required parameter requestParameters.uploadPartFrom was null or undefined when calling uploadPart.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/branches/{branch}/staging/pmpu/{uploadId}/parts/{partNumber}`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))).replace(`{${"branch"}}`, encodeURIComponent(String(requestParameters.branch))).replace(`{${"uploadId"}}`, encodeURIComponent(String(requestParameters.uploadId))).replace(`{${"partNumber"}}`, encodeURIComponent(String(requestParameters.partNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UploadPartFromToJSON(requestParameters.uploadPartFrom),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UploadToFromJSON(jsonValue));
    }

    /**
     * Return a presigned URL to upload into a presigned multipart upload.
     */
    async uploadPart(requestParameters: UploadPartRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UploadTo> {
        const response = await this.uploadPartRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upload a part by copying part of another object.
     */
    async uploadPartCopyRaw(requestParameters: UploadPartCopyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling uploadPartCopy.');
        }

        if (requestParameters.branch === null || requestParameters.branch === undefined) {
            throw new runtime.RequiredError('branch','Required parameter requestParameters.branch was null or undefined when calling uploadPartCopy.');
        }

        if (requestParameters.uploadId === null || requestParameters.uploadId === undefined) {
            throw new runtime.RequiredError('uploadId','Required parameter requestParameters.uploadId was null or undefined when calling uploadPartCopy.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling uploadPartCopy.');
        }

        if (requestParameters.partNumber === null || requestParameters.partNumber === undefined) {
            throw new runtime.RequiredError('partNumber','Required parameter requestParameters.partNumber was null or undefined when calling uploadPartCopy.');
        }

        if (requestParameters.uploadPartCopyFrom === null || requestParameters.uploadPartCopyFrom === undefined) {
            throw new runtime.RequiredError('uploadPartCopyFrom','Required parameter requestParameters.uploadPartCopyFrom was null or undefined when calling uploadPartCopy.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/branches/{branch}/staging/pmpu/{uploadId}/parts/{partNumber}/copy`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))).replace(`{${"branch"}}`, encodeURIComponent(String(requestParameters.branch))).replace(`{${"uploadId"}}`, encodeURIComponent(String(requestParameters.uploadId))).replace(`{${"partNumber"}}`, encodeURIComponent(String(requestParameters.partNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UploadPartCopyFromToJSON(requestParameters.uploadPartCopyFrom),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Upload a part by copying part of another object.
     */
    async uploadPartCopy(requestParameters: UploadPartCopyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.uploadPartCopyRaw(requestParameters, initOverrides);
    }

}

/**
  * @export
  * @enum {string}
  */
export enum ListPullRequestsStatus {
    open = 'open',
    closed = 'closed',
    all = 'all'
}
