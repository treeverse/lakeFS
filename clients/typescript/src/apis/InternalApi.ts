/* tslint:disable */
/* eslint-disable */
/**
 * lakeFS API
 * lakeFS HTTP API
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AuthCapabilities,
  BranchProtectionRule,
  CommPrefsInput,
  CommitRecordCreation,
  CredentialsWithSecret,
  GarbageCollectionConfig,
  GarbageCollectionPrepareResponse,
  GarbageCollectionRules,
  InstallationUsageReport,
  InternalDeleteBranchProtectionRuleRequest,
  ObjectStageCreation,
  ObjectStats,
  PrepareGCUncommittedRequest,
  PrepareGCUncommittedResponse,
  PrepareGarbageCollectionCommitsStatus,
  RefsDump,
  RefsRestore,
  RepositoryMetadataKeys,
  RepositoryMetadataSet,
  Setup,
  SetupState,
  StatsEventsList,
  StorageConfig,
  StorageURI,
  TaskCreation,
  VersionConfig,
} from '../models/index';
import {
    AuthCapabilitiesFromJSON,
    AuthCapabilitiesToJSON,
    BranchProtectionRuleFromJSON,
    BranchProtectionRuleToJSON,
    CommPrefsInputFromJSON,
    CommPrefsInputToJSON,
    CommitRecordCreationFromJSON,
    CommitRecordCreationToJSON,
    CredentialsWithSecretFromJSON,
    CredentialsWithSecretToJSON,
    GarbageCollectionConfigFromJSON,
    GarbageCollectionConfigToJSON,
    GarbageCollectionPrepareResponseFromJSON,
    GarbageCollectionPrepareResponseToJSON,
    GarbageCollectionRulesFromJSON,
    GarbageCollectionRulesToJSON,
    InstallationUsageReportFromJSON,
    InstallationUsageReportToJSON,
    InternalDeleteBranchProtectionRuleRequestFromJSON,
    InternalDeleteBranchProtectionRuleRequestToJSON,
    ObjectStageCreationFromJSON,
    ObjectStageCreationToJSON,
    ObjectStatsFromJSON,
    ObjectStatsToJSON,
    PrepareGCUncommittedRequestFromJSON,
    PrepareGCUncommittedRequestToJSON,
    PrepareGCUncommittedResponseFromJSON,
    PrepareGCUncommittedResponseToJSON,
    PrepareGarbageCollectionCommitsStatusFromJSON,
    PrepareGarbageCollectionCommitsStatusToJSON,
    RefsDumpFromJSON,
    RefsDumpToJSON,
    RefsRestoreFromJSON,
    RefsRestoreToJSON,
    RepositoryMetadataKeysFromJSON,
    RepositoryMetadataKeysToJSON,
    RepositoryMetadataSetFromJSON,
    RepositoryMetadataSetToJSON,
    SetupFromJSON,
    SetupToJSON,
    SetupStateFromJSON,
    SetupStateToJSON,
    StatsEventsListFromJSON,
    StatsEventsListToJSON,
    StorageConfigFromJSON,
    StorageConfigToJSON,
    StorageURIFromJSON,
    StorageURIToJSON,
    TaskCreationFromJSON,
    TaskCreationToJSON,
    VersionConfigFromJSON,
    VersionConfigToJSON,
} from '../models/index';

export interface CreateBranchProtectionRulePreflightRequest {
    repository: string;
}

export interface CreateCommitRecordRequest {
    repository: string;
    commitRecordCreation: CommitRecordCreation;
}

export interface CreateSymlinkFileRequest {
    repository: string;
    branch: string;
    location?: string;
}

export interface DeleteRepositoryMetadataRequest {
    repository: string;
    repositoryMetadataKeys: RepositoryMetadataKeys;
}

export interface DumpRefsRequest {
    repository: string;
}

export interface GetMetadataObjectRequest {
    repository: string;
    objectId: string;
    type: GetMetadataObjectType;
    presign?: boolean;
}

export interface InternalCreateBranchProtectionRuleRequest {
    repository: string;
    branchProtectionRule: BranchProtectionRule;
}

export interface InternalDeleteBranchProtectionRuleOperationRequest {
    repository: string;
    internalDeleteBranchProtectionRuleRequest: InternalDeleteBranchProtectionRuleRequest;
}

export interface InternalDeleteGarbageCollectionRulesRequest {
    repository: string;
}

export interface InternalGetBranchProtectionRulesRequest {
    repository: string;
}

export interface InternalGetGarbageCollectionRulesRequest {
    repository: string;
}

export interface InternalSetGarbageCollectionRulesRequest {
    repository: string;
    garbageCollectionRules: GarbageCollectionRules;
}

export interface PostStatsEventsRequest {
    statsEventsList: StatsEventsList;
}

export interface PrepareGarbageCollectionCommitsRequest {
    repository: string;
}

export interface PrepareGarbageCollectionCommitsAsyncRequest {
    repository: string;
}

export interface PrepareGarbageCollectionCommitsStatusRequest {
    repository: string;
    id: string;
}

export interface PrepareGarbageCollectionUncommittedRequest {
    repository: string;
    prepareGCUncommittedRequest?: PrepareGCUncommittedRequest;
}

export interface RestoreRefsRequest {
    repository: string;
    refsRestore: RefsRestore;
}

export interface SetGarbageCollectionRulesPreflightRequest {
    repository: string;
}

export interface SetRepositoryMetadataRequest {
    repository: string;
    repositoryMetadataSet: RepositoryMetadataSet;
}

export interface SetupRequest {
    setup: Setup;
}

export interface SetupCommPrefsRequest {
    commPrefsInput: CommPrefsInput;
}

export interface StageObjectRequest {
    repository: string;
    branch: string;
    path: string;
    objectStageCreation: ObjectStageCreation;
}

export interface UploadObjectPreflightRequest {
    repository: string;
    branch: string;
    path: string;
}

/**
 * InternalApi - interface
 * 
 * @export
 * @interface InternalApiInterface
 */
export interface InternalApiInterface {
    /**
     * 
     * @param {string} repository 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApiInterface
     */
    createBranchProtectionRulePreflightRaw(requestParameters: CreateBranchProtectionRulePreflightRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     */
    createBranchProtectionRulePreflight(requestParameters: CreateBranchProtectionRulePreflightRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary create commit record
     * @param {string} repository 
     * @param {CommitRecordCreation} commitRecordCreation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApiInterface
     */
    createCommitRecordRaw(requestParameters: CreateCommitRecordRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * create commit record
     */
    createCommitRecord(requestParameters: CreateCommitRecordRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary creates symlink files corresponding to the given directory
     * @param {string} repository 
     * @param {string} branch 
     * @param {string} [location] path to the table data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApiInterface
     */
    createSymlinkFileRaw(requestParameters: CreateSymlinkFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageURI>>;

    /**
     * creates symlink files corresponding to the given directory
     */
    createSymlinkFile(requestParameters: CreateSymlinkFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageURI>;

    /**
     * Delete specified keys from the repository\'s metadata. 
     * @summary delete repository metadata
     * @param {string} repository 
     * @param {RepositoryMetadataKeys} repositoryMetadataKeys 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApiInterface
     */
    deleteRepositoryMetadataRaw(requestParameters: DeleteRepositoryMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Delete specified keys from the repository\'s metadata. 
     * delete repository metadata
     */
    deleteRepositoryMetadata(requestParameters: DeleteRepositoryMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary Dump repository refs (tags, commits, branches) to object store Deprecated: a new API will introduce long running operations 
     * @param {string} repository 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApiInterface
     */
    dumpRefsRaw(requestParameters: DumpRefsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RefsDump>>;

    /**
     * Dump repository refs (tags, commits, branches) to object store Deprecated: a new API will introduce long running operations 
     */
    dumpRefs(requestParameters: DumpRefsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RefsDump>;

    /**
     * 
     * @summary list authentication capabilities supported
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApiInterface
     */
    getAuthCapabilitiesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthCapabilities>>;

    /**
     * list authentication capabilities supported
     */
    getAuthCapabilities(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthCapabilities>;

    /**
     * get information of gc settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApiInterface
     */
    getGarbageCollectionConfigRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GarbageCollectionConfig>>;

    /**
     * get information of gc settings
     */
    getGarbageCollectionConfig(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GarbageCollectionConfig>;

    /**
     * get version of lakeFS server
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof InternalApiInterface
     */
    getLakeFSVersionRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VersionConfig>>;

    /**
     * get version of lakeFS server
     */
    getLakeFSVersion(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VersionConfig>;

    /**
     * 
     * @summary return a lakeFS metadata object by ID
     * @param {string} repository 
     * @param {string} objectId 
     * @param {'range' | 'meta_range'} type 
     * @param {boolean} [presign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApiInterface
     */
    getMetadataObjectRaw(requestParameters: GetMetadataObjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>>;

    /**
     * return a lakeFS metadata object by ID
     */
    getMetadataObject(requestParameters: GetMetadataObjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob>;

    /**
     * 
     * @summary check if the lakeFS installation is already set up
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApiInterface
     */
    getSetupStateRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SetupState>>;

    /**
     * check if the lakeFS installation is already set up
     */
    getSetupState(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SetupState>;

    /**
     * retrieve lakeFS storage configuration
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof InternalApiInterface
     */
    getStorageConfigRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageConfig>>;

    /**
     * retrieve lakeFS storage configuration
     */
    getStorageConfig(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageConfig>;

    /**
     * 
     * @summary get usage report summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApiInterface
     */
    getUsageReportSummaryRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InstallationUsageReport>>;

    /**
     * get usage report summary
     */
    getUsageReportSummary(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InstallationUsageReport>;

    /**
     * 
     * @param {string} repository 
     * @param {BranchProtectionRule} branchProtectionRule 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof InternalApiInterface
     */
    internalCreateBranchProtectionRuleRaw(requestParameters: InternalCreateBranchProtectionRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     */
    internalCreateBranchProtectionRule(requestParameters: InternalCreateBranchProtectionRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @param {string} repository 
     * @param {InternalDeleteBranchProtectionRuleRequest} internalDeleteBranchProtectionRuleRequest 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof InternalApiInterface
     */
    internalDeleteBranchProtectionRuleRaw(requestParameters: InternalDeleteBranchProtectionRuleOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     */
    internalDeleteBranchProtectionRule(requestParameters: InternalDeleteBranchProtectionRuleOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Deprecated; use deleteGCRules.
     * @param {string} repository 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof InternalApiInterface
     */
    internalDeleteGarbageCollectionRulesRaw(requestParameters: InternalDeleteGarbageCollectionRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Deprecated; use deleteGCRules.
     */
    internalDeleteGarbageCollectionRules(requestParameters: InternalDeleteGarbageCollectionRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary get branch protection rules
     * @param {string} repository 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof InternalApiInterface
     */
    internalGetBranchProtectionRulesRaw(requestParameters: InternalGetBranchProtectionRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<BranchProtectionRule>>>;

    /**
     * get branch protection rules
     */
    internalGetBranchProtectionRules(requestParameters: InternalGetBranchProtectionRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<BranchProtectionRule>>;

    /**
     * Deprecated; use getGCRules.
     * @param {string} repository 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof InternalApiInterface
     */
    internalGetGarbageCollectionRulesRaw(requestParameters: InternalGetGarbageCollectionRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GarbageCollectionRules>>;

    /**
     * Deprecated; use getGCRules.
     */
    internalGetGarbageCollectionRules(requestParameters: InternalGetGarbageCollectionRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GarbageCollectionRules>;

    /**
     * Deprecated; use setGCRules.
     * @param {string} repository 
     * @param {GarbageCollectionRules} garbageCollectionRules 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof InternalApiInterface
     */
    internalSetGarbageCollectionRulesRaw(requestParameters: InternalSetGarbageCollectionRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Deprecated; use setGCRules.
     */
    internalSetGarbageCollectionRules(requestParameters: InternalSetGarbageCollectionRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary post stats events, this endpoint is meant for internal use only
     * @param {StatsEventsList} statsEventsList 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApiInterface
     */
    postStatsEventsRaw(requestParameters: PostStatsEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * post stats events, this endpoint is meant for internal use only
     */
    postStatsEvents(requestParameters: PostStatsEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary save lists of active commits for garbage collection
     * @param {string} repository 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApiInterface
     */
    prepareGarbageCollectionCommitsRaw(requestParameters: PrepareGarbageCollectionCommitsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GarbageCollectionPrepareResponse>>;

    /**
     * save lists of active commits for garbage collection
     */
    prepareGarbageCollectionCommits(requestParameters: PrepareGarbageCollectionCommitsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GarbageCollectionPrepareResponse>;

    /**
     * 
     * @summary prepare gc commits
     * @param {string} repository 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApiInterface
     */
    prepareGarbageCollectionCommitsAsyncRaw(requestParameters: PrepareGarbageCollectionCommitsAsyncRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TaskCreation>>;

    /**
     * prepare gc commits
     */
    prepareGarbageCollectionCommitsAsync(requestParameters: PrepareGarbageCollectionCommitsAsyncRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TaskCreation>;

    /**
     * 
     * @summary get status of prepare gc commits operation
     * @param {string} repository 
     * @param {string} id Unique identifier of the prepare GC commits task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApiInterface
     */
    prepareGarbageCollectionCommitsStatusRaw(requestParameters: PrepareGarbageCollectionCommitsStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PrepareGarbageCollectionCommitsStatus>>;

    /**
     * get status of prepare gc commits operation
     */
    prepareGarbageCollectionCommitsStatus(requestParameters: PrepareGarbageCollectionCommitsStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PrepareGarbageCollectionCommitsStatus>;

    /**
     * 
     * @summary save repository uncommitted metadata for garbage collection
     * @param {string} repository 
     * @param {PrepareGCUncommittedRequest} [prepareGCUncommittedRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApiInterface
     */
    prepareGarbageCollectionUncommittedRaw(requestParameters: PrepareGarbageCollectionUncommittedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PrepareGCUncommittedResponse>>;

    /**
     * save repository uncommitted metadata for garbage collection
     */
    prepareGarbageCollectionUncommitted(requestParameters: PrepareGarbageCollectionUncommittedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PrepareGCUncommittedResponse>;

    /**
     * 
     * @summary Restore repository refs (tags, commits, branches) from object store. Deprecated: a new API will introduce long running operations 
     * @param {string} repository 
     * @param {RefsRestore} refsRestore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApiInterface
     */
    restoreRefsRaw(requestParameters: RestoreRefsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Restore repository refs (tags, commits, branches) from object store. Deprecated: a new API will introduce long running operations 
     */
    restoreRefs(requestParameters: RestoreRefsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @param {string} repository 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApiInterface
     */
    setGarbageCollectionRulesPreflightRaw(requestParameters: SetGarbageCollectionRulesPreflightRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     */
    setGarbageCollectionRulesPreflight(requestParameters: SetGarbageCollectionRulesPreflightRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Set repository metadata. This will only add or update the provided keys, and will not remove any existing keys. 
     * @summary set repository metadata
     * @param {string} repository 
     * @param {RepositoryMetadataSet} repositoryMetadataSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApiInterface
     */
    setRepositoryMetadataRaw(requestParameters: SetRepositoryMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Set repository metadata. This will only add or update the provided keys, and will not remove any existing keys. 
     * set repository metadata
     */
    setRepositoryMetadata(requestParameters: SetRepositoryMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary setup lakeFS and create a first user
     * @param {Setup} setup 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApiInterface
     */
    setupRaw(requestParameters: SetupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CredentialsWithSecret>>;

    /**
     * setup lakeFS and create a first user
     */
    setup(requestParameters: SetupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CredentialsWithSecret>;

    /**
     * 
     * @summary setup communications preferences
     * @param {CommPrefsInput} commPrefsInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApiInterface
     */
    setupCommPrefsRaw(requestParameters: SetupCommPrefsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * setup communications preferences
     */
    setupCommPrefs(requestParameters: SetupCommPrefsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary stage an object\'s metadata for the given branch
     * @param {string} repository 
     * @param {string} branch 
     * @param {string} path relative to the branch
     * @param {ObjectStageCreation} objectStageCreation 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof InternalApiInterface
     */
    stageObjectRaw(requestParameters: StageObjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ObjectStats>>;

    /**
     * stage an object\'s metadata for the given branch
     */
    stageObject(requestParameters: StageObjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ObjectStats>;

    /**
     * 
     * @param {string} repository 
     * @param {string} branch 
     * @param {string} path relative to the branch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApiInterface
     */
    uploadObjectPreflightRaw(requestParameters: UploadObjectPreflightRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     */
    uploadObjectPreflight(requestParameters: UploadObjectPreflightRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

}

/**
 * 
 */
export class InternalApi extends runtime.BaseAPI implements InternalApiInterface {

    /**
     */
    async createBranchProtectionRulePreflightRaw(requestParameters: CreateBranchProtectionRulePreflightRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling createBranchProtectionRulePreflight.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/branch_protection/set_allowed`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async createBranchProtectionRulePreflight(requestParameters: CreateBranchProtectionRulePreflightRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.createBranchProtectionRulePreflightRaw(requestParameters, initOverrides);
    }

    /**
     * create commit record
     */
    async createCommitRecordRaw(requestParameters: CreateCommitRecordRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling createCommitRecord.');
        }

        if (requestParameters.commitRecordCreation === null || requestParameters.commitRecordCreation === undefined) {
            throw new runtime.RequiredError('commitRecordCreation','Required parameter requestParameters.commitRecordCreation was null or undefined when calling createCommitRecord.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/commits`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CommitRecordCreationToJSON(requestParameters.commitRecordCreation),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * create commit record
     */
    async createCommitRecord(requestParameters: CreateCommitRecordRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.createCommitRecordRaw(requestParameters, initOverrides);
    }

    /**
     * creates symlink files corresponding to the given directory
     */
    async createSymlinkFileRaw(requestParameters: CreateSymlinkFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageURI>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling createSymlinkFile.');
        }

        if (requestParameters.branch === null || requestParameters.branch === undefined) {
            throw new runtime.RequiredError('branch','Required parameter requestParameters.branch was null or undefined when calling createSymlinkFile.');
        }

        const queryParameters: any = {};

        if (requestParameters.location !== undefined) {
            queryParameters['location'] = requestParameters.location;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/refs/{branch}/symlink`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))).replace(`{${"branch"}}`, encodeURIComponent(String(requestParameters.branch))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageURIFromJSON(jsonValue));
    }

    /**
     * creates symlink files corresponding to the given directory
     */
    async createSymlinkFile(requestParameters: CreateSymlinkFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageURI> {
        const response = await this.createSymlinkFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete specified keys from the repository\'s metadata. 
     * delete repository metadata
     */
    async deleteRepositoryMetadataRaw(requestParameters: DeleteRepositoryMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling deleteRepositoryMetadata.');
        }

        if (requestParameters.repositoryMetadataKeys === null || requestParameters.repositoryMetadataKeys === undefined) {
            throw new runtime.RequiredError('repositoryMetadataKeys','Required parameter requestParameters.repositoryMetadataKeys was null or undefined when calling deleteRepositoryMetadata.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/metadata`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: RepositoryMetadataKeysToJSON(requestParameters.repositoryMetadataKeys),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete specified keys from the repository\'s metadata. 
     * delete repository metadata
     */
    async deleteRepositoryMetadata(requestParameters: DeleteRepositoryMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteRepositoryMetadataRaw(requestParameters, initOverrides);
    }

    /**
     * Dump repository refs (tags, commits, branches) to object store Deprecated: a new API will introduce long running operations 
     */
    async dumpRefsRaw(requestParameters: DumpRefsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RefsDump>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling dumpRefs.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/refs/dump`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RefsDumpFromJSON(jsonValue));
    }

    /**
     * Dump repository refs (tags, commits, branches) to object store Deprecated: a new API will introduce long running operations 
     */
    async dumpRefs(requestParameters: DumpRefsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RefsDump> {
        const response = await this.dumpRefsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list authentication capabilities supported
     */
    async getAuthCapabilitiesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthCapabilities>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/auth/capabilities`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthCapabilitiesFromJSON(jsonValue));
    }

    /**
     * list authentication capabilities supported
     */
    async getAuthCapabilities(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthCapabilities> {
        const response = await this.getAuthCapabilitiesRaw(initOverrides);
        return await response.value();
    }

    /**
     * get information of gc settings
     */
    async getGarbageCollectionConfigRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GarbageCollectionConfig>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/config/garbage-collection`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GarbageCollectionConfigFromJSON(jsonValue));
    }

    /**
     * get information of gc settings
     */
    async getGarbageCollectionConfig(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GarbageCollectionConfig> {
        const response = await this.getGarbageCollectionConfigRaw(initOverrides);
        return await response.value();
    }

    /**
     * get version of lakeFS server
     */
    async getLakeFSVersionRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VersionConfig>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/config/version`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VersionConfigFromJSON(jsonValue));
    }

    /**
     * get version of lakeFS server
     */
    async getLakeFSVersion(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VersionConfig> {
        const response = await this.getLakeFSVersionRaw(initOverrides);
        return await response.value();
    }

    /**
     * return a lakeFS metadata object by ID
     */
    async getMetadataObjectRaw(requestParameters: GetMetadataObjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling getMetadataObject.');
        }

        if (requestParameters.objectId === null || requestParameters.objectId === undefined) {
            throw new runtime.RequiredError('objectId','Required parameter requestParameters.objectId was null or undefined when calling getMetadataObject.');
        }

        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling getMetadataObject.');
        }

        const queryParameters: any = {};

        if (requestParameters.presign !== undefined) {
            queryParameters['presign'] = requestParameters.presign;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/metadata/object/{type}/{object_id}`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))).replace(`{${"object_id"}}`, encodeURIComponent(String(requestParameters.objectId))).replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * return a lakeFS metadata object by ID
     */
    async getMetadataObject(requestParameters: GetMetadataObjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.getMetadataObjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * check if the lakeFS installation is already set up
     */
    async getSetupStateRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SetupState>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/setup_lakefs`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SetupStateFromJSON(jsonValue));
    }

    /**
     * check if the lakeFS installation is already set up
     */
    async getSetupState(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SetupState> {
        const response = await this.getSetupStateRaw(initOverrides);
        return await response.value();
    }

    /**
     * retrieve lakeFS storage configuration
     */
    async getStorageConfigRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageConfig>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/config/storage`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageConfigFromJSON(jsonValue));
    }

    /**
     * retrieve lakeFS storage configuration
     */
    async getStorageConfig(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageConfig> {
        const response = await this.getStorageConfigRaw(initOverrides);
        return await response.value();
    }

    /**
     * get usage report summary
     */
    async getUsageReportSummaryRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InstallationUsageReport>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/usage-report/summary`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InstallationUsageReportFromJSON(jsonValue));
    }

    /**
     * get usage report summary
     */
    async getUsageReportSummary(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InstallationUsageReport> {
        const response = await this.getUsageReportSummaryRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async internalCreateBranchProtectionRuleRaw(requestParameters: InternalCreateBranchProtectionRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling internalCreateBranchProtectionRule.');
        }

        if (requestParameters.branchProtectionRule === null || requestParameters.branchProtectionRule === undefined) {
            throw new runtime.RequiredError('branchProtectionRule','Required parameter requestParameters.branchProtectionRule was null or undefined when calling internalCreateBranchProtectionRule.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/branch_protection`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BranchProtectionRuleToJSON(requestParameters.branchProtectionRule),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async internalCreateBranchProtectionRule(requestParameters: InternalCreateBranchProtectionRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.internalCreateBranchProtectionRuleRaw(requestParameters, initOverrides);
    }

    /**
     */
    async internalDeleteBranchProtectionRuleRaw(requestParameters: InternalDeleteBranchProtectionRuleOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling internalDeleteBranchProtectionRule.');
        }

        if (requestParameters.internalDeleteBranchProtectionRuleRequest === null || requestParameters.internalDeleteBranchProtectionRuleRequest === undefined) {
            throw new runtime.RequiredError('internalDeleteBranchProtectionRuleRequest','Required parameter requestParameters.internalDeleteBranchProtectionRuleRequest was null or undefined when calling internalDeleteBranchProtectionRule.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/branch_protection`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: InternalDeleteBranchProtectionRuleRequestToJSON(requestParameters.internalDeleteBranchProtectionRuleRequest),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async internalDeleteBranchProtectionRule(requestParameters: InternalDeleteBranchProtectionRuleOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.internalDeleteBranchProtectionRuleRaw(requestParameters, initOverrides);
    }

    /**
     * Deprecated; use deleteGCRules.
     */
    async internalDeleteGarbageCollectionRulesRaw(requestParameters: InternalDeleteGarbageCollectionRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling internalDeleteGarbageCollectionRules.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/gc/rules`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deprecated; use deleteGCRules.
     */
    async internalDeleteGarbageCollectionRules(requestParameters: InternalDeleteGarbageCollectionRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.internalDeleteGarbageCollectionRulesRaw(requestParameters, initOverrides);
    }

    /**
     * get branch protection rules
     */
    async internalGetBranchProtectionRulesRaw(requestParameters: InternalGetBranchProtectionRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<BranchProtectionRule>>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling internalGetBranchProtectionRules.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/branch_protection`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BranchProtectionRuleFromJSON));
    }

    /**
     * get branch protection rules
     */
    async internalGetBranchProtectionRules(requestParameters: InternalGetBranchProtectionRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<BranchProtectionRule>> {
        const response = await this.internalGetBranchProtectionRulesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deprecated; use getGCRules.
     */
    async internalGetGarbageCollectionRulesRaw(requestParameters: InternalGetGarbageCollectionRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GarbageCollectionRules>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling internalGetGarbageCollectionRules.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/gc/rules`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GarbageCollectionRulesFromJSON(jsonValue));
    }

    /**
     * Deprecated; use getGCRules.
     */
    async internalGetGarbageCollectionRules(requestParameters: InternalGetGarbageCollectionRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GarbageCollectionRules> {
        const response = await this.internalGetGarbageCollectionRulesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deprecated; use setGCRules.
     */
    async internalSetGarbageCollectionRulesRaw(requestParameters: InternalSetGarbageCollectionRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling internalSetGarbageCollectionRules.');
        }

        if (requestParameters.garbageCollectionRules === null || requestParameters.garbageCollectionRules === undefined) {
            throw new runtime.RequiredError('garbageCollectionRules','Required parameter requestParameters.garbageCollectionRules was null or undefined when calling internalSetGarbageCollectionRules.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/gc/rules`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GarbageCollectionRulesToJSON(requestParameters.garbageCollectionRules),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deprecated; use setGCRules.
     */
    async internalSetGarbageCollectionRules(requestParameters: InternalSetGarbageCollectionRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.internalSetGarbageCollectionRulesRaw(requestParameters, initOverrides);
    }

    /**
     * post stats events, this endpoint is meant for internal use only
     */
    async postStatsEventsRaw(requestParameters: PostStatsEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.statsEventsList === null || requestParameters.statsEventsList === undefined) {
            throw new runtime.RequiredError('statsEventsList','Required parameter requestParameters.statsEventsList was null or undefined when calling postStatsEvents.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/statistics`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StatsEventsListToJSON(requestParameters.statsEventsList),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * post stats events, this endpoint is meant for internal use only
     */
    async postStatsEvents(requestParameters: PostStatsEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.postStatsEventsRaw(requestParameters, initOverrides);
    }

    /**
     * save lists of active commits for garbage collection
     */
    async prepareGarbageCollectionCommitsRaw(requestParameters: PrepareGarbageCollectionCommitsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GarbageCollectionPrepareResponse>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling prepareGarbageCollectionCommits.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/gc/prepare_commits`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GarbageCollectionPrepareResponseFromJSON(jsonValue));
    }

    /**
     * save lists of active commits for garbage collection
     */
    async prepareGarbageCollectionCommits(requestParameters: PrepareGarbageCollectionCommitsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GarbageCollectionPrepareResponse> {
        const response = await this.prepareGarbageCollectionCommitsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * prepare gc commits
     */
    async prepareGarbageCollectionCommitsAsyncRaw(requestParameters: PrepareGarbageCollectionCommitsAsyncRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TaskCreation>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling prepareGarbageCollectionCommitsAsync.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/gc/prepare_commits/async`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskCreationFromJSON(jsonValue));
    }

    /**
     * prepare gc commits
     */
    async prepareGarbageCollectionCommitsAsync(requestParameters: PrepareGarbageCollectionCommitsAsyncRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TaskCreation> {
        const response = await this.prepareGarbageCollectionCommitsAsyncRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get status of prepare gc commits operation
     */
    async prepareGarbageCollectionCommitsStatusRaw(requestParameters: PrepareGarbageCollectionCommitsStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PrepareGarbageCollectionCommitsStatus>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling prepareGarbageCollectionCommitsStatus.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling prepareGarbageCollectionCommitsStatus.');
        }

        const queryParameters: any = {};

        if (requestParameters.id !== undefined) {
            queryParameters['id'] = requestParameters.id;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/gc/prepare_commits/status`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PrepareGarbageCollectionCommitsStatusFromJSON(jsonValue));
    }

    /**
     * get status of prepare gc commits operation
     */
    async prepareGarbageCollectionCommitsStatus(requestParameters: PrepareGarbageCollectionCommitsStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PrepareGarbageCollectionCommitsStatus> {
        const response = await this.prepareGarbageCollectionCommitsStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * save repository uncommitted metadata for garbage collection
     */
    async prepareGarbageCollectionUncommittedRaw(requestParameters: PrepareGarbageCollectionUncommittedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PrepareGCUncommittedResponse>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling prepareGarbageCollectionUncommitted.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/gc/prepare_uncommited`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PrepareGCUncommittedRequestToJSON(requestParameters.prepareGCUncommittedRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PrepareGCUncommittedResponseFromJSON(jsonValue));
    }

    /**
     * save repository uncommitted metadata for garbage collection
     */
    async prepareGarbageCollectionUncommitted(requestParameters: PrepareGarbageCollectionUncommittedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PrepareGCUncommittedResponse> {
        const response = await this.prepareGarbageCollectionUncommittedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Restore repository refs (tags, commits, branches) from object store. Deprecated: a new API will introduce long running operations 
     */
    async restoreRefsRaw(requestParameters: RestoreRefsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling restoreRefs.');
        }

        if (requestParameters.refsRestore === null || requestParameters.refsRestore === undefined) {
            throw new runtime.RequiredError('refsRestore','Required parameter requestParameters.refsRestore was null or undefined when calling restoreRefs.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/refs/restore`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: RefsRestoreToJSON(requestParameters.refsRestore),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Restore repository refs (tags, commits, branches) from object store. Deprecated: a new API will introduce long running operations 
     */
    async restoreRefs(requestParameters: RestoreRefsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.restoreRefsRaw(requestParameters, initOverrides);
    }

    /**
     */
    async setGarbageCollectionRulesPreflightRaw(requestParameters: SetGarbageCollectionRulesPreflightRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling setGarbageCollectionRulesPreflight.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/gc/rules/set_allowed`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async setGarbageCollectionRulesPreflight(requestParameters: SetGarbageCollectionRulesPreflightRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.setGarbageCollectionRulesPreflightRaw(requestParameters, initOverrides);
    }

    /**
     * Set repository metadata. This will only add or update the provided keys, and will not remove any existing keys. 
     * set repository metadata
     */
    async setRepositoryMetadataRaw(requestParameters: SetRepositoryMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling setRepositoryMetadata.');
        }

        if (requestParameters.repositoryMetadataSet === null || requestParameters.repositoryMetadataSet === undefined) {
            throw new runtime.RequiredError('repositoryMetadataSet','Required parameter requestParameters.repositoryMetadataSet was null or undefined when calling setRepositoryMetadata.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/metadata`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RepositoryMetadataSetToJSON(requestParameters.repositoryMetadataSet),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Set repository metadata. This will only add or update the provided keys, and will not remove any existing keys. 
     * set repository metadata
     */
    async setRepositoryMetadata(requestParameters: SetRepositoryMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.setRepositoryMetadataRaw(requestParameters, initOverrides);
    }

    /**
     * setup lakeFS and create a first user
     */
    async setupRaw(requestParameters: SetupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CredentialsWithSecret>> {
        if (requestParameters.setup === null || requestParameters.setup === undefined) {
            throw new runtime.RequiredError('setup','Required parameter requestParameters.setup was null or undefined when calling setup.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/setup_lakefs`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SetupToJSON(requestParameters.setup),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CredentialsWithSecretFromJSON(jsonValue));
    }

    /**
     * setup lakeFS and create a first user
     */
    async setup(requestParameters: SetupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CredentialsWithSecret> {
        const response = await this.setupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * setup communications preferences
     */
    async setupCommPrefsRaw(requestParameters: SetupCommPrefsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.commPrefsInput === null || requestParameters.commPrefsInput === undefined) {
            throw new runtime.RequiredError('commPrefsInput','Required parameter requestParameters.commPrefsInput was null or undefined when calling setupCommPrefs.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/setup_comm_prefs`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CommPrefsInputToJSON(requestParameters.commPrefsInput),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * setup communications preferences
     */
    async setupCommPrefs(requestParameters: SetupCommPrefsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.setupCommPrefsRaw(requestParameters, initOverrides);
    }

    /**
     * stage an object\'s metadata for the given branch
     */
    async stageObjectRaw(requestParameters: StageObjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ObjectStats>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling stageObject.');
        }

        if (requestParameters.branch === null || requestParameters.branch === undefined) {
            throw new runtime.RequiredError('branch','Required parameter requestParameters.branch was null or undefined when calling stageObject.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling stageObject.');
        }

        if (requestParameters.objectStageCreation === null || requestParameters.objectStageCreation === undefined) {
            throw new runtime.RequiredError('objectStageCreation','Required parameter requestParameters.objectStageCreation was null or undefined when calling stageObject.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/branches/{branch}/objects`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))).replace(`{${"branch"}}`, encodeURIComponent(String(requestParameters.branch))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ObjectStageCreationToJSON(requestParameters.objectStageCreation),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ObjectStatsFromJSON(jsonValue));
    }

    /**
     * stage an object\'s metadata for the given branch
     */
    async stageObject(requestParameters: StageObjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ObjectStats> {
        const response = await this.stageObjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async uploadObjectPreflightRaw(requestParameters: UploadObjectPreflightRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling uploadObjectPreflight.');
        }

        if (requestParameters.branch === null || requestParameters.branch === undefined) {
            throw new runtime.RequiredError('branch','Required parameter requestParameters.branch was null or undefined when calling uploadObjectPreflight.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling uploadObjectPreflight.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/branches/{branch}/objects/stage_allowed`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))).replace(`{${"branch"}}`, encodeURIComponent(String(requestParameters.branch))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async uploadObjectPreflight(requestParameters: UploadObjectPreflightRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.uploadObjectPreflightRaw(requestParameters, initOverrides);
    }

}

/**
  * @export
  * @enum {string}
  */
export enum GetMetadataObjectType {
    range = 'range',
    meta_range = 'meta_range'
}
