/* tslint:disable */
/* eslint-disable */
/**
 * lakeFS API
 * lakeFS HTTP API
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CommitList,
  DiffList,
  FindMergeBaseResult,
  Merge,
  MergeResult,
} from '../models/index';
import {
    CommitListFromJSON,
    CommitListToJSON,
    DiffListFromJSON,
    DiffListToJSON,
    FindMergeBaseResultFromJSON,
    FindMergeBaseResultToJSON,
    MergeFromJSON,
    MergeToJSON,
    MergeResultFromJSON,
    MergeResultToJSON,
} from '../models/index';

export interface DiffRefsRequest {
    repository: string;
    leftRef: string;
    rightRef: string;
    after?: string;
    amount?: number;
    prefix?: string;
    delimiter?: string;
    type?: DiffRefsType;
    includeRightStats?: boolean;
}

export interface FindMergeBaseRequest {
    repository: string;
    sourceRef: string;
    destinationBranch: string;
}

export interface LogCommitsRequest {
    repository: string;
    ref: string;
    after?: string;
    amount?: number;
    objects?: Array<string>;
    prefixes?: Array<string>;
    limit?: boolean;
    firstParent?: boolean;
    since?: Date;
    stopAt?: string;
}

export interface MergeIntoBranchRequest {
    repository: string;
    sourceRef: string;
    destinationBranch: string;
    merge?: Merge;
}

/**
 * RefsApi - interface
 * 
 * @export
 * @interface RefsApiInterface
 */
export interface RefsApiInterface {
    /**
     * 
     * @summary diff references
     * @param {string} repository 
     * @param {string} leftRef a reference (could be either a branch or a commit ID)
     * @param {string} rightRef a reference (could be either a branch or a commit ID) to compare against
     * @param {string} [after] return items after this value
     * @param {number} [amount] how many items to return
     * @param {string} [prefix] return items prefixed with this value
     * @param {string} [delimiter] delimiter used to group common prefixes by
     * @param {'two_dot' | 'three_dot'} [type] 
     * @param {boolean} [includeRightStats] If set to true, the diff will include right-side object stats. *EXPERIMENTAL*
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefsApiInterface
     */
    diffRefsRaw(requestParameters: DiffRefsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DiffList>>;

    /**
     * diff references
     */
    diffRefs(requestParameters: DiffRefsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DiffList>;

    /**
     * 
     * @summary find the merge base for 2 references
     * @param {string} repository 
     * @param {string} sourceRef source ref
     * @param {string} destinationBranch destination branch name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefsApiInterface
     */
    findMergeBaseRaw(requestParameters: FindMergeBaseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FindMergeBaseResult>>;

    /**
     * find the merge base for 2 references
     */
    findMergeBase(requestParameters: FindMergeBaseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FindMergeBaseResult>;

    /**
     * 
     * @summary get commit log from ref. If both objects and prefixes are empty, return all commits.
     * @param {string} repository 
     * @param {string} ref 
     * @param {string} [after] return items after this value
     * @param {number} [amount] how many items to return
     * @param {Array<string>} [objects] list of paths, each element is a path of a specific object
     * @param {Array<string>} [prefixes] list of paths, each element is a path of a prefix
     * @param {boolean} [limit] limit the number of items in return to \&#39;amount\&#39;. Without further indication on actual number of items.
     * @param {boolean} [firstParent] if set to true, follow only the first parent upon reaching a merge commit
     * @param {Date} [since] Show commits more recent than a specific date-time. In case used with stop_at parameter, will stop at the first commit that meets any of the conditions.
     * @param {string} [stopAt] A reference to stop at. In case used with since parameter, will stop at the first commit that meets any of the conditions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefsApiInterface
     */
    logCommitsRaw(requestParameters: LogCommitsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CommitList>>;

    /**
     * get commit log from ref. If both objects and prefixes are empty, return all commits.
     */
    logCommits(requestParameters: LogCommitsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CommitList>;

    /**
     * 
     * @summary merge references
     * @param {string} repository 
     * @param {string} sourceRef source ref
     * @param {string} destinationBranch destination branch name
     * @param {Merge} [merge] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefsApiInterface
     */
    mergeIntoBranchRaw(requestParameters: MergeIntoBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MergeResult>>;

    /**
     * merge references
     */
    mergeIntoBranch(requestParameters: MergeIntoBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MergeResult>;

}

/**
 * 
 */
export class RefsApi extends runtime.BaseAPI implements RefsApiInterface {

    /**
     * diff references
     */
    async diffRefsRaw(requestParameters: DiffRefsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DiffList>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling diffRefs.');
        }

        if (requestParameters.leftRef === null || requestParameters.leftRef === undefined) {
            throw new runtime.RequiredError('leftRef','Required parameter requestParameters.leftRef was null or undefined when calling diffRefs.');
        }

        if (requestParameters.rightRef === null || requestParameters.rightRef === undefined) {
            throw new runtime.RequiredError('rightRef','Required parameter requestParameters.rightRef was null or undefined when calling diffRefs.');
        }

        const queryParameters: any = {};

        if (requestParameters.after !== undefined) {
            queryParameters['after'] = requestParameters.after;
        }

        if (requestParameters.amount !== undefined) {
            queryParameters['amount'] = requestParameters.amount;
        }

        if (requestParameters.prefix !== undefined) {
            queryParameters['prefix'] = requestParameters.prefix;
        }

        if (requestParameters.delimiter !== undefined) {
            queryParameters['delimiter'] = requestParameters.delimiter;
        }

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        if (requestParameters.includeRightStats !== undefined) {
            queryParameters['include_right_stats'] = requestParameters.includeRightStats;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/refs/{leftRef}/diff/{rightRef}`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))).replace(`{${"leftRef"}}`, encodeURIComponent(String(requestParameters.leftRef))).replace(`{${"rightRef"}}`, encodeURIComponent(String(requestParameters.rightRef))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DiffListFromJSON(jsonValue));
    }

    /**
     * diff references
     */
    async diffRefs(requestParameters: DiffRefsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DiffList> {
        const response = await this.diffRefsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * find the merge base for 2 references
     */
    async findMergeBaseRaw(requestParameters: FindMergeBaseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FindMergeBaseResult>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling findMergeBase.');
        }

        if (requestParameters.sourceRef === null || requestParameters.sourceRef === undefined) {
            throw new runtime.RequiredError('sourceRef','Required parameter requestParameters.sourceRef was null or undefined when calling findMergeBase.');
        }

        if (requestParameters.destinationBranch === null || requestParameters.destinationBranch === undefined) {
            throw new runtime.RequiredError('destinationBranch','Required parameter requestParameters.destinationBranch was null or undefined when calling findMergeBase.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/refs/{sourceRef}/merge/{destinationBranch}`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))).replace(`{${"sourceRef"}}`, encodeURIComponent(String(requestParameters.sourceRef))).replace(`{${"destinationBranch"}}`, encodeURIComponent(String(requestParameters.destinationBranch))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FindMergeBaseResultFromJSON(jsonValue));
    }

    /**
     * find the merge base for 2 references
     */
    async findMergeBase(requestParameters: FindMergeBaseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FindMergeBaseResult> {
        const response = await this.findMergeBaseRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get commit log from ref. If both objects and prefixes are empty, return all commits.
     */
    async logCommitsRaw(requestParameters: LogCommitsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CommitList>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling logCommits.');
        }

        if (requestParameters.ref === null || requestParameters.ref === undefined) {
            throw new runtime.RequiredError('ref','Required parameter requestParameters.ref was null or undefined when calling logCommits.');
        }

        const queryParameters: any = {};

        if (requestParameters.after !== undefined) {
            queryParameters['after'] = requestParameters.after;
        }

        if (requestParameters.amount !== undefined) {
            queryParameters['amount'] = requestParameters.amount;
        }

        if (requestParameters.objects) {
            queryParameters['objects'] = requestParameters.objects;
        }

        if (requestParameters.prefixes) {
            queryParameters['prefixes'] = requestParameters.prefixes;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.firstParent !== undefined) {
            queryParameters['first_parent'] = requestParameters.firstParent;
        }

        if (requestParameters.since !== undefined) {
            queryParameters['since'] = (requestParameters.since as any).toISOString();
        }

        if (requestParameters.stopAt !== undefined) {
            queryParameters['stop_at'] = requestParameters.stopAt;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/refs/{ref}/commits`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))).replace(`{${"ref"}}`, encodeURIComponent(String(requestParameters.ref))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CommitListFromJSON(jsonValue));
    }

    /**
     * get commit log from ref. If both objects and prefixes are empty, return all commits.
     */
    async logCommits(requestParameters: LogCommitsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CommitList> {
        const response = await this.logCommitsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * merge references
     */
    async mergeIntoBranchRaw(requestParameters: MergeIntoBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MergeResult>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling mergeIntoBranch.');
        }

        if (requestParameters.sourceRef === null || requestParameters.sourceRef === undefined) {
            throw new runtime.RequiredError('sourceRef','Required parameter requestParameters.sourceRef was null or undefined when calling mergeIntoBranch.');
        }

        if (requestParameters.destinationBranch === null || requestParameters.destinationBranch === undefined) {
            throw new runtime.RequiredError('destinationBranch','Required parameter requestParameters.destinationBranch was null or undefined when calling mergeIntoBranch.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/refs/{sourceRef}/merge/{destinationBranch}`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))).replace(`{${"sourceRef"}}`, encodeURIComponent(String(requestParameters.sourceRef))).replace(`{${"destinationBranch"}}`, encodeURIComponent(String(requestParameters.destinationBranch))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MergeToJSON(requestParameters.merge),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MergeResultFromJSON(jsonValue));
    }

    /**
     * merge references
     */
    async mergeIntoBranch(requestParameters: MergeIntoBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MergeResult> {
        const response = await this.mergeIntoBranchRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
  * @export
  * @enum {string}
  */
export enum DiffRefsType {
    two_dot = 'two_dot',
    three_dot = 'three_dot'
}
