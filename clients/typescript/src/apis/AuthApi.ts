/* tslint:disable */
/* eslint-disable */
/**
 * lakeFS API
 * lakeFS HTTP API
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ACL,
  AuthenticationToken,
  Credentials,
  CredentialsList,
  CredentialsWithSecret,
  CurrentUser,
  ErrorNoACL,
  ExternalLoginInformation,
  ExternalPrincipal,
  ExternalPrincipalCreation,
  ExternalPrincipalList,
  Group,
  GroupCreation,
  GroupList,
  LoginInformation,
  Policy,
  PolicyList,
  User,
  UserCreation,
  UserList,
} from '../models/index';
import {
    ACLFromJSON,
    ACLToJSON,
    AuthenticationTokenFromJSON,
    AuthenticationTokenToJSON,
    CredentialsFromJSON,
    CredentialsToJSON,
    CredentialsListFromJSON,
    CredentialsListToJSON,
    CredentialsWithSecretFromJSON,
    CredentialsWithSecretToJSON,
    CurrentUserFromJSON,
    CurrentUserToJSON,
    ErrorNoACLFromJSON,
    ErrorNoACLToJSON,
    ExternalLoginInformationFromJSON,
    ExternalLoginInformationToJSON,
    ExternalPrincipalFromJSON,
    ExternalPrincipalToJSON,
    ExternalPrincipalCreationFromJSON,
    ExternalPrincipalCreationToJSON,
    ExternalPrincipalListFromJSON,
    ExternalPrincipalListToJSON,
    GroupFromJSON,
    GroupToJSON,
    GroupCreationFromJSON,
    GroupCreationToJSON,
    GroupListFromJSON,
    GroupListToJSON,
    LoginInformationFromJSON,
    LoginInformationToJSON,
    PolicyFromJSON,
    PolicyToJSON,
    PolicyListFromJSON,
    PolicyListToJSON,
    UserFromJSON,
    UserToJSON,
    UserCreationFromJSON,
    UserCreationToJSON,
    UserListFromJSON,
    UserListToJSON,
} from '../models/index';

export interface AddGroupMembershipRequest {
    groupId: string;
    userId: string;
}

export interface AttachPolicyToGroupRequest {
    groupId: string;
    policyId: string;
}

export interface AttachPolicyToUserRequest {
    userId: string;
    policyId: string;
}

export interface CreateCredentialsRequest {
    userId: string;
}

export interface CreateGroupRequest {
    groupCreation?: GroupCreation;
}

export interface CreatePolicyRequest {
    policy: Policy;
}

export interface CreateUserRequest {
    userCreation?: UserCreation;
}

export interface CreateUserExternalPrincipalRequest {
    userId: string;
    principalId: string;
    externalPrincipalCreation?: ExternalPrincipalCreation;
}

export interface DeleteCredentialsRequest {
    userId: string;
    accessKeyId: string;
}

export interface DeleteGroupRequest {
    groupId: string;
}

export interface DeleteGroupMembershipRequest {
    groupId: string;
    userId: string;
}

export interface DeletePolicyRequest {
    policyId: string;
}

export interface DeleteUserRequest {
    userId: string;
}

export interface DeleteUserExternalPrincipalRequest {
    userId: string;
    principalId: string;
}

export interface DetachPolicyFromGroupRequest {
    groupId: string;
    policyId: string;
}

export interface DetachPolicyFromUserRequest {
    userId: string;
    policyId: string;
}

export interface ExternalPrincipalLoginRequest {
    externalLoginInformation?: ExternalLoginInformation;
}

export interface GetCredentialsRequest {
    userId: string;
    accessKeyId: string;
}

export interface GetExternalPrincipalRequest {
    principalId: string;
}

export interface GetGroupRequest {
    groupId: string;
}

export interface GetGroupACLRequest {
    groupId: string;
}

export interface GetPolicyRequest {
    policyId: string;
}

export interface GetTokenFromMailboxRequest {
    mailbox: string;
}

export interface GetUserRequest {
    userId: string;
}

export interface ListGroupMembersRequest {
    groupId: string;
    prefix?: string;
    after?: string;
    amount?: number;
}

export interface ListGroupPoliciesRequest {
    groupId: string;
    prefix?: string;
    after?: string;
    amount?: number;
}

export interface ListGroupsRequest {
    prefix?: string;
    after?: string;
    amount?: number;
}

export interface ListPoliciesRequest {
    prefix?: string;
    after?: string;
    amount?: number;
}

export interface ListUserCredentialsRequest {
    userId: string;
    prefix?: string;
    after?: string;
    amount?: number;
}

export interface ListUserExternalPrincipalsRequest {
    userId: string;
    prefix?: string;
    after?: string;
    amount?: number;
}

export interface ListUserGroupsRequest {
    userId: string;
    prefix?: string;
    after?: string;
    amount?: number;
}

export interface ListUserPoliciesRequest {
    userId: string;
    prefix?: string;
    after?: string;
    amount?: number;
    effective?: boolean;
}

export interface ListUsersRequest {
    prefix?: string;
    after?: string;
    amount?: number;
}

export interface LoginRequest {
    loginInformation?: LoginInformation;
}

export interface ReleaseTokenToMailboxRequest {
    loginRequestToken: string;
}

export interface SetGroupACLRequest {
    groupId: string;
    aCL: ACL;
}

export interface UpdatePolicyRequest {
    policyId: string;
    policy: Policy;
}

/**
 * AuthApi - interface
 * 
 * @export
 * @interface AuthApiInterface
 */
export interface AuthApiInterface {
    /**
     * 
     * @summary add group membership
     * @param {string} groupId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    addGroupMembershipRaw(requestParameters: AddGroupMembershipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * add group membership
     */
    addGroupMembership(requestParameters: AddGroupMembershipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary attach policy to group
     * @param {string} groupId 
     * @param {string} policyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    attachPolicyToGroupRaw(requestParameters: AttachPolicyToGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * attach policy to group
     */
    attachPolicyToGroup(requestParameters: AttachPolicyToGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary attach policy to user
     * @param {string} userId 
     * @param {string} policyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    attachPolicyToUserRaw(requestParameters: AttachPolicyToUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * attach policy to user
     */
    attachPolicyToUser(requestParameters: AttachPolicyToUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary create credentials
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    createCredentialsRaw(requestParameters: CreateCredentialsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CredentialsWithSecret>>;

    /**
     * create credentials
     */
    createCredentials(requestParameters: CreateCredentialsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CredentialsWithSecret>;

    /**
     * 
     * @summary create group
     * @param {GroupCreation} [groupCreation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    createGroupRaw(requestParameters: CreateGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Group>>;

    /**
     * create group
     */
    createGroup(requestParameters: CreateGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Group>;

    /**
     * 
     * @summary create policy
     * @param {Policy} policy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    createPolicyRaw(requestParameters: CreatePolicyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Policy>>;

    /**
     * create policy
     */
    createPolicy(requestParameters: CreatePolicyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Policy>;

    /**
     * 
     * @summary create user
     * @param {UserCreation} [userCreation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    createUserRaw(requestParameters: CreateUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<User>>;

    /**
     * create user
     */
    createUser(requestParameters: CreateUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<User>;

    /**
     * 
     * @summary attach external principal to user
     * @param {string} userId 
     * @param {string} principalId 
     * @param {ExternalPrincipalCreation} [externalPrincipalCreation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    createUserExternalPrincipalRaw(requestParameters: CreateUserExternalPrincipalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * attach external principal to user
     */
    createUserExternalPrincipal(requestParameters: CreateUserExternalPrincipalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary delete credentials
     * @param {string} userId 
     * @param {string} accessKeyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    deleteCredentialsRaw(requestParameters: DeleteCredentialsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * delete credentials
     */
    deleteCredentials(requestParameters: DeleteCredentialsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary delete group
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    deleteGroupRaw(requestParameters: DeleteGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * delete group
     */
    deleteGroup(requestParameters: DeleteGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary delete group membership
     * @param {string} groupId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    deleteGroupMembershipRaw(requestParameters: DeleteGroupMembershipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * delete group membership
     */
    deleteGroupMembership(requestParameters: DeleteGroupMembershipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary delete policy
     * @param {string} policyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    deletePolicyRaw(requestParameters: DeletePolicyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * delete policy
     */
    deletePolicy(requestParameters: DeletePolicyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary delete user
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    deleteUserRaw(requestParameters: DeleteUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * delete user
     */
    deleteUser(requestParameters: DeleteUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary delete external principal from user
     * @param {string} userId 
     * @param {string} principalId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    deleteUserExternalPrincipalRaw(requestParameters: DeleteUserExternalPrincipalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * delete external principal from user
     */
    deleteUserExternalPrincipal(requestParameters: DeleteUserExternalPrincipalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary detach policy from group
     * @param {string} groupId 
     * @param {string} policyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    detachPolicyFromGroupRaw(requestParameters: DetachPolicyFromGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * detach policy from group
     */
    detachPolicyFromGroup(requestParameters: DetachPolicyFromGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary detach policy from user
     * @param {string} userId 
     * @param {string} policyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    detachPolicyFromUserRaw(requestParameters: DetachPolicyFromUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * detach policy from user
     */
    detachPolicyFromUser(requestParameters: DetachPolicyFromUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary perform a login using an external authenticator
     * @param {ExternalLoginInformation} [externalLoginInformation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    externalPrincipalLoginRaw(requestParameters: ExternalPrincipalLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthenticationToken>>;

    /**
     * perform a login using an external authenticator
     */
    externalPrincipalLogin(requestParameters: ExternalPrincipalLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthenticationToken>;

    /**
     * 
     * @summary get credentials
     * @param {string} userId 
     * @param {string} accessKeyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    getCredentialsRaw(requestParameters: GetCredentialsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Credentials>>;

    /**
     * get credentials
     */
    getCredentials(requestParameters: GetCredentialsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Credentials>;

    /**
     * 
     * @summary get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    getCurrentUserRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CurrentUser>>;

    /**
     * get current user
     */
    getCurrentUser(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CurrentUser>;

    /**
     * 
     * @summary describe external principal by id
     * @param {string} principalId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    getExternalPrincipalRaw(requestParameters: GetExternalPrincipalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExternalPrincipal>>;

    /**
     * describe external principal by id
     */
    getExternalPrincipal(requestParameters: GetExternalPrincipalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExternalPrincipal>;

    /**
     * 
     * @summary get group
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    getGroupRaw(requestParameters: GetGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Group>>;

    /**
     * get group
     */
    getGroup(requestParameters: GetGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Group>;

    /**
     * 
     * @summary get ACL of group
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    getGroupACLRaw(requestParameters: GetGroupACLRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ACL>>;

    /**
     * get ACL of group
     */
    getGroupACL(requestParameters: GetGroupACLRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ACL>;

    /**
     * 
     * @summary get policy
     * @param {string} policyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    getPolicyRaw(requestParameters: GetPolicyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Policy>>;

    /**
     * get policy
     */
    getPolicy(requestParameters: GetPolicyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Policy>;

    /**
     * 
     * @summary receive the token after user has authenticated on redirect URL.
     * @param {string} mailbox mailbox returned by getTokenRedirect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    getTokenFromMailboxRaw(requestParameters: GetTokenFromMailboxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthenticationToken>>;

    /**
     * receive the token after user has authenticated on redirect URL.
     */
    getTokenFromMailbox(requestParameters: GetTokenFromMailboxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthenticationToken>;

    /**
     * 
     * @summary start acquiring a token by logging in on a browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    getTokenRedirectRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Error>>;

    /**
     * start acquiring a token by logging in on a browser
     */
    getTokenRedirect(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Error>;

    /**
     * 
     * @summary get user
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    getUserRaw(requestParameters: GetUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<User>>;

    /**
     * get user
     */
    getUser(requestParameters: GetUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<User>;

    /**
     * 
     * @summary list group members
     * @param {string} groupId 
     * @param {string} [prefix] return items prefixed with this value
     * @param {string} [after] return items after this value
     * @param {number} [amount] how many items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    listGroupMembersRaw(requestParameters: ListGroupMembersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserList>>;

    /**
     * list group members
     */
    listGroupMembers(requestParameters: ListGroupMembersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserList>;

    /**
     * 
     * @summary list group policies
     * @param {string} groupId 
     * @param {string} [prefix] return items prefixed with this value
     * @param {string} [after] return items after this value
     * @param {number} [amount] how many items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    listGroupPoliciesRaw(requestParameters: ListGroupPoliciesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PolicyList>>;

    /**
     * list group policies
     */
    listGroupPolicies(requestParameters: ListGroupPoliciesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PolicyList>;

    /**
     * 
     * @summary list groups
     * @param {string} [prefix] return items prefixed with this value
     * @param {string} [after] return items after this value
     * @param {number} [amount] how many items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    listGroupsRaw(requestParameters: ListGroupsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GroupList>>;

    /**
     * list groups
     */
    listGroups(requestParameters: ListGroupsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GroupList>;

    /**
     * 
     * @summary list policies
     * @param {string} [prefix] return items prefixed with this value
     * @param {string} [after] return items after this value
     * @param {number} [amount] how many items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    listPoliciesRaw(requestParameters: ListPoliciesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PolicyList>>;

    /**
     * list policies
     */
    listPolicies(requestParameters: ListPoliciesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PolicyList>;

    /**
     * 
     * @summary list user credentials
     * @param {string} userId 
     * @param {string} [prefix] return items prefixed with this value
     * @param {string} [after] return items after this value
     * @param {number} [amount] how many items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    listUserCredentialsRaw(requestParameters: ListUserCredentialsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CredentialsList>>;

    /**
     * list user credentials
     */
    listUserCredentials(requestParameters: ListUserCredentialsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CredentialsList>;

    /**
     * 
     * @summary list user external policies attached to a user
     * @param {string} userId 
     * @param {string} [prefix] return items prefixed with this value
     * @param {string} [after] return items after this value
     * @param {number} [amount] how many items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    listUserExternalPrincipalsRaw(requestParameters: ListUserExternalPrincipalsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExternalPrincipalList>>;

    /**
     * list user external policies attached to a user
     */
    listUserExternalPrincipals(requestParameters: ListUserExternalPrincipalsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExternalPrincipalList>;

    /**
     * 
     * @summary list user groups
     * @param {string} userId 
     * @param {string} [prefix] return items prefixed with this value
     * @param {string} [after] return items after this value
     * @param {number} [amount] how many items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    listUserGroupsRaw(requestParameters: ListUserGroupsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GroupList>>;

    /**
     * list user groups
     */
    listUserGroups(requestParameters: ListUserGroupsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GroupList>;

    /**
     * 
     * @summary list user policies
     * @param {string} userId 
     * @param {string} [prefix] return items prefixed with this value
     * @param {string} [after] return items after this value
     * @param {number} [amount] how many items to return
     * @param {boolean} [effective] will return all distinct policies attached to the user or any of its groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    listUserPoliciesRaw(requestParameters: ListUserPoliciesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PolicyList>>;

    /**
     * list user policies
     */
    listUserPolicies(requestParameters: ListUserPoliciesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PolicyList>;

    /**
     * 
     * @summary list users
     * @param {string} [prefix] return items prefixed with this value
     * @param {string} [after] return items after this value
     * @param {number} [amount] how many items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    listUsersRaw(requestParameters: ListUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserList>>;

    /**
     * list users
     */
    listUsers(requestParameters: ListUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserList>;

    /**
     * 
     * @summary perform a login
     * @param {LoginInformation} [loginInformation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    loginRaw(requestParameters: LoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthenticationToken>>;

    /**
     * perform a login
     */
    login(requestParameters: LoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthenticationToken>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    oauthCallbackRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Error>>;

    /**
     */
    oauthCallback(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Error>;

    /**
     * 
     * @summary release a token for the current (authenticated) user to the mailbox of this login request.
     * @param {string} loginRequestToken login request token returned by getTokenRedirect.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    releaseTokenToMailboxRaw(requestParameters: ReleaseTokenToMailboxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * release a token for the current (authenticated) user to the mailbox of this login request.
     */
    releaseTokenToMailbox(requestParameters: ReleaseTokenToMailboxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary set ACL of group
     * @param {string} groupId 
     * @param {ACL} aCL 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    setGroupACLRaw(requestParameters: SetGroupACLRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * set ACL of group
     */
    setGroupACL(requestParameters: SetGroupACLRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary update policy
     * @param {string} policyId 
     * @param {Policy} policy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    updatePolicyRaw(requestParameters: UpdatePolicyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Policy>>;

    /**
     * update policy
     */
    updatePolicy(requestParameters: UpdatePolicyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Policy>;

}

/**
 * 
 */
export class AuthApi extends runtime.BaseAPI implements AuthApiInterface {

    /**
     * add group membership
     */
    async addGroupMembershipRaw(requestParameters: AddGroupMembershipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.groupId === null || requestParameters.groupId === undefined) {
            throw new runtime.RequiredError('groupId','Required parameter requestParameters.groupId was null or undefined when calling addGroupMembership.');
        }

        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling addGroupMembership.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/groups/{groupId}/members/{userId}`.replace(`{${"groupId"}}`, encodeURIComponent(String(requestParameters.groupId))).replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * add group membership
     */
    async addGroupMembership(requestParameters: AddGroupMembershipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.addGroupMembershipRaw(requestParameters, initOverrides);
    }

    /**
     * attach policy to group
     */
    async attachPolicyToGroupRaw(requestParameters: AttachPolicyToGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.groupId === null || requestParameters.groupId === undefined) {
            throw new runtime.RequiredError('groupId','Required parameter requestParameters.groupId was null or undefined when calling attachPolicyToGroup.');
        }

        if (requestParameters.policyId === null || requestParameters.policyId === undefined) {
            throw new runtime.RequiredError('policyId','Required parameter requestParameters.policyId was null or undefined when calling attachPolicyToGroup.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/groups/{groupId}/policies/{policyId}`.replace(`{${"groupId"}}`, encodeURIComponent(String(requestParameters.groupId))).replace(`{${"policyId"}}`, encodeURIComponent(String(requestParameters.policyId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * attach policy to group
     */
    async attachPolicyToGroup(requestParameters: AttachPolicyToGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.attachPolicyToGroupRaw(requestParameters, initOverrides);
    }

    /**
     * attach policy to user
     */
    async attachPolicyToUserRaw(requestParameters: AttachPolicyToUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling attachPolicyToUser.');
        }

        if (requestParameters.policyId === null || requestParameters.policyId === undefined) {
            throw new runtime.RequiredError('policyId','Required parameter requestParameters.policyId was null or undefined when calling attachPolicyToUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/users/{userId}/policies/{policyId}`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters.userId))).replace(`{${"policyId"}}`, encodeURIComponent(String(requestParameters.policyId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * attach policy to user
     */
    async attachPolicyToUser(requestParameters: AttachPolicyToUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.attachPolicyToUserRaw(requestParameters, initOverrides);
    }

    /**
     * create credentials
     */
    async createCredentialsRaw(requestParameters: CreateCredentialsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CredentialsWithSecret>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling createCredentials.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/users/{userId}/credentials`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CredentialsWithSecretFromJSON(jsonValue));
    }

    /**
     * create credentials
     */
    async createCredentials(requestParameters: CreateCredentialsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CredentialsWithSecret> {
        const response = await this.createCredentialsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create group
     */
    async createGroupRaw(requestParameters: CreateGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Group>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/groups`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GroupCreationToJSON(requestParameters.groupCreation),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GroupFromJSON(jsonValue));
    }

    /**
     * create group
     */
    async createGroup(requestParameters: CreateGroupRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Group> {
        const response = await this.createGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create policy
     */
    async createPolicyRaw(requestParameters: CreatePolicyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Policy>> {
        if (requestParameters.policy === null || requestParameters.policy === undefined) {
            throw new runtime.RequiredError('policy','Required parameter requestParameters.policy was null or undefined when calling createPolicy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/policies`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PolicyToJSON(requestParameters.policy),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PolicyFromJSON(jsonValue));
    }

    /**
     * create policy
     */
    async createPolicy(requestParameters: CreatePolicyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Policy> {
        const response = await this.createPolicyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create user
     */
    async createUserRaw(requestParameters: CreateUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<User>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/users`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserCreationToJSON(requestParameters.userCreation),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
    }

    /**
     * create user
     */
    async createUser(requestParameters: CreateUserRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<User> {
        const response = await this.createUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * attach external principal to user
     */
    async createUserExternalPrincipalRaw(requestParameters: CreateUserExternalPrincipalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling createUserExternalPrincipal.');
        }

        if (requestParameters.principalId === null || requestParameters.principalId === undefined) {
            throw new runtime.RequiredError('principalId','Required parameter requestParameters.principalId was null or undefined when calling createUserExternalPrincipal.');
        }

        const queryParameters: any = {};

        if (requestParameters.principalId !== undefined) {
            queryParameters['principalId'] = requestParameters.principalId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/users/{userId}/external/principals`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ExternalPrincipalCreationToJSON(requestParameters.externalPrincipalCreation),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * attach external principal to user
     */
    async createUserExternalPrincipal(requestParameters: CreateUserExternalPrincipalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.createUserExternalPrincipalRaw(requestParameters, initOverrides);
    }

    /**
     * delete credentials
     */
    async deleteCredentialsRaw(requestParameters: DeleteCredentialsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling deleteCredentials.');
        }

        if (requestParameters.accessKeyId === null || requestParameters.accessKeyId === undefined) {
            throw new runtime.RequiredError('accessKeyId','Required parameter requestParameters.accessKeyId was null or undefined when calling deleteCredentials.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/users/{userId}/credentials/{accessKeyId}`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters.userId))).replace(`{${"accessKeyId"}}`, encodeURIComponent(String(requestParameters.accessKeyId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * delete credentials
     */
    async deleteCredentials(requestParameters: DeleteCredentialsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteCredentialsRaw(requestParameters, initOverrides);
    }

    /**
     * delete group
     */
    async deleteGroupRaw(requestParameters: DeleteGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.groupId === null || requestParameters.groupId === undefined) {
            throw new runtime.RequiredError('groupId','Required parameter requestParameters.groupId was null or undefined when calling deleteGroup.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/groups/{groupId}`.replace(`{${"groupId"}}`, encodeURIComponent(String(requestParameters.groupId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * delete group
     */
    async deleteGroup(requestParameters: DeleteGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteGroupRaw(requestParameters, initOverrides);
    }

    /**
     * delete group membership
     */
    async deleteGroupMembershipRaw(requestParameters: DeleteGroupMembershipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.groupId === null || requestParameters.groupId === undefined) {
            throw new runtime.RequiredError('groupId','Required parameter requestParameters.groupId was null or undefined when calling deleteGroupMembership.');
        }

        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling deleteGroupMembership.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/groups/{groupId}/members/{userId}`.replace(`{${"groupId"}}`, encodeURIComponent(String(requestParameters.groupId))).replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * delete group membership
     */
    async deleteGroupMembership(requestParameters: DeleteGroupMembershipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteGroupMembershipRaw(requestParameters, initOverrides);
    }

    /**
     * delete policy
     */
    async deletePolicyRaw(requestParameters: DeletePolicyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.policyId === null || requestParameters.policyId === undefined) {
            throw new runtime.RequiredError('policyId','Required parameter requestParameters.policyId was null or undefined when calling deletePolicy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/policies/{policyId}`.replace(`{${"policyId"}}`, encodeURIComponent(String(requestParameters.policyId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * delete policy
     */
    async deletePolicy(requestParameters: DeletePolicyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deletePolicyRaw(requestParameters, initOverrides);
    }

    /**
     * delete user
     */
    async deleteUserRaw(requestParameters: DeleteUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling deleteUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/users/{userId}`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * delete user
     */
    async deleteUser(requestParameters: DeleteUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteUserRaw(requestParameters, initOverrides);
    }

    /**
     * delete external principal from user
     */
    async deleteUserExternalPrincipalRaw(requestParameters: DeleteUserExternalPrincipalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling deleteUserExternalPrincipal.');
        }

        if (requestParameters.principalId === null || requestParameters.principalId === undefined) {
            throw new runtime.RequiredError('principalId','Required parameter requestParameters.principalId was null or undefined when calling deleteUserExternalPrincipal.');
        }

        const queryParameters: any = {};

        if (requestParameters.principalId !== undefined) {
            queryParameters['principalId'] = requestParameters.principalId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/users/{userId}/external/principals`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * delete external principal from user
     */
    async deleteUserExternalPrincipal(requestParameters: DeleteUserExternalPrincipalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteUserExternalPrincipalRaw(requestParameters, initOverrides);
    }

    /**
     * detach policy from group
     */
    async detachPolicyFromGroupRaw(requestParameters: DetachPolicyFromGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.groupId === null || requestParameters.groupId === undefined) {
            throw new runtime.RequiredError('groupId','Required parameter requestParameters.groupId was null or undefined when calling detachPolicyFromGroup.');
        }

        if (requestParameters.policyId === null || requestParameters.policyId === undefined) {
            throw new runtime.RequiredError('policyId','Required parameter requestParameters.policyId was null or undefined when calling detachPolicyFromGroup.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/groups/{groupId}/policies/{policyId}`.replace(`{${"groupId"}}`, encodeURIComponent(String(requestParameters.groupId))).replace(`{${"policyId"}}`, encodeURIComponent(String(requestParameters.policyId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * detach policy from group
     */
    async detachPolicyFromGroup(requestParameters: DetachPolicyFromGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.detachPolicyFromGroupRaw(requestParameters, initOverrides);
    }

    /**
     * detach policy from user
     */
    async detachPolicyFromUserRaw(requestParameters: DetachPolicyFromUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling detachPolicyFromUser.');
        }

        if (requestParameters.policyId === null || requestParameters.policyId === undefined) {
            throw new runtime.RequiredError('policyId','Required parameter requestParameters.policyId was null or undefined when calling detachPolicyFromUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/users/{userId}/policies/{policyId}`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters.userId))).replace(`{${"policyId"}}`, encodeURIComponent(String(requestParameters.policyId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * detach policy from user
     */
    async detachPolicyFromUser(requestParameters: DetachPolicyFromUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.detachPolicyFromUserRaw(requestParameters, initOverrides);
    }

    /**
     * perform a login using an external authenticator
     */
    async externalPrincipalLoginRaw(requestParameters: ExternalPrincipalLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthenticationToken>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/auth/external/principal/login`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ExternalLoginInformationToJSON(requestParameters.externalLoginInformation),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthenticationTokenFromJSON(jsonValue));
    }

    /**
     * perform a login using an external authenticator
     */
    async externalPrincipalLogin(requestParameters: ExternalPrincipalLoginRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthenticationToken> {
        const response = await this.externalPrincipalLoginRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get credentials
     */
    async getCredentialsRaw(requestParameters: GetCredentialsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Credentials>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling getCredentials.');
        }

        if (requestParameters.accessKeyId === null || requestParameters.accessKeyId === undefined) {
            throw new runtime.RequiredError('accessKeyId','Required parameter requestParameters.accessKeyId was null or undefined when calling getCredentials.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/users/{userId}/credentials/{accessKeyId}`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters.userId))).replace(`{${"accessKeyId"}}`, encodeURIComponent(String(requestParameters.accessKeyId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CredentialsFromJSON(jsonValue));
    }

    /**
     * get credentials
     */
    async getCredentials(requestParameters: GetCredentialsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Credentials> {
        const response = await this.getCredentialsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get current user
     */
    async getCurrentUserRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CurrentUser>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/user`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CurrentUserFromJSON(jsonValue));
    }

    /**
     * get current user
     */
    async getCurrentUser(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CurrentUser> {
        const response = await this.getCurrentUserRaw(initOverrides);
        return await response.value();
    }

    /**
     * describe external principal by id
     */
    async getExternalPrincipalRaw(requestParameters: GetExternalPrincipalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExternalPrincipal>> {
        if (requestParameters.principalId === null || requestParameters.principalId === undefined) {
            throw new runtime.RequiredError('principalId','Required parameter requestParameters.principalId was null or undefined when calling getExternalPrincipal.');
        }

        const queryParameters: any = {};

        if (requestParameters.principalId !== undefined) {
            queryParameters['principalId'] = requestParameters.principalId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/external/principals`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExternalPrincipalFromJSON(jsonValue));
    }

    /**
     * describe external principal by id
     */
    async getExternalPrincipal(requestParameters: GetExternalPrincipalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExternalPrincipal> {
        const response = await this.getExternalPrincipalRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get group
     */
    async getGroupRaw(requestParameters: GetGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Group>> {
        if (requestParameters.groupId === null || requestParameters.groupId === undefined) {
            throw new runtime.RequiredError('groupId','Required parameter requestParameters.groupId was null or undefined when calling getGroup.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/groups/{groupId}`.replace(`{${"groupId"}}`, encodeURIComponent(String(requestParameters.groupId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GroupFromJSON(jsonValue));
    }

    /**
     * get group
     */
    async getGroup(requestParameters: GetGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Group> {
        const response = await this.getGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get ACL of group
     */
    async getGroupACLRaw(requestParameters: GetGroupACLRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ACL>> {
        if (requestParameters.groupId === null || requestParameters.groupId === undefined) {
            throw new runtime.RequiredError('groupId','Required parameter requestParameters.groupId was null or undefined when calling getGroupACL.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/groups/{groupId}/acl`.replace(`{${"groupId"}}`, encodeURIComponent(String(requestParameters.groupId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ACLFromJSON(jsonValue));
    }

    /**
     * get ACL of group
     */
    async getGroupACL(requestParameters: GetGroupACLRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ACL> {
        const response = await this.getGroupACLRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get policy
     */
    async getPolicyRaw(requestParameters: GetPolicyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Policy>> {
        if (requestParameters.policyId === null || requestParameters.policyId === undefined) {
            throw new runtime.RequiredError('policyId','Required parameter requestParameters.policyId was null or undefined when calling getPolicy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/policies/{policyId}`.replace(`{${"policyId"}}`, encodeURIComponent(String(requestParameters.policyId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PolicyFromJSON(jsonValue));
    }

    /**
     * get policy
     */
    async getPolicy(requestParameters: GetPolicyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Policy> {
        const response = await this.getPolicyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * receive the token after user has authenticated on redirect URL.
     */
    async getTokenFromMailboxRaw(requestParameters: GetTokenFromMailboxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthenticationToken>> {
        if (requestParameters.mailbox === null || requestParameters.mailbox === undefined) {
            throw new runtime.RequiredError('mailbox','Required parameter requestParameters.mailbox was null or undefined when calling getTokenFromMailbox.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/auth/get-token/mailboxes/{mailbox}`.replace(`{${"mailbox"}}`, encodeURIComponent(String(requestParameters.mailbox))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthenticationTokenFromJSON(jsonValue));
    }

    /**
     * receive the token after user has authenticated on redirect URL.
     */
    async getTokenFromMailbox(requestParameters: GetTokenFromMailboxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthenticationToken> {
        const response = await this.getTokenFromMailboxRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * start acquiring a token by logging in on a browser
     */
    async getTokenRedirectRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Error>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/auth/get-token/start`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<Error>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * start acquiring a token by logging in on a browser
     */
    async getTokenRedirect(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Error> {
        const response = await this.getTokenRedirectRaw(initOverrides);
        return await response.value();
    }

    /**
     * get user
     */
    async getUserRaw(requestParameters: GetUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<User>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling getUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/users/{userId}`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
    }

    /**
     * get user
     */
    async getUser(requestParameters: GetUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<User> {
        const response = await this.getUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list group members
     */
    async listGroupMembersRaw(requestParameters: ListGroupMembersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserList>> {
        if (requestParameters.groupId === null || requestParameters.groupId === undefined) {
            throw new runtime.RequiredError('groupId','Required parameter requestParameters.groupId was null or undefined when calling listGroupMembers.');
        }

        const queryParameters: any = {};

        if (requestParameters.prefix !== undefined) {
            queryParameters['prefix'] = requestParameters.prefix;
        }

        if (requestParameters.after !== undefined) {
            queryParameters['after'] = requestParameters.after;
        }

        if (requestParameters.amount !== undefined) {
            queryParameters['amount'] = requestParameters.amount;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/groups/{groupId}/members`.replace(`{${"groupId"}}`, encodeURIComponent(String(requestParameters.groupId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserListFromJSON(jsonValue));
    }

    /**
     * list group members
     */
    async listGroupMembers(requestParameters: ListGroupMembersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserList> {
        const response = await this.listGroupMembersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list group policies
     */
    async listGroupPoliciesRaw(requestParameters: ListGroupPoliciesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PolicyList>> {
        if (requestParameters.groupId === null || requestParameters.groupId === undefined) {
            throw new runtime.RequiredError('groupId','Required parameter requestParameters.groupId was null or undefined when calling listGroupPolicies.');
        }

        const queryParameters: any = {};

        if (requestParameters.prefix !== undefined) {
            queryParameters['prefix'] = requestParameters.prefix;
        }

        if (requestParameters.after !== undefined) {
            queryParameters['after'] = requestParameters.after;
        }

        if (requestParameters.amount !== undefined) {
            queryParameters['amount'] = requestParameters.amount;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/groups/{groupId}/policies`.replace(`{${"groupId"}}`, encodeURIComponent(String(requestParameters.groupId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PolicyListFromJSON(jsonValue));
    }

    /**
     * list group policies
     */
    async listGroupPolicies(requestParameters: ListGroupPoliciesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PolicyList> {
        const response = await this.listGroupPoliciesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list groups
     */
    async listGroupsRaw(requestParameters: ListGroupsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GroupList>> {
        const queryParameters: any = {};

        if (requestParameters.prefix !== undefined) {
            queryParameters['prefix'] = requestParameters.prefix;
        }

        if (requestParameters.after !== undefined) {
            queryParameters['after'] = requestParameters.after;
        }

        if (requestParameters.amount !== undefined) {
            queryParameters['amount'] = requestParameters.amount;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/groups`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GroupListFromJSON(jsonValue));
    }

    /**
     * list groups
     */
    async listGroups(requestParameters: ListGroupsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GroupList> {
        const response = await this.listGroupsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list policies
     */
    async listPoliciesRaw(requestParameters: ListPoliciesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PolicyList>> {
        const queryParameters: any = {};

        if (requestParameters.prefix !== undefined) {
            queryParameters['prefix'] = requestParameters.prefix;
        }

        if (requestParameters.after !== undefined) {
            queryParameters['after'] = requestParameters.after;
        }

        if (requestParameters.amount !== undefined) {
            queryParameters['amount'] = requestParameters.amount;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/policies`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PolicyListFromJSON(jsonValue));
    }

    /**
     * list policies
     */
    async listPolicies(requestParameters: ListPoliciesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PolicyList> {
        const response = await this.listPoliciesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list user credentials
     */
    async listUserCredentialsRaw(requestParameters: ListUserCredentialsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CredentialsList>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling listUserCredentials.');
        }

        const queryParameters: any = {};

        if (requestParameters.prefix !== undefined) {
            queryParameters['prefix'] = requestParameters.prefix;
        }

        if (requestParameters.after !== undefined) {
            queryParameters['after'] = requestParameters.after;
        }

        if (requestParameters.amount !== undefined) {
            queryParameters['amount'] = requestParameters.amount;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/users/{userId}/credentials`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CredentialsListFromJSON(jsonValue));
    }

    /**
     * list user credentials
     */
    async listUserCredentials(requestParameters: ListUserCredentialsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CredentialsList> {
        const response = await this.listUserCredentialsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list user external policies attached to a user
     */
    async listUserExternalPrincipalsRaw(requestParameters: ListUserExternalPrincipalsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExternalPrincipalList>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling listUserExternalPrincipals.');
        }

        const queryParameters: any = {};

        if (requestParameters.prefix !== undefined) {
            queryParameters['prefix'] = requestParameters.prefix;
        }

        if (requestParameters.after !== undefined) {
            queryParameters['after'] = requestParameters.after;
        }

        if (requestParameters.amount !== undefined) {
            queryParameters['amount'] = requestParameters.amount;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/users/{userId}/external/principals/ls`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExternalPrincipalListFromJSON(jsonValue));
    }

    /**
     * list user external policies attached to a user
     */
    async listUserExternalPrincipals(requestParameters: ListUserExternalPrincipalsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExternalPrincipalList> {
        const response = await this.listUserExternalPrincipalsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list user groups
     */
    async listUserGroupsRaw(requestParameters: ListUserGroupsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GroupList>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling listUserGroups.');
        }

        const queryParameters: any = {};

        if (requestParameters.prefix !== undefined) {
            queryParameters['prefix'] = requestParameters.prefix;
        }

        if (requestParameters.after !== undefined) {
            queryParameters['after'] = requestParameters.after;
        }

        if (requestParameters.amount !== undefined) {
            queryParameters['amount'] = requestParameters.amount;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/users/{userId}/groups`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GroupListFromJSON(jsonValue));
    }

    /**
     * list user groups
     */
    async listUserGroups(requestParameters: ListUserGroupsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GroupList> {
        const response = await this.listUserGroupsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list user policies
     */
    async listUserPoliciesRaw(requestParameters: ListUserPoliciesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PolicyList>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling listUserPolicies.');
        }

        const queryParameters: any = {};

        if (requestParameters.prefix !== undefined) {
            queryParameters['prefix'] = requestParameters.prefix;
        }

        if (requestParameters.after !== undefined) {
            queryParameters['after'] = requestParameters.after;
        }

        if (requestParameters.amount !== undefined) {
            queryParameters['amount'] = requestParameters.amount;
        }

        if (requestParameters.effective !== undefined) {
            queryParameters['effective'] = requestParameters.effective;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/users/{userId}/policies`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PolicyListFromJSON(jsonValue));
    }

    /**
     * list user policies
     */
    async listUserPolicies(requestParameters: ListUserPoliciesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PolicyList> {
        const response = await this.listUserPoliciesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list users
     */
    async listUsersRaw(requestParameters: ListUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserList>> {
        const queryParameters: any = {};

        if (requestParameters.prefix !== undefined) {
            queryParameters['prefix'] = requestParameters.prefix;
        }

        if (requestParameters.after !== undefined) {
            queryParameters['after'] = requestParameters.after;
        }

        if (requestParameters.amount !== undefined) {
            queryParameters['amount'] = requestParameters.amount;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/users`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserListFromJSON(jsonValue));
    }

    /**
     * list users
     */
    async listUsers(requestParameters: ListUsersRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserList> {
        const response = await this.listUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * perform a login
     */
    async loginRaw(requestParameters: LoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthenticationToken>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/auth/login`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LoginInformationToJSON(requestParameters.loginInformation),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthenticationTokenFromJSON(jsonValue));
    }

    /**
     * perform a login
     */
    async login(requestParameters: LoginRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthenticationToken> {
        const response = await this.loginRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async oauthCallbackRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Error>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/oidc/callback`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<Error>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     */
    async oauthCallback(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Error> {
        const response = await this.oauthCallbackRaw(initOverrides);
        return await response.value();
    }

    /**
     * release a token for the current (authenticated) user to the mailbox of this login request.
     */
    async releaseTokenToMailboxRaw(requestParameters: ReleaseTokenToMailboxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.loginRequestToken === null || requestParameters.loginRequestToken === undefined) {
            throw new runtime.RequiredError('loginRequestToken','Required parameter requestParameters.loginRequestToken was null or undefined when calling releaseTokenToMailbox.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/get-token/release-token/{loginRequestToken}`.replace(`{${"loginRequestToken"}}`, encodeURIComponent(String(requestParameters.loginRequestToken))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * release a token for the current (authenticated) user to the mailbox of this login request.
     */
    async releaseTokenToMailbox(requestParameters: ReleaseTokenToMailboxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.releaseTokenToMailboxRaw(requestParameters, initOverrides);
    }

    /**
     * set ACL of group
     */
    async setGroupACLRaw(requestParameters: SetGroupACLRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.groupId === null || requestParameters.groupId === undefined) {
            throw new runtime.RequiredError('groupId','Required parameter requestParameters.groupId was null or undefined when calling setGroupACL.');
        }

        if (requestParameters.aCL === null || requestParameters.aCL === undefined) {
            throw new runtime.RequiredError('aCL','Required parameter requestParameters.aCL was null or undefined when calling setGroupACL.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/groups/{groupId}/acl`.replace(`{${"groupId"}}`, encodeURIComponent(String(requestParameters.groupId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ACLToJSON(requestParameters.aCL),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * set ACL of group
     */
    async setGroupACL(requestParameters: SetGroupACLRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.setGroupACLRaw(requestParameters, initOverrides);
    }

    /**
     * update policy
     */
    async updatePolicyRaw(requestParameters: UpdatePolicyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Policy>> {
        if (requestParameters.policyId === null || requestParameters.policyId === undefined) {
            throw new runtime.RequiredError('policyId','Required parameter requestParameters.policyId was null or undefined when calling updatePolicy.');
        }

        if (requestParameters.policy === null || requestParameters.policy === undefined) {
            throw new runtime.RequiredError('policy','Required parameter requestParameters.policy was null or undefined when calling updatePolicy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/auth/policies/{policyId}`.replace(`{${"policyId"}}`, encodeURIComponent(String(requestParameters.policyId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PolicyToJSON(requestParameters.policy),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PolicyFromJSON(jsonValue));
    }

    /**
     * update policy
     */
    async updatePolicy(requestParameters: UpdatePolicyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Policy> {
        const response = await this.updatePolicyRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
