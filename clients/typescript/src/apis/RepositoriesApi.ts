/* tslint:disable */
/* eslint-disable */
/**
 * lakeFS API
 * lakeFS HTTP API
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BranchProtectionRule,
  GarbageCollectionRules,
  RefsRestore,
  Repository,
  RepositoryCreation,
  RepositoryDumpStatus,
  RepositoryList,
  RepositoryRestoreStatus,
  TaskInfo,
} from '../models/index';
import {
    BranchProtectionRuleFromJSON,
    BranchProtectionRuleToJSON,
    GarbageCollectionRulesFromJSON,
    GarbageCollectionRulesToJSON,
    RefsRestoreFromJSON,
    RefsRestoreToJSON,
    RepositoryFromJSON,
    RepositoryToJSON,
    RepositoryCreationFromJSON,
    RepositoryCreationToJSON,
    RepositoryDumpStatusFromJSON,
    RepositoryDumpStatusToJSON,
    RepositoryListFromJSON,
    RepositoryListToJSON,
    RepositoryRestoreStatusFromJSON,
    RepositoryRestoreStatusToJSON,
    TaskInfoFromJSON,
    TaskInfoToJSON,
} from '../models/index';

export interface CreateRepositoryRequest {
    repositoryCreation: RepositoryCreation;
    bare?: boolean;
}

export interface DeleteGCRulesRequest {
    repository: string;
}

export interface DeleteRepositoryRequest {
    repository: string;
    force?: boolean;
}

export interface DumpStatusRequest {
    repository: string;
    taskId: string;
}

export interface DumpSubmitRequest {
    repository: string;
}

export interface GetBranchProtectionRulesRequest {
    repository: string;
}

export interface GetGCRulesRequest {
    repository: string;
}

export interface GetRepositoryRequest {
    repository: string;
}

export interface GetRepositoryMetadataRequest {
    repository: string;
}

export interface ListRepositoriesRequest {
    prefix?: string;
    after?: string;
    amount?: number;
    search?: string;
}

export interface RestoreStatusRequest {
    repository: string;
    taskId: string;
}

export interface RestoreSubmitRequest {
    repository: string;
    refsRestore: RefsRestore;
}

export interface SetBranchProtectionRulesRequest {
    repository: string;
    branchProtectionRule: Array<BranchProtectionRule>;
    ifMatch?: string;
}

export interface SetGCRulesRequest {
    repository: string;
    garbageCollectionRules: GarbageCollectionRules;
}

/**
 * RepositoriesApi - interface
 * 
 * @export
 * @interface RepositoriesApiInterface
 */
export interface RepositoriesApiInterface {
    /**
     * 
     * @summary create repository
     * @param {RepositoryCreation} repositoryCreation 
     * @param {boolean} [bare] If true, create a bare repository with no initial commit and branch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApiInterface
     */
    createRepositoryRaw(requestParameters: CreateRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Repository>>;

    /**
     * create repository
     */
    createRepository(requestParameters: CreateRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Repository>;

    /**
     * 
     * @param {string} repository 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApiInterface
     */
    deleteGCRulesRaw(requestParameters: DeleteGCRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     */
    deleteGCRules(requestParameters: DeleteGCRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary delete repository
     * @param {string} repository 
     * @param {boolean} [force] Bypass read-only protection and delete the repository
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApiInterface
     */
    deleteRepositoryRaw(requestParameters: DeleteRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * delete repository
     */
    deleteRepository(requestParameters: DeleteRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary Status of a repository dump task
     * @param {string} repository 
     * @param {string} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApiInterface
     */
    dumpStatusRaw(requestParameters: DumpStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RepositoryDumpStatus>>;

    /**
     * Status of a repository dump task
     */
    dumpStatus(requestParameters: DumpStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RepositoryDumpStatus>;

    /**
     * 
     * @summary Backup the repository metadata (tags, commits, branches) and save the backup to the object store.
     * @param {string} repository 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApiInterface
     */
    dumpSubmitRaw(requestParameters: DumpSubmitRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TaskInfo>>;

    /**
     * Backup the repository metadata (tags, commits, branches) and save the backup to the object store.
     */
    dumpSubmit(requestParameters: DumpSubmitRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TaskInfo>;

    /**
     * 
     * @summary get branch protection rules
     * @param {string} repository 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApiInterface
     */
    getBranchProtectionRulesRaw(requestParameters: GetBranchProtectionRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<BranchProtectionRule>>>;

    /**
     * get branch protection rules
     */
    getBranchProtectionRules(requestParameters: GetBranchProtectionRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<BranchProtectionRule>>;

    /**
     * 
     * @summary get repository GC rules
     * @param {string} repository 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApiInterface
     */
    getGCRulesRaw(requestParameters: GetGCRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GarbageCollectionRules>>;

    /**
     * get repository GC rules
     */
    getGCRules(requestParameters: GetGCRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GarbageCollectionRules>;

    /**
     * 
     * @summary get repository
     * @param {string} repository 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApiInterface
     */
    getRepositoryRaw(requestParameters: GetRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Repository>>;

    /**
     * get repository
     */
    getRepository(requestParameters: GetRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Repository>;

    /**
     * 
     * @summary get repository metadata
     * @param {string} repository 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApiInterface
     */
    getRepositoryMetadataRaw(requestParameters: GetRepositoryMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: string; }>>;

    /**
     * get repository metadata
     */
    getRepositoryMetadata(requestParameters: GetRepositoryMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: string; }>;

    /**
     * 
     * @summary list repositories
     * @param {string} [prefix] return items prefixed with this value
     * @param {string} [after] return items after this value
     * @param {number} [amount] how many items to return
     * @param {string} [search] string for searching relevant entries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApiInterface
     */
    listRepositoriesRaw(requestParameters: ListRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RepositoryList>>;

    /**
     * list repositories
     */
    listRepositories(requestParameters: ListRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RepositoryList>;

    /**
     * 
     * @summary Status of a restore request
     * @param {string} repository 
     * @param {string} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApiInterface
     */
    restoreStatusRaw(requestParameters: RestoreStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RepositoryRestoreStatus>>;

    /**
     * Status of a restore request
     */
    restoreStatus(requestParameters: RestoreStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RepositoryRestoreStatus>;

    /**
     * 
     * @summary Restore repository from a dump in the object store
     * @param {string} repository 
     * @param {RefsRestore} refsRestore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApiInterface
     */
    restoreSubmitRaw(requestParameters: RestoreSubmitRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TaskInfo>>;

    /**
     * Restore repository from a dump in the object store
     */
    restoreSubmit(requestParameters: RestoreSubmitRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TaskInfo>;

    /**
     * 
     * @param {string} repository 
     * @param {Array<BranchProtectionRule>} branchProtectionRule 
     * @param {string} [ifMatch] if provided, the branch protection rules will be updated only if the current ETag match the provided value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApiInterface
     */
    setBranchProtectionRulesRaw(requestParameters: SetBranchProtectionRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     */
    setBranchProtectionRules(requestParameters: SetBranchProtectionRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @param {string} repository 
     * @param {GarbageCollectionRules} garbageCollectionRules 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApiInterface
     */
    setGCRulesRaw(requestParameters: SetGCRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     */
    setGCRules(requestParameters: SetGCRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

}

/**
 * 
 */
export class RepositoriesApi extends runtime.BaseAPI implements RepositoriesApiInterface {

    /**
     * create repository
     */
    async createRepositoryRaw(requestParameters: CreateRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Repository>> {
        if (requestParameters.repositoryCreation === null || requestParameters.repositoryCreation === undefined) {
            throw new runtime.RequiredError('repositoryCreation','Required parameter requestParameters.repositoryCreation was null or undefined when calling createRepository.');
        }

        const queryParameters: any = {};

        if (requestParameters.bare !== undefined) {
            queryParameters['bare'] = requestParameters.bare;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RepositoryCreationToJSON(requestParameters.repositoryCreation),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RepositoryFromJSON(jsonValue));
    }

    /**
     * create repository
     */
    async createRepository(requestParameters: CreateRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Repository> {
        const response = await this.createRepositoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async deleteGCRulesRaw(requestParameters: DeleteGCRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling deleteGCRules.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/settings/gc_rules`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async deleteGCRules(requestParameters: DeleteGCRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteGCRulesRaw(requestParameters, initOverrides);
    }

    /**
     * delete repository
     */
    async deleteRepositoryRaw(requestParameters: DeleteRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling deleteRepository.');
        }

        const queryParameters: any = {};

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * delete repository
     */
    async deleteRepository(requestParameters: DeleteRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteRepositoryRaw(requestParameters, initOverrides);
    }

    /**
     * Status of a repository dump task
     */
    async dumpStatusRaw(requestParameters: DumpStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RepositoryDumpStatus>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling dumpStatus.');
        }

        if (requestParameters.taskId === null || requestParameters.taskId === undefined) {
            throw new runtime.RequiredError('taskId','Required parameter requestParameters.taskId was null or undefined when calling dumpStatus.');
        }

        const queryParameters: any = {};

        if (requestParameters.taskId !== undefined) {
            queryParameters['task_id'] = requestParameters.taskId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/dump`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RepositoryDumpStatusFromJSON(jsonValue));
    }

    /**
     * Status of a repository dump task
     */
    async dumpStatus(requestParameters: DumpStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RepositoryDumpStatus> {
        const response = await this.dumpStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Backup the repository metadata (tags, commits, branches) and save the backup to the object store.
     */
    async dumpSubmitRaw(requestParameters: DumpSubmitRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TaskInfo>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling dumpSubmit.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/dump`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskInfoFromJSON(jsonValue));
    }

    /**
     * Backup the repository metadata (tags, commits, branches) and save the backup to the object store.
     */
    async dumpSubmit(requestParameters: DumpSubmitRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TaskInfo> {
        const response = await this.dumpSubmitRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get branch protection rules
     */
    async getBranchProtectionRulesRaw(requestParameters: GetBranchProtectionRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<BranchProtectionRule>>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling getBranchProtectionRules.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/settings/branch_protection`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BranchProtectionRuleFromJSON));
    }

    /**
     * get branch protection rules
     */
    async getBranchProtectionRules(requestParameters: GetBranchProtectionRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<BranchProtectionRule>> {
        const response = await this.getBranchProtectionRulesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get repository GC rules
     */
    async getGCRulesRaw(requestParameters: GetGCRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GarbageCollectionRules>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling getGCRules.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/settings/gc_rules`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GarbageCollectionRulesFromJSON(jsonValue));
    }

    /**
     * get repository GC rules
     */
    async getGCRules(requestParameters: GetGCRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GarbageCollectionRules> {
        const response = await this.getGCRulesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get repository
     */
    async getRepositoryRaw(requestParameters: GetRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Repository>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling getRepository.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RepositoryFromJSON(jsonValue));
    }

    /**
     * get repository
     */
    async getRepository(requestParameters: GetRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Repository> {
        const response = await this.getRepositoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get repository metadata
     */
    async getRepositoryMetadataRaw(requestParameters: GetRepositoryMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: string; }>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling getRepositoryMetadata.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/metadata`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * get repository metadata
     */
    async getRepositoryMetadata(requestParameters: GetRepositoryMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: string; }> {
        const response = await this.getRepositoryMetadataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list repositories
     */
    async listRepositoriesRaw(requestParameters: ListRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RepositoryList>> {
        const queryParameters: any = {};

        if (requestParameters.prefix !== undefined) {
            queryParameters['prefix'] = requestParameters.prefix;
        }

        if (requestParameters.after !== undefined) {
            queryParameters['after'] = requestParameters.after;
        }

        if (requestParameters.amount !== undefined) {
            queryParameters['amount'] = requestParameters.amount;
        }

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RepositoryListFromJSON(jsonValue));
    }

    /**
     * list repositories
     */
    async listRepositories(requestParameters: ListRepositoriesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RepositoryList> {
        const response = await this.listRepositoriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Status of a restore request
     */
    async restoreStatusRaw(requestParameters: RestoreStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RepositoryRestoreStatus>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling restoreStatus.');
        }

        if (requestParameters.taskId === null || requestParameters.taskId === undefined) {
            throw new runtime.RequiredError('taskId','Required parameter requestParameters.taskId was null or undefined when calling restoreStatus.');
        }

        const queryParameters: any = {};

        if (requestParameters.taskId !== undefined) {
            queryParameters['task_id'] = requestParameters.taskId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/restore`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RepositoryRestoreStatusFromJSON(jsonValue));
    }

    /**
     * Status of a restore request
     */
    async restoreStatus(requestParameters: RestoreStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RepositoryRestoreStatus> {
        const response = await this.restoreStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Restore repository from a dump in the object store
     */
    async restoreSubmitRaw(requestParameters: RestoreSubmitRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TaskInfo>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling restoreSubmit.');
        }

        if (requestParameters.refsRestore === null || requestParameters.refsRestore === undefined) {
            throw new runtime.RequiredError('refsRestore','Required parameter requestParameters.refsRestore was null or undefined when calling restoreSubmit.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/restore`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RefsRestoreToJSON(requestParameters.refsRestore),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskInfoFromJSON(jsonValue));
    }

    /**
     * Restore repository from a dump in the object store
     */
    async restoreSubmit(requestParameters: RestoreSubmitRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TaskInfo> {
        const response = await this.restoreSubmitRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async setBranchProtectionRulesRaw(requestParameters: SetBranchProtectionRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling setBranchProtectionRules.');
        }

        if (requestParameters.branchProtectionRule === null || requestParameters.branchProtectionRule === undefined) {
            throw new runtime.RequiredError('branchProtectionRule','Required parameter requestParameters.branchProtectionRule was null or undefined when calling setBranchProtectionRules.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/settings/branch_protection`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.branchProtectionRule.map(BranchProtectionRuleToJSON),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async setBranchProtectionRules(requestParameters: SetBranchProtectionRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.setBranchProtectionRulesRaw(requestParameters, initOverrides);
    }

    /**
     */
    async setGCRulesRaw(requestParameters: SetGCRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling setGCRules.');
        }

        if (requestParameters.garbageCollectionRules === null || requestParameters.garbageCollectionRules === undefined) {
            throw new runtime.RequiredError('garbageCollectionRules','Required parameter requestParameters.garbageCollectionRules was null or undefined when calling setGCRules.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/settings/gc_rules`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: GarbageCollectionRulesToJSON(requestParameters.garbageCollectionRules),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async setGCRules(requestParameters: SetGCRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.setGCRulesRaw(requestParameters, initOverrides);
    }

}
