/* tslint:disable */
/* eslint-disable */
/**
 * lakeFS API
 * lakeFS HTTP API
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ActionRun,
  ActionRunList,
  HookRunList,
} from '../models/index';
import {
    ActionRunFromJSON,
    ActionRunToJSON,
    ActionRunListFromJSON,
    ActionRunListToJSON,
    HookRunListFromJSON,
    HookRunListToJSON,
} from '../models/index';

export interface GetRunRequest {
    repository: string;
    runId: string;
}

export interface GetRunHookOutputRequest {
    repository: string;
    runId: string;
    hookRunId: string;
}

export interface ListRepositoryRunsRequest {
    repository: string;
    after?: string;
    amount?: number;
    branch?: string;
    commit?: string;
}

export interface ListRunHooksRequest {
    repository: string;
    runId: string;
    after?: string;
    amount?: number;
}

/**
 * ActionsApi - interface
 * 
 * @export
 * @interface ActionsApiInterface
 */
export interface ActionsApiInterface {
    /**
     * 
     * @summary get a run
     * @param {string} repository 
     * @param {string} runId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    getRunRaw(requestParameters: GetRunRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ActionRun>>;

    /**
     * get a run
     */
    getRun(requestParameters: GetRunRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ActionRun>;

    /**
     * 
     * @summary get run hook output
     * @param {string} repository 
     * @param {string} runId 
     * @param {string} hookRunId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    getRunHookOutputRaw(requestParameters: GetRunHookOutputRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>>;

    /**
     * get run hook output
     */
    getRunHookOutput(requestParameters: GetRunHookOutputRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob>;

    /**
     * 
     * @summary list runs
     * @param {string} repository 
     * @param {string} [after] return items after this value
     * @param {number} [amount] how many items to return
     * @param {string} [branch] 
     * @param {string} [commit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    listRepositoryRunsRaw(requestParameters: ListRepositoryRunsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ActionRunList>>;

    /**
     * list runs
     */
    listRepositoryRuns(requestParameters: ListRepositoryRunsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ActionRunList>;

    /**
     * 
     * @summary list run hooks
     * @param {string} repository 
     * @param {string} runId 
     * @param {string} [after] return items after this value
     * @param {number} [amount] how many items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    listRunHooksRaw(requestParameters: ListRunHooksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<HookRunList>>;

    /**
     * list run hooks
     */
    listRunHooks(requestParameters: ListRunHooksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<HookRunList>;

}

/**
 * 
 */
export class ActionsApi extends runtime.BaseAPI implements ActionsApiInterface {

    /**
     * get a run
     */
    async getRunRaw(requestParameters: GetRunRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ActionRun>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling getRun.');
        }

        if (requestParameters.runId === null || requestParameters.runId === undefined) {
            throw new runtime.RequiredError('runId','Required parameter requestParameters.runId was null or undefined when calling getRun.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/actions/runs/{run_id}`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))).replace(`{${"run_id"}}`, encodeURIComponent(String(requestParameters.runId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ActionRunFromJSON(jsonValue));
    }

    /**
     * get a run
     */
    async getRun(requestParameters: GetRunRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ActionRun> {
        const response = await this.getRunRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get run hook output
     */
    async getRunHookOutputRaw(requestParameters: GetRunHookOutputRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling getRunHookOutput.');
        }

        if (requestParameters.runId === null || requestParameters.runId === undefined) {
            throw new runtime.RequiredError('runId','Required parameter requestParameters.runId was null or undefined when calling getRunHookOutput.');
        }

        if (requestParameters.hookRunId === null || requestParameters.hookRunId === undefined) {
            throw new runtime.RequiredError('hookRunId','Required parameter requestParameters.hookRunId was null or undefined when calling getRunHookOutput.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/actions/runs/{run_id}/hooks/{hook_run_id}/output`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))).replace(`{${"run_id"}}`, encodeURIComponent(String(requestParameters.runId))).replace(`{${"hook_run_id"}}`, encodeURIComponent(String(requestParameters.hookRunId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * get run hook output
     */
    async getRunHookOutput(requestParameters: GetRunHookOutputRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.getRunHookOutputRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list runs
     */
    async listRepositoryRunsRaw(requestParameters: ListRepositoryRunsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ActionRunList>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling listRepositoryRuns.');
        }

        const queryParameters: any = {};

        if (requestParameters.after !== undefined) {
            queryParameters['after'] = requestParameters.after;
        }

        if (requestParameters.amount !== undefined) {
            queryParameters['amount'] = requestParameters.amount;
        }

        if (requestParameters.branch !== undefined) {
            queryParameters['branch'] = requestParameters.branch;
        }

        if (requestParameters.commit !== undefined) {
            queryParameters['commit'] = requestParameters.commit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/actions/runs`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ActionRunListFromJSON(jsonValue));
    }

    /**
     * list runs
     */
    async listRepositoryRuns(requestParameters: ListRepositoryRunsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ActionRunList> {
        const response = await this.listRepositoryRunsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list run hooks
     */
    async listRunHooksRaw(requestParameters: ListRunHooksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<HookRunList>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling listRunHooks.');
        }

        if (requestParameters.runId === null || requestParameters.runId === undefined) {
            throw new runtime.RequiredError('runId','Required parameter requestParameters.runId was null or undefined when calling listRunHooks.');
        }

        const queryParameters: any = {};

        if (requestParameters.after !== undefined) {
            queryParameters['after'] = requestParameters.after;
        }

        if (requestParameters.amount !== undefined) {
            queryParameters['amount'] = requestParameters.amount;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/actions/runs/{run_id}/hooks`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))).replace(`{${"run_id"}}`, encodeURIComponent(String(requestParameters.runId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => HookRunListFromJSON(jsonValue));
    }

    /**
     * list run hooks
     */
    async listRunHooks(requestParameters: ListRunHooksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<HookRunList> {
        const response = await this.listRunHooksRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
