/* tslint:disable */
/* eslint-disable */
/**
 * lakeFS API
 * lakeFS HTTP API
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BranchCreation,
  CherryPickCreation,
  Commit,
  DiffList,
  Ref,
  RefList,
  ResetCreation,
  RevertCreation,
} from '../models/index';
import {
    BranchCreationFromJSON,
    BranchCreationToJSON,
    CherryPickCreationFromJSON,
    CherryPickCreationToJSON,
    CommitFromJSON,
    CommitToJSON,
    DiffListFromJSON,
    DiffListToJSON,
    RefFromJSON,
    RefToJSON,
    RefListFromJSON,
    RefListToJSON,
    ResetCreationFromJSON,
    ResetCreationToJSON,
    RevertCreationFromJSON,
    RevertCreationToJSON,
} from '../models/index';

export interface CherryPickRequest {
    repository: string;
    branch: string;
    cherryPickCreation: CherryPickCreation;
}

export interface CreateBranchRequest {
    repository: string;
    branchCreation: BranchCreation;
}

export interface DeleteBranchRequest {
    repository: string;
    branch: string;
    force?: boolean;
}

export interface DiffBranchRequest {
    repository: string;
    branch: string;
    after?: string;
    amount?: number;
    prefix?: string;
    delimiter?: string;
}

export interface GetBranchRequest {
    repository: string;
    branch: string;
}

export interface ListBranchesRequest {
    repository: string;
    prefix?: string;
    after?: string;
    amount?: number;
    showHidden?: boolean;
}

export interface ResetBranchRequest {
    repository: string;
    branch: string;
    resetCreation: ResetCreation;
}

export interface RevertBranchRequest {
    repository: string;
    branch: string;
    revertCreation: RevertCreation;
}

/**
 * BranchesApi - interface
 * 
 * @export
 * @interface BranchesApiInterface
 */
export interface BranchesApiInterface {
    /**
     * 
     * @summary Replay the changes from the given commit on the branch
     * @param {string} repository 
     * @param {string} branch 
     * @param {CherryPickCreation} cherryPickCreation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApiInterface
     */
    cherryPickRaw(requestParameters: CherryPickRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Commit>>;

    /**
     * Replay the changes from the given commit on the branch
     */
    cherryPick(requestParameters: CherryPickRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Commit>;

    /**
     * 
     * @summary create branch
     * @param {string} repository 
     * @param {BranchCreation} branchCreation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApiInterface
     */
    createBranchRaw(requestParameters: CreateBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>>;

    /**
     * create branch
     */
    createBranch(requestParameters: CreateBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string>;

    /**
     * 
     * @summary delete branch
     * @param {string} repository 
     * @param {string} branch 
     * @param {boolean} [force] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApiInterface
     */
    deleteBranchRaw(requestParameters: DeleteBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * delete branch
     */
    deleteBranch(requestParameters: DeleteBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary diff branch
     * @param {string} repository 
     * @param {string} branch 
     * @param {string} [after] return items after this value
     * @param {number} [amount] how many items to return
     * @param {string} [prefix] return items prefixed with this value
     * @param {string} [delimiter] delimiter used to group common prefixes by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApiInterface
     */
    diffBranchRaw(requestParameters: DiffBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DiffList>>;

    /**
     * diff branch
     */
    diffBranch(requestParameters: DiffBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DiffList>;

    /**
     * 
     * @summary get branch
     * @param {string} repository 
     * @param {string} branch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApiInterface
     */
    getBranchRaw(requestParameters: GetBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Ref>>;

    /**
     * get branch
     */
    getBranch(requestParameters: GetBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Ref>;

    /**
     * 
     * @summary list branches
     * @param {string} repository 
     * @param {string} [prefix] return items prefixed with this value
     * @param {string} [after] return items after this value
     * @param {number} [amount] how many items to return
     * @param {boolean} [showHidden] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApiInterface
     */
    listBranchesRaw(requestParameters: ListBranchesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RefList>>;

    /**
     * list branches
     */
    listBranches(requestParameters: ListBranchesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RefList>;

    /**
     * 
     * @summary reset branch
     * @param {string} repository 
     * @param {string} branch 
     * @param {ResetCreation} resetCreation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApiInterface
     */
    resetBranchRaw(requestParameters: ResetBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * reset branch
     */
    resetBranch(requestParameters: ResetBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary revert
     * @param {string} repository 
     * @param {string} branch 
     * @param {RevertCreation} revertCreation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApiInterface
     */
    revertBranchRaw(requestParameters: RevertBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * revert
     */
    revertBranch(requestParameters: RevertBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

}

/**
 * 
 */
export class BranchesApi extends runtime.BaseAPI implements BranchesApiInterface {

    /**
     * Replay the changes from the given commit on the branch
     */
    async cherryPickRaw(requestParameters: CherryPickRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Commit>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling cherryPick.');
        }

        if (requestParameters.branch === null || requestParameters.branch === undefined) {
            throw new runtime.RequiredError('branch','Required parameter requestParameters.branch was null or undefined when calling cherryPick.');
        }

        if (requestParameters.cherryPickCreation === null || requestParameters.cherryPickCreation === undefined) {
            throw new runtime.RequiredError('cherryPickCreation','Required parameter requestParameters.cherryPickCreation was null or undefined when calling cherryPick.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/branches/{branch}/cherry-pick`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))).replace(`{${"branch"}}`, encodeURIComponent(String(requestParameters.branch))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CherryPickCreationToJSON(requestParameters.cherryPickCreation),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CommitFromJSON(jsonValue));
    }

    /**
     * Replay the changes from the given commit on the branch
     */
    async cherryPick(requestParameters: CherryPickRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Commit> {
        const response = await this.cherryPickRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create branch
     */
    async createBranchRaw(requestParameters: CreateBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling createBranch.');
        }

        if (requestParameters.branchCreation === null || requestParameters.branchCreation === undefined) {
            throw new runtime.RequiredError('branchCreation','Required parameter requestParameters.branchCreation was null or undefined when calling createBranch.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/branches`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BranchCreationToJSON(requestParameters.branchCreation),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * create branch
     */
    async createBranch(requestParameters: CreateBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.createBranchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete branch
     */
    async deleteBranchRaw(requestParameters: DeleteBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling deleteBranch.');
        }

        if (requestParameters.branch === null || requestParameters.branch === undefined) {
            throw new runtime.RequiredError('branch','Required parameter requestParameters.branch was null or undefined when calling deleteBranch.');
        }

        const queryParameters: any = {};

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/branches/{branch}`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))).replace(`{${"branch"}}`, encodeURIComponent(String(requestParameters.branch))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * delete branch
     */
    async deleteBranch(requestParameters: DeleteBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteBranchRaw(requestParameters, initOverrides);
    }

    /**
     * diff branch
     */
    async diffBranchRaw(requestParameters: DiffBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DiffList>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling diffBranch.');
        }

        if (requestParameters.branch === null || requestParameters.branch === undefined) {
            throw new runtime.RequiredError('branch','Required parameter requestParameters.branch was null or undefined when calling diffBranch.');
        }

        const queryParameters: any = {};

        if (requestParameters.after !== undefined) {
            queryParameters['after'] = requestParameters.after;
        }

        if (requestParameters.amount !== undefined) {
            queryParameters['amount'] = requestParameters.amount;
        }

        if (requestParameters.prefix !== undefined) {
            queryParameters['prefix'] = requestParameters.prefix;
        }

        if (requestParameters.delimiter !== undefined) {
            queryParameters['delimiter'] = requestParameters.delimiter;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/branches/{branch}/diff`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))).replace(`{${"branch"}}`, encodeURIComponent(String(requestParameters.branch))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DiffListFromJSON(jsonValue));
    }

    /**
     * diff branch
     */
    async diffBranch(requestParameters: DiffBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DiffList> {
        const response = await this.diffBranchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get branch
     */
    async getBranchRaw(requestParameters: GetBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Ref>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling getBranch.');
        }

        if (requestParameters.branch === null || requestParameters.branch === undefined) {
            throw new runtime.RequiredError('branch','Required parameter requestParameters.branch was null or undefined when calling getBranch.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/branches/{branch}`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))).replace(`{${"branch"}}`, encodeURIComponent(String(requestParameters.branch))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RefFromJSON(jsonValue));
    }

    /**
     * get branch
     */
    async getBranch(requestParameters: GetBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Ref> {
        const response = await this.getBranchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list branches
     */
    async listBranchesRaw(requestParameters: ListBranchesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RefList>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling listBranches.');
        }

        const queryParameters: any = {};

        if (requestParameters.prefix !== undefined) {
            queryParameters['prefix'] = requestParameters.prefix;
        }

        if (requestParameters.after !== undefined) {
            queryParameters['after'] = requestParameters.after;
        }

        if (requestParameters.amount !== undefined) {
            queryParameters['amount'] = requestParameters.amount;
        }

        if (requestParameters.showHidden !== undefined) {
            queryParameters['show_hidden'] = requestParameters.showHidden;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/branches`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RefListFromJSON(jsonValue));
    }

    /**
     * list branches
     */
    async listBranches(requestParameters: ListBranchesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RefList> {
        const response = await this.listBranchesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * reset branch
     */
    async resetBranchRaw(requestParameters: ResetBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling resetBranch.');
        }

        if (requestParameters.branch === null || requestParameters.branch === undefined) {
            throw new runtime.RequiredError('branch','Required parameter requestParameters.branch was null or undefined when calling resetBranch.');
        }

        if (requestParameters.resetCreation === null || requestParameters.resetCreation === undefined) {
            throw new runtime.RequiredError('resetCreation','Required parameter requestParameters.resetCreation was null or undefined when calling resetBranch.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/branches/{branch}`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))).replace(`{${"branch"}}`, encodeURIComponent(String(requestParameters.branch))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ResetCreationToJSON(requestParameters.resetCreation),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * reset branch
     */
    async resetBranch(requestParameters: ResetBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.resetBranchRaw(requestParameters, initOverrides);
    }

    /**
     * revert
     */
    async revertBranchRaw(requestParameters: RevertBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling revertBranch.');
        }

        if (requestParameters.branch === null || requestParameters.branch === undefined) {
            throw new runtime.RequiredError('branch','Required parameter requestParameters.branch was null or undefined when calling revertBranch.');
        }

        if (requestParameters.revertCreation === null || requestParameters.revertCreation === undefined) {
            throw new runtime.RequiredError('revertCreation','Required parameter requestParameters.revertCreation was null or undefined when calling revertBranch.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/repositories/{repository}/branches/{branch}/revert`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters.repository))).replace(`{${"branch"}}`, encodeURIComponent(String(requestParameters.branch))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RevertCreationToJSON(requestParameters.revertCreation),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * revert
     */
    async revertBranch(requestParameters: RevertBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.revertBranchRaw(requestParameters, initOverrides);
    }

}
