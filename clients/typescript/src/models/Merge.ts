/* tslint:disable */
/* eslint-disable */
/**
 * lakeFS API
 * lakeFS HTTP API
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
/**
 * 
 * @export
 * @interface Merge
 */
export interface Merge {
    /**
     * 
     * @type {string}
     * @memberof Merge
     */
    message?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Merge
     */
    metadata?: { [key: string]: string; };
    /**
     * In case of a merge conflict, this option will force the merge process to automatically favor changes from the dest branch ('dest-wins') or from the source branch('source-wins'). In case no selection is made, the merge process will fail in case of a conflict
     * @type {string}
     * @memberof Merge
     */
    strategy?: string;
    /**
     * Allow merge into a read-only branch or into a branch with the same content
     * @type {boolean}
     * @memberof Merge
     */
    force?: boolean;
    /**
     * Allow merge when the branches have the same content
     * @type {boolean}
     * @memberof Merge
     */
    allowEmpty?: boolean;
    /**
     * If set, set only the destination branch as a parent, which "squashes" the merge to
     * appear as a single commit on the destination branch.  The source commit is no longer
     * a part of the merge commit; consider adding it to the 'metadata' or 'message'
     * fields.  This behaves like a GitHub or GitLab "squash merge", or in Git terms 'git
     * merge --squash; git commit ...'.
     * @type {boolean}
     * @memberof Merge
     */
    squashMerge?: boolean;
}

/**
 * Check if a given object implements the Merge interface.
 */
export function instanceOfMerge(value: object): boolean {
    let isInstance = true;

    return isInstance;
}

export function MergeFromJSON(json: any): Merge {
    return MergeFromJSONTyped(json, false);
}

export function MergeFromJSONTyped(json: any, ignoreDiscriminator: boolean): Merge {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'message': !exists(json, 'message') ? undefined : json['message'],
        'metadata': !exists(json, 'metadata') ? undefined : json['metadata'],
        'strategy': !exists(json, 'strategy') ? undefined : json['strategy'],
        'force': !exists(json, 'force') ? undefined : json['force'],
        'allowEmpty': !exists(json, 'allow_empty') ? undefined : json['allow_empty'],
        'squashMerge': !exists(json, 'squash_merge') ? undefined : json['squash_merge'],
    };
}

export function MergeToJSON(value?: Merge | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'message': value.message,
        'metadata': value.metadata,
        'strategy': value.strategy,
        'force': value.force,
        'allow_empty': value.allowEmpty,
        'squash_merge': value.squashMerge,
    };
}

