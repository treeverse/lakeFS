// Package apigen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package apigen

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"runtime/trace"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/pkg/errors"
)

const (
	Jwt_tokenScopes = "jwt_token.Scopes"
)

// ClaimTokenId defines model for ClaimTokenId.
type ClaimTokenId struct {

	// Unix Epoch in seconds
	ExpiresAt int64  `json:"expires_at"`
	TokenId   string `json:"token_id"`
}

// Credentials defines model for Credentials.
type Credentials struct {
	AccessKeyId string `json:"access_key_id"`

	// Unix Epoch in seconds
	CreationDate int64 `json:"creation_date"`
}

// CredentialsList defines model for CredentialsList.
type CredentialsList struct {

	// The pagination mechanism is used to retrieve a list of items.
	Pagination Pagination    `json:"pagination"`
	Results    []Credentials `json:"results"`
}

// CredentialsWithSecret defines model for CredentialsWithSecret.
type CredentialsWithSecret struct {
	AccessKeyId string `json:"access_key_id"`

	// Unix Epoch in seconds.
	CreationDate    int64  `json:"creation_date"`
	SecretAccessKey string `json:"secret_access_key"`
	UserId          int64  `json:"user_id"`

	// Important - this filed is required instead of the user_id which is deprecated. A unique identifier for the user. In password-based authentication should be the email.
	UserName *string `json:"user_name,omitempty"`
}

// Error defines model for Error.
type Error struct {

	// The error message.
	Message string `json:"message"`
}

// ExternalPrincipal defines model for ExternalPrincipal.
type ExternalPrincipal struct {
	Id     string `json:"id"`
	UserId string `json:"user_id"`
}

// ExternalPrincipalList defines model for ExternalPrincipalList.
type ExternalPrincipalList struct {

	// The pagination mechanism is used to retrieve a list of items.
	Pagination Pagination          `json:"pagination"`
	Results    []ExternalPrincipal `json:"results"`
}

// Group defines model for Group.
type Group struct {

	// Unix Epoch in seconds.
	CreationDate int64   `json:"creation_date"`
	Description  *string `json:"description,omitempty"`

	// A unique identifier of the group.
	Id *string `json:"id,omitempty"`

	// A unique identifier for the group, represented by a human-readable name.
	Name string `json:"name"`
}

// GroupCreation defines model for GroupCreation.
type GroupCreation struct {
	Description *string `json:"description,omitempty"`

	// A unique identifier for the group, represented by a human-readable name.
	Id string `json:"id"`
}

// GroupList defines model for GroupList.
type GroupList struct {

	// The pagination mechanism is used to retrieve a list of items.
	Pagination Pagination `json:"pagination"`
	Results    []Group    `json:"results"`
}

// Pagination defines model for Pagination.
type Pagination struct {

	// A boolean indicating whether the Next page is available.
	HasMore bool `json:"has_more"`

	// Maximum number of entries per page.
	MaxPerPage int `json:"max_per_page"`

	// A value used to retrieve the next page of results. This value is typically passed as the after parameter in the subsequent API call. The next page will include all items appearing after the specified next_offset.
	NextOffset string `json:"next_offset"`

	// Number of values in the results.
	Results int `json:"results"`
}

// Policy defines model for Policy.
type Policy struct {

	// Represents the access control list assigned to this policy.
	Acl *string `json:"acl,omitempty"`

	// Unix Epoch in seconds.
	CreationDate *int64 `json:"creation_date,omitempty"`

	// A unique, human-readable name for the policy.
	Name      string      `json:"name"`
	Statement []Statement `json:"statement"`
}

// PolicyCondition defines model for PolicyCondition.
type PolicyCondition struct {
	AdditionalProperties map[string][]string `json:"-"`
}

// PolicyList defines model for PolicyList.
type PolicyList struct {

	// The pagination mechanism is used to retrieve a list of items.
	Pagination Pagination `json:"pagination"`
	Results    []Policy   `json:"results"`
}

// Statement defines model for Statement.
type Statement struct {
	Action []string `json:"action"`

	// Optional conditions for when this statement applies.
	Condition *Statement_Condition `json:"condition,omitempty"`
	Effect    string               `json:"effect"`
	Resource  string               `json:"resource"`
}

// Statement_Condition defines model for Statement.Condition.
type Statement_Condition struct {
	AdditionalProperties map[string]PolicyCondition `json:"-"`
}

// User defines model for User.
type User struct {

	// Unix Epoch in seconds.
	CreationDate int64   `json:"creation_date"`
	Email        *string `json:"email,omitempty"`

	// Represents an encrypted password as a string.
	EncryptedPassword []byte  `json:"encryptedPassword"`
	ExternalId        *string `json:"external_id,omitempty"`

	// A name for the user that is not necessarily unique.
	FriendlyName *string `json:"friendly_name,omitempty"`

	// User source. Based on implementation.
	Source *string `json:"source,omitempty"`

	// A unique identifier for the user.
	Username string `json:"username"`
}

// UserCreation defines model for UserCreation.
type UserCreation struct {

	// If provided, the email is set to the same value as the username.
	Email *string `json:"email,omitempty"`

	// Represents an encrypted password as a string.
	EncryptedPassword *[]byte `json:"encryptedPassword,omitempty"`
	ExternalId        *string `json:"external_id,omitempty"`
	FriendlyName      *string `json:"friendlyName,omitempty"`

	// A boolean that determines whether an invitation email should be sent to a user for account creation. If passed and set to true, the invitation email will be sent along with the user creation.
	Invite *bool `json:"invite,omitempty"`

	// User source. Based on implementation.
	Source *string `json:"source,omitempty"`

	// A unique identifier for the user. For password-based authentication, it is the email.
	Username string `json:"username"`
}

// UserList defines model for UserList.
type UserList struct {

	// The pagination mechanism is used to retrieve a list of items.
	Pagination Pagination `json:"pagination"`
	Results    []User     `json:"results"`
}

// UserPassword defines model for UserPassword.
type UserPassword struct {
	EncryptedPassword []byte `json:"encryptedPassword"`
}

// VersionConfig defines model for VersionConfig.
type VersionConfig struct {
	Version string `json:"version"`
}

// PaginationAfter defines model for PaginationAfter.
type PaginationAfter string

// PaginationAmount defines model for PaginationAmount.
type PaginationAmount int

// PaginationPrefix defines model for PaginationPrefix.
type PaginationPrefix string

// Conflict defines model for Conflict.
type Conflict Error

// NotFound defines model for NotFound.
type NotFound Error

// ServerError defines model for ServerError.
type ServerError Error

// Unauthorized defines model for Unauthorized.
type Unauthorized Error

// ValidationError defines model for ValidationError.
type ValidationError Error

// GetExternalPrincipalParams defines parameters for GetExternalPrincipal.
type GetExternalPrincipalParams struct {
	PrincipalId string `json:"principalId"`
}

// ListGroupsParams defines parameters for ListGroups.
type ListGroupsParams struct {

	// Indicates the prefix that all returned items must start with for the purpose of filtering results.
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// Indicates the starting point for the returned items. Items must be sorted by a specific parameter, and the response should include only those that come after the "after" value in the sorted list. This is used for pagination, as the next page needs to start from a specific point in the ordered items list.
	After *PaginationAfter `json:"after,omitempty"`

	// Specifies the number of items the server should return. It is used to determine how many results to display.
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// CreateGroupJSONBody defines parameters for CreateGroup.
type CreateGroupJSONBody GroupCreation

// ListGroupMembersParams defines parameters for ListGroupMembers.
type ListGroupMembersParams struct {

	// Indicates the prefix that all returned items must start with for the purpose of filtering results.
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// Indicates the starting point for the returned items. Items must be sorted by a specific parameter, and the response should include only those that come after the "after" value in the sorted list. This is used for pagination, as the next page needs to start from a specific point in the ordered items list.
	After *PaginationAfter `json:"after,omitempty"`

	// Specifies the number of items the server should return. It is used to determine how many results to display.
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// ListGroupPoliciesParams defines parameters for ListGroupPolicies.
type ListGroupPoliciesParams struct {

	// Indicates the prefix that all returned items must start with for the purpose of filtering results.
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// Indicates the starting point for the returned items. Items must be sorted by a specific parameter, and the response should include only those that come after the "after" value in the sorted list. This is used for pagination, as the next page needs to start from a specific point in the ordered items list.
	After *PaginationAfter `json:"after,omitempty"`

	// Specifies the number of items the server should return. It is used to determine how many results to display.
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// ListPoliciesParams defines parameters for ListPolicies.
type ListPoliciesParams struct {

	// Indicates the prefix that all returned items must start with for the purpose of filtering results.
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// Indicates the starting point for the returned items. Items must be sorted by a specific parameter, and the response should include only those that come after the "after" value in the sorted list. This is used for pagination, as the next page needs to start from a specific point in the ordered items list.
	After *PaginationAfter `json:"after,omitempty"`

	// Specifies the number of items the server should return. It is used to determine how many results to display.
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// CreatePolicyJSONBody defines parameters for CreatePolicy.
type CreatePolicyJSONBody Policy

// UpdatePolicyJSONBody defines parameters for UpdatePolicy.
type UpdatePolicyJSONBody Policy

// ClaimTokenIdJSONBody defines parameters for ClaimTokenId.
type ClaimTokenIdJSONBody ClaimTokenId

// ListUsersParams defines parameters for ListUsers.
type ListUsersParams struct {

	// Indicates the prefix that all returned items must start with for the purpose of filtering results.
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// Indicates the starting point for the returned items. Items must be sorted by a specific parameter, and the response should include only those that come after the "after" value in the sorted list. This is used for pagination, as the next page needs to start from a specific point in the ordered items list.
	After *PaginationAfter `json:"after,omitempty"`

	// Specifies the number of items the server should return. It is used to determine how many results to display.
	Amount *PaginationAmount `json:"amount,omitempty"`
	Id     *int64            `json:"id,omitempty"`
	Email  *string           `json:"email,omitempty"`

	// Used only in lakeFS Enterprise; not applicable in the lakeFS OSS version.
	ExternalId *string `json:"external_id,omitempty"`
}

// CreateUserJSONBody defines parameters for CreateUser.
type CreateUserJSONBody UserCreation

// ListUserCredentialsParams defines parameters for ListUserCredentials.
type ListUserCredentialsParams struct {

	// Indicates the prefix that all returned items must start with for the purpose of filtering results.
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// Indicates the starting point for the returned items. Items must be sorted by a specific parameter, and the response should include only those that come after the "after" value in the sorted list. This is used for pagination, as the next page needs to start from a specific point in the ordered items list.
	After *PaginationAfter `json:"after,omitempty"`

	// Specifies the number of items the server should return. It is used to determine how many results to display.
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// CreateCredentialsParams defines parameters for CreateCredentials.
type CreateCredentialsParams struct {
	AccessKey *string `json:"access_key,omitempty"`
	SecretKey *string `json:"secret_key,omitempty"`
}

// DeleteUserExternalPrincipalParams defines parameters for DeleteUserExternalPrincipal.
type DeleteUserExternalPrincipalParams struct {
	PrincipalId string `json:"principalId"`
}

// CreateUserExternalPrincipalParams defines parameters for CreateUserExternalPrincipal.
type CreateUserExternalPrincipalParams struct {
	PrincipalId string `json:"principalId"`
}

// ListUserExternalPrincipalsParams defines parameters for ListUserExternalPrincipals.
type ListUserExternalPrincipalsParams struct {

	// Indicates the prefix that all returned items must start with for the purpose of filtering results.
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// Indicates the starting point for the returned items. Items must be sorted by a specific parameter, and the response should include only those that come after the "after" value in the sorted list. This is used for pagination, as the next page needs to start from a specific point in the ordered items list.
	After *PaginationAfter `json:"after,omitempty"`

	// Specifies the number of items the server should return. It is used to determine how many results to display.
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// UpdateUserFriendlyNameJSONBody defines parameters for UpdateUserFriendlyName.
type UpdateUserFriendlyNameJSONBody struct {
	FriendlyName string `json:"friendly_name"`
}

// ListUserGroupsParams defines parameters for ListUserGroups.
type ListUserGroupsParams struct {

	// Indicates the prefix that all returned items must start with for the purpose of filtering results.
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// Indicates the starting point for the returned items. Items must be sorted by a specific parameter, and the response should include only those that come after the "after" value in the sorted list. This is used for pagination, as the next page needs to start from a specific point in the ordered items list.
	After *PaginationAfter `json:"after,omitempty"`

	// Specifies the number of items the server should return. It is used to determine how many results to display.
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// UpdatePasswordJSONBody defines parameters for UpdatePassword.
type UpdatePasswordJSONBody UserPassword

// ListUserPoliciesParams defines parameters for ListUserPolicies.
type ListUserPoliciesParams struct {

	// Indicates the prefix that all returned items must start with for the purpose of filtering results.
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// Indicates the starting point for the returned items. Items must be sorted by a specific parameter, and the response should include only those that come after the "after" value in the sorted list. This is used for pagination, as the next page needs to start from a specific point in the ordered items list.
	After *PaginationAfter `json:"after,omitempty"`

	// Specifies the number of items the server should return. It is used to determine how many results to display.
	Amount *PaginationAmount `json:"amount,omitempty"`

	// If true, return all distinct policies attached to the user or any of the groups the user belongs to, otherwise, return only the policies directly attached to the user.
	Effective *bool `json:"effective,omitempty"`
}

// CreateGroupJSONRequestBody defines body for CreateGroup for application/json ContentType.
type CreateGroupJSONRequestBody CreateGroupJSONBody

// CreatePolicyJSONRequestBody defines body for CreatePolicy for application/json ContentType.
type CreatePolicyJSONRequestBody CreatePolicyJSONBody

// UpdatePolicyJSONRequestBody defines body for UpdatePolicy for application/json ContentType.
type UpdatePolicyJSONRequestBody UpdatePolicyJSONBody

// ClaimTokenIdJSONRequestBody defines body for ClaimTokenId for application/json ContentType.
type ClaimTokenIdJSONRequestBody ClaimTokenIdJSONBody

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody CreateUserJSONBody

// UpdateUserFriendlyNameJSONRequestBody defines body for UpdateUserFriendlyName for application/json ContentType.
type UpdateUserFriendlyNameJSONRequestBody UpdateUserFriendlyNameJSONBody

// UpdatePasswordJSONRequestBody defines body for UpdatePassword for application/json ContentType.
type UpdatePasswordJSONRequestBody UpdatePasswordJSONBody

// Getter for additional properties for PolicyCondition. Returns the specified
// element and whether it was found
func (a PolicyCondition) Get(fieldName string) (value []string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PolicyCondition
func (a *PolicyCondition) Set(fieldName string, value []string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string][]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PolicyCondition to handle AdditionalProperties
func (a *PolicyCondition) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string][]string)
		for fieldName, fieldBuf := range object {
			var fieldVal []string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PolicyCondition to handle AdditionalProperties
func (a PolicyCondition) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Statement_Condition. Returns the specified
// element and whether it was found
func (a Statement_Condition) Get(fieldName string) (value PolicyCondition, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Statement_Condition
func (a *Statement_Condition) Set(fieldName string, value PolicyCondition) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]PolicyCondition)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Statement_Condition to handle AdditionalProperties
func (a *Statement_Condition) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]PolicyCondition)
		for fieldName, fieldBuf := range object {
			var fieldVal PolicyCondition
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Statement_Condition to handle AdditionalProperties
func (a Statement_Condition) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// chi-interface.tmpl based on https://github.com/deepmap/oapi-codegen/tree/master/pkg/codegen/templates

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// get credentials
	// (GET /auth/credentials/{accessKeyId})
	GetCredentials(w http.ResponseWriter, r *http.Request, accessKeyId string)
	// describe external principal by id
	// (GET /auth/external/principals)
	GetExternalPrincipal(w http.ResponseWriter, r *http.Request, params GetExternalPrincipalParams)
	// list groups
	// (GET /auth/groups)
	ListGroups(w http.ResponseWriter, r *http.Request, params ListGroupsParams)
	// create group
	// (POST /auth/groups)
	CreateGroup(w http.ResponseWriter, r *http.Request, body CreateGroupJSONRequestBody)
	// delete group
	// (DELETE /auth/groups/{groupId})
	DeleteGroup(w http.ResponseWriter, r *http.Request, groupId string)
	// get group
	// (GET /auth/groups/{groupId})
	GetGroup(w http.ResponseWriter, r *http.Request, groupId string)
	// list group members
	// (GET /auth/groups/{groupId}/members)
	ListGroupMembers(w http.ResponseWriter, r *http.Request, groupId string, params ListGroupMembersParams)
	// delete group membership
	// (DELETE /auth/groups/{groupId}/members/{userId})
	DeleteGroupMembership(w http.ResponseWriter, r *http.Request, groupId string, userId string)
	// add group membership
	// (PUT /auth/groups/{groupId}/members/{userId})
	AddGroupMembership(w http.ResponseWriter, r *http.Request, groupId string, userId string)
	// list group policies
	// (GET /auth/groups/{groupId}/policies)
	ListGroupPolicies(w http.ResponseWriter, r *http.Request, groupId string, params ListGroupPoliciesParams)
	// detach policy from group
	// (DELETE /auth/groups/{groupId}/policies/{policyId})
	DetachPolicyFromGroup(w http.ResponseWriter, r *http.Request, groupId string, policyId string)
	// attach policy to group
	// (PUT /auth/groups/{groupId}/policies/{policyId})
	AttachPolicyToGroup(w http.ResponseWriter, r *http.Request, groupId string, policyId string)
	// list policies
	// (GET /auth/policies)
	ListPolicies(w http.ResponseWriter, r *http.Request, params ListPoliciesParams)
	// create policy
	// (POST /auth/policies)
	CreatePolicy(w http.ResponseWriter, r *http.Request, body CreatePolicyJSONRequestBody)
	// delete policy
	// (DELETE /auth/policies/{policyId})
	DeletePolicy(w http.ResponseWriter, r *http.Request, policyId string)
	// get policy
	// (GET /auth/policies/{policyId})
	GetPolicy(w http.ResponseWriter, r *http.Request, policyId string)
	// update policy
	// (PUT /auth/policies/{policyId})
	UpdatePolicy(w http.ResponseWriter, r *http.Request, body UpdatePolicyJSONRequestBody, policyId string)
	// claim a token ID, returns validation error if already claimed
	// (POST /auth/tokenid/claim)
	ClaimTokenId(w http.ResponseWriter, r *http.Request, body ClaimTokenIdJSONRequestBody)
	// list users
	// (GET /auth/users)
	ListUsers(w http.ResponseWriter, r *http.Request, params ListUsersParams)
	// create user
	// (POST /auth/users)
	CreateUser(w http.ResponseWriter, r *http.Request, body CreateUserJSONRequestBody)
	// delete user
	// (DELETE /auth/users/{userId})
	DeleteUser(w http.ResponseWriter, r *http.Request, userId string)
	// get user
	// (GET /auth/users/{userId})
	GetUser(w http.ResponseWriter, r *http.Request, userId string)
	// list user credentials
	// (GET /auth/users/{userId}/credentials)
	ListUserCredentials(w http.ResponseWriter, r *http.Request, userId string, params ListUserCredentialsParams)
	// create credentials
	// (POST /auth/users/{userId}/credentials)
	CreateCredentials(w http.ResponseWriter, r *http.Request, userId string, params CreateCredentialsParams)
	// delete credentials
	// (DELETE /auth/users/{userId}/credentials/{accessKeyId})
	DeleteCredentials(w http.ResponseWriter, r *http.Request, userId string, accessKeyId string)
	// get credentials for a user
	// (GET /auth/users/{userId}/credentials/{accessKeyId})
	GetCredentialsForUser(w http.ResponseWriter, r *http.Request, userId string, accessKeyId string)
	// delete external principal from user's external principal list
	// (DELETE /auth/users/{userId}/external/principals)
	DeleteUserExternalPrincipal(w http.ResponseWriter, r *http.Request, userId string, params DeleteUserExternalPrincipalParams)
	// Create principal as external identity connected to a user
	// (POST /auth/users/{userId}/external/principals)
	CreateUserExternalPrincipal(w http.ResponseWriter, r *http.Request, userId string, params CreateUserExternalPrincipalParams)
	// list external principals for user
	// (GET /auth/users/{userId}/external/principals/ls)
	ListUserExternalPrincipals(w http.ResponseWriter, r *http.Request, userId string, params ListUserExternalPrincipalsParams)
	// update users friendly name
	// (PUT /auth/users/{userId}/friendly_name)
	UpdateUserFriendlyName(w http.ResponseWriter, r *http.Request, body UpdateUserFriendlyNameJSONRequestBody, userId string)
	// list user groups
	// (GET /auth/users/{userId}/groups)
	ListUserGroups(w http.ResponseWriter, r *http.Request, userId string, params ListUserGroupsParams)
	// update users password
	// (PUT /auth/users/{userId}/password)
	UpdatePassword(w http.ResponseWriter, r *http.Request, body UpdatePasswordJSONRequestBody, userId string)
	// list user policies
	// (GET /auth/users/{userId}/policies)
	ListUserPolicies(w http.ResponseWriter, r *http.Request, userId string, params ListUserPoliciesParams)
	// detach policy from user
	// (DELETE /auth/users/{userId}/policies/{policyId})
	DetachPolicyFromUser(w http.ResponseWriter, r *http.Request, userId string, policyId string)
	// attach policy to user
	// (PUT /auth/users/{userId}/policies/{policyId})
	AttachPolicyToUser(w http.ResponseWriter, r *http.Request, userId string, policyId string)

	// (GET /config/version)
	GetVersion(w http.ResponseWriter, r *http.Request)

	// (GET /healthcheck)
	HealthCheck(w http.ResponseWriter, r *http.Request)
}

// chi-middleware.tmpl based on https://github.com/deepmap/oapi-codegen/tree/master/pkg/codegen/templates

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// GetCredentials operation middleware
func (siw *ServerInterfaceWrapper) GetCredentials(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetCredentials")
	defer task.End()

	var err error

	// ------------- Path parameter "accessKeyId" -------------
	var accessKeyId string

	err = runtime.BindStyledParameter("simple", false, "accessKeyId", chi.URLParam(r, "accessKeyId"), &accessKeyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter accessKeyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCredentials(w, r, accessKeyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetExternalPrincipal operation middleware
func (siw *ServerInterfaceWrapper) GetExternalPrincipal(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetExternalPrincipal")
	defer task.End()

	var err error

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetExternalPrincipalParams

	// ------------- Required query parameter "principalId" -------------
	if paramValue := r.URL.Query().Get("principalId"); paramValue != "" {

	} else {
		http.Error(w, "Query argument principalId is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "principalId", r.URL.Query(), &params.PrincipalId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter principalId: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetExternalPrincipal(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListGroups operation middleware
func (siw *ServerInterfaceWrapper) ListGroups(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListGroups")
	defer task.End()

	var err error

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListGroupsParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListGroups(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateGroup operation middleware
func (siw *ServerInterfaceWrapper) CreateGroup(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CreateGroup")
	defer task.End()

	// ------------- Body parse -------------
	var body CreateGroupJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreateGroup' as JSON", http.StatusBadRequest)
			return
		}
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateGroup(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteGroup operation middleware
func (siw *ServerInterfaceWrapper) DeleteGroup(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DeleteGroup")
	defer task.End()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGroup(w, r, groupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetGroup operation middleware
func (siw *ServerInterfaceWrapper) GetGroup(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetGroup")
	defer task.End()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGroup(w, r, groupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListGroupMembers operation middleware
func (siw *ServerInterfaceWrapper) ListGroupMembers(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListGroupMembers")
	defer task.End()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListGroupMembersParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListGroupMembers(w, r, groupId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteGroupMembership operation middleware
func (siw *ServerInterfaceWrapper) DeleteGroupMembership(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DeleteGroupMembership")
	defer task.End()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGroupMembership(w, r, groupId, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddGroupMembership operation middleware
func (siw *ServerInterfaceWrapper) AddGroupMembership(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:AddGroupMembership")
	defer task.End()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddGroupMembership(w, r, groupId, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListGroupPolicies operation middleware
func (siw *ServerInterfaceWrapper) ListGroupPolicies(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListGroupPolicies")
	defer task.End()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListGroupPoliciesParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListGroupPolicies(w, r, groupId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DetachPolicyFromGroup operation middleware
func (siw *ServerInterfaceWrapper) DetachPolicyFromGroup(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DetachPolicyFromGroup")
	defer task.End()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DetachPolicyFromGroup(w, r, groupId, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AttachPolicyToGroup operation middleware
func (siw *ServerInterfaceWrapper) AttachPolicyToGroup(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:AttachPolicyToGroup")
	defer task.End()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachPolicyToGroup(w, r, groupId, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListPolicies operation middleware
func (siw *ServerInterfaceWrapper) ListPolicies(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListPolicies")
	defer task.End()

	var err error

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPoliciesParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListPolicies(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreatePolicy operation middleware
func (siw *ServerInterfaceWrapper) CreatePolicy(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CreatePolicy")
	defer task.End()

	// ------------- Body parse -------------
	var body CreatePolicyJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreatePolicy' as JSON", http.StatusBadRequest)
			return
		}
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreatePolicy(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeletePolicy operation middleware
func (siw *ServerInterfaceWrapper) DeletePolicy(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DeletePolicy")
	defer task.End()

	var err error

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeletePolicy(w, r, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetPolicy operation middleware
func (siw *ServerInterfaceWrapper) GetPolicy(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetPolicy")
	defer task.End()

	var err error

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPolicy(w, r, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdatePolicy operation middleware
func (siw *ServerInterfaceWrapper) UpdatePolicy(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:UpdatePolicy")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body UpdatePolicyJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'UpdatePolicy' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdatePolicy(w, r, body, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ClaimTokenId operation middleware
func (siw *ServerInterfaceWrapper) ClaimTokenId(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ClaimTokenId")
	defer task.End()

	// ------------- Body parse -------------
	var body ClaimTokenIdJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'ClaimTokenId' as JSON", http.StatusBadRequest)
			return
		}
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ClaimTokenId(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListUsers operation middleware
func (siw *ServerInterfaceWrapper) ListUsers(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListUsers")
	defer task.End()

	var err error

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUsersParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "id" -------------
	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "id", r.URL.Query(), &params.Id)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter id: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "email" -------------
	if paramValue := r.URL.Query().Get("email"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "email", r.URL.Query(), &params.Email)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter email: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "external_id" -------------
	if paramValue := r.URL.Query().Get("external_id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "external_id", r.URL.Query(), &params.ExternalId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter external_id: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUsers(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateUser operation middleware
func (siw *ServerInterfaceWrapper) CreateUser(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CreateUser")
	defer task.End()

	// ------------- Body parse -------------
	var body CreateUserJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreateUser' as JSON", http.StatusBadRequest)
			return
		}
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateUser(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteUser operation middleware
func (siw *ServerInterfaceWrapper) DeleteUser(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DeleteUser")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUser(w, r, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetUser operation middleware
func (siw *ServerInterfaceWrapper) GetUser(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetUser")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUser(w, r, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListUserCredentials operation middleware
func (siw *ServerInterfaceWrapper) ListUserCredentials(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListUserCredentials")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUserCredentialsParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUserCredentials(w, r, userId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateCredentials operation middleware
func (siw *ServerInterfaceWrapper) CreateCredentials(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CreateCredentials")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateCredentialsParams

	// ------------- Optional query parameter "access_key" -------------
	if paramValue := r.URL.Query().Get("access_key"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "access_key", r.URL.Query(), &params.AccessKey)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter access_key: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "secret_key" -------------
	if paramValue := r.URL.Query().Get("secret_key"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "secret_key", r.URL.Query(), &params.SecretKey)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter secret_key: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateCredentials(w, r, userId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteCredentials operation middleware
func (siw *ServerInterfaceWrapper) DeleteCredentials(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DeleteCredentials")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "accessKeyId" -------------
	var accessKeyId string

	err = runtime.BindStyledParameter("simple", false, "accessKeyId", chi.URLParam(r, "accessKeyId"), &accessKeyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter accessKeyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteCredentials(w, r, userId, accessKeyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetCredentialsForUser operation middleware
func (siw *ServerInterfaceWrapper) GetCredentialsForUser(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetCredentialsForUser")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "accessKeyId" -------------
	var accessKeyId string

	err = runtime.BindStyledParameter("simple", false, "accessKeyId", chi.URLParam(r, "accessKeyId"), &accessKeyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter accessKeyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCredentialsForUser(w, r, userId, accessKeyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteUserExternalPrincipal operation middleware
func (siw *ServerInterfaceWrapper) DeleteUserExternalPrincipal(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DeleteUserExternalPrincipal")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteUserExternalPrincipalParams

	// ------------- Required query parameter "principalId" -------------
	if paramValue := r.URL.Query().Get("principalId"); paramValue != "" {

	} else {
		http.Error(w, "Query argument principalId is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "principalId", r.URL.Query(), &params.PrincipalId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter principalId: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUserExternalPrincipal(w, r, userId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateUserExternalPrincipal operation middleware
func (siw *ServerInterfaceWrapper) CreateUserExternalPrincipal(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:CreateUserExternalPrincipal")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateUserExternalPrincipalParams

	// ------------- Required query parameter "principalId" -------------
	if paramValue := r.URL.Query().Get("principalId"); paramValue != "" {

	} else {
		http.Error(w, "Query argument principalId is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "principalId", r.URL.Query(), &params.PrincipalId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter principalId: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateUserExternalPrincipal(w, r, userId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListUserExternalPrincipals operation middleware
func (siw *ServerInterfaceWrapper) ListUserExternalPrincipals(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListUserExternalPrincipals")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUserExternalPrincipalsParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUserExternalPrincipals(w, r, userId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateUserFriendlyName operation middleware
func (siw *ServerInterfaceWrapper) UpdateUserFriendlyName(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:UpdateUserFriendlyName")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body UpdateUserFriendlyNameJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'UpdateUserFriendlyName' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateUserFriendlyName(w, r, body, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListUserGroups operation middleware
func (siw *ServerInterfaceWrapper) ListUserGroups(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListUserGroups")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUserGroupsParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUserGroups(w, r, userId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdatePassword operation middleware
func (siw *ServerInterfaceWrapper) UpdatePassword(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:UpdatePassword")
	defer task.End()

	var err error

	// ------------- Body parse -------------
	var body UpdatePasswordJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'UpdatePassword' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdatePassword(w, r, body, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListUserPolicies operation middleware
func (siw *ServerInterfaceWrapper) ListUserPolicies(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:ListUserPolicies")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUserPoliciesParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "effective" -------------
	if paramValue := r.URL.Query().Get("effective"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "effective", r.URL.Query(), &params.Effective)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter effective: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUserPolicies(w, r, userId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DetachPolicyFromUser operation middleware
func (siw *ServerInterfaceWrapper) DetachPolicyFromUser(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:DetachPolicyFromUser")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DetachPolicyFromUser(w, r, userId, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AttachPolicyToUser operation middleware
func (siw *ServerInterfaceWrapper) AttachPolicyToUser(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:AttachPolicyToUser")
	defer task.End()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachPolicyToUser(w, r, userId, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetVersion operation middleware
func (siw *ServerInterfaceWrapper) GetVersion(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:GetVersion")
	defer task.End()

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetVersion(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// HealthCheck operation middleware
func (siw *ServerInterfaceWrapper) HealthCheck(w http.ResponseWriter, r *http.Request) {
	ctx, task := trace.NewTask(r.Context(), "api:HealthCheck")
	defer task.End()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HealthCheck(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL     string
	BaseRouter  chi.Router
	Middlewares []MiddlewareFunc
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/credentials/{accessKeyId}", wrapper.GetCredentials)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/external/principals", wrapper.GetExternalPrincipal)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/groups", wrapper.ListGroups)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/groups", wrapper.CreateGroup)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/groups/{groupId}", wrapper.DeleteGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/groups/{groupId}", wrapper.GetGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/groups/{groupId}/members", wrapper.ListGroupMembers)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/groups/{groupId}/members/{userId}", wrapper.DeleteGroupMembership)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/auth/groups/{groupId}/members/{userId}", wrapper.AddGroupMembership)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/groups/{groupId}/policies", wrapper.ListGroupPolicies)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/groups/{groupId}/policies/{policyId}", wrapper.DetachPolicyFromGroup)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/auth/groups/{groupId}/policies/{policyId}", wrapper.AttachPolicyToGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/policies", wrapper.ListPolicies)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/policies", wrapper.CreatePolicy)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/policies/{policyId}", wrapper.DeletePolicy)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/policies/{policyId}", wrapper.GetPolicy)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/auth/policies/{policyId}", wrapper.UpdatePolicy)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/tokenid/claim", wrapper.ClaimTokenId)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/users", wrapper.ListUsers)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/users", wrapper.CreateUser)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/users/{userId}", wrapper.DeleteUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/users/{userId}", wrapper.GetUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/users/{userId}/credentials", wrapper.ListUserCredentials)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/users/{userId}/credentials", wrapper.CreateCredentials)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/users/{userId}/credentials/{accessKeyId}", wrapper.DeleteCredentials)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/users/{userId}/credentials/{accessKeyId}", wrapper.GetCredentialsForUser)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/users/{userId}/external/principals", wrapper.DeleteUserExternalPrincipal)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/users/{userId}/external/principals", wrapper.CreateUserExternalPrincipal)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/users/{userId}/external/principals/ls", wrapper.ListUserExternalPrincipals)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/auth/users/{userId}/friendly_name", wrapper.UpdateUserFriendlyName)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/users/{userId}/groups", wrapper.ListUserGroups)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/auth/users/{userId}/password", wrapper.UpdatePassword)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/users/{userId}/policies", wrapper.ListUserPolicies)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/users/{userId}/policies/{policyId}", wrapper.DetachPolicyFromUser)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/auth/users/{userId}/policies/{policyId}", wrapper.AttachPolicyToUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/config/version", wrapper.GetVersion)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/healthcheck", wrapper.HealthCheck)
	})

	return r
}

// inline.tmpl based on https://github.com/deepmap/oapi-codegen/tree/master/pkg/codegen/templates

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"Sm4/3f5fAAAA//+4Fk2MHaEAAA==",
}

// GetSwaggerSpecReader returns a reader to the Swagger specification corresponding to the generated code in this file.
func GetSwaggerSpecReader() (io.Reader, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	return zr, err
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.T, error) {
	zr, err := GetSwaggerSpecReader()
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	swagger, err := openapi3.NewLoader().LoadFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
