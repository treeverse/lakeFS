create extension if not exists btree_gist;

create sequence if not exists branches_id_seq
    as integer;

create sequence if not exists repositories_id_seq
    as integer;


create table repositories
(
    id                integer                  default nextval('repositories_id_seq'::regclass) not null
        constraint repositories_pk
            primary key,
    name              varchar(64)                                                               not null,
    storage_namespace varchar                                                                   not null,
    creation_date     timestamp with time zone default now()                                    not null,
    default_branch    integer                  default 1                                        not null
);


create unique index repositories_name_uindex
    on repositories (name);

create table branches
(
    repository_id integer                                              not null
        constraint branches_repository_id_fkey
            references repositories,
    id            integer default nextval('branches_id_seq'::regclass) not null
        constraint branches_pk
            primary key,
    name          varchar(64)                                          not null,
    next_commit   integer default 1                                    not null
);

create unique index branches_repository_name_uindex
    on branches (name, repository_id);

create table commits
(
    branch_id     integer                                not null
        constraint commits_branches_repository_id_fk
            references branches
            on delete cascade,
    commit_number integer                                not null,
    committer     varchar,
    message       varchar,
    creation_date timestamp with time zone default now() not null,
    metadata      json,
    constraint commits_pkey
        primary key (branch_id, commit_number)
);

create table entries
(
    branch_id        integer                                not null
        constraint entries_branches_id_fk
            references branches,
    key              varchar                                not null,
    commits          int4range                              not null,
    physical_address varchar(64),
    creation_date    timestamp with time zone default now() not null,
    size             bigint                                 not null,
    checksum         varchar(64)                            not null,
    metadata         json,
    CONSTRAINT entries_commit_overlap EXCLUDE
        USING gist (key WITH =,branch_id WITH =, commits WITH &&)
);

create index entries_branch_index
    on entries (branch_id);

create table object_dedup
(
    repository_id    integer     not null
        constraint object_dedup_repository_id_fkey
            references repositories
            on delete cascade,
    dedup_id         bytea       not null,
    physical_address varchar(64) not null,
    size             integer     not null,
    number_of_parts  smallint default 1,
    constraint object_dedup_pkey
        primary key (repository_id, dedup_id)
);

create table multipart_uploads
(
    repository_id    integer                                not null
        constraint multipart_uploads_repository_id_fkey
            references repositories
            on delete cascade,
    upload_id        varchar                                not null
        constraint multipart_uploads_pkey
            primary key,
    path             varchar                                not null,
    creation_date    timestamp with time zone default now() not null,
    object_name      bytea,
    physical_address varchar
);


create table lineage
(
    branch_id        integer not null
        constraint lineage_branches_repository_id_fk
            references branches
            on delete cascade,
    precedence       integer not null,
    ancestor_branch  integer not null
        constraint lineage_branches_repository_id_fk_2
            references branches
            on delete cascade,
    effective_commit integer not null,
    branch_commits   int4range default '[1,)'::int4range,
    CONSTRAINT lineage_pk UNIQUE (branch_id, ancestor_branch, branch_commits),
    CONSTRAINT lineage_commit_overlap EXCLUDE
        USING gist (branch_id WITH =, ancestor_branch WITH =, branch_commits WITH &&)

);


create view lineage_v (branch_id, precedence, ancestor_branch, effective_commit, branch_commits) as
SELECT lineage.branch_id,
       lineage.precedence,
       lineage.ancestor_branch,
       lineage.effective_commit,
       lineage.branch_commits
FROM lineage
UNION ALL
SELECT branches.id          AS branch_id,
       0                    AS precedence,
       branches.id          AS ancestor_branch,
       branches.next_commit AS effective_commit,
       '[1,)'::int4range    AS branch_commits
FROM branches;

create view entries_lineage_v
            (displayed_branch, source_branch, key, commits, physical_address, creation_date, size, checksum, precedence,
             rank)
as
SELECT l.branch_id                                                                                AS displayed_branch,
       e.branch_id                                                                                AS source_branch,
       e.key,
       e.commits,
       e.physical_address,
       e.creation_date,
       e.size,
       e.checksum,
       l.precedence,
       rank() OVER (PARTITION BY l.branch_id, e.key ORDER BY l.precedence, lower(e.commits) DESC) AS rank
FROM entries e
         JOIN lineage_v l ON l.ancestor_branch = e.branch_id
WHERE lower(e.commits) <= l.effective_commit;
