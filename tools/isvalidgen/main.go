package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

const codeTemplate = `{{- $root := . -}}
// Code generated by github.com/treeverse/lakefs/tools/isvalidgen; DO NOT EDIT.
package {{.Package}}
{{ range .Types }}
// {{$root.Method}} for {{.Type}} reports whether the value is one of the declared constants.
func (v {{.Type}}) {{$root.Method}}() bool {
	switch v {
	case {{ range $i, $v := .Values }}{{- if ne $i 0 }},
		{{end}}{{ $v }}
	{{- end }}:
		return true
	default:
		return false
	}
}
{{- end }}
`

type genTypeData struct {
	Type   string
	Values []string
}

type genData struct {
	Package string
	Method  string
	Types   []genTypeData
}

type config struct {
	source string
	types  []string
	method string
	output string
}

var (
	errNoSource = errors.New("no source file provided")
	errNoTypes  = errors.New("no types provided")
	errNoMethod = errors.New("no method provided")
	errNoOutput = errors.New("no output file provided")
)

func parseFlags() (*config, error) {
	var typesArg string
	cfg := &config{}
	flag.StringVar(&cfg.source, "source", "", "Path to source .go file containing the type and constants")
	flag.StringVar(&typesArg, "type", "", "Name(s) of type(s), comma-separated (e.g. EventType,OtherType)")
	flag.StringVar(&cfg.method, "method", "IsValid", "Method name to generate: IsValid")
	flag.StringVar(&cfg.output, "output", "", "Path to output file (default: the input file with _isvalid.gen.go appended)")
	flag.Parse()

	if cfg.source == "" {
		return nil, errNoSource
	}
	if typesArg == "" {
		return nil, errNoTypes
	}
	for _, t := range strings.Split(typesArg, ",") {
		name := strings.TrimSpace(t)
		if name != "" {
			cfg.types = append(cfg.types, name)
		}
	}
	if len(cfg.types) == 0 {
		return nil, errNoTypes
	}
	if cfg.method == "" {
		cfg.method = "IsValid"
	}
	if cfg.output == "" {
		cfg.output = defaultOutPath(cfg.source)
	}
	return cfg, nil
}

func collectTypedConstNames(file *ast.File, typename string) []string {
	var values []string
	ast.Inspect(file, func(n ast.Node) bool {
		decl, ok := n.(*ast.GenDecl)
		if !ok || decl.Tok != token.CONST {
			return true
		}
		for _, spec := range decl.Specs {
			vs, ok := spec.(*ast.ValueSpec)
			if !ok {
				continue
			}
			if ident, ok := vs.Type.(*ast.Ident); ok && ident.Name == typename {
				for _, name := range vs.Names {
					values = append(values, name.Name)
				}
			}
		}
		return true
	})
	return values
}

func defaultOutPath(source string) string {
	base := strings.TrimSuffix(filepath.Base(source), ".go")
	dir := filepath.Dir(source)
	filename := base + "_isvalid.gen.go"
	return filepath.Join(dir, filename)
}

func main() {
	cfg, err := parseFlags()
	if err != nil {
		fmt.Fprintln(os.Stderr, "isvalidgen:", err)
		os.Exit(1)
	}

	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, cfg.source, nil, parser.ParseComments)
	if err != nil {
		fmt.Fprintln(os.Stderr, "parse:", err)
		os.Exit(1)
	}

	data := genData{
		Package: file.Name.Name,
		Method:  cfg.method,
	}
	tmpl := template.Must(template.New("isvalid").Parse(codeTemplate))

	for _, typename := range cfg.types {
		values := collectTypedConstNames(file, typename)
		if len(values) == 0 {
			fmt.Fprintf(os.Stderr, "no constants of type %s found in %s\n", typename, cfg.source)
			os.Exit(1)
		}
		data.Types = append(data.Types, genTypeData{
			Type:   typename,
			Values: values,
		})
	}

	var code bytes.Buffer
	if err := tmpl.Execute(&code, data); err != nil {
		fmt.Fprintln(os.Stderr, "execute:", err)
		os.Exit(1)
	}

	const perm = 0o666
	if err := os.WriteFile(cfg.output, code.Bytes(), perm); err != nil {
		fmt.Fprintf(os.Stderr, "write %s: %v\n", cfg.output, err)
		os.Exit(1)
	}
}
