package cmd

import (
	"fmt"
	"os"
	"path"

	"github.com/spf13/cobra"
)

var dbtGenerateSchemaMacro = &cobra.Command{
	Use:        "generate-schema-macro",
	Short:      "generates the a macro allowing lakectl to run dbt on dynamic schemas",
	Example:    "lakectl dbt generate-schema-macro",
	Deprecated: "Upcoming releases of lakectl will no longer support this command.",
	Run: func(cmd *cobra.Command, args []string) {
		projectRoot := Must(cmd.Flags().GetString("project-root"))

		if !pathExists(path.Join(projectRoot, macrosDirName)) {
			DieFmt("The project-root should contain the macro directory")
		}

		macroPath := path.Join(projectRoot, macrosDirName, generateSchemaName)
		if pathExists(macroPath) {
			DieFmt("%s already exists, add lakeFS schema generation manually", macroPath)
		}
		const generateSchemaData = `
generate_schema_name.sql 

{# This macro was generated by lakeFS in order to allow lakectl run dbt on dynamic schemas #}

{% macro generate_schema_name(custom_schema_name, node) -%}
    {{  env_var('LAKEFS_SCHEMA', target.schema) }}

{%- endmacro %}
`
		//nolint:gosec
		err := os.WriteFile(macroPath, []byte(generateSchemaData), 0o644) //nolint: gomnd
		if err != nil {
			DieErr(err)
		}
		fmt.Println("macro created in path", macroPath)
	},
}

func getDBTTables(projectRoot string) []DBTResource {
	resources, err := DBTLsToJSON(projectRoot, resourceType, materializedSelection, ExecuteCommand)
	if err != nil {
		DieErr(err)
	}
	return resources
}

func pathExists(path string) bool {
	_, err := os.Stat(path)
	if err != nil {
		if os.IsNotExist(err) {
			return false
		}
		DieErr(err)
	}
	return true
}

//nolint:gochecknoinits
func init() {
	dbtGenerateSchemaMacro.Flags().String("project-root", ".", "location of dbt project")

	dbtCmd.AddCommand(dbtGenerateSchemaMacro)
}
